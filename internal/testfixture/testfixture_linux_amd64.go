// Code generated by 'ccgo -DSQLITE_OMIT_LOAD_EXTENSION -DTCLSH -DTCLSH_INIT_PROC=sqlite3TestInit -I/usr/include/tcl8.6 -ccgo-export-defines  -ccgo-export-fields F -ccgo-pkgname testfixture -o internal/testfixture/testfixture_linux_amd64.go testdata/sqlite-src-3320300/ext/expert/sqlite3expert.c testdata/sqlite-src-3320300/ext/expert/test_expert.c testdata/sqlite-src-3320300/ext/fts5/fts5_tcl.c testdata/sqlite-src-3320300/ext/misc/amatch.c testdata/sqlite-src-3320300/ext/misc/carray.c testdata/sqlite-src-3320300/ext/misc/closure.c testdata/sqlite-src-3320300/ext/misc/csv.c testdata/sqlite-src-3320300/ext/misc/eval.c testdata/sqlite-src-3320300/ext/misc/explain.c testdata/sqlite-src-3320300/ext/misc/fileio.c testdata/sqlite-src-3320300/ext/misc/fuzzer.c testdata/sqlite-src-3320300/ext/misc/ieee754.c testdata/sqlite-src-3320300/ext/misc/mmapwarm.c testdata/sqlite-src-3320300/ext/misc/nextchar.c testdata/sqlite-src-3320300/ext/misc/normalize.c testdata/sqlite-src-3320300/ext/misc/percentile.c testdata/sqlite-src-3320300/ext/misc/prefixes.c testdata/sqlite-src-3320300/ext/misc/regexp.c testdata/sqlite-src-3320300/ext/misc/remember.c testdata/sqlite-src-3320300/ext/misc/series.c testdata/sqlite-src-3320300/ext/misc/spellfix.c testdata/sqlite-src-3320300/ext/misc/totype.c testdata/sqlite-src-3320300/ext/misc/unionvtab.c testdata/sqlite-src-3320300/ext/misc/wholenumber.c testdata/sqlite-src-3320300/ext/rbu/sqlite3rbu.c testdata/sqlite-src-3320300/ext/rbu/test_rbu.c testdata/sqlite-src-3320300/src/tclsqlite.c testdata/sqlite-src-3320300/src/test1.c testdata/sqlite-src-3320300/src/test2.c testdata/sqlite-src-3320300/src/test3.c testdata/sqlite-src-3320300/src/test4.c testdata/sqlite-src-3320300/src/test5.c testdata/sqlite-src-3320300/src/test6.c testdata/sqlite-src-3320300/src/test7.c testdata/sqlite-src-3320300/src/test8.c testdata/sqlite-src-3320300/src/test9.c testdata/sqlite-src-3320300/src/test_async.c testdata/sqlite-src-3320300/src/test_autoext.c testdata/sqlite-src-3320300/src/test_backup.c testdata/sqlite-src-3320300/src/test_bestindex.c testdata/sqlite-src-3320300/src/test_blob.c testdata/sqlite-src-3320300/src/test_btree.c testdata/sqlite-src-3320300/src/test_config.c testdata/sqlite-src-3320300/src/test_delete.c testdata/sqlite-src-3320300/src/test_demovfs.c testdata/sqlite-src-3320300/src/test_devsym.c testdata/sqlite-src-3320300/src/test_fs.c testdata/sqlite-src-3320300/src/test_func.c testdata/sqlite-src-3320300/src/test_hexio.c testdata/sqlite-src-3320300/src/test_init.c testdata/sqlite-src-3320300/src/test_intarray.c testdata/sqlite-src-3320300/src/test_journal.c testdata/sqlite-src-3320300/src/test_malloc.c testdata/sqlite-src-3320300/src/test_md5.c testdata/sqlite-src-3320300/src/test_multiplex.c testdata/sqlite-src-3320300/src/test_mutex.c testdata/sqlite-src-3320300/src/test_onefile.c testdata/sqlite-src-3320300/src/test_osinst.c testdata/sqlite-src-3320300/src/test_pcache.c testdata/sqlite-src-3320300/src/test_quota.c testdata/sqlite-src-3320300/src/test_rtree.c testdata/sqlite-src-3320300/src/test_schema.c testdata/sqlite-src-3320300/src/test_superlock.c testdata/sqlite-src-3320300/src/test_syscall.c testdata/sqlite-src-3320300/src/test_tclsh.c testdata/sqlite-src-3320300/src/test_tclvar.c testdata/sqlite-src-3320300/src/test_thread.c testdata/sqlite-src-3320300/src/test_vdbecov.c testdata/sqlite-src-3320300/src/test_vfs.c testdata/sqlite-src-3320300/src/test_window.c -Itestdata/sqlite-amalgamation-3320300 -Itestdata/sqlite-src-3320300 -l modernc.org/tcl/lib,modernc.org/sqlite/internal/crt2,modernc.org/sqlite/lib -DHAVE_USLEEP -DLONGDOUBLE_TYPE=double -DSQLITE_DEFAULT_MEMSTATUS=0 -DSQLITE_DEFAULT_WAL_SYNCHRONOUS=1 -DSQLITE_DQS=0 -DSQLITE_ENABLE_UNLOCK_NOTIFY -DSQLITE_LIKE_DOESNT_MATCH_BLOBS -DSQLITE_MAX_EXPR_DEPTH=0 -DSQLITE_MUTEX_APPDEF=1 -DSQLITE_MUTEX_NOOP -DSQLITE_OMIT_DECLTYPE -DSQLITE_OMIT_PROGRESS_CALLBACK -DSQLITE_OMIT_UTF16 -DSQLITE_TEST -DSQLITE_THREADSAFE=2 -ccgo-long-double-is-double', DO NOT EDIT.

package testfixture

import (
	"math"
	"reflect"
	"unsafe"

	"modernc.org/crt/v3"
	"modernc.org/sqlite/internal/crt2"
	"modernc.org/sqlite/lib"
	"modernc.org/tcl/lib"
)

var _ = math.Pi
var _ reflect.Kind
var _ unsafe.Pointer

const (
	BUFSIZ                                = 8192
	EOF                                   = -1
	EXPERT_CONFIG_SAMPLE                  = 1
	EXPERT_REPORT_CANDIDATES              = 4
	EXPERT_REPORT_INDEXES                 = 2
	EXPERT_REPORT_PLAN                    = 3
	EXPERT_REPORT_SQL                     = 1
	FILENAME_MAX                          = 4096
	FOPEN_MAX                             = 16
	FTS5_TOKENIZE_AUX                     = 0x0008
	FTS5_TOKENIZE_DOCUMENT                = 0x0004
	FTS5_TOKENIZE_PREFIX                  = 0x0002
	FTS5_TOKENIZE_QUERY                   = 0x0001
	FTS5_TOKEN_COLOCATED                  = 0x0001
	FULLY_WITHIN                          = 2
	HAVE_USLEEP                           = 1
	IDX_HASH_SIZE                         = 1023
	L_ctermid                             = 9
	L_tmpnam                              = 20
	NOT_WITHIN                            = 0
	PARTLY_WITHIN                         = 1
	P_tmpdir                              = "/tmp"
	SEEK_CUR                              = 1
	SEEK_END                              = 2
	SEEK_SET                              = 0
	SQLITE3_H                             = 0
	SQLITE3_TEXT                          = 3
	SQLITEEXPERT_H                        = 1
	SQLITE_ABORT                          = 4
	SQLITE_ABORT_ROLLBACK                 = 516
	SQLITE_ACCESS_EXISTS                  = 0
	SQLITE_ACCESS_READ                    = 2
	SQLITE_ACCESS_READWRITE               = 1
	SQLITE_ALTER_TABLE                    = 26
	SQLITE_ANALYZE                        = 28
	SQLITE_ANY                            = 5
	SQLITE_API                            = 0
	SQLITE_APICALL                        = 0
	SQLITE_ATTACH                         = 24
	SQLITE_AUTH                           = 23
	SQLITE_AUTH_USER                      = 279
	SQLITE_BLOB                           = 4
	SQLITE_BUSY                           = 5
	SQLITE_BUSY_RECOVERY                  = 261
	SQLITE_BUSY_SNAPSHOT                  = 517
	SQLITE_BUSY_TIMEOUT                   = 773
	SQLITE_CALLBACK                       = 0
	SQLITE_CANTOPEN                       = 14
	SQLITE_CANTOPEN_CONVPATH              = 1038
	SQLITE_CANTOPEN_DIRTYWAL              = 1294
	SQLITE_CANTOPEN_FULLPATH              = 782
	SQLITE_CANTOPEN_ISDIR                 = 526
	SQLITE_CANTOPEN_NOTEMPDIR             = 270
	SQLITE_CANTOPEN_SYMLINK               = 1550
	SQLITE_CDECL                          = 0
	SQLITE_CHECKPOINT_FULL                = 1
	SQLITE_CHECKPOINT_PASSIVE             = 0
	SQLITE_CHECKPOINT_RESTART             = 2
	SQLITE_CHECKPOINT_TRUNCATE            = 3
	SQLITE_CONFIG_COVERING_INDEX_SCAN     = 20
	SQLITE_CONFIG_GETMALLOC               = 5
	SQLITE_CONFIG_GETMUTEX                = 11
	SQLITE_CONFIG_GETPCACHE               = 15
	SQLITE_CONFIG_GETPCACHE2              = 19
	SQLITE_CONFIG_HEAP                    = 8
	SQLITE_CONFIG_LOG                     = 16
	SQLITE_CONFIG_LOOKASIDE               = 13
	SQLITE_CONFIG_MALLOC                  = 4
	SQLITE_CONFIG_MEMDB_MAXSIZE           = 29
	SQLITE_CONFIG_MEMSTATUS               = 9
	SQLITE_CONFIG_MMAP_SIZE               = 22
	SQLITE_CONFIG_MULTITHREAD             = 2
	SQLITE_CONFIG_MUTEX                   = 10
	SQLITE_CONFIG_PAGECACHE               = 7
	SQLITE_CONFIG_PCACHE                  = 14
	SQLITE_CONFIG_PCACHE2                 = 18
	SQLITE_CONFIG_PCACHE_HDRSZ            = 24
	SQLITE_CONFIG_PMASZ                   = 25
	SQLITE_CONFIG_SCRATCH                 = 6
	SQLITE_CONFIG_SERIALIZED              = 3
	SQLITE_CONFIG_SINGLETHREAD            = 1
	SQLITE_CONFIG_SMALL_MALLOC            = 27
	SQLITE_CONFIG_SORTERREF_SIZE          = 28
	SQLITE_CONFIG_SQLLOG                  = 21
	SQLITE_CONFIG_STMTJRNL_SPILL          = 26
	SQLITE_CONFIG_URI                     = 17
	SQLITE_CONFIG_WIN32_HEAPSIZE          = 23
	SQLITE_CONSTRAINT                     = 19
	SQLITE_CONSTRAINT_CHECK               = 275
	SQLITE_CONSTRAINT_COMMITHOOK          = 531
	SQLITE_CONSTRAINT_FOREIGNKEY          = 787
	SQLITE_CONSTRAINT_FUNCTION            = 1043
	SQLITE_CONSTRAINT_NOTNULL             = 1299
	SQLITE_CONSTRAINT_PINNED              = 2835
	SQLITE_CONSTRAINT_PRIMARYKEY          = 1555
	SQLITE_CONSTRAINT_ROWID               = 2579
	SQLITE_CONSTRAINT_TRIGGER             = 1811
	SQLITE_CONSTRAINT_UNIQUE              = 2067
	SQLITE_CONSTRAINT_VTAB                = 2323
	SQLITE_COPY                           = 0
	SQLITE_CORRUPT                        = 11
	SQLITE_CORRUPT_INDEX                  = 779
	SQLITE_CORRUPT_SEQUENCE               = 523
	SQLITE_CORRUPT_VTAB                   = 267
	SQLITE_CREATE_INDEX                   = 1
	SQLITE_CREATE_TABLE                   = 2
	SQLITE_CREATE_TEMP_INDEX              = 3
	SQLITE_CREATE_TEMP_TABLE              = 4
	SQLITE_CREATE_TEMP_TRIGGER            = 5
	SQLITE_CREATE_TEMP_VIEW               = 6
	SQLITE_CREATE_TRIGGER                 = 7
	SQLITE_CREATE_VIEW                    = 8
	SQLITE_CREATE_VTABLE                  = 29
	SQLITE_DBCONFIG_DEFENSIVE             = 1010
	SQLITE_DBCONFIG_DQS_DDL               = 1014
	SQLITE_DBCONFIG_DQS_DML               = 1013
	SQLITE_DBCONFIG_ENABLE_FKEY           = 1002
	SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER = 1004
	SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION = 1005
	SQLITE_DBCONFIG_ENABLE_QPSG           = 1007
	SQLITE_DBCONFIG_ENABLE_TRIGGER        = 1003
	SQLITE_DBCONFIG_ENABLE_VIEW           = 1015
	SQLITE_DBCONFIG_LEGACY_ALTER_TABLE    = 1012
	SQLITE_DBCONFIG_LEGACY_FILE_FORMAT    = 1016
	SQLITE_DBCONFIG_LOOKASIDE             = 1001
	SQLITE_DBCONFIG_MAINDBNAME            = 1000
	SQLITE_DBCONFIG_MAX                   = 1017
	SQLITE_DBCONFIG_NO_CKPT_ON_CLOSE      = 1006
	SQLITE_DBCONFIG_RESET_DATABASE        = 1009
	SQLITE_DBCONFIG_TRIGGER_EQP           = 1008
	SQLITE_DBCONFIG_TRUSTED_SCHEMA        = 1017
	SQLITE_DBCONFIG_WRITABLE_SCHEMA       = 1011
	SQLITE_DBSTATUS_CACHE_HIT             = 7
	SQLITE_DBSTATUS_CACHE_MISS            = 8
	SQLITE_DBSTATUS_CACHE_SPILL           = 12
	SQLITE_DBSTATUS_CACHE_USED            = 1
	SQLITE_DBSTATUS_CACHE_USED_SHARED     = 11
	SQLITE_DBSTATUS_CACHE_WRITE           = 9
	SQLITE_DBSTATUS_DEFERRED_FKS          = 10
	SQLITE_DBSTATUS_LOOKASIDE_HIT         = 4
	SQLITE_DBSTATUS_LOOKASIDE_MISS_FULL   = 6
	SQLITE_DBSTATUS_LOOKASIDE_MISS_SIZE   = 5
	SQLITE_DBSTATUS_LOOKASIDE_USED        = 0
	SQLITE_DBSTATUS_MAX                   = 12
	SQLITE_DBSTATUS_SCHEMA_USED           = 2
	SQLITE_DBSTATUS_STMT_USED             = 3
	SQLITE_DEFAULT_MEMSTATUS              = 0
	SQLITE_DEFAULT_WAL_SYNCHRONOUS        = 1
	SQLITE_DELETE                         = 9
	SQLITE_DENY                           = 1
	SQLITE_DEPRECATED                     = 0
	SQLITE_DESERIALIZE_FREEONCLOSE        = 1
	SQLITE_DESERIALIZE_READONLY           = 4
	SQLITE_DESERIALIZE_RESIZEABLE         = 2
	SQLITE_DETACH                         = 25
	SQLITE_DETERMINISTIC                  = 0x000000800
	SQLITE_DIRECTONLY                     = 0x000080000
	SQLITE_DONE                           = 101
	SQLITE_DQS                            = 0
	SQLITE_DROP_INDEX                     = 10
	SQLITE_DROP_TABLE                     = 11
	SQLITE_DROP_TEMP_INDEX                = 12
	SQLITE_DROP_TEMP_TABLE                = 13
	SQLITE_DROP_TEMP_TRIGGER              = 14
	SQLITE_DROP_TEMP_VIEW                 = 15
	SQLITE_DROP_TRIGGER                   = 16
	SQLITE_DROP_VIEW                      = 17
	SQLITE_DROP_VTABLE                    = 30
	SQLITE_EMPTY                          = 16
	SQLITE_ENABLE_UNLOCK_NOTIFY           = 1
	SQLITE_ERROR                          = 1
	SQLITE_ERROR_MISSING_COLLSEQ          = 257
	SQLITE_ERROR_RETRY                    = 513
	SQLITE_ERROR_SNAPSHOT                 = 769
	SQLITE_EXPERIMENTAL                   = 0
	SQLITE_FAIL                           = 3
	SQLITE_FCNTL_BEGIN_ATOMIC_WRITE       = 31
	SQLITE_FCNTL_BUSYHANDLER              = 15
	SQLITE_FCNTL_CHUNK_SIZE               = 6
	SQLITE_FCNTL_CKPT_DONE                = 37
	SQLITE_FCNTL_CKPT_START               = 39
	SQLITE_FCNTL_COMMIT_ATOMIC_WRITE      = 32
	SQLITE_FCNTL_COMMIT_PHASETWO          = 22
	SQLITE_FCNTL_DATA_VERSION             = 35
	SQLITE_FCNTL_FILE_POINTER             = 7
	SQLITE_FCNTL_GET_LOCKPROXYFILE        = 2
	SQLITE_FCNTL_HAS_MOVED                = 20
	SQLITE_FCNTL_JOURNAL_POINTER          = 28
	SQLITE_FCNTL_LAST_ERRNO               = 4
	SQLITE_FCNTL_LOCKSTATE                = 1
	SQLITE_FCNTL_LOCK_TIMEOUT             = 34
	SQLITE_FCNTL_MMAP_SIZE                = 18
	SQLITE_FCNTL_OVERWRITE                = 11
	SQLITE_FCNTL_PDB                      = 30
	SQLITE_FCNTL_PERSIST_WAL              = 10
	SQLITE_FCNTL_POWERSAFE_OVERWRITE      = 13
	SQLITE_FCNTL_PRAGMA                   = 14
	SQLITE_FCNTL_RBU                      = 26
	SQLITE_FCNTL_RESERVE_BYTES            = 38
	SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE    = 33
	SQLITE_FCNTL_SET_LOCKPROXYFILE        = 3
	SQLITE_FCNTL_SIZE_HINT                = 5
	SQLITE_FCNTL_SIZE_LIMIT               = 36
	SQLITE_FCNTL_SYNC                     = 21
	SQLITE_FCNTL_SYNC_OMITTED             = 8
	SQLITE_FCNTL_TEMPFILENAME             = 16
	SQLITE_FCNTL_TRACE                    = 19
	SQLITE_FCNTL_VFSNAME                  = 12
	SQLITE_FCNTL_VFS_POINTER              = 27
	SQLITE_FCNTL_WAL_BLOCK                = 24
	SQLITE_FCNTL_WIN32_AV_RETRY           = 9
	SQLITE_FCNTL_WIN32_GET_HANDLE         = 29
	SQLITE_FCNTL_WIN32_SET_HANDLE         = 23
	SQLITE_FCNTL_ZIPVFS                   = 25
	SQLITE_FLOAT                          = 2
	SQLITE_FORMAT                         = 24
	SQLITE_FULL                           = 13
	SQLITE_FUNCTION                       = 31
	SQLITE_GET_LOCKPROXYFILE              = 2
	SQLITE_IGNORE                         = 2
	SQLITE_INDEX_CONSTRAINT_EQ            = 2
	SQLITE_INDEX_CONSTRAINT_FUNCTION      = 150
	SQLITE_INDEX_CONSTRAINT_GE            = 32
	SQLITE_INDEX_CONSTRAINT_GLOB          = 66
	SQLITE_INDEX_CONSTRAINT_GT            = 4
	SQLITE_INDEX_CONSTRAINT_IS            = 72
	SQLITE_INDEX_CONSTRAINT_ISNOT         = 69
	SQLITE_INDEX_CONSTRAINT_ISNOTNULL     = 70
	SQLITE_INDEX_CONSTRAINT_ISNULL        = 71
	SQLITE_INDEX_CONSTRAINT_LE            = 8
	SQLITE_INDEX_CONSTRAINT_LIKE          = 65
	SQLITE_INDEX_CONSTRAINT_LT            = 16
	SQLITE_INDEX_CONSTRAINT_MATCH         = 64
	SQLITE_INDEX_CONSTRAINT_NE            = 68
	SQLITE_INDEX_CONSTRAINT_REGEXP        = 67
	SQLITE_INDEX_SCAN_UNIQUE              = 1
	SQLITE_INNOCUOUS                      = 0x000200000
	SQLITE_INSERT                         = 18
	SQLITE_INTEGER                        = 1
	SQLITE_INTERNAL                       = 2
	SQLITE_INTERRUPT                      = 9
	SQLITE_IOCAP_ATOMIC                   = 0x00000001
	SQLITE_IOCAP_ATOMIC16K                = 0x00000040
	SQLITE_IOCAP_ATOMIC1K                 = 0x00000004
	SQLITE_IOCAP_ATOMIC2K                 = 0x00000008
	SQLITE_IOCAP_ATOMIC32K                = 0x00000080
	SQLITE_IOCAP_ATOMIC4K                 = 0x00000010
	SQLITE_IOCAP_ATOMIC512                = 0x00000002
	SQLITE_IOCAP_ATOMIC64K                = 0x00000100
	SQLITE_IOCAP_ATOMIC8K                 = 0x00000020
	SQLITE_IOCAP_BATCH_ATOMIC             = 0x00004000
	SQLITE_IOCAP_IMMUTABLE                = 0x00002000
	SQLITE_IOCAP_POWERSAFE_OVERWRITE      = 0x00001000
	SQLITE_IOCAP_SAFE_APPEND              = 0x00000200
	SQLITE_IOCAP_SEQUENTIAL               = 0x00000400
	SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN    = 0x00000800
	SQLITE_IOERR                          = 10
	SQLITE_IOERR_ACCESS                   = 3338
	SQLITE_IOERR_AUTH                     = 7178
	SQLITE_IOERR_BEGIN_ATOMIC             = 7434
	SQLITE_IOERR_BLOCKED                  = 2826
	SQLITE_IOERR_CHECKRESERVEDLOCK        = 3594
	SQLITE_IOERR_CLOSE                    = 4106
	SQLITE_IOERR_COMMIT_ATOMIC            = 7690
	SQLITE_IOERR_CONVPATH                 = 6666
	SQLITE_IOERR_DATA                     = 8202
	SQLITE_IOERR_DELETE                   = 2570
	SQLITE_IOERR_DELETE_NOENT             = 5898
	SQLITE_IOERR_DIR_CLOSE                = 4362
	SQLITE_IOERR_DIR_FSYNC                = 1290
	SQLITE_IOERR_FSTAT                    = 1802
	SQLITE_IOERR_FSYNC                    = 1034
	SQLITE_IOERR_GETTEMPPATH              = 6410
	SQLITE_IOERR_LOCK                     = 3850
	SQLITE_IOERR_MMAP                     = 6154
	SQLITE_IOERR_NOMEM                    = 3082
	SQLITE_IOERR_RDLOCK                   = 2314
	SQLITE_IOERR_READ                     = 266
	SQLITE_IOERR_ROLLBACK_ATOMIC          = 7946
	SQLITE_IOERR_SEEK                     = 5642
	SQLITE_IOERR_SHMLOCK                  = 5130
	SQLITE_IOERR_SHMMAP                   = 5386
	SQLITE_IOERR_SHMOPEN                  = 4618
	SQLITE_IOERR_SHMSIZE                  = 4874
	SQLITE_IOERR_SHORT_READ               = 522
	SQLITE_IOERR_TRUNCATE                 = 1546
	SQLITE_IOERR_UNLOCK                   = 2058
	SQLITE_IOERR_VNODE                    = 6922
	SQLITE_IOERR_WRITE                    = 778
	SQLITE_LAST_ERRNO                     = 4
	SQLITE_LIKE_DOESNT_MATCH_BLOBS        = 1
	SQLITE_LIMIT_ATTACHED                 = 7
	SQLITE_LIMIT_COLUMN                   = 2
	SQLITE_LIMIT_COMPOUND_SELECT          = 4
	SQLITE_LIMIT_EXPR_DEPTH               = 3
	SQLITE_LIMIT_FUNCTION_ARG             = 6
	SQLITE_LIMIT_LENGTH                   = 0
	SQLITE_LIMIT_LIKE_PATTERN_LENGTH      = 8
	SQLITE_LIMIT_SQL_LENGTH               = 1
	SQLITE_LIMIT_TRIGGER_DEPTH            = 10
	SQLITE_LIMIT_VARIABLE_NUMBER          = 9
	SQLITE_LIMIT_VDBE_OP                  = 5
	SQLITE_LIMIT_WORKER_THREADS           = 11
	SQLITE_LOCKED                         = 6
	SQLITE_LOCKED_SHAREDCACHE             = 262
	SQLITE_LOCKED_VTAB                    = 518
	SQLITE_LOCK_EXCLUSIVE                 = 4
	SQLITE_LOCK_NONE                      = 0
	SQLITE_LOCK_PENDING                   = 3
	SQLITE_LOCK_RESERVED                  = 2
	SQLITE_LOCK_SHARED                    = 1
	SQLITE_MAX_EXPR_DEPTH                 = 0
	SQLITE_MISMATCH                       = 20
	SQLITE_MISUSE                         = 21
	SQLITE_MUTEX_APPDEF                   = 1
	SQLITE_MUTEX_FAST                     = 0
	SQLITE_MUTEX_NOOP                     = 1
	SQLITE_MUTEX_RECURSIVE                = 1
	SQLITE_MUTEX_STATIC_APP1              = 8
	SQLITE_MUTEX_STATIC_APP2              = 9
	SQLITE_MUTEX_STATIC_APP3              = 10
	SQLITE_MUTEX_STATIC_LRU               = 6
	SQLITE_MUTEX_STATIC_LRU2              = 7
	SQLITE_MUTEX_STATIC_MASTER            = 2
	SQLITE_MUTEX_STATIC_MEM               = 3
	SQLITE_MUTEX_STATIC_MEM2              = 4
	SQLITE_MUTEX_STATIC_OPEN              = 4
	SQLITE_MUTEX_STATIC_PMEM              = 7
	SQLITE_MUTEX_STATIC_PRNG              = 5
	SQLITE_MUTEX_STATIC_VFS1              = 11
	SQLITE_MUTEX_STATIC_VFS2              = 12
	SQLITE_MUTEX_STATIC_VFS3              = 13
	SQLITE_NOLFS                          = 22
	SQLITE_NOMEM                          = 7
	SQLITE_NOTADB                         = 26
	SQLITE_NOTFOUND                       = 12
	SQLITE_NOTICE                         = 27
	SQLITE_NOTICE_RECOVER_ROLLBACK        = 539
	SQLITE_NOTICE_RECOVER_WAL             = 283
	SQLITE_NULL                           = 5
	SQLITE_OK                             = 0
	SQLITE_OK_LOAD_PERMANENTLY            = 256
	SQLITE_OK_SYMLINK                     = 512
	SQLITE_OMIT_DECLTYPE                  = 1
	SQLITE_OMIT_LOAD_EXTENSION            = 1
	SQLITE_OMIT_PROGRESS_CALLBACK         = 1
	SQLITE_OMIT_UTF16                     = 1
	SQLITE_OPEN_AUTOPROXY                 = 0x00000020
	SQLITE_OPEN_CREATE                    = 0x00000004
	SQLITE_OPEN_DELETEONCLOSE             = 0x00000008
	SQLITE_OPEN_EXCLUSIVE                 = 0x00000010
	SQLITE_OPEN_FULLMUTEX                 = 0x00010000
	SQLITE_OPEN_MAIN_DB                   = 0x00000100
	SQLITE_OPEN_MAIN_JOURNAL              = 0x00000800
	SQLITE_OPEN_MASTER_JOURNAL            = 0x00004000
	SQLITE_OPEN_MEMORY                    = 0x00000080
	SQLITE_OPEN_NOFOLLOW                  = 0x01000000
	SQLITE_OPEN_NOMUTEX                   = 0x00008000
	SQLITE_OPEN_PRIVATECACHE              = 0x00040000
	SQLITE_OPEN_READONLY                  = 0x00000001
	SQLITE_OPEN_READWRITE                 = 0x00000002
	SQLITE_OPEN_SHAREDCACHE               = 0x00020000
	SQLITE_OPEN_SUBJOURNAL                = 0x00002000
	SQLITE_OPEN_TEMP_DB                   = 0x00000200
	SQLITE_OPEN_TEMP_JOURNAL              = 0x00001000
	SQLITE_OPEN_TRANSIENT_DB              = 0x00000400
	SQLITE_OPEN_URI                       = 0x00000040
	SQLITE_OPEN_WAL                       = 0x00080000
	SQLITE_PERM                           = 3
	SQLITE_PRAGMA                         = 19
	SQLITE_PREPARE_NORMALIZE              = 0x02
	SQLITE_PREPARE_NO_VTAB                = 0x04
	SQLITE_PREPARE_PERSISTENT             = 0x01
	SQLITE_PROTOCOL                       = 15
	SQLITE_RANGE                          = 25
	SQLITE_READ                           = 20
	SQLITE_READONLY                       = 8
	SQLITE_READONLY_CANTINIT              = 1288
	SQLITE_READONLY_CANTLOCK              = 520
	SQLITE_READONLY_DBMOVED               = 1032
	SQLITE_READONLY_DIRECTORY             = 1544
	SQLITE_READONLY_RECOVERY              = 264
	SQLITE_READONLY_ROLLBACK              = 776
	SQLITE_RECURSIVE                      = 33
	SQLITE_REINDEX                        = 27
	SQLITE_REPLACE                        = 5
	SQLITE_ROLLBACK                       = 1
	SQLITE_ROW                            = 100
	SQLITE_SAVEPOINT                      = 32
	SQLITE_SCANSTAT_EST                   = 2
	SQLITE_SCANSTAT_EXPLAIN               = 4
	SQLITE_SCANSTAT_NAME                  = 3
	SQLITE_SCANSTAT_NLOOP                 = 0
	SQLITE_SCANSTAT_NVISIT                = 1
	SQLITE_SCANSTAT_SELECTID              = 5
	SQLITE_SCHEMA                         = 17
	SQLITE_SELECT                         = 21
	SQLITE_SERIALIZE_NOCOPY               = 0x001
	SQLITE_SET_LOCKPROXYFILE              = 3
	SQLITE_SHM_EXCLUSIVE                  = 8
	SQLITE_SHM_LOCK                       = 2
	SQLITE_SHM_NLOCK                      = 8
	SQLITE_SHM_SHARED                     = 4
	SQLITE_SHM_UNLOCK                     = 1
	SQLITE_SOURCE_ID                      = "2020-06-18 14:00:33 7ebdfa80be8e8e73324b8d66b3460222eb74c7e9dfd655b48d6ca7e1933cc8fd"
	SQLITE_STATUS_MALLOC_COUNT            = 9
	SQLITE_STATUS_MALLOC_SIZE             = 5
	SQLITE_STATUS_MEMORY_USED             = 0
	SQLITE_STATUS_PAGECACHE_OVERFLOW      = 2
	SQLITE_STATUS_PAGECACHE_SIZE          = 7
	SQLITE_STATUS_PAGECACHE_USED          = 1
	SQLITE_STATUS_PARSER_STACK            = 6
	SQLITE_STATUS_SCRATCH_OVERFLOW        = 4
	SQLITE_STATUS_SCRATCH_SIZE            = 8
	SQLITE_STATUS_SCRATCH_USED            = 3
	SQLITE_STDCALL                        = 0
	SQLITE_STMTSTATUS_AUTOINDEX           = 3
	SQLITE_STMTSTATUS_FULLSCAN_STEP       = 1
	SQLITE_STMTSTATUS_MEMUSED             = 99
	SQLITE_STMTSTATUS_REPREPARE           = 5
	SQLITE_STMTSTATUS_RUN                 = 6
	SQLITE_STMTSTATUS_SORT                = 2
	SQLITE_STMTSTATUS_VM_STEP             = 4
	SQLITE_SUBTYPE                        = 0x000100000
	SQLITE_SYNC_DATAONLY                  = 0x00010
	SQLITE_SYNC_FULL                      = 0x00003
	SQLITE_SYNC_NORMAL                    = 0x00002
	SQLITE_SYSAPI                         = 0
	SQLITE_TEST                           = 1
	SQLITE_TESTCTRL_ALWAYS                = 13
	SQLITE_TESTCTRL_ASSERT                = 12
	SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS   = 10
	SQLITE_TESTCTRL_BITVEC_TEST           = 8
	SQLITE_TESTCTRL_BYTEORDER             = 22
	SQLITE_TESTCTRL_EXPLAIN_STMT          = 19
	SQLITE_TESTCTRL_EXTRA_SCHEMA_CHECKS   = 29
	SQLITE_TESTCTRL_FAULT_INSTALL         = 9
	SQLITE_TESTCTRL_FIRST                 = 5
	SQLITE_TESTCTRL_IMPOSTER              = 25
	SQLITE_TESTCTRL_INTERNAL_FUNCTIONS    = 17
	SQLITE_TESTCTRL_ISINIT                = 23
	SQLITE_TESTCTRL_ISKEYWORD             = 16
	SQLITE_TESTCTRL_LAST                  = 29
	SQLITE_TESTCTRL_LOCALTIME_FAULT       = 18
	SQLITE_TESTCTRL_NEVER_CORRUPT         = 20
	SQLITE_TESTCTRL_ONCE_RESET_THRESHOLD  = 19
	SQLITE_TESTCTRL_OPTIMIZATIONS         = 15
	SQLITE_TESTCTRL_PARSER_COVERAGE       = 26
	SQLITE_TESTCTRL_PENDING_BYTE          = 11
	SQLITE_TESTCTRL_PRNG_RESET            = 7
	SQLITE_TESTCTRL_PRNG_RESTORE          = 6
	SQLITE_TESTCTRL_PRNG_SAVE             = 5
	SQLITE_TESTCTRL_PRNG_SEED             = 28
	SQLITE_TESTCTRL_RESERVE               = 14
	SQLITE_TESTCTRL_RESULT_INTREAL        = 27
	SQLITE_TESTCTRL_SCRATCHMALLOC         = 17
	SQLITE_TESTCTRL_SORTER_MMAP           = 24
	SQLITE_TESTCTRL_VDBE_COVERAGE         = 21
	SQLITE_TEXT                           = 3
	SQLITE_THREADSAFE                     = 2
	SQLITE_TOOBIG                         = 18
	SQLITE_TRACE_CLOSE                    = 0x08
	SQLITE_TRACE_PROFILE                  = 0x02
	SQLITE_TRACE_ROW                      = 0x04
	SQLITE_TRACE_STMT                     = 0x01
	SQLITE_TRANSACTION                    = 22
	SQLITE_UPDATE                         = 23
	SQLITE_UTF16                          = 4
	SQLITE_UTF16BE                        = 3
	SQLITE_UTF16LE                        = 2
	SQLITE_UTF16_ALIGNED                  = 8
	SQLITE_UTF8                           = 1
	SQLITE_VERSION                        = "3.32.3"
	SQLITE_VERSION_NUMBER                 = 3032003
	SQLITE_VTAB_CONSTRAINT_SUPPORT        = 1
	SQLITE_VTAB_DIRECTONLY                = 3
	SQLITE_VTAB_INNOCUOUS                 = 2
	SQLITE_WARNING                        = 28
	SQLITE_WARNING_AUTOINDEX              = 284
	SQLITE_WIN32_DATA_DIRECTORY_TYPE      = 1
	SQLITE_WIN32_TEMP_DIRECTORY_TYPE      = 2
	TCLSH                                 = 1
	TMP_MAX                               = 238328
	UNIQUE_TABLE_NAME                     = "t592690916721053953805701627921227776"
	_ANSI_STDARG_H_                       = 0
	_ASSERT_H                             = 1
	_ASSERT_H_DECLS                       = 0
	_ATFILE_SOURCE                        = 1
	_BITS_STDIO_LIM_H                     = 1
	_BITS_TYPESIZES_H                     = 1
	_BITS_TYPES_H                         = 1
	_BITS_TYPES_LOCALE_T_H                = 1
	_BITS_TYPES___LOCALE_T_H              = 1
	_BSD_SIZE_T_                          = 0
	_BSD_SIZE_T_DEFINED_                  = 0
	_DEFAULT_SOURCE                       = 1
	_FEATURES_H                           = 1
	_FTS5_H                               = 0
	_GCC_SIZE_T                           = 0
	_IOFBF                                = 0
	_IOLBF                                = 1
	_IONBF                                = 2
	_IO_EOF_SEEN                          = 0x0010
	_IO_ERR_SEEN                          = 0x0020
	_IO_USER_LOCK                         = 0x8000
	_LP64                                 = 1
	_POSIX_C_SOURCE                       = 200809
	_POSIX_SOURCE                         = 1
	_SIZET_                               = 0
	_SIZE_T                               = 0
	_SIZE_T_                              = 0
	_SIZE_T_DECLARED                      = 0
	_SIZE_T_DEFINED                       = 0
	_SIZE_T_DEFINED_                      = 0
	_SQLITE3RTREE_H_                      = 0
	_STDARG_H                             = 0
	_STDC_PREDEF_H                        = 1
	_STDIO_H                              = 1
	_STRINGS_H                            = 1
	_STRING_H                             = 1
	_SYS_CDEFS_H                          = 1
	_SYS_SIZE_T_H                         = 0
	_T_SIZE                               = 0
	_T_SIZE_                              = 0
	_VA_LIST                              = 0
	_VA_LIST_                             = 0
	_VA_LIST_DEFINED                      = 0
	_VA_LIST_T_H                          = 0
	Linux                                 = 1
	Unix                                  = 1
	AIO_PRIO_DELTA_MAX                    = 20
	BC_BASE_MAX                           = 99
	BC_DIM_MAX                            = 2048
	BC_SCALE_MAX                          = 99
	BC_STRING_MAX                         = 1000
	CHARCLASS_NAME_MAX                    = 2048
	CHAR_BIT                              = 8
	CHAR_MAX                              = 127
	CHAR_MIN                              = -128
	COLL_WEIGHTS_MAX                      = 255
	CRTIMPORT                             = 0
	DELAYTIMER_MAX                        = 2147483647
	DLLEXPORT                             = 0
	DLLIMPORT                             = 0
	EXPR_NEST_MAX                         = 32
	HOST_NAME_MAX                         = 64
	INLINE                                = 0
	INT_MAX                               = 2147483647
	INT_MIN                               = -2147483648
	LINE_MAX                              = 2048
	LLONG_MAX                             = 9223372036854775807
	LLONG_MIN                             = -9223372036854775808
	LOGIN_NAME_MAX                        = 256
	LONG_MAX                              = 9223372036854775807
	LONG_MIN                              = -9223372036854775808
	MAX_CANON                             = 255
	MAX_INPUT                             = 255
	MB_LEN_MAX                            = 16
	MP_DIGIT_DECLARED                     = 0
	MP_INT_DECLARED                       = 0
	MQ_PRIO_MAX                           = 32768
	NAME_MAX                              = 255
	NGROUPS_MAX                           = 65536
	NUM_STATIC_TOKENS                     = 20
	PATH_MAX                              = 4096
	PIPE_BUF                              = 4096
	PTHREAD_DESTRUCTOR_ITERATIONS         = 4
	PTHREAD_KEYS_MAX                      = 1024
	PTHREAD_STACK_MIN                     = 16384
	RE_DUP_MAX                            = 32767
	RTSIG_MAX                             = 32
	SCHAR_MAX                             = 127
	SCHAR_MIN                             = -128
	SEM_VALUE_MAX                         = 2147483647
	SHRT_MAX                              = 32767
	SHRT_MIN                              = -32768
	SQLITE_TCLAPI                         = 0
	SSIZE_MAX                             = 9223372036854775807
	TCL_ALLOW_INLINE_COMPILATION          = 0x20000
	TCL_ALL_EVENTS                        = -3
	TCL_ALPHA_RELEASE                     = 0
	TCL_APPEND_VALUE                      = 4
	TCL_ARGV_CONSTANT                     = 15
	TCL_ARGV_END                          = 23
	TCL_ARGV_FLOAT                        = 19
	TCL_ARGV_FUNC                         = 20
	TCL_ARGV_GENFUNC                      = 21
	TCL_ARGV_HELP                         = 22
	TCL_ARGV_INT                          = 16
	TCL_ARGV_REST                         = 18
	TCL_ARGV_STRING                       = 17
	TCL_BETA_RELEASE                      = 1
	TCL_BREAK                             = 3
	TCL_CANCEL_UNWIND                     = 0x100000
	TCL_CHANNEL_THREAD_INSERT             = 0
	TCL_CHANNEL_THREAD_REMOVE             = 1
	TCL_CLOSE_READ                        = 2
	TCL_CLOSE_WRITE                       = 4
	TCL_CONTINUE                          = 4
	TCL_CONVERT_MULTIBYTE                 = -1
	TCL_CONVERT_NOSPACE                   = -4
	TCL_CONVERT_SYNTAX                    = -2
	TCL_CONVERT_UNKNOWN                   = -3
	TCL_CREATE_HARD_LINK                  = 0x02
	TCL_CREATE_SYMBOLIC_LINK              = 0x01
	TCL_CUSTOM_PTR_KEYS                   = -1
	TCL_CUSTOM_TYPE_KEYS                  = -2
	TCL_DONT_QUOTE_HASH                   = 8
	TCL_DONT_USE_BRACES                   = 1
	TCL_DONT_WAIT                         = 2
	TCL_DOUBLE_SPACE                      = 27
	TCL_DSTRING_STATIC_SIZE               = 200
	TCL_ENCODING_CHAR_LIMIT               = 0x10
	TCL_ENCODING_END                      = 0x02
	TCL_ENCODING_NO_TERMINATE             = 0x08
	TCL_ENCODING_START                    = 0x01
	TCL_ENCODING_STOPONERROR              = 0x04
	TCL_ENFORCE_MODE                      = 16
	TCL_ENSEMBLE_PREFIX                   = 0x02
	TCL_ERROR                             = 1
	TCL_EVAL_DIRECT                       = 0x040000
	TCL_EVAL_GLOBAL                       = 0x020000
	TCL_EVAL_INVOKE                       = 0x080000
	TCL_EVAL_NOERR                        = 0x200000
	TCL_EXACT                             = 1
	TCL_EXCEPTION                         = 8
	TCL_FILE_EVENTS                       = 8
	TCL_FINAL_RELEASE                     = 2
	TCL_GLOBAL_ONLY                       = 1
	TCL_GLOB_PERM_HIDDEN                  = 2
	TCL_GLOB_PERM_R                       = 4
	TCL_GLOB_PERM_RONLY                   = 1
	TCL_GLOB_PERM_W                       = 8
	TCL_GLOB_PERM_X                       = 16
	TCL_GLOB_TYPE_BLOCK                   = 1
	TCL_GLOB_TYPE_CHAR                    = 2
	TCL_GLOB_TYPE_DIR                     = 4
	TCL_GLOB_TYPE_FILE                    = 16
	TCL_GLOB_TYPE_LINK                    = 32
	TCL_GLOB_TYPE_MOUNT                   = 128
	TCL_GLOB_TYPE_PIPE                    = 8
	TCL_GLOB_TYPE_SOCK                    = 64
	TCL_HASH_KEY_RANDOMIZE_HASH           = 0x1
	TCL_HASH_KEY_STORE_HASH               = 1
	TCL_HASH_KEY_SYSTEM_HASH              = 0x2
	TCL_HASH_KEY_TYPE_VERSION             = 1
	TCL_IDLE_EVENTS                       = 32
	TCL_INTEGER_SPACE                     = 24
	TCL_INTERP_DESTROYED                  = 0x100
	TCL_LEAVE_ERR_MSG                     = 0x200
	TCL_LIMIT_COMMANDS                    = 0x01
	TCL_LIMIT_TIME                        = 0x02
	TCL_LINK_BOOLEAN                      = 3
	TCL_LINK_CHAR                         = 6
	TCL_LINK_DOUBLE                       = 2
	TCL_LINK_FLOAT                        = 13
	TCL_LINK_INT                          = 1
	TCL_LINK_LONG                         = 11
	TCL_LINK_READ_ONLY                    = 0x80
	TCL_LINK_SHORT                        = 8
	TCL_LINK_STRING                       = 4
	TCL_LINK_UCHAR                        = 7
	TCL_LINK_UINT                         = 10
	TCL_LINK_ULONG                        = 12
	TCL_LINK_USHORT                       = 9
	TCL_LINK_WIDE_INT                     = 5
	TCL_LINK_WIDE_UINT                    = 14
	TCL_LIST_ELEMENT                      = 8
	TCL_LL_MODIFIER                       = "l"
	TCL_LOAD_GLOBAL                       = 1
	TCL_LOAD_LAZY                         = 2
	TCL_MAJOR_VERSION                     = 8
	TCL_MATCH_NOCASE                      = 1
	TCL_MAX_PREC                          = 17
	TCL_MINOR_VERSION                     = 6
	TCL_MODE_BLOCKING                     = 0
	TCL_MODE_NONBLOCKING                  = 1
	TCL_NAMESPACE_ONLY                    = 2
	TCL_NORETURN                          = 0
	TCL_NORETURN1                         = 0
	TCL_NO_EVAL                           = 0x010000
	TCL_OK                                = 0
	TCL_ONE_WORD_KEYS                     = 1
	TCL_PARSE_BAD_NUMBER                  = 9
	TCL_PARSE_BRACE_EXTRA                 = 2
	TCL_PARSE_MISSING_BRACE               = 3
	TCL_PARSE_MISSING_BRACKET             = 4
	TCL_PARSE_MISSING_PAREN               = 5
	TCL_PARSE_MISSING_QUOTE               = 6
	TCL_PARSE_MISSING_VAR_BRACE           = 7
	TCL_PARSE_PART1                       = 0x400
	TCL_PARSE_QUOTE_EXTRA                 = 1
	TCL_PARSE_SUCCESS                     = 0
	TCL_PARSE_SYNTAX                      = 8
	TCL_PATCH_LEVEL                       = "8.6.9"
	TCL_READABLE                          = 2
	TCL_REG_ADVANCED                      = 000003
	TCL_REG_ADVF                          = 000002
	TCL_REG_BASIC                         = 000000
	TCL_REG_CANMATCH                      = 001000
	TCL_REG_EXPANDED                      = 000040
	TCL_REG_EXTENDED                      = 000001
	TCL_REG_NEWLINE                       = 000300
	TCL_REG_NLANCH                        = 000200
	TCL_REG_NLSTOP                        = 000100
	TCL_REG_NOCASE                        = 000010
	TCL_REG_NOSUB                         = 000020
	TCL_REG_NOTBOL                        = 0001
	TCL_REG_NOTEOL                        = 0002
	TCL_REG_QUOTE                         = 000004
	TCL_RELEASE_LEVEL                     = 2
	TCL_RELEASE_SERIAL                    = 9
	TCL_RESULT_SIZE                       = 200
	TCL_RETURN                            = 2
	TCL_SERVICE_ALL                       = 1
	TCL_SERVICE_NONE                      = 0
	TCL_SMALL_HASH_TABLE                  = 4
	TCL_STDERR                            = 8
	TCL_STDIN                             = 2
	TCL_STDOUT                            = 4
	TCL_STORAGE_CLASS                     = 0
	TCL_STRING_KEYS                       = 0
	TCL_SUBST_ALL                         = 007
	TCL_SUBST_BACKSLASHES                 = 004
	TCL_SUBST_COMMANDS                    = 001
	TCL_SUBST_VARIABLES                   = 002
	TCL_THREAD_CREATE_RETURN              = 0
	TCL_THREAD_JOINABLE                   = 1
	TCL_THREAD_NOFLAGS                    = 0
	TCL_THREAD_STACK_DEFAULT              = 0
	TCL_TIMER_EVENTS                      = 16
	TCL_TOKEN_BS                          = 8
	TCL_TOKEN_COMMAND                     = 16
	TCL_TOKEN_EXPAND_WORD                 = 256
	TCL_TOKEN_OPERATOR                    = 128
	TCL_TOKEN_SIMPLE_WORD                 = 2
	TCL_TOKEN_SUB_EXPR                    = 64
	TCL_TOKEN_TEXT                        = 4
	TCL_TOKEN_VARIABLE                    = 32
	TCL_TOKEN_WORD                        = 1
	TCL_TRACE_ARRAY                       = 0x800
	TCL_TRACE_DELETE                      = 0x4000
	TCL_TRACE_DESTROYED                   = 0x80
	TCL_TRACE_OLD_STYLE                   = 0x1000
	TCL_TRACE_READS                       = 0x10
	TCL_TRACE_RENAME                      = 0x2000
	TCL_TRACE_RESULT_DYNAMIC              = 0x8000
	TCL_TRACE_RESULT_OBJECT               = 0x10000
	TCL_TRACE_UNSETS                      = 0x40
	TCL_TRACE_WRITES                      = 0x20
	TCL_UNLOAD_DETACH_FROM_INTERPRETER    = 1
	TCL_UNLOAD_DETACH_FROM_PROCESS        = 2
	TCL_UTF_MAX                           = 3
	TCL_VERSION                           = "8.6"
	TCL_WIDE_INT_IS_LONG                  = 1
	TCL_WINDOW_EVENTS                     = 4
	TCL_WRITABLE                          = 4
	TCL_ZLIB_COMPRESS_BEST                = 9
	TCL_ZLIB_COMPRESS_DEFAULT             = -1
	TCL_ZLIB_COMPRESS_FAST                = 1
	TCL_ZLIB_COMPRESS_NONE                = 0
	TCL_ZLIB_FINALIZE                     = 4
	TCL_ZLIB_FLUSH                        = 2
	TCL_ZLIB_FORMAT_AUTO                  = 8
	TCL_ZLIB_FORMAT_GZIP                  = 4
	TCL_ZLIB_FORMAT_RAW                   = 1
	TCL_ZLIB_FORMAT_ZLIB                  = 2
	TCL_ZLIB_FULLFLUSH                    = 3
	TCL_ZLIB_NO_FLUSH                     = 0
	TCL_ZLIB_STREAM_DEFLATE               = 16
	TCL_ZLIB_STREAM_INFLATE               = 32
	TTY_NAME_MAX                          = 32
	UCHAR_MAX                             = 255
	UINT_MAX                              = 4294967295
	ULLONG_MAX                            = -1
	ULONG_MAX                             = -1
	USHRT_MAX                             = 65535
	XATTR_LIST_MAX                        = 65536
	XATTR_NAME_MAX                        = 255
	XATTR_SIZE_MAX                        = 65536
	_BITS_POSIX1_LIM_H                    = 1
	_BITS_POSIX2_LIM_H                    = 1
	_CLIENTDATA                           = 0
	_GCC_LIMITS_H_                        = 0
	_LIBC_LIMITS_H_                       = 1
	_LIMITS_H                             = 1
	_LIMITS_H___                          = 0
	_LINUX_LIMITS_H                       = 0
	_POSIX2_BC_BASE_MAX                   = 99
	_POSIX2_BC_DIM_MAX                    = 2048
	_POSIX2_BC_SCALE_MAX                  = 99
	_POSIX2_BC_STRING_MAX                 = 1000
	_POSIX2_CHARCLASS_NAME_MAX            = 14
	_POSIX2_COLL_WEIGHTS_MAX              = 2
	_POSIX2_EXPR_NEST_MAX                 = 32
	_POSIX2_LINE_MAX                      = 2048
	_POSIX2_RE_DUP_MAX                    = 255
	_POSIX_AIO_LISTIO_MAX                 = 2
	_POSIX_AIO_MAX                        = 1
	_POSIX_ARG_MAX                        = 4096
	_POSIX_CHILD_MAX                      = 25
	_POSIX_CLOCKRES_MIN                   = 20000000
	_POSIX_DELAYTIMER_MAX                 = 32
	_POSIX_HOST_NAME_MAX                  = 255
	_POSIX_LINK_MAX                       = 8
	_POSIX_LOGIN_NAME_MAX                 = 9
	_POSIX_MAX_CANON                      = 255
	_POSIX_MAX_INPUT                      = 255
	_POSIX_MQ_OPEN_MAX                    = 8
	_POSIX_MQ_PRIO_MAX                    = 32
	_POSIX_NAME_MAX                       = 14
	_POSIX_NGROUPS_MAX                    = 8
	_POSIX_OPEN_MAX                       = 20
	_POSIX_PATH_MAX                       = 256
	_POSIX_PIPE_BUF                       = 512
	_POSIX_RE_DUP_MAX                     = 255
	_POSIX_RTSIG_MAX                      = 8
	_POSIX_SEM_NSEMS_MAX                  = 256
	_POSIX_SEM_VALUE_MAX                  = 32767
	_POSIX_SIGQUEUE_MAX                   = 32
	_POSIX_SSIZE_MAX                      = 32767
	_POSIX_STREAM_MAX                     = 8
	_POSIX_SYMLINK_MAX                    = 255
	_POSIX_SYMLOOP_MAX                    = 8
	_POSIX_THREAD_DESTRUCTOR_ITERATIONS   = 4
	_POSIX_THREAD_KEYS_MAX                = 128
	_POSIX_THREAD_THREADS_MAX             = 64
	_POSIX_TIMER_MAX                      = 32
	_POSIX_TTY_NAME_MAX                   = 9
	_POSIX_TZNAME_MAX                     = 6
	_TCL                                  = 0
	_TCLDECLS                             = 0
	_TCLPLATDECLS                         = 0
	AMATCH_COL_COMMAND                    = 3
	AMATCH_COL_DISTANCE                   = 1
	AMATCH_COL_LANGUAGE                   = 2
	AMATCH_COL_NWORD                      = 4
	AMATCH_COL_WORD                       = 0
	AMATCH_MX_COST                        = 1000
	AMATCH_MX_LANGID                      = 2147483647
	AMATCH_MX_LENGTH                      = 50
	BIG_ENDIAN                            = 4321
	BYTE_ORDER                            = 1234
	EXIT_FAILURE                          = 1
	EXIT_SUCCESS                          = 0
	FD_SETSIZE                            = 1024
	LITTLE_ENDIAN                         = 1234
	PDP_ENDIAN                            = 3412
	RAND_MAX                              = 2147483647
	SQLITE3EXT_H                          = 0
	SQLITE_EXTENSION_INIT1                = 0
	SQLITE_EXTENSION_INIT3                = 0
	WCONTINUED                            = 8
	WEXITED                               = 4
	WNOHANG                               = 1
	WNOWAIT                               = 0x01000000
	WSTOPPED                              = 2
	WUNTRACED                             = 2
	_ALLOCA_H                             = 1
	_BITS_BYTESWAP_H                      = 1
	_BITS_FLOATN_COMMON_H                 = 0
	_BITS_FLOATN_H                        = 0
	_BITS_PTHREADTYPES_ARCH_H             = 1
	_BITS_PTHREADTYPES_COMMON_H           = 1
	_BITS_STDINT_INTN_H                   = 1
	_BITS_UINTN_IDENTITY_H                = 1
	_CTYPE_H                              = 1
	_ENDIAN_H                             = 1
	_GCC_WCHAR_T                          = 0
	_STDLIB_H                             = 1
	_STRUCT_TIMESPEC                      = 1
	_SYS_SELECT_H                         = 1
	_SYS_TYPES_H                          = 1
	_THREAD_SHARED_TYPES_H                = 1
	_T_WCHAR                              = 0
	_T_WCHAR_                             = 0
	_WCHAR_T                              = 0
	_WCHAR_T_                             = 0
	_WCHAR_T_DECLARED                     = 0
	_WCHAR_T_DEFINED                      = 0
	_WCHAR_T_DEFINED_                     = 0
	_WCHAR_T_H                            = 0
	CARRAY_COLUMN_COUNT                   = 2
	CARRAY_COLUMN_CTYPE                   = 3
	CARRAY_COLUMN_POINTER                 = 1
	CARRAY_COLUMN_VALUE                   = 0
	CARRAY_DOUBLE                         = 2
	CARRAY_INT32                          = 0
	CARRAY_INT64                          = 1
	CARRAY_TEXT                           = 3
	CLOSURE_COL_DEPTH                     = 1
	CLOSURE_COL_ID                        = 0
	CLOSURE_COL_IDCOLUMN                  = 4
	CLOSURE_COL_PARENTCOLUMN              = 5
	CLOSURE_COL_ROOT                      = 2
	CLOSURE_COL_TABLENAME                 = 3
	CSVTEST_FIDX                          = 0x0001
	CSV_INBUFSZ                           = 1024
	CSV_MXERR                             = 200
	CSV_NOINLINE                          = 0
	EXPLN_COLUMN_ADDR                     = 0
	EXPLN_COLUMN_COMMENT                  = 7
	EXPLN_COLUMN_OPCODE                   = 1
	EXPLN_COLUMN_P1                       = 2
	EXPLN_COLUMN_P2                       = 3
	EXPLN_COLUMN_P3                       = 4
	EXPLN_COLUMN_P4                       = 5
	EXPLN_COLUMN_P5                       = 6
	EXPLN_COLUMN_SQL                      = 8
	ACCESSPERMS                           = 511
	ALLPERMS                              = 4095
	AT_EACCESS                            = 0x200
	AT_FDCWD                              = -100
	AT_REMOVEDIR                          = 0x200
	AT_SYMLINK_FOLLOW                     = 0x400
	AT_SYMLINK_NOFOLLOW                   = 0x100
	CLOCK_BOOTTIME                        = 7
	CLOCK_BOOTTIME_ALARM                  = 9
	CLOCK_MONOTONIC                       = 1
	CLOCK_MONOTONIC_COARSE                = 6
	CLOCK_MONOTONIC_RAW                   = 4
	CLOCK_PROCESS_CPUTIME_ID              = 2
	CLOCK_REALTIME                        = 0
	CLOCK_REALTIME_ALARM                  = 8
	CLOCK_REALTIME_COARSE                 = 5
	CLOCK_TAI                             = 11
	CLOCK_THREAD_CPUTIME_ID               = 3
	DEFFILEMODE                           = 438
	E2BIG                                 = 7
	EACCES                                = 13
	EADDRINUSE                            = 98
	EADDRNOTAVAIL                         = 99
	EADV                                  = 68
	EAFNOSUPPORT                          = 97
	EAGAIN                                = 11
	EALREADY                              = 114
	EBADE                                 = 52
	EBADF                                 = 9
	EBADFD                                = 77
	EBADMSG                               = 74
	EBADR                                 = 53
	EBADRQC                               = 56
	EBADSLT                               = 57
	EBFONT                                = 59
	EBUSY                                 = 16
	ECANCELED                             = 125
	ECHILD                                = 10
	ECHRNG                                = 44
	ECOMM                                 = 70
	ECONNABORTED                          = 103
	ECONNREFUSED                          = 111
	ECONNRESET                            = 104
	EDEADLK                               = 35
	EDEADLOCK                             = 35
	EDESTADDRREQ                          = 89
	EDOM                                  = 33
	EDOTDOT                               = 73
	EDQUOT                                = 122
	EEXIST                                = 17
	EFAULT                                = 14
	EFBIG                                 = 27
	EHOSTDOWN                             = 112
	EHOSTUNREACH                          = 113
	EHWPOISON                             = 133
	EIDRM                                 = 43
	EILSEQ                                = 84
	EINPROGRESS                           = 115
	EINTR                                 = 4
	EINVAL                                = 22
	EIO                                   = 5
	EISCONN                               = 106
	EISDIR                                = 21
	EISNAM                                = 120
	EKEYEXPIRED                           = 127
	EKEYREJECTED                          = 129
	EKEYREVOKED                           = 128
	EL2HLT                                = 51
	EL2NSYNC                              = 45
	EL3HLT                                = 46
	EL3RST                                = 47
	ELIBACC                               = 79
	ELIBBAD                               = 80
	ELIBEXEC                              = 83
	ELIBMAX                               = 82
	ELIBSCN                               = 81
	ELNRNG                                = 48
	ELOOP                                 = 40
	EMEDIUMTYPE                           = 124
	EMFILE                                = 24
	EMLINK                                = 31
	EMSGSIZE                              = 90
	EMULTIHOP                             = 72
	ENAMETOOLONG                          = 36
	ENAVAIL                               = 119
	ENETDOWN                              = 100
	ENETRESET                             = 102
	ENETUNREACH                           = 101
	ENFILE                                = 23
	ENOANO                                = 55
	ENOBUFS                               = 105
	ENOCSI                                = 50
	ENODATA                               = 61
	ENODEV                                = 19
	ENOENT                                = 2
	ENOEXEC                               = 8
	ENOKEY                                = 126
	ENOLCK                                = 37
	ENOLINK                               = 67
	ENOMEDIUM                             = 123
	ENOMEM                                = 12
	ENOMSG                                = 42
	ENONET                                = 64
	ENOPKG                                = 65
	ENOPROTOOPT                           = 92
	ENOSPC                                = 28
	ENOSR                                 = 63
	ENOSTR                                = 60
	ENOSYS                                = 38
	ENOTBLK                               = 15
	ENOTCONN                              = 107
	ENOTDIR                               = 20
	ENOTEMPTY                             = 39
	ENOTNAM                               = 118
	ENOTRECOVERABLE                       = 131
	ENOTSOCK                              = 88
	ENOTSUP                               = 95
	ENOTTY                                = 25
	ENOTUNIQ                              = 76
	ENXIO                                 = 6
	EOPNOTSUPP                            = 95
	EOVERFLOW                             = 75
	EOWNERDEAD                            = 130
	EPERM                                 = 1
	EPFNOSUPPORT                          = 96
	EPIPE                                 = 32
	EPROTO                                = 71
	EPROTONOSUPPORT                       = 93
	EPROTOTYPE                            = 91
	ERANGE                                = 34
	EREMCHG                               = 78
	EREMOTE                               = 66
	EREMOTEIO                             = 121
	ERESTART                              = 85
	ERFKILL                               = 132
	EROFS                                 = 30
	ESHUTDOWN                             = 108
	ESOCKTNOSUPPORT                       = 94
	ESPIPE                                = 29
	ESRCH                                 = 3
	ESRMNT                                = 69
	ESTALE                                = 116
	ESTRPIPE                              = 86
	ETIME                                 = 62
	ETIMEDOUT                             = 110
	ETOOMANYREFS                          = 109
	ETXTBSY                               = 26
	EUCLEAN                               = 117
	EUNATCH                               = 49
	EUSERS                                = 87
	EWOULDBLOCK                           = 11
	EXDEV                                 = 18
	EXFULL                                = 54
	FAPPEND                               = 1024
	FASYNC                                = 8192
	FD_CLOEXEC                            = 1
	FFSYNC                                = 1052672
	FNDELAY                               = 2048
	FNONBLOCK                             = 2048
	FSDIR_COLUMN_DATA                     = 3
	FSDIR_COLUMN_DIR                      = 5
	FSDIR_COLUMN_MODE                     = 1
	FSDIR_COLUMN_MTIME                    = 2
	FSDIR_COLUMN_NAME                     = 0
	FSDIR_COLUMN_PATH                     = 4
	FSDIR_SCHEMA                          = "(name,mode,mtime,data,path HIDDEN,dir HIDDEN)"
	F_DUPFD                               = 0
	F_DUPFD_CLOEXEC                       = 1030
	F_EXLCK                               = 4
	F_GETFD                               = 1
	F_GETFL                               = 3
	F_GETLK                               = 5
	F_GETLK64                             = 5
	F_GETOWN                              = 9
	F_LOCK                                = 1
	F_OK                                  = 0
	F_RDLCK                               = 0
	F_SETFD                               = 2
	F_SETFL                               = 4
	F_SETLK                               = 6
	F_SETLK64                             = 6
	F_SETLKW                              = 7
	F_SETLKW64                            = 7
	F_SETOWN                              = 8
	F_SHLCK                               = 8
	F_TEST                                = 3
	F_TLOCK                               = 2
	F_ULOCK                               = 0
	F_UNLCK                               = 2
	F_WRLCK                               = 1
	LOCK_EX                               = 2
	LOCK_NB                               = 4
	LOCK_SH                               = 1
	LOCK_UN                               = 8
	L_INCR                                = 1
	L_SET                                 = 0
	L_XTND                                = 2
	MAXNAMLEN                             = 255
	O_ACCMODE                             = 0003
	O_APPEND                              = 02000
	O_ASYNC                               = 020000
	O_CLOEXEC                             = 524288
	O_CREAT                               = 0100
	O_DIRECTORY                           = 65536
	O_DSYNC                               = 4096
	O_EXCL                                = 0200
	O_FSYNC                               = 1052672
	O_NDELAY                              = 2048
	O_NOCTTY                              = 0400
	O_NOFOLLOW                            = 131072
	O_NONBLOCK                            = 04000
	O_RDONLY                              = 00
	O_RDWR                                = 02
	O_RSYNC                               = 1052672
	O_SYNC                                = 04010000
	O_TRUNC                               = 01000
	O_WRONLY                              = 01
	POSIX_FADV_DONTNEED                   = 4
	POSIX_FADV_NOREUSE                    = 5
	POSIX_FADV_NORMAL                     = 0
	POSIX_FADV_RANDOM                     = 1
	POSIX_FADV_SEQUENTIAL                 = 2
	POSIX_FADV_WILLNEED                   = 3
	R_OK                                  = 4
	STDERR_FILENO                         = 2
	STDIN_FILENO                          = 0
	STDOUT_FILENO                         = 1
	S_BLKSIZE                             = 512
	S_IEXEC                               = 64
	S_IFBLK                               = 24576
	S_IFCHR                               = 8192
	S_IFDIR                               = 16384
	S_IFIFO                               = 4096
	S_IFLNK                               = 40960
	S_IFMT                                = 61440
	S_IFREG                               = 32768
	S_IFSOCK                              = 49152
	S_IREAD                               = 256
	S_IRGRP                               = 32
	S_IROTH                               = 4
	S_IRUSR                               = 256
	S_IRWXG                               = 56
	S_IRWXO                               = 7
	S_IRWXU                               = 448
	S_ISGID                               = 1024
	S_ISUID                               = 2048
	S_ISVTX                               = 512
	S_IWGRP                               = 16
	S_IWOTH                               = 2
	S_IWRITE                              = 128
	S_IWUSR                               = 128
	S_IXGRP                               = 8
	S_IXOTH                               = 1
	S_IXUSR                               = 64
	TIMER_ABSTIME                         = 1
	TIME_UTC                              = 1
	UTIME_NOW                             = 1073741823
	UTIME_OMIT                            = 1073741822
	W_OK                                  = 2
	X_OK                                  = 1
	_ASM_GENERIC_ERRNO_BASE_H             = 0
	_ASM_GENERIC_ERRNO_H                  = 0
	_BITS_ERRNO_H                         = 1
	_BITS_POSIX_OPT_H                     = 1
	_BITS_STAT_H                          = 1
	_BITS_TIME_H                          = 1
	_DIRENT_H                             = 1
	_DIRENT_HAVE_D_OFF                    = 0
	_DIRENT_HAVE_D_RECLEN                 = 0
	_DIRENT_HAVE_D_TYPE                   = 0
	_DIRENT_MATCHES_DIRENT64              = 1
	_ERRNO_H                              = 1
	_FCNTL_H                              = 1
	_GETOPT_CORE_H                        = 1
	_GETOPT_POSIX_H                       = 1
	_LFS64_ASYNCHRONOUS_IO                = 1
	_LFS64_LARGEFILE                      = 1
	_LFS64_STDIO                          = 1
	_LFS_ASYNCHRONOUS_IO                  = 1
	_LFS_LARGEFILE                        = 1
	_MKNOD_VER                            = 0
	_MKNOD_VER_LINUX                      = 0
	_POSIX2_CHAR_TERM                     = 200809
	_POSIX2_C_BIND                        = 200809
	_POSIX2_C_DEV                         = 200809
	_POSIX2_C_VERSION                     = 200809
	_POSIX2_LOCALEDEF                     = 200809
	_POSIX2_SW_DEV                        = 200809
	_POSIX2_VERSION                       = 200809
	_POSIX_ADVISORY_INFO                  = 200809
	_POSIX_ASYNCHRONOUS_IO                = 200809
	_POSIX_ASYNC_IO                       = 1
	_POSIX_BARRIERS                       = 200809
	_POSIX_CHOWN_RESTRICTED               = 0
	_POSIX_CLOCK_SELECTION                = 200809
	_POSIX_CPUTIME                        = 0
	_POSIX_FSYNC                          = 200809
	_POSIX_IPV6                           = 200809
	_POSIX_JOB_CONTROL                    = 1
	_POSIX_MAPPED_FILES                   = 200809
	_POSIX_MEMLOCK                        = 200809
	_POSIX_MEMLOCK_RANGE                  = 200809
	_POSIX_MEMORY_PROTECTION              = 200809
	_POSIX_MESSAGE_PASSING                = 200809
	_POSIX_MONOTONIC_CLOCK                = 0
	_POSIX_NO_TRUNC                       = 1
	_POSIX_PRIORITIZED_IO                 = 200809
	_POSIX_PRIORITY_SCHEDULING            = 200809
	_POSIX_RAW_SOCKETS                    = 200809
	_POSIX_READER_WRITER_LOCKS            = 200809
	_POSIX_REALTIME_SIGNALS               = 200809
	_POSIX_REENTRANT_FUNCTIONS            = 1
	_POSIX_REGEXP                         = 1
	_POSIX_SAVED_IDS                      = 1
	_POSIX_SEMAPHORES                     = 200809
	_POSIX_SHARED_MEMORY_OBJECTS          = 200809
	_POSIX_SHELL                          = 1
	_POSIX_SPAWN                          = 200809
	_POSIX_SPIN_LOCKS                     = 200809
	_POSIX_SPORADIC_SERVER                = -1
	_POSIX_SYNCHRONIZED_IO                = 200809
	_POSIX_THREADS                        = 200809
	_POSIX_THREAD_ATTR_STACKADDR          = 200809
	_POSIX_THREAD_ATTR_STACKSIZE          = 200809
	_POSIX_THREAD_CPUTIME                 = 0
	_POSIX_THREAD_PRIORITY_SCHEDULING     = 200809
	_POSIX_THREAD_PRIO_INHERIT            = 200809
	_POSIX_THREAD_PRIO_PROTECT            = 200809
	_POSIX_THREAD_PROCESS_SHARED          = 200809
	_POSIX_THREAD_ROBUST_PRIO_INHERIT     = 200809
	_POSIX_THREAD_ROBUST_PRIO_PROTECT     = -1
	_POSIX_THREAD_SAFE_FUNCTIONS          = 200809
	_POSIX_THREAD_SPORADIC_SERVER         = -1
	_POSIX_TIMEOUTS                       = 200809
	_POSIX_TIMERS                         = 200809
	_POSIX_TRACE                          = -1
	_POSIX_TRACE_EVENT_FILTER             = -1
	_POSIX_TRACE_INHERIT                  = -1
	_POSIX_TRACE_LOG                      = -1
	_POSIX_TYPED_MEMORY_OBJECTS           = -1
	_POSIX_V6_LP64_OFF64                  = 1
	_POSIX_V6_LPBIG_OFFBIG                = -1
	_POSIX_V7_LP64_OFF64                  = 1
	_POSIX_V7_LPBIG_OFFBIG                = -1
	_POSIX_VDISABLE                       = 0
	_POSIX_VERSION                        = 200809
	_STATBUF_ST_BLKSIZE                   = 0
	_STATBUF_ST_NSEC                      = 0
	_STATBUF_ST_RDEV                      = 0
	_STAT_VER                             = 1
	_STAT_VER_KERNEL                      = 0
	_STAT_VER_LINUX                       = 1
	_SYS_STAT_H                           = 1
	_SYS_TIME_H                           = 1
	_TIME_H                               = 1
	_UNISTD_H                             = 1
	_UTIME_H                              = 1
	_XBS5_LP64_OFF64                      = 1
	_XBS5_LPBIG_OFFBIG                    = -1
	_XOPEN_ENH_I18N                       = 1
	_XOPEN_LEGACY                         = 1
	_XOPEN_REALTIME                       = 1
	_XOPEN_REALTIME_THREADS               = 1
	_XOPEN_SHM                            = 1
	_XOPEN_UNIX                           = 1
	_XOPEN_VERSION                        = 700
	_XOPEN_XCU_VERSION                    = 4
	_XOPEN_XPG2                           = 1
	_XOPEN_XPG3                           = 1
	_XOPEN_XPG4                           = 1
	FUZZER_HASH                           = 4001
	FUZZER_MX_COST                        = 1000
	FUZZER_MX_LENGTH                      = 50
	FUZZER_MX_OUTPUT_LENGTH               = 100
	FUZZER_MX_RULEID                      = 2147483647
	FUZZER_NQUEUE                         = 20
	NDEBUG                                = 0
	CC_AND                                = 24
	CC_BANG                               = 15
	CC_COMMA                              = 23
	CC_DIGIT                              = 3
	CC_DOLLAR                             = 4
	CC_DOT                                = 26
	CC_EQ                                 = 14
	CC_GT                                 = 13
	CC_ID                                 = 2
	CC_ILLEGAL                            = 27
	CC_KYWD                               = 1
	CC_LP                                 = 17
	CC_LT                                 = 12
	CC_MINUS                              = 11
	CC_PERCENT                            = 22
	CC_PIPE                               = 10
	CC_PLUS                               = 20
	CC_QUOTE                              = 8
	CC_QUOTE2                             = 9
	CC_RP                                 = 18
	CC_SEMI                               = 19
	CC_SLASH                              = 16
	CC_SPACE                              = 7
	CC_STAR                               = 21
	CC_TILDA                              = 25
	CC_VARALPHA                           = 5
	CC_VARNUM                             = 6
	CC_X                                  = 0
	TK_BITAND                             = 3
	TK_BITNOT                             = 3
	TK_BITOR                              = 3
	TK_BLOB                               = 2
	TK_COMMA                              = 3
	TK_CONCAT                             = 3
	TK_DOT                                = 3
	TK_EQ                                 = 3
	TK_ERROR                              = 4
	TK_FLOAT                              = 2
	TK_GE                                 = 3
	TK_GT                                 = 3
	TK_ID                                 = 1
	TK_ILLEGAL                            = 4
	TK_INTEGER                            = 2
	TK_LE                                 = 3
	TK_LITERAL                            = 2
	TK_LP                                 = 3
	TK_LSHIFT                             = 3
	TK_LT                                 = 3
	TK_MINUS                              = 3
	TK_NAME                               = 1
	TK_NE                                 = 3
	TK_PLUS                               = 3
	TK_PUNCT                              = 3
	TK_REM                                = 3
	TK_RP                                 = 3
	TK_RSHIFT                             = 3
	TK_SEMI                               = 3
	TK_SLASH                              = 3
	TK_SPACE                              = 0
	TK_STAR                               = 3
	TK_STRING                             = 2
	TK_VARIABLE                           = 2
	RE_EOF                                = 0
	RE_OP_ACCEPT                          = 6
	RE_OP_ANY                             = 2
	RE_OP_ANYSTAR                         = 3
	RE_OP_BOUNDARY                        = 17
	RE_OP_CC_EXC                          = 8
	RE_OP_CC_INC                          = 7
	RE_OP_CC_RANGE                        = 10
	RE_OP_CC_VALUE                        = 9
	RE_OP_DIGIT                           = 13
	RE_OP_FORK                            = 4
	RE_OP_GOTO                            = 5
	RE_OP_MATCH                           = 1
	RE_OP_NOTDIGIT                        = 14
	RE_OP_NOTSPACE                        = 16
	RE_OP_NOTWORD                         = 12
	RE_OP_SPACE                           = 15
	RE_OP_WORD                            = 11
	SERIES_COLUMN_START                   = 1
	SERIES_COLUMN_STEP                    = 3
	SERIES_COLUMN_STOP                    = 2
	SERIES_COLUMN_VALUE                   = 0
	SQLITE_SERIES_CONSTRAINT_VERIFY       = 0
	CCLASS_B                              = 2
	CCLASS_C                              = 3
	CCLASS_D                              = 4
	CCLASS_DIGIT                          = 10
	CCLASS_H                              = 5
	CCLASS_L                              = 6
	CCLASS_M                              = 8
	CCLASS_OTHER                          = 12
	CCLASS_R                              = 7
	CCLASS_SILENT                         = 0
	CCLASS_SPACE                          = 11
	CCLASS_VOWEL                          = 1
	CCLASS_Y                              = 9
	FINAL_INS_COST_DIV                    = 4
	SCRIPT_ARABIC                         = 0x0010
	SCRIPT_CYRILLIC                       = 0x0002
	SCRIPT_GREEK                          = 0x0004
	SCRIPT_HEBREW                         = 0x0008
	SCRIPT_LATIN                          = 0x0001
	SPELLFIX_COL_COMMAND                  = 11
	SPELLFIX_COL_DISTANCE                 = 2
	SPELLFIX_COL_LANGID                   = 3
	SPELLFIX_COL_MATCHLEN                 = 5
	SPELLFIX_COL_PHONEHASH                = 6
	SPELLFIX_COL_RANK                     = 1
	SPELLFIX_COL_SCOPE                    = 8
	SPELLFIX_COL_SCORE                    = 4
	SPELLFIX_COL_SOUNDSLIKE               = 10
	SPELLFIX_COL_SRCHCNT                  = 9
	SPELLFIX_COL_TOP                      = 7
	SPELLFIX_COL_WORD                     = 0
	SPELLFIX_IDXNUM_DIST                  = 48
	SPELLFIX_IDXNUM_DISTLE                = 0x20
	SPELLFIX_IDXNUM_DISTLT                = 0x10
	SPELLFIX_IDXNUM_LANGID                = 0x02
	SPELLFIX_IDXNUM_MATCH                 = 0x01
	SPELLFIX_IDXNUM_ROWID                 = 0x40
	SPELLFIX_IDXNUM_SCOPE                 = 0x08
	SPELLFIX_IDXNUM_TOP                   = 0x04
	SPELLFIX_MX_HASH                      = 32
	SPELLFIX_MX_RUN                       = 1
	SQLITE_SPELLFIX_STACKALLOC_SZ         = 1024
	TOTYPE_BIGENDIAN                      = 0
	TOTYPE_LITTLEENDIAN                   = 1
	SWARMVTAB_MAX_OPEN                    = 9
	RBU_CREATE_STATE                      = "CREATE TABLE IF NOT EXISTS %s.rbu_state(k INTEGER PRIMARY KEY, v)"
	RBU_DELETE                            = 2
	RBU_ENABLE_DELTA_CKSUM                = 0
	RBU_IDX_DELETE                        = 4
	RBU_IDX_INSERT                        = 5
	RBU_INSERT                            = 1
	RBU_PK_EXTERNAL                       = 3
	RBU_PK_IPK                            = 2
	RBU_PK_NONE                           = 1
	RBU_PK_NOTABLE                        = 0
	RBU_PK_VTAB                           = 5
	RBU_PK_WITHOUT_ROWID                  = 4
	RBU_REPLACE                           = 3
	RBU_STAGE_CAPTURE                     = 3
	RBU_STAGE_CKPT                        = 4
	RBU_STAGE_DONE                        = 5
	RBU_STAGE_MOVE                        = 2
	RBU_STAGE_OAL                         = 1
	RBU_STATE_CKPT                        = 6
	RBU_STATE_COOKIE                      = 7
	RBU_STATE_DATATBL                     = 10
	RBU_STATE_IDX                         = 3
	RBU_STATE_OALSZ                       = 8
	RBU_STATE_PHASEONESTEP                = 9
	RBU_STATE_PROGRESS                    = 5
	RBU_STATE_ROW                         = 4
	RBU_STATE_STAGE                       = 1
	RBU_STATE_TBL                         = 2
	RBU_UPDATE                            = 6
	SQLITE_FCNTL_RBUCNT                   = 5149216
	SQLITE_RBU_STATE_CHECKPOINT           = 3
	SQLITE_RBU_STATE_DONE                 = 4
	SQLITE_RBU_STATE_ERROR                = 5
	SQLITE_RBU_STATE_MOVE                 = 2
	SQLITE_RBU_STATE_OAL                  = 1
	SQLITE_RBU_UPDATE_CACHESIZE           = 16
	WAL_LOCK_CKPT                         = 1
	WAL_LOCK_READ0                        = 3
	WAL_LOCK_WRITE                        = 0
	_SQLITE3RBU_H                         = 0
	FP_XSTATE_MAGIC1                      = 0x46505853
	FP_XSTATE_MAGIC2                      = 0x46505845
	MAX_PREPARED_STMTS                    = 100
	MINSIGSTKSZ                           = 2048
	NGREG                                 = 23
	NSIG                                  = 65
	NUM_PREPARED_STMTS                    = 10
	SA_INTERRUPT                          = 0x20000000
	SA_NOCLDSTOP                          = 1
	SA_NOCLDWAIT                          = 2
	SA_NODEFER                            = 0x40000000
	SA_NOMASK                             = 1073741824
	SA_ONESHOT                            = 2147483648
	SA_ONSTACK                            = 0x08000000
	SA_RESETHAND                          = 0x80000000
	SA_RESTART                            = 0x10000000
	SA_SIGINFO                            = 4
	SA_STACK                              = 134217728
	SIGABRT                               = 6
	SIGALRM                               = 14
	SIGBUS                                = 7
	SIGCHLD                               = 17
	SIGCLD                                = 17
	SIGCONT                               = 18
	SIGFPE                                = 8
	SIGHUP                                = 1
	SIGILL                                = 4
	SIGINT                                = 2
	SIGIO                                 = 29
	SIGIOT                                = 6
	SIGKILL                               = 9
	SIGPIPE                               = 13
	SIGPOLL                               = 29
	SIGPROF                               = 27
	SIGPWR                                = 30
	SIGQUIT                               = 3
	SIGSEGV                               = 11
	SIGSTKFLT                             = 16
	SIGSTKSZ                              = 8192
	SIGSTOP                               = 19
	SIGSYS                                = 31
	SIGTERM                               = 15
	SIGTRAP                               = 5
	SIGTSTP                               = 20
	SIGTTIN                               = 21
	SIGTTOU                               = 22
	SIGURG                                = 23
	SIGUSR1                               = 10
	SIGUSR2                               = 12
	SIGVTALRM                             = 26
	SIGWINCH                              = 28
	SIGXCPU                               = 24
	SIGXFSZ                               = 25
	SIG_BLOCK                             = 0
	SIG_SETMASK                           = 2
	SIG_UNBLOCK                           = 1
	SQLITE_EVAL_WITHOUTNULLS              = 0x00001
	SQLITE_TCL_NRE                        = 1
	_BITS_SIGACTION_H                     = 1
	_BITS_SIGCONTEXT_H                    = 1
	_BITS_SIGEVENT_CONSTS_H               = 1
	_BITS_SIGINFO_ARCH_H                  = 1
	_BITS_SIGINFO_CONSTS_H                = 1
	_BITS_SIGNUM_GENERIC_H                = 1
	_BITS_SIGNUM_H                        = 1
	_BITS_SIGSTACK_H                      = 1
	_BITS_SIGTHREAD_H                     = 1
	_BITS_SS_FLAGS_H                      = 1
	_NSIG                                 = 65
	_SIGNAL_H                             = 0
	_SYS_UCONTEXT_H                       = 1
	AggInfoMagic                          = 0x2059e99e
	BTREE_APPEND                          = 0x08
	BTREE_APPLICATION_ID                  = 8
	BTREE_AUTOVACUUM_FULL                 = 1
	BTREE_AUTOVACUUM_INCR                 = 2
	BTREE_AUTOVACUUM_NONE                 = 0
	BTREE_AUXDELETE                       = 0x04
	BTREE_BLOBKEY                         = 2
	BTREE_BULKLOAD                        = 0x00000001
	BTREE_DATA_VERSION                    = 15
	BTREE_DEFAULT_CACHE_SIZE              = 3
	BTREE_FILE_FORMAT                     = 2
	BTREE_FORDELETE                       = 0x00000008
	BTREE_FREE_PAGE_COUNT                 = 0
	BTREE_HINT_RANGE                      = 0
	BTREE_INCR_VACUUM                     = 7
	BTREE_INTKEY                          = 1
	BTREE_LARGEST_ROOT_PAGE               = 4
	BTREE_MEMORY                          = 2
	BTREE_OMIT_JOURNAL                    = 1
	BTREE_SAVEPOSITION                    = 0x02
	BTREE_SCHEMA_VERSION                  = 1
	BTREE_SEEK_EQ                         = 0x00000002
	BTREE_SINGLE                          = 4
	BTREE_TEXT_ENCODING                   = 5
	BTREE_UNORDERED                       = 8
	BTREE_USER_VERSION                    = 6
	BTREE_WRCSR                           = 0x00000004
	CACHE_STALE                           = 0
	COLFLAG_BUSY                          = 0x0100
	COLFLAG_GENERATED                     = 0x0060
	COLFLAG_HASTYPE                       = 0x0004
	COLFLAG_HIDDEN                        = 0x0002
	COLFLAG_NOINSERT                      = 0x0062
	COLFLAG_NOTAVAIL                      = 0x0080
	COLFLAG_PRIMKEY                       = 0x0001
	COLFLAG_SORTERREF                     = 0x0010
	COLFLAG_STORED                        = 0x0040
	COLFLAG_UNIQUE                        = 0x0008
	COLFLAG_VIRTUAL                       = 0x0020
	COLNAME_COLUMN                        = 4
	COLNAME_DATABASE                      = 2
	COLNAME_DECLTYPE                      = 1
	COLNAME_N                             = 1
	COLNAME_NAME                          = 0
	COLNAME_TABLE                         = 3
	CURTYPE_BTREE                         = 0
	CURTYPE_PSEUDO                        = 3
	CURTYPE_SORTER                        = 1
	CURTYPE_VTAB                          = 2
	DBFLAG_EncodingFixed                  = 0x0040
	DBFLAG_InternalFunc                   = 0x0020
	DBFLAG_PreferBuiltin                  = 0x0002
	DBFLAG_SchemaChange                   = 0x0001
	DBFLAG_SchemaKnownOk                  = 0x0010
	DBFLAG_Vacuum                         = 0x0004
	DBFLAG_VacuumInto                     = 0x0008
	DB_ResetWanted                        = 0x0008
	DB_SchemaLoaded                       = 0x0001
	DB_UnresetViews                       = 0x0002
	ENAME_NAME                            = 0
	ENAME_SPAN                            = 1
	ENAME_TAB                             = 2
	EP_Agg                                = 0x000010
	EP_Alias                              = 0x400000
	EP_CanBeNull                          = 0x100000
	EP_Collate                            = 0x000100
	EP_Commuted                           = 0x000200
	EP_ConstFunc                          = 0x080000
	EP_DblQuoted                          = 0x000040
	EP_Distinct                           = 0x000002
	EP_FixedCol                           = 0x000008
	EP_FromDDL                            = 0x40000000
	EP_FromJoin                           = 0x000001
	EP_HasFunc                            = 0x000004
	EP_Immutable                          = 0x02
	EP_InfixFunc                          = 0x000080
	EP_IntValue                           = 0x000400
	EP_IsFalse                            = 0x20000000
	EP_IsTrue                             = 0x10000000
	EP_Leaf                               = 0x800000
	EP_MemToken                           = 0x010000
	EP_NoReduce                           = 0x01
	EP_Propagate                          = 2097412
	EP_Quoted                             = 0x4000000
	EP_Reduced                            = 0x002000
	EP_Skip                               = 0x001000
	EP_Static                             = 0x8000000
	EP_Subquery                           = 0x200000
	EP_Subrtn                             = 0x2000000
	EP_TokenOnly                          = 0x004000
	EP_Unlikely                           = 0x040000
	EP_VarSelect                          = 0x000020
	EP_Win                                = 0x008000
	EP_WinFunc                            = 0x1000000
	EP_xIsSelect                          = 0x000800
	EXCLUSIVE_LOCK                        = 4
	EXPRDUP_REDUCE                        = 0x0001
	GCC_VERSION                           = 0
	HAVE_FCHOWN                           = 1
	HAVE_LSTAT                            = 1
	HAVE_READLINK                         = 1
	INITFLAG_AlterTable                   = 0x0001
	INLINEFUNC_affinity                   = 4
	INLINEFUNC_coalesce                   = 0
	INLINEFUNC_expr_compare               = 3
	INLINEFUNC_expr_implies_expr          = 2
	INLINEFUNC_iif                        = 5
	INLINEFUNC_implies_nonnull_row        = 1
	INLINEFUNC_unlikely                   = 99
	IN_INDEX_EPH                          = 2
	IN_INDEX_INDEX_ASC                    = 3
	IN_INDEX_INDEX_DESC                   = 4
	IN_INDEX_LOOP                         = 0x0004
	IN_INDEX_MEMBERSHIP                   = 0x0002
	IN_INDEX_NOOP                         = 5
	IN_INDEX_NOOP_OK                      = 0x0001
	IN_INDEX_ROWID                        = 1
	IOV_MAX                               = 1024
	JT_CROSS                              = 0x0002
	JT_ERROR                              = 0x0040
	JT_INNER                              = 0x0001
	JT_LEFT                               = 0x0008
	JT_NATURAL                            = 0x0004
	JT_OUTER                              = 0x0020
	JT_RIGHT                              = 0x0010
	KEYINFO_ORDER_BIGNULL                 = 0x02
	KEYINFO_ORDER_DESC                    = 0x01
	LOCATE_NOERR                          = 0x02
	LOCATE_VIEW                           = 0x01
	LONG_BIT                              = 64
	LOOKASIDE_SMALL                       = 128
	MASTER_NAME                           = "sqlite_master"
	MASTER_ROOT                           = 1
	MEMTYPE_HEAP                          = 0x01
	MEMTYPE_LOOKASIDE                     = 0x02
	MEMTYPE_PCACHE                        = 0x04
	MEM_AffMask                           = 0x003
	MEM_Agg                               = 0x2000
	MEM_Blob                              = 0x0010
	MEM_Cleared                           = 0x0100
	MEM_Dyn                               = 0x0400
	MEM_Ephem                             = 0x1000
	MEM_FromBind                          = 0x0040
	MEM_Int                               = 0x0004
	MEM_IntReal                           = 0x0020
	MEM_Null                              = 0x0001
	MEM_Real                              = 0x0008
	MEM_Static                            = 0x0800
	MEM_Str                               = 0x0002
	MEM_Subtype                           = 0x8000
	MEM_Term                              = 0x0200
	MEM_TypeMask                          = 0xc1b
	MEM_Undefined                         = 0x0080
	MEM_Zero                              = 0x4000
	MSVC_VERSION                          = 0
	NC_AllowAgg                           = 0x00001
	NC_AllowWin                           = 0x04000
	NC_Complex                            = 0x02000
	NC_FromDDL                            = 0x40000
	NC_GenCol                             = 0x00008
	NC_HasAgg                             = 0x00010
	NC_HasWin                             = 0x08000
	NC_IdxExpr                            = 0x00020
	NC_InAggFunc                          = 0x20000
	NC_IsCheck                            = 0x00004
	NC_IsDDL                              = 0x10000
	NC_MinMaxAgg                          = 0x01000
	NC_PartIdx                            = 0x00002
	NC_SelfRef                            = 0x0002e
	NC_UAggInfo                           = 0x00100
	NC_UEList                             = 0x00080
	NC_UUpsert                            = 0x00200
	NC_VarSelect                          = 0x00040
	NL_ARGMAX                             = 4096
	NL_LANGMAX                            = 2048
	NL_MSGMAX                             = 2147483647
	NL_NMAX                               = 2147483647
	NL_SETMAX                             = 2147483647
	NL_TEXTMAX                            = 2147483647
	NO_LOCK                               = 0
	NZERO                                 = 20
	OE_Abort                              = 2
	OE_Cascade                            = 10
	OE_Default                            = 11
	OE_Fail                               = 3
	OE_Ignore                             = 4
	OE_None                               = 0
	OE_Replace                            = 5
	OE_Restrict                           = 7
	OE_Rollback                           = 1
	OE_SetDflt                            = 9
	OE_SetNull                            = 8
	OE_Update                             = 6
	OMIT_TEMPDB                           = 0
	ONEPASS_MULTI                         = 2
	ONEPASS_OFF                           = 0
	ONEPASS_SINGLE                        = 1
	OPFLAG_APPEND                         = 0x08
	OPFLAG_AUXDELETE                      = 0x04
	OPFLAG_BULKCSR                        = 0x01
	OPFLAG_EPHEM                          = 0x01
	OPFLAG_FORDELETE                      = 0x08
	OPFLAG_ISNOOP                         = 0x40
	OPFLAG_ISUPDATE                       = 0x04
	OPFLAG_LASTROWID                      = 0x20
	OPFLAG_LENGTHARG                      = 0x40
	OPFLAG_NCHANGE                        = 0x01
	OPFLAG_NOCHNG                         = 0x01
	OPFLAG_NOCHNG_MAGIC                   = 0x6d
	OPFLAG_P2ISREG                        = 0x10
	OPFLAG_PERMUTE                        = 0x01
	OPFLAG_SAVEPOSITION                   = 0x02
	OPFLAG_SEEKEQ                         = 0x02
	OPFLAG_TYPEOFARG                      = 0x80
	OPFLAG_USESEEKRESULT                  = 0x10
	OPFLG_IN1                             = 0x02
	OPFLG_IN2                             = 0x04
	OPFLG_IN3                             = 0x08
	OPFLG_JUMP                            = 0x01
	OPFLG_OUT2                            = 0x10
	OPFLG_OUT3                            = 0x20
	OP_Abortable                          = 175
	OP_Add                                = 105
	OP_AddImm                             = 82
	OP_Affinity                           = 90
	OP_AggFinal                           = 157
	OP_AggInverse                         = 153
	OP_AggStep                            = 154
	OP_AggStep1                           = 155
	OP_AggValue                           = 156
	OP_And                                = 44
	OP_AutoCommit                         = 1
	OP_BitAnd                             = 101
	OP_BitNot                             = 112
	OP_BitOr                              = 102
	OP_Blob                               = 74
	OP_Cast                               = 84
	OP_Checkpoint                         = 6
	OP_Clear                              = 137
	OP_Close                              = 116
	OP_CollSeq                            = 81
	OP_Column                             = 89
	OP_ColumnsUsed                        = 117
	OP_Compare                            = 86
	OP_Concat                             = 110
	OP_Copy                               = 77
	OP_Count                              = 92
	OP_CreateBtree                        = 139
	OP_CursorHint                         = 171
	OP_CursorLock                         = 159
	OP_CursorUnlock                       = 160
	OP_DecrJumpZero                       = 59
	OP_DeferredSeek                       = 133
	OP_Delete                             = 122
	OP_Destroy                            = 136
	OP_Divide                             = 108
	OP_DropIndex                          = 144
	OP_DropTable                          = 143
	OP_DropTrigger                        = 145
	OP_ElseNotEq                          = 58
	OP_EndCoroutine                       = 66
	OP_Eq                                 = 53
	OP_Expire                             = 158
	OP_Explain                            = 174
	OP_FinishSeek                         = 135
	OP_FkCounter                          = 149
	OP_FkIfZero                           = 47
	OP_Found                              = 30
	OP_Function                           = 64
	OP_Ge                                 = 57
	OP_Gosub                              = 12
	OP_Goto                               = 11
	OP_Gt                                 = 54
	OP_Halt                               = 68
	OP_HaltIfNull                         = 67
	OP_IdxDelete                          = 132
	OP_IdxGE                              = 41
	OP_IdxGT                              = 39
	OP_IdxInsert                          = 130
	OP_IdxLE                              = 38
	OP_IdxLT                              = 40
	OP_IdxRowid                           = 134
	OP_If                                 = 18
	OP_IfNoHope                           = 27
	OP_IfNot                              = 20
	OP_IfNotOpen                          = 26
	OP_IfNotZero                          = 49
	OP_IfNullRow                          = 21
	OP_IfPos                              = 48
	OP_IfSmaller                          = 34
	OP_IncrVacuum                         = 60
	OP_Init                               = 62
	OP_InitCoroutine                      = 13
	OP_Insert                             = 121
	OP_Int64                              = 70
	OP_IntCopy                            = 79
	OP_Integer                            = 69
	OP_IntegrityCk                        = 146
	OP_IsNull                             = 50
	OP_IsTrue                             = 87
	OP_JournalMode                        = 7
	OP_Jump                               = 16
	OP_Last                               = 33
	OP_Le                                 = 55
	OP_LoadAnalysis                       = 142
	OP_Lt                                 = 56
	OP_MakeRecord                         = 91
	OP_MaxPgcnt                           = 169
	OP_MemMax                             = 151
	OP_Move                               = 76
	OP_Multiply                           = 107
	OP_MustBeInt                          = 15
	OP_Ne                                 = 52
	OP_NewRowid                           = 120
	OP_Next                               = 5
	OP_NoConflict                         = 28
	OP_Noop                               = 173
	OP_Not                                = 19
	OP_NotExists                          = 32
	OP_NotFound                           = 29
	OP_NotNull                            = 51
	OP_Null                               = 72
	OP_NullRow                            = 128
	OP_Offset                             = 88
	OP_OffsetLimit                        = 152
	OP_Once                               = 17
	OP_OpenAutoindex                      = 99
	OP_OpenDup                            = 98
	OP_OpenEphemeral                      = 100
	OP_OpenPseudo                         = 114
	OP_OpenRead                           = 96
	OP_OpenWrite                          = 97
	OP_Or                                 = 43
	OP_Pagecount                          = 168
	OP_Param                              = 148
	OP_ParseSchema                        = 141
	OP_Permutation                        = 85
	OP_Prev                               = 4
	OP_Program                            = 46
	OP_PureFunc                           = 63
	OP_ReadCookie                         = 93
	OP_Real                               = 150
	OP_RealAffinity                       = 83
	OP_ReleaseReg                         = 172
	OP_Remainder                          = 109
	OP_ReopenIdx                          = 95
	OP_ResetCount                         = 123
	OP_ResetSorter                        = 138
	OP_ResultRow                          = 80
	OP_Return                             = 65
	OP_Rewind                             = 37
	OP_RowData                            = 126
	OP_RowSetAdd                          = 147
	OP_RowSetRead                         = 42
	OP_RowSetTest                         = 45
	OP_Rowid                              = 127
	OP_SCopy                              = 78
	OP_Savepoint                          = 0
	OP_SeekEnd                            = 129
	OP_SeekGE                             = 24
	OP_SeekGT                             = 25
	OP_SeekHit                            = 118
	OP_SeekLE                             = 23
	OP_SeekLT                             = 22
	OP_SeekRowid                          = 31
	OP_Sequence                           = 119
	OP_SequenceTest                       = 113
	OP_SetCookie                          = 94
	OP_ShiftLeft                          = 103
	OP_ShiftRight                         = 104
	OP_SoftNull                           = 73
	OP_Sort                               = 36
	OP_SorterCompare                      = 124
	OP_SorterData                         = 125
	OP_SorterInsert                       = 131
	OP_SorterNext                         = 3
	OP_SorterOpen                         = 111
	OP_SorterSort                         = 35
	OP_SqlExec                            = 140
	OP_String                             = 71
	OP_String8                            = 115
	OP_Subtract                           = 106
	OP_TableLock                          = 161
	OP_Trace                              = 170
	OP_Transaction                        = 2
	OP_VBegin                             = 162
	OP_VColumn                            = 166
	OP_VCreate                            = 163
	OP_VDestroy                           = 164
	OP_VFilter                            = 9
	OP_VNext                              = 61
	OP_VOpen                              = 165
	OP_VRename                            = 167
	OP_VUpdate                            = 10
	OP_Vacuum                             = 8
	OP_Variable                           = 75
	OP_Yield                              = 14
	OS_VXWORKS                            = 0
	P4_ADVANCE                            = -5
	P4_COLLSEQ                            = -2
	P4_DYNAMIC                            = -7
	P4_DYNBLOB                            = -17
	P4_EXPR                               = -10
	P4_FREE_IF_LE                         = -7
	P4_FUNCCTX                            = -16
	P4_FUNCDEF                            = -8
	P4_INT32                              = -3
	P4_INT64                              = -14
	P4_INTARRAY                           = -15
	P4_KEYINFO                            = -9
	P4_MEM                                = -11
	P4_NOTUSED                            = 0
	P4_REAL                               = -13
	P4_STATIC                             = -1
	P4_SUBPROGRAM                         = -4
	P4_TABLE                              = -6
	P4_TRANSIENT                          = 0
	P4_VTAB                               = -12
	P5_ConstraintCheck                    = 3
	P5_ConstraintFK                       = 4
	P5_ConstraintNotNull                  = 1
	P5_ConstraintUnique                   = 2
	PAGER_CACHESPILL                      = 0x20
	PAGER_CKPT_FULLFSYNC                  = 0x10
	PAGER_FLAGS_MASK                      = 0x38
	PAGER_FULLFSYNC                       = 0x08
	PAGER_GET_NOCONTENT                   = 0x01
	PAGER_GET_READONLY                    = 0x02
	PAGER_JOURNALMODE_DELETE              = 0
	PAGER_JOURNALMODE_MEMORY              = 4
	PAGER_JOURNALMODE_OFF                 = 2
	PAGER_JOURNALMODE_PERSIST             = 1
	PAGER_JOURNALMODE_QUERY               = -1
	PAGER_JOURNALMODE_TRUNCATE            = 3
	PAGER_JOURNALMODE_WAL                 = 5
	PAGER_LOCKINGMODE_EXCLUSIVE           = 1
	PAGER_LOCKINGMODE_NORMAL              = 0
	PAGER_LOCKINGMODE_QUERY               = -1
	PAGER_MEMORY                          = 0x0002
	PAGER_OMIT_JOURNAL                    = 0x0001
	PAGER_SYNCHRONOUS_EXTRA               = 0x04
	PAGER_SYNCHRONOUS_FULL                = 0x03
	PAGER_SYNCHRONOUS_MASK                = 0x07
	PAGER_SYNCHRONOUS_NORMAL              = 0x02
	PAGER_SYNCHRONOUS_OFF                 = 0x01
	PARSE_MODE_DECLARE_VTAB               = 1
	PARSE_MODE_NORMAL                     = 0
	PARSE_MODE_RENAME                     = 2
	PARSE_MODE_UNMAP                      = 3
	PENDING_LOCK                          = 3
	PGHDR_CLEAN                           = 0x001
	PGHDR_DIRTY                           = 0x002
	PGHDR_DONT_WRITE                      = 0x010
	PGHDR_MMAP                            = 0x020
	PGHDR_NEED_SYNC                       = 0x008
	PGHDR_WAL_APPEND                      = 0x040
	PGHDR_WRITEABLE                       = 0x004
	PRIO_MAX                              = 20
	PRIO_MIN                              = -20
	RESERVED_LOCK                         = 2
	RLIM64_INFINITY                       = -1
	RLIM_INFINITY                         = -1
	RLIM_SAVED_CUR                        = -1
	RLIM_SAVED_MAX                        = -1
	SAVEPOINT_BEGIN                       = 0
	SAVEPOINT_RELEASE                     = 1
	SAVEPOINT_ROLLBACK                    = 2
	SELECTTRACE_ENABLED                   = 0
	SF_Aggregate                          = 0x0000008
	SF_All                                = 0x0000002
	SF_ComplexResult                      = 0x0040000
	SF_Compound                           = 0x0000100
	SF_Converted                          = 0x0010000
	SF_Distinct                           = 0x0000001
	SF_Expanded                           = 0x0000040
	SF_FixedLimit                         = 0x0004000
	SF_HasAgg                             = 0x0000010
	SF_HasTypeInfo                        = 0x0000080
	SF_IncludeHidden                      = 0x0020000
	SF_MaybeConvert                       = 0x0008000
	SF_MinMaxAgg                          = 0x0001000
	SF_MultiValue                         = 0x0000400
	SF_NestedFrom                         = 0x0000800
	SF_NoopOrderBy                        = 0x0400000
	SF_Recursive                          = 0x0002000
	SF_Resolved                           = 0x0000004
	SF_UsesEphemeral                      = 0x0000020
	SF_Values                             = 0x0000200
	SF_View                               = 0x0200000
	SF_WhereBegin                         = 0x0080000
	SF_WinRewrite                         = 0x0100000
	SHARED_LOCK                           = 1
	SHARED_SIZE                           = 510
	SQLITEINT_H                           = 0
	SQLITE_AFF_BLOB                       = 0x41
	SQLITE_AFF_INTEGER                    = 0x44
	SQLITE_AFF_MASK                       = 0x47
	SQLITE_AFF_NONE                       = 0x40
	SQLITE_AFF_NUMERIC                    = 0x43
	SQLITE_AFF_REAL                       = 0x45
	SQLITE_AFF_TEXT                       = 0x42
	SQLITE_ASCII                          = 1
	SQLITE_AllOpts                        = 65535
	SQLITE_AutoIndex                      = 0x00008000
	SQLITE_BIGENDIAN                      = 0
	SQLITE_BIG_DBL                        = 0
	SQLITE_BTREE_H                        = 0
	SQLITE_BYTEORDER                      = 1234
	SQLITE_CacheSpill                     = 0x00000020
	SQLITE_CellSizeCk                     = 0x00200000
	SQLITE_CkptFullFSync                  = 0x00000010
	SQLITE_CountOfView                    = 0x0200
	SQLITE_CoverIdxScan                   = 0x0020
	SQLITE_CursorHints                    = 0x0400
	SQLITE_DEFAULT_AUTOVACUUM             = 0
	SQLITE_DEFAULT_CACHE_SIZE             = -2000
	SQLITE_DEFAULT_FILE_FORMAT            = 4
	SQLITE_DEFAULT_JOURNAL_SIZE_LIMIT     = -1
	SQLITE_DEFAULT_MMAP_SIZE              = 0
	SQLITE_DEFAULT_PAGE_SIZE              = 4096
	SQLITE_DEFAULT_PCACHE_INITSZ          = 20
	SQLITE_DEFAULT_RECURSIVE_TRIGGERS     = 0
	SQLITE_DEFAULT_SECTOR_SIZE            = 4096
	SQLITE_DEFAULT_SORTERREF_SIZE         = 0x7
	SQLITE_DEFAULT_SYNCHRONOUS            = 2
	SQLITE_DEFAULT_WAL_AUTOCHECKPOINT     = 1000
	SQLITE_DEFAULT_WORKER_THREADS         = 0
	SQLITE_Defensive                      = 0x10000000
	SQLITE_DeferFKs                       = 0x00080000
	SQLITE_DistinctOpt                    = 0x0010
	SQLITE_DqsDDL                         = 0x20000000
	SQLITE_DqsDML                         = 0x40000000
	SQLITE_ECEL_DUP                       = 0x01
	SQLITE_ECEL_FACTOR                    = 0x02
	SQLITE_ECEL_OMITREF                   = 0x08
	SQLITE_ECEL_REF                       = 0x04
	SQLITE_ENABLE_LOCKING_STYLE           = 0
	SQLITE_EnableQPSG                     = 0x00800000
	SQLITE_EnableTrigger                  = 0x00040000
	SQLITE_EnableView                     = 0x80000000
	SQLITE_FAULTINJECTOR_COUNT            = 1
	SQLITE_FAULTINJECTOR_MALLOC           = 0
	SQLITE_FCNTL_DB_UNCHANGED             = 0xca093fa0
	SQLITE_FRAME_MAGIC                    = 0x879fb71e
	SQLITE_FUNC_CASE                      = 0x0008
	SQLITE_FUNC_CONSTANT                  = 0x0800
	SQLITE_FUNC_COUNT                     = 0x0100
	SQLITE_FUNC_DIRECT                    = 0x00080000
	SQLITE_FUNC_ENCMASK                   = 0x0003
	SQLITE_FUNC_EPHEM                     = 0x0010
	SQLITE_FUNC_HASH_SZ                   = 23
	SQLITE_FUNC_INLINE                    = 0x00400000
	SQLITE_FUNC_INTERNAL                  = 0x00040000
	SQLITE_FUNC_LENGTH                    = 0x0040
	SQLITE_FUNC_LIKE                      = 0x0004
	SQLITE_FUNC_MINMAX                    = 0x1000
	SQLITE_FUNC_NEEDCOLL                  = 0x0020
	SQLITE_FUNC_OFFSET                    = 0x8000
	SQLITE_FUNC_SLOCHNG                   = 0x2000
	SQLITE_FUNC_SUBTYPE                   = 0x00100000
	SQLITE_FUNC_TEST                      = 0x4000
	SQLITE_FUNC_TYPEOF                    = 0x0080
	SQLITE_FUNC_UNLIKELY                  = 0x0400
	SQLITE_FUNC_UNSAFE                    = 0x00200000
	SQLITE_FUNC_WINDOW                    = 0x00010000
	SQLITE_FactorOutConst                 = 0x0008
	SQLITE_ForeignKeys                    = 0x00004000
	SQLITE_Fts3Tokenizer                  = 0x00400000
	SQLITE_FullColNames                   = 0x00000004
	SQLITE_FullFSync                      = 0x00000008
	SQLITE_GroupByOrder                   = 0x0004
	SQLITE_HASH_H                         = 0
	SQLITE_HAVE_OS_TRACE                  = 0
	SQLITE_IDXTYPE_APPDEF                 = 0
	SQLITE_IDXTYPE_IPK                    = 3
	SQLITE_IDXTYPE_PRIMARYKEY             = 2
	SQLITE_IDXTYPE_UNIQUE                 = 1
	SQLITE_IOERR_NOMEM_BKPT               = 3082
	SQLITE_IgnoreChecks                   = 0x00000200
	SQLITE_JUMPIFNULL                     = 0x10
	SQLITE_KEEPNULL                       = 0x08
	SQLITE_LITTLEENDIAN                   = 1
	SQLITE_LegacyAlter                    = 0x04000000
	SQLITE_LegacyFileFmt                  = 0x00000002
	SQLITE_LoadExtFunc                    = 0x00020000
	SQLITE_LoadExtension                  = 0x00010000
	SQLITE_MAGIC_BUSY                     = 0xf03b7906
	SQLITE_MAGIC_CLOSED                   = 0x9f3c2d33
	SQLITE_MAGIC_ERROR                    = 0xb5357930
	SQLITE_MAGIC_OPEN                     = 0xa029a697
	SQLITE_MAGIC_SICK                     = 0x4b771290
	SQLITE_MAGIC_ZOMBIE                   = 0x64cffc7
	SQLITE_MALLOC_SOFT_LIMIT              = 1024
	SQLITE_MAX_ATTACHED                   = 10
	SQLITE_MAX_COLUMN                     = 2000
	SQLITE_MAX_COMPOUND_SELECT            = 500
	SQLITE_MAX_DEFAULT_PAGE_SIZE          = 8192
	SQLITE_MAX_FILE_FORMAT                = 4
	SQLITE_MAX_FUNCTION_ARG               = 127
	SQLITE_MAX_LENGTH                     = 1000000000
	SQLITE_MAX_LIKE_PATTERN_LENGTH        = 50000
	SQLITE_MAX_MMAP_SIZE                  = 0x7fff0000
	SQLITE_MAX_PAGE_COUNT                 = 1073741823
	SQLITE_MAX_PAGE_SIZE                  = 65536
	SQLITE_MAX_SCHEMA_RETRY               = 50
	SQLITE_MAX_SQL_LENGTH                 = 1000000000
	SQLITE_MAX_TRIGGER_DEPTH              = 1000
	SQLITE_MAX_VARIABLE_NUMBER            = 32766
	SQLITE_MAX_VDBE_OP                    = 250000000
	SQLITE_MAX_WORKER_THREADS             = 8
	SQLITE_MSVC_H                         = 0
	SQLITE_MX_JUMP_OPCODE                 = 62
	SQLITE_NEED_ERR_NAME                  = 0
	SQLITE_NOINLINE                       = 0
	SQLITE_NOMEM_BKPT                     = 7
	SQLITE_NOTNULL                        = 0x90
	SQLITE_NULLEQ                         = 0x80
	SQLITE_N_BTREE_META                   = 16
	SQLITE_N_LIMIT                        = 12
	SQLITE_NoCkptOnClose                  = 0x00000800
	SQLITE_NoSchemaError                  = 0x08000000
	SQLITE_NullCallback                   = 0x00000100
	SQLITE_OS_OTHER                       = 0
	SQLITE_OS_SETUP_H                     = 0
	SQLITE_OS_UNIX                        = 1
	SQLITE_OS_WIN                         = 0
	SQLITE_OmitNoopJoin                   = 0x0100
	SQLITE_OrderByIdxJoin                 = 0x0040
	SQLITE_PAGER_H                        = 0
	SQLITE_POWERSAFE_OVERWRITE            = 1
	SQLITE_PREPARE_MASK                   = 0x0
	SQLITE_PREPARE_SAVESQL                = 0x80
	SQLITE_PRINTF_INTERNAL                = 0x01
	SQLITE_PRINTF_MALLOCED                = 0x04
	SQLITE_PRINTF_SQLFUNC                 = 0x02
	SQLITE_PTRSIZE                        = 8
	SQLITE_PropagateConst                 = 0x8000
	SQLITE_PushDown                       = 0x1000
	SQLITE_QueryFlattener                 = 0x0001
	SQLITE_QueryOnly                      = 0x00100000
	SQLITE_ReadUncommit                   = 0x00000400
	SQLITE_RecTriggers                    = 0x00002000
	SQLITE_ResetDatabase                  = 0x02000000
	SQLITE_ReverseOrder                   = 0x00001000
	SQLITE_SO_ASC                         = 0
	SQLITE_SO_DESC                        = 1
	SQLITE_SO_UNDEFINED                   = -1
	SQLITE_STOREP2                        = 0x20
	SQLITE_SYSTEM_MALLOC                  = 1
	SQLITE_ShortColNames                  = 0x00000040
	SQLITE_SimplifyJoin                   = 0x2000
	SQLITE_SkipScan                       = 0x4000
	SQLITE_Stat4                          = 0x0800
	SQLITE_TEMP_FILE_PREFIX               = "etilqs_"
	SQLITE_TEMP_STORE                     = 1
	SQLITE_TOKEN_KEYWORD                  = 0x2
	SQLITE_TOKEN_QUOTED                   = 0x1
	SQLITE_TRACE_LEGACY                   = 0x40
	SQLITE_TRACE_NONLEGACY_MASK           = 0x0
	SQLITE_TRACE_XPROFILE                 = 0x80
	SQLITE_Transitive                     = 0x0080
	SQLITE_TriggerEQP                     = 0x01000000
	SQLITE_TrustedSchema                  = 0x00000080
	SQLITE_UTF16NATIVE                    = 2
	SQLITE_VDBEINT_H                      = 0
	SQLITE_VDBE_H                         = 0
	SQLITE_VTABRISK_High                  = 2
	SQLITE_VTABRISK_Low                   = 0
	SQLITE_VTABRISK_Normal                = 1
	SQLITE_WSD                            = 0
	SQLITE_WindowFunc                     = 0x0002
	SQLITE_WriteSchema                    = 0x00000001
	SRT_Coroutine                         = 13
	SRT_Discard                           = 4
	SRT_DistFifo                          = 6
	SRT_DistQueue                         = 8
	SRT_EphemTab                          = 12
	SRT_Except                            = 2
	SRT_Exists                            = 3
	SRT_Fifo                              = 5
	SRT_Mem                               = 10
	SRT_Output                            = 9
	SRT_Queue                             = 7
	SRT_Set                               = 11
	SRT_Table                             = 14
	SRT_Union                             = 1
	TEMP_MASTER_NAME                      = "sqlite_temp_master"
	TF_Autoincrement                      = 0x0008
	TF_Ephemeral                          = 0x0002
	TF_HasGenerated                       = 0x0060
	TF_HasNotNull                         = 0x0800
	TF_HasPrimaryKey                      = 0x0004
	TF_HasStat1                           = 0x0010
	TF_HasStored                          = 0x0040
	TF_HasVirtual                         = 0x0020
	TF_NoVisibleRowid                     = 0x0200
	TF_OOOHidden                          = 0x0400
	TF_Readonly                           = 0x0001
	TF_Shadow                             = 0x1000
	TF_StatsUsed                          = 0x0100
	TF_WithoutRowid                       = 0x0080
	TK_ABORT                              = 27
	TK_ACTION                             = 28
	TK_ADD                                = 160
	TK_AFTER                              = 29
	TK_AGG_COLUMN                         = 166
	TK_AGG_FUNCTION                       = 165
	TK_ALL                                = 133
	TK_ALTER                              = 159
	TK_ALWAYS                             = 96
	TK_ANALYZE                            = 30
	TK_AND                                = 44
	TK_ANY                                = 100
	TK_AS                                 = 24
	TK_ASC                                = 31
	TK_ASTERISK                           = 177
	TK_ATTACH                             = 32
	TK_AUTOINCR                           = 124
	TK_BEFORE                             = 33
	TK_BEGIN                              = 5
	TK_BETWEEN                            = 48
	TK_BY                                 = 34
	TK_CASCADE                            = 35
	TK_CASE                               = 154
	TK_CAST                               = 36
	TK_CHECK                              = 122
	TK_COLLATE                            = 111
	TK_COLUMN                             = 164
	TK_COLUMNKW                           = 60
	TK_COMMIT                             = 10
	TK_CONFLICT                           = 37
	TK_CONSTRAINT                         = 117
	TK_CREATE                             = 17
	TK_CTIME_KW                           = 99
	TK_CURRENT                            = 85
	TK_DATABASE                           = 38
	TK_DEFAULT                            = 118
	TK_DEFERRABLE                         = 129
	TK_DEFERRED                           = 7
	TK_DELETE                             = 126
	TK_DESC                               = 39
	TK_DETACH                             = 40
	TK_DISTINCT                           = 138
	TK_DO                                 = 61
	TK_DROP                               = 131
	TK_EACH                               = 41
	TK_ELSE                               = 157
	TK_END                                = 11
	TK_ESCAPE                             = 58
	TK_EXCEPT                             = 134
	TK_EXCLUDE                            = 91
	TK_EXCLUSIVE                          = 9
	TK_EXISTS                             = 20
	TK_EXPLAIN                            = 2
	TK_FAIL                               = 42
	TK_FILTER                             = 163
	TK_FIRST                              = 83
	TK_FOLLOWING                          = 86
	TK_FOR                                = 62
	TK_FOREIGN                            = 130
	TK_FROM                               = 140
	TK_FUNCTION                           = 169
	TK_GENERATED                          = 95
	TK_GROUP                              = 144
	TK_GROUPS                             = 92
	TK_HAVING                             = 145
	TK_IF                                 = 18
	TK_IF_NULL_ROW                        = 176
	TK_IGNORE                             = 63
	TK_IMMEDIATE                          = 8
	TK_IN                                 = 49
	TK_INDEX                              = 158
	TK_INDEXED                            = 114
	TK_INITIALLY                          = 64
	TK_INSERT                             = 125
	TK_INSTEAD                            = 65
	TK_INTERSECT                          = 135
	TK_INTO                               = 148
	TK_IS                                 = 45
	TK_ISNOT                              = 168
	TK_ISNULL                             = 50
	TK_JOIN                               = 141
	TK_JOIN_KW                            = 116
	TK_KEY                                = 67
	TK_LAST                               = 84
	TK_LIKE_KW                            = 47
	TK_LIMIT                              = 146
	TK_MATCH                              = 46
	TK_NO                                 = 66
	TK_NOT                                = 19
	TK_NOTHING                            = 149
	TK_NOTNULL                            = 51
	TK_NULL                               = 119
	TK_NULLS                              = 82
	TK_OF                                 = 68
	TK_OFFSET                             = 69
	TK_ON                                 = 113
	TK_OR                                 = 43
	TK_ORDER                              = 143
	TK_OTHERS                             = 93
	TK_OVER                               = 162
	TK_PARTITION                          = 87
	TK_PLAN                               = 4
	TK_PRAGMA                             = 70
	TK_PRECEDING                          = 88
	TK_PRIMARY                            = 120
	TK_QUERY                              = 3
	TK_RAISE                              = 71
	TK_RANGE                              = 89
	TK_RECURSIVE                          = 72
	TK_REFERENCES                         = 123
	TK_REGISTER                           = 173
	TK_REINDEX                            = 97
	TK_RELEASE                            = 14
	TK_RENAME                             = 98
	TK_REPLACE                            = 73
	TK_RESTRICT                           = 74
	TK_ROLLBACK                           = 12
	TK_ROW                                = 75
	TK_ROWS                               = 76
	TK_SAVEPOINT                          = 13
	TK_SELECT                             = 136
	TK_SELECT_COLUMN                      = 175
	TK_SET                                = 128
	TK_SPAN                               = 178
	TK_TABLE                              = 16
	TK_TEMP                               = 21
	TK_THEN                               = 156
	TK_TIES                               = 94
	TK_TO                                 = 15
	TK_TRANSACTION                        = 6
	TK_TRIGGER                            = 77
	TK_TRUEFALSE                          = 167
	TK_TRUTH                              = 172
	TK_UMINUS                             = 170
	TK_UNBOUNDED                          = 90
	TK_UNION                              = 132
	TK_UNIQUE                             = 121
	TK_UPDATE                             = 127
	TK_UPLUS                              = 171
	TK_USING                              = 142
	TK_VACUUM                             = 78
	TK_VALUES                             = 137
	TK_VECTOR                             = 174
	TK_VIEW                               = 79
	TK_VIRTUAL                            = 80
	TK_WHEN                               = 155
	TK_WHERE                              = 147
	TK_WINDOW                             = 161
	TK_WITH                               = 81
	TK_WITHOUT                            = 25
	TRIGGER_AFTER                         = 2
	TRIGGER_BEFORE                        = 1
	VDBE_DISPLAY_P4                       = 1
	VDBE_MAGIC_DEAD                       = 0x5606c3c8
	VDBE_MAGIC_HALT                       = 0x319c2973
	VDBE_MAGIC_INIT                       = 0x16bceaa5
	VDBE_MAGIC_RESET                      = 0x48fa9f76
	VDBE_MAGIC_RUN                        = 0x2df20da3
	WHERE_DISTINCTBY                      = 0x0080
	WHERE_DISTINCT_NOOP                   = 0
	WHERE_DISTINCT_ORDERED                = 2
	WHERE_DISTINCT_UNIQUE                 = 1
	WHERE_DISTINCT_UNORDERED              = 3
	WHERE_DUPLICATES_OK                   = 0x0010
	WHERE_GROUPBY                         = 0x0040
	WHERE_ONEPASS_DESIRED                 = 0x0004
	WHERE_ONEPASS_MULTIROW                = 0x0008
	WHERE_ORDERBY_LIMIT                   = 0x0800
	WHERE_ORDERBY_MAX                     = 0x0002
	WHERE_ORDERBY_MIN                     = 0x0001
	WHERE_ORDERBY_NORMAL                  = 0x0000
	WHERE_OR_SUBCLAUSE                    = 0x0020
	WHERE_SEEK_TABLE                      = 0x0400
	WHERE_SEEK_UNIQ_TABLE                 = 0x1000
	WHERE_SORTBYGROUP                     = 0x0200
	WHERE_USE_LIMIT                       = 0x4000
	WHERE_WANT_DISTINCT                   = 0x0100
	WORD_BIT                              = 32
	WRC_Abort                             = 2
	WRC_Continue                          = 0
	WRC_Prune                             = 1
	XN_EXPR                               = -2
	XN_ROWID                              = -1
	_ANSI_STDDEF_H                        = 0
	_BITS_UIO_LIM_H                       = 1
	_BSD_PTRDIFF_T_                       = 0
	_FILE_OFFSET_BITS                     = 64
	_GCC_MAX_ALIGN_T                      = 0
	_GCC_PTRDIFF_T                        = 0
	_LARGEFILE_SOURCE                     = 1
	_LARGE_FILE                           = 1
	_PTRDIFF_T                            = 0
	_PTRDIFF_T_                           = 0
	_PTRDIFF_T_DECLARED                   = 0
	_SQLITE_OS_H_                         = 0
	_STDDEF_H                             = 0
	_STDDEF_H_                            = 0
	_SYS_RESOURCE_H                       = 1
	_T_PTRDIFF                            = 0
	_T_PTRDIFF_                           = 0
	_XOPEN_LIM_H                          = 1
	_XOPEN_SOURCE                         = 600
	BTCF_AtLast                           = 0x08
	BTCF_Incrblob                         = 0x10
	BTCF_Multiple                         = 0x20
	BTCF_Pinned                           = 0x40
	BTCF_ValidNKey                        = 0x02
	BTCF_ValidOvfl                        = 0x04
	BTCF_WriteFlag                        = 0x01
	BTCURSOR_MAX_DEPTH                    = 20
	BTS_EXCLUSIVE                         = 0x0040
	BTS_FAST_SECURE                       = 0x000c
	BTS_INITIALLY_EMPTY                   = 0x0010
	BTS_NO_WAL                            = 0x0020
	BTS_OVERWRITE                         = 0x0008
	BTS_PAGESIZE_FIXED                    = 0x0002
	BTS_PENDING                           = 0x0080
	BTS_READ_ONLY                         = 0x0001
	BTS_SECURE_DELETE                     = 0x0004
	CURSOR_FAULT                          = 4
	CURSOR_INVALID                        = 1
	CURSOR_REQUIRESEEK                    = 3
	CURSOR_SKIPNEXT                       = 2
	CURSOR_VALID                          = 0
	PTF_INTKEY                            = 0x01
	PTF_LEAF                              = 0x08
	PTF_LEAFDATA                          = 0x04
	PTF_ZERODATA                          = 0x02
	PTRMAP_BTREE                          = 5
	PTRMAP_FREEPAGE                       = 2
	PTRMAP_OVERFLOW1                      = 3
	PTRMAP_OVERFLOW2                      = 4
	PTRMAP_ROOTPAGE                       = 1
	READ_LOCK                             = 1
	SQLITE_FILE_HEADER                    = "SQLite format 3"
	TRANS_NONE                            = 0
	TRANS_READ                            = 1
	TRANS_WRITE                           = 2
	WRITE_LOCK                            = 2
	N_THREAD                              = 26
	PTHREAD_BARRIER_SERIAL_THREAD         = -1
	PTHREAD_ONCE_INIT                     = 0
	SCHED_FIFO                            = 1
	SCHED_OTHER                           = 0
	SCHED_RR                              = 2
	_BITS_CPU_SET_H                       = 1
	_BITS_SCHED_H                         = 1
	_BITS_SETJMP_H                        = 1
	_BITS_TYPES_STRUCT_SCHED_PARAM        = 1
	_PTHREAD_H                            = 1
	_SCHED_H                              = 1
	TCL_THREADS                           = 0
	MX_CHUNK_NUMBER                       = 299
	SQLITE_MULTIPLEX_JOURNAL_8_3_OFFSET   = 400
	SQLITE_MULTIPLEX_WAL_8_3_OFFSET       = 700
	DEVSYM_MAX_PATHNAME                   = 512
	DEVSYM_VFS_NAME                       = "devsym"
	WRITECRASH_NAME                       = "writecrash"
	O_LARGEFILE                           = 0
	SQLITE_INTARRAY_H                     = 0
	JT_MAX_PATHNAME                       = 512
	JT_VFS_NAME                           = "jt"
	MALLOC_LOG_FRAMES                     = 10
	DEFAULT_SECTOR_SIZE                   = 0x1000
	MAX_PAGE_SIZE                         = 0x10000
	MULTIPLEX_CTRL_ENABLE                 = 214014
	MULTIPLEX_CTRL_SET_CHUNK_SIZE         = 214015
	MULTIPLEX_CTRL_SET_MAX_CHUNKS         = 214016
	SQLITE_CORE                           = 1
	SQLITE_MULTIPLEX_CHUNK_SIZE           = 2147418112
	SQLITE_MULTIPLEX_MAX_CHUNKS           = 12
	SQLITE_MULTIPLEX_VFS_NAME             = "multiplex"
	SQLITE_TEST_MULTIPLEX_H               = 0
	MAX_MUTEXES                           = 14
	STATIC_MUTEXES                        = 12
	BLOBSIZE                              = 10485760
	BLOCKSIZE                             = 512
	DATABASE_FILE                         = 1
	FS_VFS_NAME                           = "fs"
	JOURNAL_FILE                          = 2
	INST_MAX_PATHNAME                     = 512
	OS_ACCESS                             = 1
	OS_ANNOTATE                           = 28
	OS_CHECKRESERVEDLOCK                  = 2
	OS_CLOSE                              = 3
	OS_CURRENTTIME                        = 4
	OS_DELETE                             = 5
	OS_DEVCHAR                            = 6
	OS_FILECONTROL                        = 7
	OS_FILESIZE                           = 8
	OS_FULLPATHNAME                       = 9
	OS_LOCK                               = 11
	OS_NUMEVENTS                          = 29
	OS_OPEN                               = 12
	OS_RANDOMNESS                         = 13
	OS_READ                               = 14
	OS_SECTORSIZE                         = 15
	OS_SHMBARRIER                         = 26
	OS_SHMLOCK                            = 25
	OS_SHMMAP                             = 23
	OS_SHMUNMAP                           = 22
	OS_SLEEP                              = 16
	OS_SYNC                               = 17
	OS_TRUNCATE                           = 18
	OS_UNLOCK                             = 19
	OS_WRITE                              = 20
	VFSLOG_BUFFERSIZE                     = 8192
	TESTPCACHE_CLEAR                      = 0xd42670d4
	TESTPCACHE_NPAGE                      = 217
	TESTPCACHE_RESERVE                    = 17
	TESTPCACHE_VALID                      = 0x364585fd
	MAP_FIXED                             = 0x10
	MAP_PRIVATE                           = 0x02
	MAP_SHARED                            = 0x01
	MCL_CURRENT                           = 1
	MCL_FUTURE                            = 2
	MCL_ONFAULT                           = 4
	MS_ASYNC                              = 1
	MS_INVALIDATE                         = 2
	MS_SYNC                               = 4
	POSIX_MADV_DONTNEED                   = 4
	POSIX_MADV_NORMAL                     = 0
	POSIX_MADV_RANDOM                     = 1
	POSIX_MADV_SEQUENTIAL                 = 2
	POSIX_MADV_WILLNEED                   = 3
	PROT_EXEC                             = 0x4
	PROT_GROWSDOWN                        = 0x01000000
	PROT_GROWSUP                          = 0x02000000
	PROT_NONE                             = 0x0
	PROT_READ                             = 0x1
	PROT_WRITE                            = 0x2
	_SYS_MMAN_H                           = 1
	TCLVAR_NAME_EQ                        = 101
	TCLVAR_NAME_MATCH                     = 109
	TCLVAR_VALUE_GLOB                     = 103
	TCLVAR_VALUE_LIKE                     = 108
	TCLVAR_VALUE_REGEXP                   = 114
	FAULT_INJECT_NONE                     = 0
	FAULT_INJECT_PERSISTENT               = 2
	FAULT_INJECT_TRANSIENT                = 1
	TESTVFS_ACCESS_MASK                   = 0x00004000
	TESTVFS_ALL_MASK                      = 0x001
	TESTVFS_CKLOCK_MASK                   = 0x00080000
	TESTVFS_CLOSE_MASK                    = 0x00000800
	TESTVFS_DELETE_MASK                   = 0x00000400
	TESTVFS_FCNTL_MASK                    = 0x00100000
	TESTVFS_FULLPATHNAME_MASK             = 0x00008000
	TESTVFS_LOCK_MASK                     = 0x00040000
	TESTVFS_MAX_ARGS                      = 12
	TESTVFS_MAX_PAGES                     = 1024
	TESTVFS_OPEN_MASK                     = 0x00000100
	TESTVFS_READ_MASK                     = 0x00010000
	TESTVFS_SHMBARRIER_MASK               = 0x00000040
	TESTVFS_SHMCLOSE_MASK                 = 0x00000080
	TESTVFS_SHMLOCK_MASK                  = 0x00000010
	TESTVFS_SHMMAP_MASK                   = 0x00000020
	TESTVFS_SHMOPEN_MASK                  = 0x00000001
	TESTVFS_SYNC_MASK                     = 0x00000200
	TESTVFS_TRUNCATE_MASK                 = 0x00002000
	TESTVFS_UNLOCK_MASK                   = 0x00020000
	TESTVFS_WRITE_MASK                    = 0x00001000
)

type ptrdiff_t = int64 /* <builtin>:3:26 */

type size_t = uint64 /* <builtin>:9:23 */

type wchar_t = int32 /* <builtin>:15:24 */

// Define the standard macros for the user,
//   if this invocation was from the user program.

// Define va_list, if desired, from __gnuc_va_list.
// We deliberately do not define va_list when called from
//   stdio.h, because ANSI C says that stdio.h is not supposed to define
//   va_list.  stdio.h needs to have access to that data type,
//   but must not use that name.  It should use the name __gnuc_va_list,
//   which is safe because it is reserved for the implementation.

// The macro _VA_LIST_ is the same thing used by this file in Ultrix.
//   But on BSD NET2 we must not test or define or undef it.
//   (Note that the comments in NET 2's ansi.h
//   are incorrect for _VA_LIST_--see stdio.h!)
// The macro _VA_LIST_DEFINED is used in Windows NT 3.5
// The macro _VA_LIST is used in SCO Unix 3.2.
// The macro _VA_LIST_T_H is used in the Bull dpx2
// The macro __va_list__ is used by BeOS.
type va_list = uintptr /* stdarg.h:99:24 */

// CAPI3REF: Database Connection Handle
// KEYWORDS: {database connection} {database connections}
//
// Each open SQLite database is represented by a pointer to an instance of
// the opaque structure named "sqlite3".  It is useful to think of an sqlite3
// pointer as an object.  The [sqlite3_open()], [sqlite3_open16()], and
// [sqlite3_open_v2()] interfaces are its constructors, and [sqlite3_close()]
// and [sqlite3_close_v2()] are its destructors.  There are many other
// interfaces (such as
// [sqlite3_prepare_v2()], [sqlite3_create_function()], and
// [sqlite3_busy_timeout()] to name but three) that are methods on an
// sqlite3 object.
type sqlite32 = struct {
	FpVfs                   uintptr
	FpVdbe                  uintptr
	FpDfltColl              uintptr
	Fmutex                  uintptr
	FaDb                    uintptr
	FnDb                    int32
	FmDbFlags               u32
	Fflags                  u64
	FlastRowid              i64
	FszMmap                 i64
	FnSchemaLock            u32
	FopenFlags              uint32
	FerrCode                int32
	FerrMask                int32
	FiSysErrno              int32
	FdbOptFlags             u16
	Fenc                    u8
	FautoCommit             u8
	Ftemp_store             u8
	FmallocFailed           u8
	FbBenignMalloc          u8
	FdfltLockMode           u8
	FnextAutovac            int8
	FsuppressErr            u8
	FvtabOnConflict         u8
	FisTransactionSavepoint u8
	FmTrace                 u8
	FnoSharedCache          u8
	FnSqlExec               u8
	FnextPagesize           int32
	Fmagic                  u32
	FnChange                int32
	FnTotalChange           int32
	FaLimit                 [12]int32
	FnMaxSorterMmap         int32
	Finit                   struct {
		FnewTnum       int32
		FiDb           u8
		Fbusy          u8
		_              [2]byte
		ForphanTrigger uint8 /* unsigned orphanTrigger: 1, unsigned imposterTable: 1, unsigned reopenMemdb: 1 */
		FazInit        uintptr
	}
	FnVdbeActive       int32
	FnVdbeRead         int32
	FnVdbeWrite        int32
	FnVdbeExec         int32
	FnVDestroy         int32
	FnExtension        int32
	FaExtension        uintptr
	FxTrace            uintptr
	FpTraceArg         uintptr
	FxProfile          uintptr
	FpProfileArg       uintptr
	FpCommitArg        uintptr
	FxCommitCallback   uintptr
	FpRollbackArg      uintptr
	FxRollbackCallback uintptr
	FpUpdateArg        uintptr
	FxUpdateCallback   uintptr
	FpParse            uintptr
	FxWalCallback      uintptr
	FpWalArg           uintptr
	FxCollNeeded       uintptr
	FxCollNeeded16     uintptr
	FpCollNeededArg    uintptr
	FpErr              uintptr
	Fu1                struct {
		_              [0]uint64
		FisInterrupted int32
		_              [4]byte
	}
	Flookaside           Lookaside
	FxAuth               sqlite3_xauth
	FpAuthArg            uintptr
	FnVTrans             int32
	FaModule             Hash
	FpVtabCtx            uintptr
	FaVTrans             uintptr
	FpDisconnect         uintptr
	FaFunc               Hash
	FaCollSeq            Hash
	FbusyHandler         BusyHandler
	FaDbStatic           [2]Db
	FpSavepoint          uintptr
	FnAnalysisLimit      int32
	FbusyTimeout         int32
	FnSavepoint          int32
	FnStatement          int32
	FnDeferredCons       i64
	FnDeferredImmCons    i64
	FpnBytesFreed        uintptr
	FpBlockingConnection uintptr
	FpUnlockConnection   uintptr
	FpUnlockArg          uintptr
	FxUnlockNotify       uintptr
	FpNextBlocked        uintptr
}

// CAPI3REF: 64-Bit Integer Types
// KEYWORDS: sqlite_int64 sqlite_uint64
//
// Because there is no cross-platform way to specify 64-bit integer types
// SQLite includes typedefs for 64-bit signed and unsigned integers.
//
// The sqlite3_int64 and sqlite3_uint64 are the preferred type definitions.
// The sqlite_int64 and sqlite_uint64 types are supported for backwards
// compatibility only.
//
// ^The sqlite3_int64 and sqlite_int64 types can store integer values
// between -9223372036854775808 and +9223372036854775807 inclusive.  ^The
// sqlite3_uint64 and sqlite_uint64 types can store integer values
// between 0 and +18446744073709551615 inclusive.
type sqlite_int64 = int64           /* sqlite3.h:278:25 */
type sqlite_uint64 = uint64         /* sqlite3.h:279:34 */
type sqlite3_int64 = sqlite_int64   /* sqlite3.h:281:22 */
type sqlite3_uint64 = sqlite_uint64 /* sqlite3.h:282:23 */

// The type for a callback function.
// This is legacy and deprecated.  It is included for historical
// compatibility and is not documented.
type sqlite3_callback = uintptr /* sqlite3.h:338:13 */

// CAPI3REF: Result Codes
// KEYWORDS: {result code definitions}
//
// Many SQLite functions return an integer result code from the set shown
// here in order to indicate success or failure.
//
// New error codes may be added in future versions of SQLite.
//
// See also: [extended result code definitions]
// beginning-of-error-codes
// end-of-error-codes

// CAPI3REF: Extended Result Codes
// KEYWORDS: {extended result code definitions}
//
// In its default configuration, SQLite API routines return one of 30 integer
// [result codes].  However, experience has shown that many of
// these result codes are too coarse-grained.  They do not provide as
// much information about problems as programmers might like.  In an effort to
// address this, newer versions of SQLite (version 3.3.8 [dateof:3.3.8]
// and later) include
// support for additional result codes that provide more detailed information
// about errors. These [extended result codes] are enabled or disabled
// on a per database connection basis using the
// [sqlite3_extended_result_codes()] API.  Or, the extended code for
// the most recent error can be obtained using
// [sqlite3_extended_errcode()].

// CAPI3REF: Flags For File Open Operations
//
// These bit values are intended for use in the
// 3rd parameter to the [sqlite3_open_v2()] interface and
// in the 4th parameter to the [sqlite3_vfs.xOpen] method.

// Reserved:                         0x00F00000

// CAPI3REF: Device Characteristics
//
// The xDeviceCharacteristics method of the [sqlite3_io_methods]
// object returns an integer which is a vector of these
// bit values expressing I/O characteristics of the mass storage
// device that holds the file that the [sqlite3_io_methods]
// refers to.
//
// The SQLITE_IOCAP_ATOMIC property means that all writes of
// any size are atomic.  The SQLITE_IOCAP_ATOMICnnn values
// mean that writes of blocks that are nnn bytes in size and
// are aligned to an address which is an integer multiple of
// nnn are atomic.  The SQLITE_IOCAP_SAFE_APPEND value means
// that when data is appended to a file, the data is appended
// first then the size of the file is extended, never the other
// way around.  The SQLITE_IOCAP_SEQUENTIAL property means that
// information is written to disk in the same order as calls
// to xWrite().  The SQLITE_IOCAP_POWERSAFE_OVERWRITE property means that
// after reboot following a crash or power loss, the only bytes in a
// file that were written at the application level might have changed
// and that adjacent bytes, even bytes within the same sector are
// guaranteed to be unchanged.  The SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN
// flag indicates that a file cannot be deleted when open.  The
// SQLITE_IOCAP_IMMUTABLE flag indicates that the file is on
// read-only media and cannot be changed even by processes with
// elevated privileges.
//
// The SQLITE_IOCAP_BATCH_ATOMIC property means that the underlying
// filesystem supports doing multiple write operations atomically when those
// write operations are bracketed by [SQLITE_FCNTL_BEGIN_ATOMIC_WRITE] and
// [SQLITE_FCNTL_COMMIT_ATOMIC_WRITE].

// CAPI3REF: File Locking Levels
//
// SQLite uses one of these integer values as the second
// argument to calls it makes to the xLock() and xUnlock() methods
// of an [sqlite3_io_methods] object.

// CAPI3REF: Synchronization Type Flags
//
// When SQLite invokes the xSync() method of an
// [sqlite3_io_methods] object it uses a combination of
// these integer values as the second argument.
//
// When the SQLITE_SYNC_DATAONLY flag is used, it means that the
// sync operation only needs to flush data to mass storage.  Inode
// information need not be flushed. If the lower four bits of the flag
// equal SQLITE_SYNC_NORMAL, that means to use normal fsync() semantics.
// If the lower four bits equal SQLITE_SYNC_FULL, that means
// to use Mac OS X style fullsync instead of fsync().
//
// Do not confuse the SQLITE_SYNC_NORMAL and SQLITE_SYNC_FULL flags
// with the [PRAGMA synchronous]=NORMAL and [PRAGMA synchronous]=FULL
// settings.  The [synchronous pragma] determines when calls to the
// xSync VFS method occur and applies uniformly across all platforms.
// The SQLITE_SYNC_NORMAL and SQLITE_SYNC_FULL flags determine how
// energetic or rigorous or forceful the sync operations are and
// only make a difference on Mac OSX for the default SQLite code.
// (Third-party VFS implementations might also make the distinction
// between SQLITE_SYNC_NORMAL and SQLITE_SYNC_FULL, but among the
// operating systems natively supported by SQLite, only Mac OSX
// cares about the difference.)

// CAPI3REF: OS Interface Open File Handle
//
// An [sqlite3_file] object represents an open file in the
// [sqlite3_vfs | OS interface layer].  Individual OS interface
// implementations will
// want to subclass this object by appending additional fields
// for their own use.  The pMethods entry is a pointer to an
// [sqlite3_io_methods] object that defines methods for performing
// I/O operations on the open file.
type sqlite3_file1 = struct{ FpMethods uintptr }

// CAPI3REF: Result Codes
// KEYWORDS: {result code definitions}
//
// Many SQLite functions return an integer result code from the set shown
// here in order to indicate success or failure.
//
// New error codes may be added in future versions of SQLite.
//
// See also: [extended result code definitions]
// beginning-of-error-codes
// end-of-error-codes

// CAPI3REF: Extended Result Codes
// KEYWORDS: {extended result code definitions}
//
// In its default configuration, SQLite API routines return one of 30 integer
// [result codes].  However, experience has shown that many of
// these result codes are too coarse-grained.  They do not provide as
// much information about problems as programmers might like.  In an effort to
// address this, newer versions of SQLite (version 3.3.8 [dateof:3.3.8]
// and later) include
// support for additional result codes that provide more detailed information
// about errors. These [extended result codes] are enabled or disabled
// on a per database connection basis using the
// [sqlite3_extended_result_codes()] API.  Or, the extended code for
// the most recent error can be obtained using
// [sqlite3_extended_errcode()].

// CAPI3REF: Flags For File Open Operations
//
// These bit values are intended for use in the
// 3rd parameter to the [sqlite3_open_v2()] interface and
// in the 4th parameter to the [sqlite3_vfs.xOpen] method.

// Reserved:                         0x00F00000

// CAPI3REF: Device Characteristics
//
// The xDeviceCharacteristics method of the [sqlite3_io_methods]
// object returns an integer which is a vector of these
// bit values expressing I/O characteristics of the mass storage
// device that holds the file that the [sqlite3_io_methods]
// refers to.
//
// The SQLITE_IOCAP_ATOMIC property means that all writes of
// any size are atomic.  The SQLITE_IOCAP_ATOMICnnn values
// mean that writes of blocks that are nnn bytes in size and
// are aligned to an address which is an integer multiple of
// nnn are atomic.  The SQLITE_IOCAP_SAFE_APPEND value means
// that when data is appended to a file, the data is appended
// first then the size of the file is extended, never the other
// way around.  The SQLITE_IOCAP_SEQUENTIAL property means that
// information is written to disk in the same order as calls
// to xWrite().  The SQLITE_IOCAP_POWERSAFE_OVERWRITE property means that
// after reboot following a crash or power loss, the only bytes in a
// file that were written at the application level might have changed
// and that adjacent bytes, even bytes within the same sector are
// guaranteed to be unchanged.  The SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN
// flag indicates that a file cannot be deleted when open.  The
// SQLITE_IOCAP_IMMUTABLE flag indicates that the file is on
// read-only media and cannot be changed even by processes with
// elevated privileges.
//
// The SQLITE_IOCAP_BATCH_ATOMIC property means that the underlying
// filesystem supports doing multiple write operations atomically when those
// write operations are bracketed by [SQLITE_FCNTL_BEGIN_ATOMIC_WRITE] and
// [SQLITE_FCNTL_COMMIT_ATOMIC_WRITE].

// CAPI3REF: File Locking Levels
//
// SQLite uses one of these integer values as the second
// argument to calls it makes to the xLock() and xUnlock() methods
// of an [sqlite3_io_methods] object.

// CAPI3REF: Synchronization Type Flags
//
// When SQLite invokes the xSync() method of an
// [sqlite3_io_methods] object it uses a combination of
// these integer values as the second argument.
//
// When the SQLITE_SYNC_DATAONLY flag is used, it means that the
// sync operation only needs to flush data to mass storage.  Inode
// information need not be flushed. If the lower four bits of the flag
// equal SQLITE_SYNC_NORMAL, that means to use normal fsync() semantics.
// If the lower four bits equal SQLITE_SYNC_FULL, that means
// to use Mac OS X style fullsync instead of fsync().
//
// Do not confuse the SQLITE_SYNC_NORMAL and SQLITE_SYNC_FULL flags
// with the [PRAGMA synchronous]=NORMAL and [PRAGMA synchronous]=FULL
// settings.  The [synchronous pragma] determines when calls to the
// xSync VFS method occur and applies uniformly across all platforms.
// The SQLITE_SYNC_NORMAL and SQLITE_SYNC_FULL flags determine how
// energetic or rigorous or forceful the sync operations are and
// only make a difference on Mac OSX for the default SQLite code.
// (Third-party VFS implementations might also make the distinction
// between SQLITE_SYNC_NORMAL and SQLITE_SYNC_FULL, but among the
// operating systems natively supported by SQLite, only Mac OSX
// cares about the difference.)

// CAPI3REF: OS Interface Open File Handle
//
// An [sqlite3_file] object represents an open file in the
// [sqlite3_vfs | OS interface layer].  Individual OS interface
// implementations will
// want to subclass this object by appending additional fields
// for their own use.  The pMethods entry is a pointer to an
// [sqlite3_io_methods] object that defines methods for performing
// I/O operations on the open file.
type sqlite3_file = sqlite3_file1 /* sqlite3.h:680:29 */
type sqlite3_io_methods1 = struct {
	FiVersion               int32
	FxClose                 uintptr
	FxRead                  uintptr
	FxWrite                 uintptr
	FxTruncate              uintptr
	FxSync                  uintptr
	FxFileSize              uintptr
	FxLock                  uintptr
	FxUnlock                uintptr
	FxCheckReservedLock     uintptr
	FxFileControl           uintptr
	FxSectorSize            uintptr
	FxDeviceCharacteristics uintptr
	FxShmMap                uintptr
	FxShmLock               uintptr
	FxShmBarrier            uintptr
	FxShmUnmap              uintptr
	FxFetch                 uintptr
	FxUnfetch               uintptr
}

// CAPI3REF: OS Interface File Virtual Methods Object
//
// Every file opened by the [sqlite3_vfs.xOpen] method populates an
// [sqlite3_file] object (or, more commonly, a subclass of the
// [sqlite3_file] object) with a pointer to an instance of this object.
// This object defines the methods used to perform various operations
// against the open file represented by the [sqlite3_file] object.
//
// If the [sqlite3_vfs.xOpen] method sets the sqlite3_file.pMethods element
// to a non-NULL pointer, then the sqlite3_io_methods.xClose method
// may be invoked even if the [sqlite3_vfs.xOpen] reported that it failed.  The
// only way to prevent a call to xClose following a failed [sqlite3_vfs.xOpen]
// is for the [sqlite3_vfs.xOpen] to set the sqlite3_file.pMethods element
// to NULL.
//
// The flags argument to xSync may be one of [SQLITE_SYNC_NORMAL] or
// [SQLITE_SYNC_FULL].  The first choice is the normal fsync().
// The second choice is a Mac OS X style fullsync.  The [SQLITE_SYNC_DATAONLY]
// flag may be ORed in to indicate that only the data of the file
// and not its inode needs to be synced.
//
// The integer values to xLock() and xUnlock() are one of
// <ul>
// <li> [SQLITE_LOCK_NONE],
// <li> [SQLITE_LOCK_SHARED],
// <li> [SQLITE_LOCK_RESERVED],
// <li> [SQLITE_LOCK_PENDING], or
// <li> [SQLITE_LOCK_EXCLUSIVE].
// </ul>
// xLock() increases the lock. xUnlock() decreases the lock.
// The xCheckReservedLock() method checks whether any database connection,
// either in this process or in some other process, is holding a RESERVED,
// PENDING, or EXCLUSIVE lock on the file.  It returns true
// if such a lock exists and false otherwise.
//
// The xFileControl() method is a generic interface that allows custom
// VFS implementations to directly control an open file using the
// [sqlite3_file_control()] interface.  The second "op" argument is an
// integer opcode.  The third argument is a generic pointer intended to
// point to a structure that may contain arguments or space in which to
// write return values.  Potential uses for xFileControl() might be
// functions to enable blocking locks with timeouts, to change the
// locking strategy (for example to use dot-file locks), to inquire
// about the status of a lock, or to break stale locks.  The SQLite
// core reserves all opcodes less than 100 for its own use.
// A [file control opcodes | list of opcodes] less than 100 is available.
// Applications that define a custom xFileControl method should use opcodes
// greater than 100 to avoid conflicts.  VFS implementations should
// return [SQLITE_NOTFOUND] for file control opcodes that they do not
// recognize.
//
// The xSectorSize() method returns the sector size of the
// device that underlies the file.  The sector size is the
// minimum write that can be performed without disturbing
// other bytes in the file.  The xDeviceCharacteristics()
// method returns a bit vector describing behaviors of the
// underlying device:
//
// <ul>
// <li> [SQLITE_IOCAP_ATOMIC]
// <li> [SQLITE_IOCAP_ATOMIC512]
// <li> [SQLITE_IOCAP_ATOMIC1K]
// <li> [SQLITE_IOCAP_ATOMIC2K]
// <li> [SQLITE_IOCAP_ATOMIC4K]
// <li> [SQLITE_IOCAP_ATOMIC8K]
// <li> [SQLITE_IOCAP_ATOMIC16K]
// <li> [SQLITE_IOCAP_ATOMIC32K]
// <li> [SQLITE_IOCAP_ATOMIC64K]
// <li> [SQLITE_IOCAP_SAFE_APPEND]
// <li> [SQLITE_IOCAP_SEQUENTIAL]
// <li> [SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN]
// <li> [SQLITE_IOCAP_POWERSAFE_OVERWRITE]
// <li> [SQLITE_IOCAP_IMMUTABLE]
// <li> [SQLITE_IOCAP_BATCH_ATOMIC]
// </ul>
//
// The SQLITE_IOCAP_ATOMIC property means that all writes of
// any size are atomic.  The SQLITE_IOCAP_ATOMICnnn values
// mean that writes of blocks that are nnn bytes in size and
// are aligned to an address which is an integer multiple of
// nnn are atomic.  The SQLITE_IOCAP_SAFE_APPEND value means
// that when data is appended to a file, the data is appended
// first then the size of the file is extended, never the other
// way around.  The SQLITE_IOCAP_SEQUENTIAL property means that
// information is written to disk in the same order as calls
// to xWrite().
//
// If xRead() returns SQLITE_IOERR_SHORT_READ it must also fill
// in the unread portions of the buffer with zeros.  A VFS that
// fails to zero-fill short reads might seem to work.  However,
// failure to zero-fill short reads will eventually lead to
// database corruption.
type sqlite3_io_methods = sqlite3_io_methods1 /* sqlite3.h:779:35 */

// CAPI3REF: Standard File Control Opcodes
// KEYWORDS: {file control opcodes} {file control opcode}
//
// These integer constants are opcodes for the xFileControl method
// of the [sqlite3_io_methods] object and for the [sqlite3_file_control()]
// interface.
//
// <ul>
// <li>[[SQLITE_FCNTL_LOCKSTATE]]
// The [SQLITE_FCNTL_LOCKSTATE] opcode is used for debugging.  This
// opcode causes the xFileControl method to write the current state of
// the lock (one of [SQLITE_LOCK_NONE], [SQLITE_LOCK_SHARED],
// [SQLITE_LOCK_RESERVED], [SQLITE_LOCK_PENDING], or [SQLITE_LOCK_EXCLUSIVE])
// into an integer that the pArg argument points to. This capability
// is used during testing and is only available when the SQLITE_TEST
// compile-time option is used.
//
// <li>[[SQLITE_FCNTL_SIZE_HINT]]
// The [SQLITE_FCNTL_SIZE_HINT] opcode is used by SQLite to give the VFS
// layer a hint of how large the database file will grow to be during the
// current transaction.  This hint is not guaranteed to be accurate but it
// is often close.  The underlying VFS might choose to preallocate database
// file space based on this hint in order to help writes to the database
// file run faster.
//
// <li>[[SQLITE_FCNTL_SIZE_LIMIT]]
// The [SQLITE_FCNTL_SIZE_LIMIT] opcode is used by in-memory VFS that
// implements [sqlite3_deserialize()] to set an upper bound on the size
// of the in-memory database.  The argument is a pointer to a [sqlite3_int64].
// If the integer pointed to is negative, then it is filled in with the
// current limit.  Otherwise the limit is set to the larger of the value
// of the integer pointed to and the current database size.  The integer
// pointed to is set to the new limit.
//
// <li>[[SQLITE_FCNTL_CHUNK_SIZE]]
// The [SQLITE_FCNTL_CHUNK_SIZE] opcode is used to request that the VFS
// extends and truncates the database file in chunks of a size specified
// by the user. The fourth argument to [sqlite3_file_control()] should
// point to an integer (type int) containing the new chunk-size to use
// for the nominated database. Allocating database file space in large
// chunks (say 1MB at a time), may reduce file-system fragmentation and
// improve performance on some systems.
//
// <li>[[SQLITE_FCNTL_FILE_POINTER]]
// The [SQLITE_FCNTL_FILE_POINTER] opcode is used to obtain a pointer
// to the [sqlite3_file] object associated with a particular database
// connection.  See also [SQLITE_FCNTL_JOURNAL_POINTER].
//
// <li>[[SQLITE_FCNTL_JOURNAL_POINTER]]
// The [SQLITE_FCNTL_JOURNAL_POINTER] opcode is used to obtain a pointer
// to the [sqlite3_file] object associated with the journal file (either
// the [rollback journal] or the [write-ahead log]) for a particular database
// connection.  See also [SQLITE_FCNTL_FILE_POINTER].
//
// <li>[[SQLITE_FCNTL_SYNC_OMITTED]]
// No longer in use.
//
// <li>[[SQLITE_FCNTL_SYNC]]
// The [SQLITE_FCNTL_SYNC] opcode is generated internally by SQLite and
// sent to the VFS immediately before the xSync method is invoked on a
// database file descriptor. Or, if the xSync method is not invoked
// because the user has configured SQLite with
// [PRAGMA synchronous | PRAGMA synchronous=OFF] it is invoked in place
// of the xSync method. In most cases, the pointer argument passed with
// this file-control is NULL. However, if the database file is being synced
// as part of a multi-database commit, the argument points to a nul-terminated
// string containing the transactions master-journal file name. VFSes that
// do not need this signal should silently ignore this opcode. Applications
// should not call [sqlite3_file_control()] with this opcode as doing so may
// disrupt the operation of the specialized VFSes that do require it.
//
// <li>[[SQLITE_FCNTL_COMMIT_PHASETWO]]
// The [SQLITE_FCNTL_COMMIT_PHASETWO] opcode is generated internally by SQLite
// and sent to the VFS after a transaction has been committed immediately
// but before the database is unlocked. VFSes that do not need this signal
// should silently ignore this opcode. Applications should not call
// [sqlite3_file_control()] with this opcode as doing so may disrupt the
// operation of the specialized VFSes that do require it.
//
// <li>[[SQLITE_FCNTL_WIN32_AV_RETRY]]
// ^The [SQLITE_FCNTL_WIN32_AV_RETRY] opcode is used to configure automatic
// retry counts and intervals for certain disk I/O operations for the
// windows [VFS] in order to provide robustness in the presence of
// anti-virus programs.  By default, the windows VFS will retry file read,
// file write, and file delete operations up to 10 times, with a delay
// of 25 milliseconds before the first retry and with the delay increasing
// by an additional 25 milliseconds with each subsequent retry.  This
// opcode allows these two values (10 retries and 25 milliseconds of delay)
// to be adjusted.  The values are changed for all database connections
// within the same process.  The argument is a pointer to an array of two
// integers where the first integer is the new retry count and the second
// integer is the delay.  If either integer is negative, then the setting
// is not changed but instead the prior value of that setting is written
// into the array entry, allowing the current retry settings to be
// interrogated.  The zDbName parameter is ignored.
//
// <li>[[SQLITE_FCNTL_PERSIST_WAL]]
// ^The [SQLITE_FCNTL_PERSIST_WAL] opcode is used to set or query the
// persistent [WAL | Write Ahead Log] setting.  By default, the auxiliary
// write ahead log ([WAL file]) and shared memory
// files used for transaction control
// are automatically deleted when the latest connection to the database
// closes.  Setting persistent WAL mode causes those files to persist after
// close.  Persisting the files is useful when other processes that do not
// have write permission on the directory containing the database file want
// to read the database file, as the WAL and shared memory files must exist
// in order for the database to be readable.  The fourth parameter to
// [sqlite3_file_control()] for this opcode should be a pointer to an integer.
// That integer is 0 to disable persistent WAL mode or 1 to enable persistent
// WAL mode.  If the integer is -1, then it is overwritten with the current
// WAL persistence setting.
//
// <li>[[SQLITE_FCNTL_POWERSAFE_OVERWRITE]]
// ^The [SQLITE_FCNTL_POWERSAFE_OVERWRITE] opcode is used to set or query the
// persistent "powersafe-overwrite" or "PSOW" setting.  The PSOW setting
// determines the [SQLITE_IOCAP_POWERSAFE_OVERWRITE] bit of the
// xDeviceCharacteristics methods. The fourth parameter to
// [sqlite3_file_control()] for this opcode should be a pointer to an integer.
// That integer is 0 to disable zero-damage mode or 1 to enable zero-damage
// mode.  If the integer is -1, then it is overwritten with the current
// zero-damage mode setting.
//
// <li>[[SQLITE_FCNTL_OVERWRITE]]
// ^The [SQLITE_FCNTL_OVERWRITE] opcode is invoked by SQLite after opening
// a write transaction to indicate that, unless it is rolled back for some
// reason, the entire database file will be overwritten by the current
// transaction. This is used by VACUUM operations.
//
// <li>[[SQLITE_FCNTL_VFSNAME]]
// ^The [SQLITE_FCNTL_VFSNAME] opcode can be used to obtain the names of
// all [VFSes] in the VFS stack.  The names are of all VFS shims and the
// final bottom-level VFS are written into memory obtained from
// [sqlite3_malloc()] and the result is stored in the char* variable
// that the fourth parameter of [sqlite3_file_control()] points to.
// The caller is responsible for freeing the memory when done.  As with
// all file-control actions, there is no guarantee that this will actually
// do anything.  Callers should initialize the char* variable to a NULL
// pointer in case this file-control is not implemented.  This file-control
// is intended for diagnostic use only.
//
// <li>[[SQLITE_FCNTL_VFS_POINTER]]
// ^The [SQLITE_FCNTL_VFS_POINTER] opcode finds a pointer to the top-level
// [VFSes] currently in use.  ^(The argument X in
// sqlite3_file_control(db,SQLITE_FCNTL_VFS_POINTER,X) must be
// of type "[sqlite3_vfs] **".  This opcodes will set *X
// to a pointer to the top-level VFS.)^
// ^When there are multiple VFS shims in the stack, this opcode finds the
// upper-most shim only.
//
// <li>[[SQLITE_FCNTL_PRAGMA]]
// ^Whenever a [PRAGMA] statement is parsed, an [SQLITE_FCNTL_PRAGMA]
// file control is sent to the open [sqlite3_file] object corresponding
// to the database file to which the pragma statement refers. ^The argument
// to the [SQLITE_FCNTL_PRAGMA] file control is an array of
// pointers to strings (char**) in which the second element of the array
// is the name of the pragma and the third element is the argument to the
// pragma or NULL if the pragma has no argument.  ^The handler for an
// [SQLITE_FCNTL_PRAGMA] file control can optionally make the first element
// of the char** argument point to a string obtained from [sqlite3_mprintf()]
// or the equivalent and that string will become the result of the pragma or
// the error message if the pragma fails. ^If the
// [SQLITE_FCNTL_PRAGMA] file control returns [SQLITE_NOTFOUND], then normal
// [PRAGMA] processing continues.  ^If the [SQLITE_FCNTL_PRAGMA]
// file control returns [SQLITE_OK], then the parser assumes that the
// VFS has handled the PRAGMA itself and the parser generates a no-op
// prepared statement if result string is NULL, or that returns a copy
// of the result string if the string is non-NULL.
// ^If the [SQLITE_FCNTL_PRAGMA] file control returns
// any result code other than [SQLITE_OK] or [SQLITE_NOTFOUND], that means
// that the VFS encountered an error while handling the [PRAGMA] and the
// compilation of the PRAGMA fails with an error.  ^The [SQLITE_FCNTL_PRAGMA]
// file control occurs at the beginning of pragma statement analysis and so
// it is able to override built-in [PRAGMA] statements.
//
// <li>[[SQLITE_FCNTL_BUSYHANDLER]]
// ^The [SQLITE_FCNTL_BUSYHANDLER]
// file-control may be invoked by SQLite on the database file handle
// shortly after it is opened in order to provide a custom VFS with access
// to the connection's busy-handler callback. The argument is of type (void**)
// - an array of two (void *) values. The first (void *) actually points
// to a function of type (int (*)(void *)). In order to invoke the connection's
// busy-handler, this function should be invoked with the second (void *) in
// the array as the only argument. If it returns non-zero, then the operation
// should be retried. If it returns zero, the custom VFS should abandon the
// current operation.
//
// <li>[[SQLITE_FCNTL_TEMPFILENAME]]
// ^Applications can invoke the [SQLITE_FCNTL_TEMPFILENAME] file-control
// to have SQLite generate a
// temporary filename using the same algorithm that is followed to generate
// temporary filenames for TEMP tables and other internal uses.  The
// argument should be a char** which will be filled with the filename
// written into memory obtained from [sqlite3_malloc()].  The caller should
// invoke [sqlite3_free()] on the result to avoid a memory leak.
//
// <li>[[SQLITE_FCNTL_MMAP_SIZE]]
// The [SQLITE_FCNTL_MMAP_SIZE] file control is used to query or set the
// maximum number of bytes that will be used for memory-mapped I/O.
// The argument is a pointer to a value of type sqlite3_int64 that
// is an advisory maximum number of bytes in the file to memory map.  The
// pointer is overwritten with the old value.  The limit is not changed if
// the value originally pointed to is negative, and so the current limit
// can be queried by passing in a pointer to a negative number.  This
// file-control is used internally to implement [PRAGMA mmap_size].
//
// <li>[[SQLITE_FCNTL_TRACE]]
// The [SQLITE_FCNTL_TRACE] file control provides advisory information
// to the VFS about what the higher layers of the SQLite stack are doing.
// This file control is used by some VFS activity tracing [shims].
// The argument is a zero-terminated string.  Higher layers in the
// SQLite stack may generate instances of this file control if
// the [SQLITE_USE_FCNTL_TRACE] compile-time option is enabled.
//
// <li>[[SQLITE_FCNTL_HAS_MOVED]]
// The [SQLITE_FCNTL_HAS_MOVED] file control interprets its argument as a
// pointer to an integer and it writes a boolean into that integer depending
// on whether or not the file has been renamed, moved, or deleted since it
// was first opened.
//
// <li>[[SQLITE_FCNTL_WIN32_GET_HANDLE]]
// The [SQLITE_FCNTL_WIN32_GET_HANDLE] opcode can be used to obtain the
// underlying native file handle associated with a file handle.  This file
// control interprets its argument as a pointer to a native file handle and
// writes the resulting value there.
//
// <li>[[SQLITE_FCNTL_WIN32_SET_HANDLE]]
// The [SQLITE_FCNTL_WIN32_SET_HANDLE] opcode is used for debugging.  This
// opcode causes the xFileControl method to swap the file handle with the one
// pointed to by the pArg argument.  This capability is used during testing
// and only needs to be supported when SQLITE_TEST is defined.
//
// <li>[[SQLITE_FCNTL_WAL_BLOCK]]
// The [SQLITE_FCNTL_WAL_BLOCK] is a signal to the VFS layer that it might
// be advantageous to block on the next WAL lock if the lock is not immediately
// available.  The WAL subsystem issues this signal during rare
// circumstances in order to fix a problem with priority inversion.
// Applications should <em>not</em> use this file-control.
//
// <li>[[SQLITE_FCNTL_ZIPVFS]]
// The [SQLITE_FCNTL_ZIPVFS] opcode is implemented by zipvfs only. All other
// VFS should return SQLITE_NOTFOUND for this opcode.
//
// <li>[[SQLITE_FCNTL_RBU]]
// The [SQLITE_FCNTL_RBU] opcode is implemented by the special VFS used by
// the RBU extension only.  All other VFS should return SQLITE_NOTFOUND for
// this opcode.
//
// <li>[[SQLITE_FCNTL_BEGIN_ATOMIC_WRITE]]
// If the [SQLITE_FCNTL_BEGIN_ATOMIC_WRITE] opcode returns SQLITE_OK, then
// the file descriptor is placed in "batch write mode", which
// means all subsequent write operations will be deferred and done
// atomically at the next [SQLITE_FCNTL_COMMIT_ATOMIC_WRITE].  Systems
// that do not support batch atomic writes will return SQLITE_NOTFOUND.
// ^Following a successful SQLITE_FCNTL_BEGIN_ATOMIC_WRITE and prior to
// the closing [SQLITE_FCNTL_COMMIT_ATOMIC_WRITE] or
// [SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE], SQLite will make
// no VFS interface calls on the same [sqlite3_file] file descriptor
// except for calls to the xWrite method and the xFileControl method
// with [SQLITE_FCNTL_SIZE_HINT].
//
// <li>[[SQLITE_FCNTL_COMMIT_ATOMIC_WRITE]]
// The [SQLITE_FCNTL_COMMIT_ATOMIC_WRITE] opcode causes all write
// operations since the previous successful call to
// [SQLITE_FCNTL_BEGIN_ATOMIC_WRITE] to be performed atomically.
// This file control returns [SQLITE_OK] if and only if the writes were
// all performed successfully and have been committed to persistent storage.
// ^Regardless of whether or not it is successful, this file control takes
// the file descriptor out of batch write mode so that all subsequent
// write operations are independent.
// ^SQLite will never invoke SQLITE_FCNTL_COMMIT_ATOMIC_WRITE without
// a prior successful call to [SQLITE_FCNTL_BEGIN_ATOMIC_WRITE].
//
// <li>[[SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE]]
// The [SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE] opcode causes all write
// operations since the previous successful call to
// [SQLITE_FCNTL_BEGIN_ATOMIC_WRITE] to be rolled back.
// ^This file control takes the file descriptor out of batch write mode
// so that all subsequent write operations are independent.
// ^SQLite will never invoke SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE without
// a prior successful call to [SQLITE_FCNTL_BEGIN_ATOMIC_WRITE].
//
// <li>[[SQLITE_FCNTL_LOCK_TIMEOUT]]
// The [SQLITE_FCNTL_LOCK_TIMEOUT] opcode is used to configure a VFS
// to block for up to M milliseconds before failing when attempting to
// obtain a file lock using the xLock or xShmLock methods of the VFS.
// The parameter is a pointer to a 32-bit signed integer that contains
// the value that M is to be set to. Before returning, the 32-bit signed
// integer is overwritten with the previous value of M.
//
// <li>[[SQLITE_FCNTL_DATA_VERSION]]
// The [SQLITE_FCNTL_DATA_VERSION] opcode is used to detect changes to
// a database file.  The argument is a pointer to a 32-bit unsigned integer.
// The "data version" for the pager is written into the pointer.  The
// "data version" changes whenever any change occurs to the corresponding
// database file, either through SQL statements on the same database
// connection or through transactions committed by separate database
// connections possibly in other processes. The [sqlite3_total_changes()]
// interface can be used to find if any database on the connection has changed,
// but that interface responds to changes on TEMP as well as MAIN and does
// not provide a mechanism to detect changes to MAIN only.  Also, the
// [sqlite3_total_changes()] interface responds to internal changes only and
// omits changes made by other database connections.  The
// [PRAGMA data_version] command provides a mechanism to detect changes to
// a single attached database that occur due to other database connections,
// but omits changes implemented by the database connection on which it is
// called.  This file control is the only mechanism to detect changes that
// happen either internally or externally and that are associated with
// a particular attached database.
//
// <li>[[SQLITE_FCNTL_CKPT_START]]
// The [SQLITE_FCNTL_CKPT_START] opcode is invoked from within a checkpoint
// in wal mode before the client starts to copy pages from the wal
// file to the database file.
//
// <li>[[SQLITE_FCNTL_CKPT_DONE]]
// The [SQLITE_FCNTL_CKPT_DONE] opcode is invoked from within a checkpoint
// in wal mode after the client has finished copying pages from the wal
// file to the database file, but before the *-shm file is updated to
// record the fact that the pages have been checkpointed.
// </ul>

// deprecated names

// CAPI3REF: Mutex Handle
//
// The mutex module within SQLite defines [sqlite3_mutex] to be an
// abstract type for a mutex object.  The SQLite core never looks
// at the internal representation of an [sqlite3_mutex].  It only
// deals with pointers to the [sqlite3_mutex] object.
//
// Mutexes are created using [sqlite3_mutex_alloc()].
type sqlite3_mutex1 = struct {
	FpReal uintptr
	FeType int32
	_      [4]byte
}

// CAPI3REF: Loadable Extension Thunk
//
// A pointer to the opaque sqlite3_api_routines structure is passed as
// the third parameter to entry points of [loadable extensions].  This
// structure must be typedefed in order to work around compiler warnings
// on some platforms.
type sqlite3_api_routines1 = struct {
	Faggregate_context      uintptr
	Faggregate_count        uintptr
	Fbind_blob              uintptr
	Fbind_double            uintptr
	Fbind_int               uintptr
	Fbind_int64             uintptr
	Fbind_null              uintptr
	Fbind_parameter_count   uintptr
	Fbind_parameter_index   uintptr
	Fbind_parameter_name    uintptr
	Fbind_text              uintptr
	Fbind_text16            uintptr
	Fbind_value             uintptr
	Fbusy_handler           uintptr
	Fbusy_timeout           uintptr
	Fchanges                uintptr
	Fclose                  uintptr
	Fcollation_needed       uintptr
	Fcollation_needed16     uintptr
	Fcolumn_blob            uintptr
	Fcolumn_bytes           uintptr
	Fcolumn_bytes16         uintptr
	Fcolumn_count           uintptr
	Fcolumn_database_name   uintptr
	Fcolumn_database_name16 uintptr
	Fcolumn_decltype        uintptr
	Fcolumn_decltype16      uintptr
	Fcolumn_double          uintptr
	Fcolumn_int             uintptr
	Fcolumn_int64           uintptr
	Fcolumn_name            uintptr
	Fcolumn_name16          uintptr
	Fcolumn_origin_name     uintptr
	Fcolumn_origin_name16   uintptr
	Fcolumn_table_name      uintptr
	Fcolumn_table_name16    uintptr
	Fcolumn_text            uintptr
	Fcolumn_text16          uintptr
	Fcolumn_type            uintptr
	Fcolumn_value           uintptr
	Fcommit_hook            uintptr
	Fcomplete               uintptr
	Fcomplete16             uintptr
	Fcreate_collation       uintptr
	Fcreate_collation16     uintptr
	Fcreate_function        uintptr
	Fcreate_function16      uintptr
	Fcreate_module          uintptr
	Fdata_count             uintptr
	Fdb_handle              uintptr
	Fdeclare_vtab           uintptr
	Fenable_shared_cache    uintptr
	Ferrcode                uintptr
	Ferrmsg                 uintptr
	Ferrmsg16               uintptr
	Fexec                   uintptr
	Fexpired                uintptr
	Ffinalize               uintptr
	Ffree                   uintptr
	Ffree_table             uintptr
	Fget_autocommit         uintptr
	Fget_auxdata            uintptr
	Fget_table              uintptr
	Fglobal_recover         uintptr
	Finterruptx             uintptr
	Flast_insert_rowid      uintptr
	Flibversion             uintptr
	Flibversion_number      uintptr
	Fmalloc                 uintptr
	Fmprintf                uintptr
	Fopen                   uintptr
	Fopen16                 uintptr
	Fprepare                uintptr
	Fprepare16              uintptr
	Fprofile                uintptr
	Fprogress_handler       uintptr
	Frealloc                uintptr
	Freset                  uintptr
	Fresult_blob            uintptr
	Fresult_double          uintptr
	Fresult_error           uintptr
	Fresult_error16         uintptr
	Fresult_int             uintptr
	Fresult_int64           uintptr
	Fresult_null            uintptr
	Fresult_text            uintptr
	Fresult_text16          uintptr
	Fresult_text16be        uintptr
	Fresult_text16le        uintptr
	Fresult_value           uintptr
	Frollback_hook          uintptr
	Fset_authorizer         uintptr
	Fset_auxdata            uintptr
	Fxsnprintf              uintptr
	Fstep                   uintptr
	Ftable_column_metadata  uintptr
	Fthread_cleanup         uintptr
	Ftotal_changes          uintptr
	Ftrace                  uintptr
	Ftransfer_bindings      uintptr
	Fupdate_hook            uintptr
	Fuser_data              uintptr
	Fvalue_blob             uintptr
	Fvalue_bytes            uintptr
	Fvalue_bytes16          uintptr
	Fvalue_double           uintptr
	Fvalue_int              uintptr
	Fvalue_int64            uintptr
	Fvalue_numeric_type     uintptr
	Fvalue_text             uintptr
	Fvalue_text16           uintptr
	Fvalue_text16be         uintptr
	Fvalue_text16le         uintptr
	Fvalue_type             uintptr
	Fvmprintf               uintptr
	Foverload_function      uintptr
	Fprepare_v2             uintptr
	Fprepare16_v2           uintptr
	Fclear_bindings         uintptr
	Fcreate_module_v2       uintptr
	Fbind_zeroblob          uintptr
	Fblob_bytes             uintptr
	Fblob_close             uintptr
	Fblob_open              uintptr
	Fblob_read              uintptr
	Fblob_write             uintptr
	Fcreate_collation_v2    uintptr
	Ffile_control           uintptr
	Fmemory_highwater       uintptr
	Fmemory_used            uintptr
	Fmutex_alloc            uintptr
	Fmutex_enter            uintptr
	Fmutex_free             uintptr
	Fmutex_leave            uintptr
	Fmutex_try              uintptr
	Fopen_v2                uintptr
	Frelease_memory         uintptr
	Fresult_error_nomem     uintptr
	Fresult_error_toobig    uintptr
	Fsleep                  uintptr
	Fsoft_heap_limit        uintptr
	Fvfs_find               uintptr
	Fvfs_register           uintptr
	Fvfs_unregister         uintptr
	Fxthreadsafe            uintptr
	Fresult_zeroblob        uintptr
	Fresult_error_code      uintptr
	Ftest_control           uintptr
	Frandomness             uintptr
	Fcontext_db_handle      uintptr
	Fextended_result_codes  uintptr
	Flimit                  uintptr
	Fnext_stmt              uintptr
	Fsql                    uintptr
	Fstatus                 uintptr
	Fbackup_finish          uintptr
	Fbackup_init            uintptr
	Fbackup_pagecount       uintptr
	Fbackup_remaining       uintptr
	Fbackup_step            uintptr
	Fcompileoption_get      uintptr
	Fcompileoption_used     uintptr
	Fcreate_function_v2     uintptr
	Fdb_config              uintptr
	Fdb_mutex               uintptr
	Fdb_status              uintptr
	Fextended_errcode       uintptr
	Flog                    uintptr
	Fsoft_heap_limit64      uintptr
	Fsourceid               uintptr
	Fstmt_status            uintptr
	Fstrnicmp               uintptr
	Funlock_notify          uintptr
	Fwal_autocheckpoint     uintptr
	Fwal_checkpoint         uintptr
	Fwal_hook               uintptr
	Fblob_reopen            uintptr
	Fvtab_config            uintptr
	Fvtab_on_conflict       uintptr
	Fclose_v2               uintptr
	Fdb_filename            uintptr
	Fdb_readonly            uintptr
	Fdb_release_memory      uintptr
	Ferrstr                 uintptr
	Fstmt_busy              uintptr
	Fstmt_readonly          uintptr
	Fstricmp                uintptr
	Furi_boolean            uintptr
	Furi_int64              uintptr
	Furi_parameter          uintptr
	Fxvsnprintf             uintptr
	Fwal_checkpoint_v2      uintptr
	Fauto_extension         uintptr
	Fbind_blob64            uintptr
	Fbind_text64            uintptr
	Fcancel_auto_extension  uintptr
	Fload_extension         uintptr
	Fmalloc64               uintptr
	Fmsize                  uintptr
	Frealloc64              uintptr
	Freset_auto_extension   uintptr
	Fresult_blob64          uintptr
	Fresult_text64          uintptr
	Fstrglob                uintptr
	Fvalue_dup              uintptr
	Fvalue_free             uintptr
	Fresult_zeroblob64      uintptr
	Fbind_zeroblob64        uintptr
	Fvalue_subtype          uintptr
	Fresult_subtype         uintptr
	Fstatus64               uintptr
	Fstrlike                uintptr
	Fdb_cacheflush          uintptr
	Fsystem_errno           uintptr
	Ftrace_v2               uintptr
	Fexpanded_sql           uintptr
	Fset_last_insert_rowid  uintptr
	Fprepare_v3             uintptr
	Fprepare16_v3           uintptr
	Fbind_pointer           uintptr
	Fresult_pointer         uintptr
	Fvalue_pointer          uintptr
	Fvtab_nochange          uintptr
	Fvalue_nochange         uintptr
	Fvtab_collation         uintptr
	Fkeyword_count          uintptr
	Fkeyword_name           uintptr
	Fkeyword_check          uintptr
	Fstr_new                uintptr
	Fstr_finish             uintptr
	Fstr_appendf            uintptr
	Fstr_vappendf           uintptr
	Fstr_append             uintptr
	Fstr_appendall          uintptr
	Fstr_appendchar         uintptr
	Fstr_reset              uintptr
	Fstr_errcode            uintptr
	Fstr_length             uintptr
	Fstr_value              uintptr
	Fcreate_window_function uintptr
	Fnormalized_sql         uintptr
	Fstmt_isexplain         uintptr
	Fvalue_frombind         uintptr
	Fdrop_modules           uintptr
	Fhard_heap_limit64      uintptr
	Furi_key                uintptr
	Ffilename_database      uintptr
	Ffilename_journal       uintptr
	Ffilename_wal           uintptr
	Fcreate_filename        uintptr
	Ffree_filename          uintptr
	Fdatabase_file_object   uintptr
}

// CAPI3REF: OS Interface Object
//
// An instance of the sqlite3_vfs object defines the interface between
// the SQLite core and the underlying operating system.  The "vfs"
// in the name of the object stands for "virtual file system".  See
// the [VFS | VFS documentation] for further information.
//
// The VFS interface is sometimes extended by adding new methods onto
// the end.  Each time such an extension occurs, the iVersion field
// is incremented.  The iVersion value started out as 1 in
// SQLite [version 3.5.0] on [dateof:3.5.0], then increased to 2
// with SQLite [version 3.7.0] on [dateof:3.7.0], and then increased
// to 3 with SQLite [version 3.7.6] on [dateof:3.7.6].  Additional fields
// may be appended to the sqlite3_vfs object and the iVersion value
// may increase again in future versions of SQLite.
// Note that due to an oversight, the structure
// of the sqlite3_vfs object changed in the transition from
// SQLite [version 3.5.9] to [version 3.6.0] on [dateof:3.6.0]
// and yet the iVersion field was not increased.
//
// The szOsFile field is the size of the subclassed [sqlite3_file]
// structure used by this VFS.  mxPathname is the maximum length of
// a pathname in this VFS.
//
// Registered sqlite3_vfs objects are kept on a linked list formed by
// the pNext pointer.  The [sqlite3_vfs_register()]
// and [sqlite3_vfs_unregister()] interfaces manage this list
// in a thread-safe way.  The [sqlite3_vfs_find()] interface
// searches the list.  Neither the application code nor the VFS
// implementation should use the pNext pointer.
//
// The pNext field is the only field in the sqlite3_vfs
// structure that SQLite will ever modify.  SQLite will only access
// or modify this field while holding a particular static mutex.
// The application should never modify anything within the sqlite3_vfs
// object once the object has been registered.
//
// The zName field holds the name of the VFS module.  The name must
// be unique across all VFS modules.
//
// [[sqlite3_vfs.xOpen]]
// ^SQLite guarantees that the zFilename parameter to xOpen
// is either a NULL pointer or string obtained
// from xFullPathname() with an optional suffix added.
// ^If a suffix is added to the zFilename parameter, it will
// consist of a single "-" character followed by no more than
// 11 alphanumeric and/or "-" characters.
// ^SQLite further guarantees that
// the string will be valid and unchanged until xClose() is
// called. Because of the previous sentence,
// the [sqlite3_file] can safely store a pointer to the
// filename if it needs to remember the filename for some reason.
// If the zFilename parameter to xOpen is a NULL pointer then xOpen
// must invent its own temporary name for the file.  ^Whenever the
// xFilename parameter is NULL it will also be the case that the
// flags parameter will include [SQLITE_OPEN_DELETEONCLOSE].
//
// The flags argument to xOpen() includes all bits set in
// the flags argument to [sqlite3_open_v2()].  Or if [sqlite3_open()]
// or [sqlite3_open16()] is used, then flags includes at least
// [SQLITE_OPEN_READWRITE] | [SQLITE_OPEN_CREATE].
// If xOpen() opens a file read-only then it sets *pOutFlags to
// include [SQLITE_OPEN_READONLY].  Other bits in *pOutFlags may be set.
//
// ^(SQLite will also add one of the following flags to the xOpen()
// call, depending on the object being opened:
//
// <ul>
// <li>  [SQLITE_OPEN_MAIN_DB]
// <li>  [SQLITE_OPEN_MAIN_JOURNAL]
// <li>  [SQLITE_OPEN_TEMP_DB]
// <li>  [SQLITE_OPEN_TEMP_JOURNAL]
// <li>  [SQLITE_OPEN_TRANSIENT_DB]
// <li>  [SQLITE_OPEN_SUBJOURNAL]
// <li>  [SQLITE_OPEN_MASTER_JOURNAL]
// <li>  [SQLITE_OPEN_WAL]
// </ul>)^
//
// The file I/O implementation can use the object type flags to
// change the way it deals with files.  For example, an application
// that does not care about crash recovery or rollback might make
// the open of a journal file a no-op.  Writes to this journal would
// also be no-ops, and any attempt to read the journal would return
// SQLITE_IOERR.  Or the implementation might recognize that a database
// file will be doing page-aligned sector reads and writes in a random
// order and set up its I/O subsystem accordingly.
//
// SQLite might also add one of the following flags to the xOpen method:
//
// <ul>
// <li> [SQLITE_OPEN_DELETEONCLOSE]
// <li> [SQLITE_OPEN_EXCLUSIVE]
// </ul>
//
// The [SQLITE_OPEN_DELETEONCLOSE] flag means the file should be
// deleted when it is closed.  ^The [SQLITE_OPEN_DELETEONCLOSE]
// will be set for TEMP databases and their journals, transient
// databases, and subjournals.
//
// ^The [SQLITE_OPEN_EXCLUSIVE] flag is always used in conjunction
// with the [SQLITE_OPEN_CREATE] flag, which are both directly
// analogous to the O_EXCL and O_CREAT flags of the POSIX open()
// API.  The SQLITE_OPEN_EXCLUSIVE flag, when paired with the
// SQLITE_OPEN_CREATE, is used to indicate that file should always
// be created, and that it is an error if it already exists.
// It is <i>not</i> used to indicate the file should be opened
// for exclusive access.
//
// ^At least szOsFile bytes of memory are allocated by SQLite
// to hold the [sqlite3_file] structure passed as the third
// argument to xOpen.  The xOpen method does not have to
// allocate the structure; it should just fill it in.  Note that
// the xOpen method must set the sqlite3_file.pMethods to either
// a valid [sqlite3_io_methods] object or to NULL.  xOpen must do
// this even if the open fails.  SQLite expects that the sqlite3_file.pMethods
// element will be valid after xOpen returns regardless of the success
// or failure of the xOpen call.
//
// [[sqlite3_vfs.xAccess]]
// ^The flags argument to xAccess() may be [SQLITE_ACCESS_EXISTS]
// to test for the existence of a file, or [SQLITE_ACCESS_READWRITE] to
// test whether a file is readable and writable, or [SQLITE_ACCESS_READ]
// to test whether a file is at least readable.  The SQLITE_ACCESS_READ
// flag is never actually used and is not implemented in the built-in
// VFSes of SQLite.  The file is named by the second argument and can be a
// directory. The xAccess method returns [SQLITE_OK] on success or some
// non-zero error code if there is an I/O error or if the name of
// the file given in the second argument is illegal.  If SQLITE_OK
// is returned, then non-zero or zero is written into *pResOut to indicate
// whether or not the file is accessible.
//
// ^SQLite will always allocate at least mxPathname+1 bytes for the
// output buffer xFullPathname.  The exact size of the output buffer
// is also passed as a parameter to both  methods. If the output buffer
// is not large enough, [SQLITE_CANTOPEN] should be returned. Since this is
// handled as a fatal error by SQLite, vfs implementations should endeavor
// to prevent this by setting mxPathname to a sufficiently large value.
//
// The xRandomness(), xSleep(), xCurrentTime(), and xCurrentTimeInt64()
// interfaces are not strictly a part of the filesystem, but they are
// included in the VFS structure for completeness.
// The xRandomness() function attempts to return nBytes bytes
// of good-quality randomness into zOut.  The return value is
// the actual number of bytes of randomness obtained.
// The xSleep() method causes the calling thread to sleep for at
// least the number of microseconds given.  ^The xCurrentTime()
// method returns a Julian Day Number for the current date and time as
// a floating point value.
// ^The xCurrentTimeInt64() method returns, as an integer, the Julian
// Day Number multiplied by 86400000 (the number of milliseconds in
// a 24-hour day).
// ^SQLite will use the xCurrentTimeInt64() method to get the current
// date and time if that method is available (if iVersion is 2 or
// greater and the function pointer is not NULL) and will fall back
// to xCurrentTime() if xCurrentTimeInt64() is unavailable.
//
// ^The xSetSystemCall(), xGetSystemCall(), and xNestSystemCall() interfaces
// are not used by the SQLite core.  These optional interfaces are provided
// by some VFSes to facilitate testing of the VFS code. By overriding
// system calls with functions under its control, a test program can
// simulate faults and error conditions that would otherwise be difficult
// or impossible to induce.  The set of system calls that can be overridden
// varies from one VFS to another, and from one version of the same VFS to the
// next.  Applications that use these interfaces must be prepared for any
// or all of these interfaces to be NULL or for their behavior to change
// from one release to the next.  Applications must not attempt to access
// any of these methods if the iVersion of the VFS is less than 3.
type sqlite3_vfs1 = struct {
	FiVersion          int32
	FszOsFile          int32
	FmxPathname        int32
	FpNext             uintptr
	FzName             uintptr
	FpAppData          uintptr
	FxOpen             uintptr
	FxDelete           uintptr
	FxAccess           uintptr
	FxFullPathname     uintptr
	FxDlOpen           uintptr
	FxDlError          uintptr
	FxDlSym            uintptr
	FxDlClose          uintptr
	FxRandomness       uintptr
	FxSleep            uintptr
	FxCurrentTime      uintptr
	FxGetLastError     uintptr
	FxCurrentTimeInt64 uintptr
	FxSetSystemCall    uintptr
	FxGetSystemCall    uintptr
	FxNextSystemCall   uintptr
}

// CAPI3REF: OS Interface Object
//
// An instance of the sqlite3_vfs object defines the interface between
// the SQLite core and the underlying operating system.  The "vfs"
// in the name of the object stands for "virtual file system".  See
// the [VFS | VFS documentation] for further information.
//
// The VFS interface is sometimes extended by adding new methods onto
// the end.  Each time such an extension occurs, the iVersion field
// is incremented.  The iVersion value started out as 1 in
// SQLite [version 3.5.0] on [dateof:3.5.0], then increased to 2
// with SQLite [version 3.7.0] on [dateof:3.7.0], and then increased
// to 3 with SQLite [version 3.7.6] on [dateof:3.7.6].  Additional fields
// may be appended to the sqlite3_vfs object and the iVersion value
// may increase again in future versions of SQLite.
// Note that due to an oversight, the structure
// of the sqlite3_vfs object changed in the transition from
// SQLite [version 3.5.9] to [version 3.6.0] on [dateof:3.6.0]
// and yet the iVersion field was not increased.
//
// The szOsFile field is the size of the subclassed [sqlite3_file]
// structure used by this VFS.  mxPathname is the maximum length of
// a pathname in this VFS.
//
// Registered sqlite3_vfs objects are kept on a linked list formed by
// the pNext pointer.  The [sqlite3_vfs_register()]
// and [sqlite3_vfs_unregister()] interfaces manage this list
// in a thread-safe way.  The [sqlite3_vfs_find()] interface
// searches the list.  Neither the application code nor the VFS
// implementation should use the pNext pointer.
//
// The pNext field is the only field in the sqlite3_vfs
// structure that SQLite will ever modify.  SQLite will only access
// or modify this field while holding a particular static mutex.
// The application should never modify anything within the sqlite3_vfs
// object once the object has been registered.
//
// The zName field holds the name of the VFS module.  The name must
// be unique across all VFS modules.
//
// [[sqlite3_vfs.xOpen]]
// ^SQLite guarantees that the zFilename parameter to xOpen
// is either a NULL pointer or string obtained
// from xFullPathname() with an optional suffix added.
// ^If a suffix is added to the zFilename parameter, it will
// consist of a single "-" character followed by no more than
// 11 alphanumeric and/or "-" characters.
// ^SQLite further guarantees that
// the string will be valid and unchanged until xClose() is
// called. Because of the previous sentence,
// the [sqlite3_file] can safely store a pointer to the
// filename if it needs to remember the filename for some reason.
// If the zFilename parameter to xOpen is a NULL pointer then xOpen
// must invent its own temporary name for the file.  ^Whenever the
// xFilename parameter is NULL it will also be the case that the
// flags parameter will include [SQLITE_OPEN_DELETEONCLOSE].
//
// The flags argument to xOpen() includes all bits set in
// the flags argument to [sqlite3_open_v2()].  Or if [sqlite3_open()]
// or [sqlite3_open16()] is used, then flags includes at least
// [SQLITE_OPEN_READWRITE] | [SQLITE_OPEN_CREATE].
// If xOpen() opens a file read-only then it sets *pOutFlags to
// include [SQLITE_OPEN_READONLY].  Other bits in *pOutFlags may be set.
//
// ^(SQLite will also add one of the following flags to the xOpen()
// call, depending on the object being opened:
//
// <ul>
// <li>  [SQLITE_OPEN_MAIN_DB]
// <li>  [SQLITE_OPEN_MAIN_JOURNAL]
// <li>  [SQLITE_OPEN_TEMP_DB]
// <li>  [SQLITE_OPEN_TEMP_JOURNAL]
// <li>  [SQLITE_OPEN_TRANSIENT_DB]
// <li>  [SQLITE_OPEN_SUBJOURNAL]
// <li>  [SQLITE_OPEN_MASTER_JOURNAL]
// <li>  [SQLITE_OPEN_WAL]
// </ul>)^
//
// The file I/O implementation can use the object type flags to
// change the way it deals with files.  For example, an application
// that does not care about crash recovery or rollback might make
// the open of a journal file a no-op.  Writes to this journal would
// also be no-ops, and any attempt to read the journal would return
// SQLITE_IOERR.  Or the implementation might recognize that a database
// file will be doing page-aligned sector reads and writes in a random
// order and set up its I/O subsystem accordingly.
//
// SQLite might also add one of the following flags to the xOpen method:
//
// <ul>
// <li> [SQLITE_OPEN_DELETEONCLOSE]
// <li> [SQLITE_OPEN_EXCLUSIVE]
// </ul>
//
// The [SQLITE_OPEN_DELETEONCLOSE] flag means the file should be
// deleted when it is closed.  ^The [SQLITE_OPEN_DELETEONCLOSE]
// will be set for TEMP databases and their journals, transient
// databases, and subjournals.
//
// ^The [SQLITE_OPEN_EXCLUSIVE] flag is always used in conjunction
// with the [SQLITE_OPEN_CREATE] flag, which are both directly
// analogous to the O_EXCL and O_CREAT flags of the POSIX open()
// API.  The SQLITE_OPEN_EXCLUSIVE flag, when paired with the
// SQLITE_OPEN_CREATE, is used to indicate that file should always
// be created, and that it is an error if it already exists.
// It is <i>not</i> used to indicate the file should be opened
// for exclusive access.
//
// ^At least szOsFile bytes of memory are allocated by SQLite
// to hold the [sqlite3_file] structure passed as the third
// argument to xOpen.  The xOpen method does not have to
// allocate the structure; it should just fill it in.  Note that
// the xOpen method must set the sqlite3_file.pMethods to either
// a valid [sqlite3_io_methods] object or to NULL.  xOpen must do
// this even if the open fails.  SQLite expects that the sqlite3_file.pMethods
// element will be valid after xOpen returns regardless of the success
// or failure of the xOpen call.
//
// [[sqlite3_vfs.xAccess]]
// ^The flags argument to xAccess() may be [SQLITE_ACCESS_EXISTS]
// to test for the existence of a file, or [SQLITE_ACCESS_READWRITE] to
// test whether a file is readable and writable, or [SQLITE_ACCESS_READ]
// to test whether a file is at least readable.  The SQLITE_ACCESS_READ
// flag is never actually used and is not implemented in the built-in
// VFSes of SQLite.  The file is named by the second argument and can be a
// directory. The xAccess method returns [SQLITE_OK] on success or some
// non-zero error code if there is an I/O error or if the name of
// the file given in the second argument is illegal.  If SQLITE_OK
// is returned, then non-zero or zero is written into *pResOut to indicate
// whether or not the file is accessible.
//
// ^SQLite will always allocate at least mxPathname+1 bytes for the
// output buffer xFullPathname.  The exact size of the output buffer
// is also passed as a parameter to both  methods. If the output buffer
// is not large enough, [SQLITE_CANTOPEN] should be returned. Since this is
// handled as a fatal error by SQLite, vfs implementations should endeavor
// to prevent this by setting mxPathname to a sufficiently large value.
//
// The xRandomness(), xSleep(), xCurrentTime(), and xCurrentTimeInt64()
// interfaces are not strictly a part of the filesystem, but they are
// included in the VFS structure for completeness.
// The xRandomness() function attempts to return nBytes bytes
// of good-quality randomness into zOut.  The return value is
// the actual number of bytes of randomness obtained.
// The xSleep() method causes the calling thread to sleep for at
// least the number of microseconds given.  ^The xCurrentTime()
// method returns a Julian Day Number for the current date and time as
// a floating point value.
// ^The xCurrentTimeInt64() method returns, as an integer, the Julian
// Day Number multiplied by 86400000 (the number of milliseconds in
// a 24-hour day).
// ^SQLite will use the xCurrentTimeInt64() method to get the current
// date and time if that method is available (if iVersion is 2 or
// greater and the function pointer is not NULL) and will fall back
// to xCurrentTime() if xCurrentTimeInt64() is unavailable.
//
// ^The xSetSystemCall(), xGetSystemCall(), and xNestSystemCall() interfaces
// are not used by the SQLite core.  These optional interfaces are provided
// by some VFSes to facilitate testing of the VFS code. By overriding
// system calls with functions under its control, a test program can
// simulate faults and error conditions that would otherwise be difficult
// or impossible to induce.  The set of system calls that can be overridden
// varies from one VFS to another, and from one version of the same VFS to the
// next.  Applications that use these interfaces must be prepared for any
// or all of these interfaces to be NULL or for their behavior to change
// from one release to the next.  Applications must not attempt to access
// any of these methods if the iVersion of the VFS is less than 3.
type sqlite3_vfs = sqlite3_vfs1    /* sqlite3.h:1364:28 */
type sqlite3_syscall_ptr = uintptr /* sqlite3.h:1365:14 */

// CAPI3REF: Memory Allocation Routines
//
// An instance of this object defines the interface between SQLite
// and low-level memory allocation routines.
//
// This object is used in only one place in the SQLite interface.
// A pointer to an instance of this object is the argument to
// [sqlite3_config()] when the configuration option is
// [SQLITE_CONFIG_MALLOC] or [SQLITE_CONFIG_GETMALLOC].
// By creating an instance of this object
// and passing it to [sqlite3_config]([SQLITE_CONFIG_MALLOC])
// during configuration, an application can specify an alternative
// memory allocation subsystem for SQLite to use for all of its
// dynamic memory needs.
//
// Note that SQLite comes with several [built-in memory allocators]
// that are perfectly adequate for the overwhelming majority of applications
// and that this object is only useful to a tiny minority of applications
// with specialized memory allocation requirements.  This object is
// also used during testing of SQLite in order to specify an alternative
// memory allocator that simulates memory out-of-memory conditions in
// order to verify that SQLite recovers gracefully from such
// conditions.
//
// The xMalloc, xRealloc, and xFree methods must work like the
// malloc(), realloc() and free() functions from the standard C library.
// ^SQLite guarantees that the second argument to
// xRealloc is always a value returned by a prior call to xRoundup.
//
// xSize should return the allocated size of a memory allocation
// previously obtained from xMalloc or xRealloc.  The allocated size
// is always at least as big as the requested size but may be larger.
//
// The xRoundup method returns what would be the allocated size of
// a memory allocation given a particular requested size.  Most memory
// allocators round up memory allocations at least to the next multiple
// of 8.  Some allocators round up to a larger multiple or to a power of 2.
// Every memory allocation request coming in through [sqlite3_malloc()]
// or [sqlite3_realloc()] first calls xRoundup.  If xRoundup returns 0,
// that causes the corresponding memory allocation to fail.
//
// The xInit method initializes the memory allocator.  For example,
// it might allocate any required mutexes or initialize internal data
// structures.  The xShutdown method is invoked (indirectly) by
// [sqlite3_shutdown()] and should deallocate any resources acquired
// by xInit.  The pAppData pointer is used as the only parameter to
// xInit and xShutdown.
//
// SQLite holds the [SQLITE_MUTEX_STATIC_MASTER] mutex when it invokes
// the xInit method, so the xInit method need not be threadsafe.  The
// xShutdown method is only called from [sqlite3_shutdown()] so it does
// not need to be threadsafe either.  For all other methods, SQLite
// holds the [SQLITE_MUTEX_STATIC_MEM] mutex as long as the
// [SQLITE_CONFIG_MEMSTATUS] configuration option is turned on (which
// it is by default) and so the methods are automatically serialized.
// However, if [SQLITE_CONFIG_MEMSTATUS] is disabled, then the other
// methods must be threadsafe or else make their own arrangements for
// serialization.
//
// SQLite will never invoke xInit() more than once without an intervening
// call to xShutdown().
type sqlite3_mem_methods1 = struct {
	FxMalloc   uintptr
	FxFree     uintptr
	FxRealloc  uintptr
	FxSize     uintptr
	FxRoundup  uintptr
	FxInit     uintptr
	FxShutdown uintptr
	FpAppData  uintptr
}

// CAPI3REF: Memory Allocation Routines
//
// An instance of this object defines the interface between SQLite
// and low-level memory allocation routines.
//
// This object is used in only one place in the SQLite interface.
// A pointer to an instance of this object is the argument to
// [sqlite3_config()] when the configuration option is
// [SQLITE_CONFIG_MALLOC] or [SQLITE_CONFIG_GETMALLOC].
// By creating an instance of this object
// and passing it to [sqlite3_config]([SQLITE_CONFIG_MALLOC])
// during configuration, an application can specify an alternative
// memory allocation subsystem for SQLite to use for all of its
// dynamic memory needs.
//
// Note that SQLite comes with several [built-in memory allocators]
// that are perfectly adequate for the overwhelming majority of applications
// and that this object is only useful to a tiny minority of applications
// with specialized memory allocation requirements.  This object is
// also used during testing of SQLite in order to specify an alternative
// memory allocator that simulates memory out-of-memory conditions in
// order to verify that SQLite recovers gracefully from such
// conditions.
//
// The xMalloc, xRealloc, and xFree methods must work like the
// malloc(), realloc() and free() functions from the standard C library.
// ^SQLite guarantees that the second argument to
// xRealloc is always a value returned by a prior call to xRoundup.
//
// xSize should return the allocated size of a memory allocation
// previously obtained from xMalloc or xRealloc.  The allocated size
// is always at least as big as the requested size but may be larger.
//
// The xRoundup method returns what would be the allocated size of
// a memory allocation given a particular requested size.  Most memory
// allocators round up memory allocations at least to the next multiple
// of 8.  Some allocators round up to a larger multiple or to a power of 2.
// Every memory allocation request coming in through [sqlite3_malloc()]
// or [sqlite3_realloc()] first calls xRoundup.  If xRoundup returns 0,
// that causes the corresponding memory allocation to fail.
//
// The xInit method initializes the memory allocator.  For example,
// it might allocate any required mutexes or initialize internal data
// structures.  The xShutdown method is invoked (indirectly) by
// [sqlite3_shutdown()] and should deallocate any resources acquired
// by xInit.  The pAppData pointer is used as the only parameter to
// xInit and xShutdown.
//
// SQLite holds the [SQLITE_MUTEX_STATIC_MASTER] mutex when it invokes
// the xInit method, so the xInit method need not be threadsafe.  The
// xShutdown method is only called from [sqlite3_shutdown()] so it does
// not need to be threadsafe either.  For all other methods, SQLite
// holds the [SQLITE_MUTEX_STATIC_MEM] mutex as long as the
// [SQLITE_CONFIG_MEMSTATUS] configuration option is turned on (which
// it is by default) and so the methods are automatically serialized.
// However, if [SQLITE_CONFIG_MEMSTATUS] is disabled, then the other
// methods must be threadsafe or else make their own arrangements for
// serialization.
//
// SQLite will never invoke xInit() more than once without an intervening
// call to xShutdown().
type sqlite3_mem_methods = sqlite3_mem_methods1 /* sqlite3.h:1662:36 */

// CAPI3REF: Dynamically Typed Value Object
// KEYWORDS: {protected sqlite3_value} {unprotected sqlite3_value}
//
// SQLite uses the sqlite3_value object to represent all values
// that can be stored in a database table. SQLite uses dynamic typing
// for the values it stores.  ^Values stored in sqlite3_value objects
// can be integers, floating point values, strings, BLOBs, or NULL.
//
// An sqlite3_value object may be either "protected" or "unprotected".
// Some interfaces require a protected sqlite3_value.  Other interfaces
// will accept either a protected or an unprotected sqlite3_value.
// Every interface that accepts sqlite3_value arguments specifies
// whether or not it requires a protected sqlite3_value.  The
// [sqlite3_value_dup()] interface can be used to construct a new
// protected sqlite3_value from an unprotected sqlite3_value.
//
// The terms "protected" and "unprotected" refer to whether or not
// a mutex is held.  An internal mutex is held for a protected
// sqlite3_value object but no mutex is held for an unprotected
// sqlite3_value object.  If SQLite is compiled to be single-threaded
// (with [SQLITE_THREADSAFE=0] and with [sqlite3_threadsafe()] returning 0)
// or if SQLite is run in one of reduced mutex modes
// [SQLITE_CONFIG_SINGLETHREAD] or [SQLITE_CONFIG_MULTITHREAD]
// then there is no distinction between protected and unprotected
// sqlite3_value objects and they can be used interchangeably.  However,
// for maximum code portability it is recommended that applications
// still make the distinction between protected and unprotected
// sqlite3_value objects even when not strictly required.
//
// ^The sqlite3_value objects that are passed as parameters into the
// implementation of [application-defined SQL functions] are protected.
// ^The sqlite3_value object returned by
// [sqlite3_column_value()] is unprotected.
// Unprotected sqlite3_value objects may only be used as arguments
// to [sqlite3_result_value()], [sqlite3_bind_value()], and
// [sqlite3_value_dup()].
// The [sqlite3_value_blob | sqlite3_value_type()] family of
// interfaces require protected sqlite3_value objects.
type sqlite3_value1 = struct {
	Fu        struct{ Fr float64 }
	Fflags    u16
	Fenc      u8
	FeSubtype u8
	Fn        int32
	Fz        uintptr
	FzMalloc  uintptr
	FszMalloc int32
	FuTemp    u32
	Fdb       uintptr
	FxDel     uintptr
}

// CAPI3REF: SQL Function Context Object
//
// The context in which an SQL function executes is stored in an
// sqlite3_context object.  ^A pointer to an sqlite3_context object
// is always first parameter to [application-defined SQL functions].
// The application-defined SQL function implementation will pass this
// pointer through into calls to [sqlite3_result_int | sqlite3_result()],
// [sqlite3_aggregate_context()], [sqlite3_user_data()],
// [sqlite3_context_db_handle()], [sqlite3_get_auxdata()],
// and/or [sqlite3_set_auxdata()].
type sqlite3_context1 = struct {
	FpOut     uintptr
	FpFunc    uintptr
	FpMem     uintptr
	FpVdbe    uintptr
	FiOp      int32
	FisError  int32
	FskipFlag u8
	Fargc     u8
	Fargv     [1]uintptr
}

// CAPI3REF: Constants Defining Special Destructor Behavior
//
// These are special values for the destructor that is passed in as the
// final argument to routines like [sqlite3_result_blob()].  ^If the destructor
// argument is SQLITE_STATIC, it means that the content pointer is constant
// and will never change.  It does not need to be destroyed.  ^The
// SQLITE_TRANSIENT value means that the content will likely change in
// the near future and that SQLite should make its own private copy of
// the content before returning.
//
// The typedef is necessary to work around problems in certain
// C++ compilers.
type sqlite3_destructor_type = uintptr /* sqlite3.h:5619:14 */

// The interface to the virtual-table mechanism is currently considered
// to be experimental.  The interface might change in incompatible ways.
// If this is a problem for you, do not use the interface at this time.
//
// When the virtual-table mechanism stabilizes, we will declare the
// interface fixed, support it indefinitely, and remove this comment.

// Structures used by the virtual table interface
type sqlite3_vtab1 = struct {
	FpModule uintptr
	FnRef    int32
	FzErrMsg uintptr
}

// The interface to the virtual-table mechanism is currently considered
// to be experimental.  The interface might change in incompatible ways.
// If this is a problem for you, do not use the interface at this time.
//
// When the virtual-table mechanism stabilizes, we will declare the
// interface fixed, support it indefinitely, and remove this comment.

// Structures used by the virtual table interface
type sqlite3_vtab = sqlite3_vtab1 /* sqlite3.h:6687:29 */
type sqlite3_index_info1 = struct {
	FnConstraint      int32
	FaConstraint      uintptr
	FnOrderBy         int32
	FaOrderBy         uintptr
	FaConstraintUsage uintptr
	FidxNum           int32
	FidxStr           uintptr
	FneedToFreeIdxStr int32
	ForderByConsumed  int32
	FestimatedCost    float64
	FestimatedRows    sqlite3_int64
	FidxFlags         int32
	FcolUsed          sqlite3_uint64
}

type sqlite3_index_info = sqlite3_index_info1 /* sqlite3.h:6688:35 */
type sqlite3_vtab_cursor1 = struct{ FpVtab uintptr }

type sqlite3_vtab_cursor = sqlite3_vtab_cursor1 /* sqlite3.h:6689:36 */
type sqlite3_module1 = struct {
	FiVersion      int32
	FxCreate       uintptr
	FxConnect      uintptr
	FxBestIndex    uintptr
	FxDisconnect   uintptr
	FxDestroy      uintptr
	FxOpen         uintptr
	FxClose        uintptr
	FxFilter       uintptr
	FxNext         uintptr
	FxEof          uintptr
	FxColumn       uintptr
	FxRowid        uintptr
	FxUpdate       uintptr
	FxBegin        uintptr
	FxSync         uintptr
	FxCommit       uintptr
	FxRollback     uintptr
	FxFindFunction uintptr
	FxRename       uintptr
	FxSavepoint    uintptr
	FxRelease      uintptr
	FxRollbackTo   uintptr
	FxShadowName   uintptr
}

type sqlite3_module = sqlite3_module1 /* sqlite3.h:6690:31 */

// CAPI3REF: Virtual Table Indexing Information
// KEYWORDS: sqlite3_index_info
//
// The sqlite3_index_info structure and its substructures is used as part
// of the [virtual table] interface to
// pass information into and receive the reply from the [xBestIndex]
// method of a [virtual table module].  The fields under **Inputs** are the
// inputs to xBestIndex and are read-only.  xBestIndex inserts its
// results into the **Outputs** fields.
//
// ^(The aConstraint[] array records WHERE clause constraints of the form:
//
// <blockquote>column OP expr</blockquote>
//
// where OP is =, &lt;, &lt;=, &gt;, or &gt;=.)^  ^(The particular operator is
// stored in aConstraint[].op using one of the
// [SQLITE_INDEX_CONSTRAINT_EQ | SQLITE_INDEX_CONSTRAINT_ values].)^
// ^(The index of the column is stored in
// aConstraint[].iColumn.)^  ^(aConstraint[].usable is TRUE if the
// expr on the right-hand side can be evaluated (and thus the constraint
// is usable) and false if it cannot.)^
//
// ^The optimizer automatically inverts terms of the form "expr OP column"
// and makes other simplifications to the WHERE clause in an attempt to
// get as many WHERE clause terms into the form shown above as possible.
// ^The aConstraint[] array only reports WHERE clause terms that are
// relevant to the particular virtual table being queried.
//
// ^Information about the ORDER BY clause is stored in aOrderBy[].
// ^Each term of aOrderBy records a column of the ORDER BY clause.
//
// The colUsed field indicates which columns of the virtual table may be
// required by the current scan. Virtual table columns are numbered from
// zero in the order in which they appear within the CREATE TABLE statement
// passed to sqlite3_declare_vtab(). For the first 63 columns (columns 0-62),
// the corresponding bit is set within the colUsed mask if the column may be
// required by SQLite. If the table has at least 64 columns and any column
// to the right of the first 63 is required, then bit 63 of colUsed is also
// set. In other words, column iCol may be required if the expression
// (colUsed & ((sqlite3_uint64)1 << (iCol>=63 ? 63 : iCol))) evaluates to
// non-zero.
//
// The [xBestIndex] method must fill aConstraintUsage[] with information
// about what parameters to pass to xFilter.  ^If argvIndex>0 then
// the right-hand side of the corresponding aConstraint[] is evaluated
// and becomes the argvIndex-th entry in argv.  ^(If aConstraintUsage[].omit
// is true, then the constraint is assumed to be fully handled by the
// virtual table and might not be checked again by the byte code.)^ ^(The
// aConstraintUsage[].omit flag is an optimization hint. When the omit flag
// is left in its default setting of false, the constraint will always be
// checked separately in byte code.  If the omit flag is change to true, then
// the constraint may or may not be checked in byte code.  In other words,
// when the omit flag is true there is no guarantee that the constraint will
// not be checked again using byte code.)^
//
// ^The idxNum and idxPtr values are recorded and passed into the
// [xFilter] method.
// ^[sqlite3_free()] is used to free idxPtr if and only if
// needToFreeIdxPtr is true.
//
// ^The orderByConsumed means that output from [xFilter]/[xNext] will occur in
// the correct order to satisfy the ORDER BY clause so that no separate
// sorting step is required.
//
// ^The estimatedCost value is an estimate of the cost of a particular
// strategy. A cost of N indicates that the cost of the strategy is similar
// to a linear scan of an SQLite table with N rows. A cost of log(N)
// indicates that the expense of the operation is similar to that of a
// binary search on a unique indexed field of an SQLite table with N rows.
//
// ^The estimatedRows value is an estimate of the number of rows that
// will be returned by the strategy.
//
// The xBestIndex method may optionally populate the idxFlags field with a
// mask of SQLITE_INDEX_SCAN_* flags. Currently there is only one such flag -
// SQLITE_INDEX_SCAN_UNIQUE. If the xBestIndex method sets this flag, SQLite
// assumes that the strategy may visit at most one row.
//
// Additionally, if xBestIndex sets the SQLITE_INDEX_SCAN_UNIQUE flag, then
// SQLite also assumes that if a call to the xUpdate() method is made as
// part of the same statement to delete or update a virtual table row and the
// implementation returns SQLITE_CONSTRAINT, then there is no need to rollback
// any database changes. In other words, if the xUpdate() returns
// SQLITE_CONSTRAINT, the database contents must be exactly as they were
// before xUpdate was called. By contrast, if SQLITE_INDEX_SCAN_UNIQUE is not
// set and xUpdate returns SQLITE_CONSTRAINT, any database changes made by
// the xUpdate method are automatically rolled back by SQLite.
//
// IMPORTANT: The estimatedRows field was added to the sqlite3_index_info
// structure for SQLite [version 3.8.2] ([dateof:3.8.2]).
// If a virtual table extension is
// used with an SQLite version earlier than 3.8.2, the results of attempting
// to read or write the estimatedRows field are undefined (but are likely
// to include crashing the application). The estimatedRows field should
// therefore only be used if [sqlite3_libversion_number()] returns a
// value greater than or equal to 3008002. Similarly, the idxFlags field
// was added for [version 3.9.0] ([dateof:3.9.0]).
// It may therefore only be used if
// sqlite3_libversion_number() returns a value greater than or equal to
// 3009000.
type sqlite3_index_constraint = struct {
	FiColumn     int32
	Fop          uint8
	Fusable      uint8
	FiTermOffset int32
}

// CAPI3REF: Virtual Table Indexing Information
// KEYWORDS: sqlite3_index_info
//
// The sqlite3_index_info structure and its substructures is used as part
// of the [virtual table] interface to
// pass information into and receive the reply from the [xBestIndex]
// method of a [virtual table module].  The fields under **Inputs** are the
// inputs to xBestIndex and are read-only.  xBestIndex inserts its
// results into the **Outputs** fields.
//
// ^(The aConstraint[] array records WHERE clause constraints of the form:
//
// <blockquote>column OP expr</blockquote>
//
// where OP is =, &lt;, &lt;=, &gt;, or &gt;=.)^  ^(The particular operator is
// stored in aConstraint[].op using one of the
// [SQLITE_INDEX_CONSTRAINT_EQ | SQLITE_INDEX_CONSTRAINT_ values].)^
// ^(The index of the column is stored in
// aConstraint[].iColumn.)^  ^(aConstraint[].usable is TRUE if the
// expr on the right-hand side can be evaluated (and thus the constraint
// is usable) and false if it cannot.)^
//
// ^The optimizer automatically inverts terms of the form "expr OP column"
// and makes other simplifications to the WHERE clause in an attempt to
// get as many WHERE clause terms into the form shown above as possible.
// ^The aConstraint[] array only reports WHERE clause terms that are
// relevant to the particular virtual table being queried.
//
// ^Information about the ORDER BY clause is stored in aOrderBy[].
// ^Each term of aOrderBy records a column of the ORDER BY clause.
//
// The colUsed field indicates which columns of the virtual table may be
// required by the current scan. Virtual table columns are numbered from
// zero in the order in which they appear within the CREATE TABLE statement
// passed to sqlite3_declare_vtab(). For the first 63 columns (columns 0-62),
// the corresponding bit is set within the colUsed mask if the column may be
// required by SQLite. If the table has at least 64 columns and any column
// to the right of the first 63 is required, then bit 63 of colUsed is also
// set. In other words, column iCol may be required if the expression
// (colUsed & ((sqlite3_uint64)1 << (iCol>=63 ? 63 : iCol))) evaluates to
// non-zero.
//
// The [xBestIndex] method must fill aConstraintUsage[] with information
// about what parameters to pass to xFilter.  ^If argvIndex>0 then
// the right-hand side of the corresponding aConstraint[] is evaluated
// and becomes the argvIndex-th entry in argv.  ^(If aConstraintUsage[].omit
// is true, then the constraint is assumed to be fully handled by the
// virtual table and might not be checked again by the byte code.)^ ^(The
// aConstraintUsage[].omit flag is an optimization hint. When the omit flag
// is left in its default setting of false, the constraint will always be
// checked separately in byte code.  If the omit flag is change to true, then
// the constraint may or may not be checked in byte code.  In other words,
// when the omit flag is true there is no guarantee that the constraint will
// not be checked again using byte code.)^
//
// ^The idxNum and idxPtr values are recorded and passed into the
// [xFilter] method.
// ^[sqlite3_free()] is used to free idxPtr if and only if
// needToFreeIdxPtr is true.
//
// ^The orderByConsumed means that output from [xFilter]/[xNext] will occur in
// the correct order to satisfy the ORDER BY clause so that no separate
// sorting step is required.
//
// ^The estimatedCost value is an estimate of the cost of a particular
// strategy. A cost of N indicates that the cost of the strategy is similar
// to a linear scan of an SQLite table with N rows. A cost of log(N)
// indicates that the expense of the operation is similar to that of a
// binary search on a unique indexed field of an SQLite table with N rows.
//
// ^The estimatedRows value is an estimate of the number of rows that
// will be returned by the strategy.
//
// The xBestIndex method may optionally populate the idxFlags field with a
// mask of SQLITE_INDEX_SCAN_* flags. Currently there is only one such flag -
// SQLITE_INDEX_SCAN_UNIQUE. If the xBestIndex method sets this flag, SQLite
// assumes that the strategy may visit at most one row.
//
// Additionally, if xBestIndex sets the SQLITE_INDEX_SCAN_UNIQUE flag, then
// SQLite also assumes that if a call to the xUpdate() method is made as
// part of the same statement to delete or update a virtual table row and the
// implementation returns SQLITE_CONSTRAINT, then there is no need to rollback
// any database changes. In other words, if the xUpdate() returns
// SQLITE_CONSTRAINT, the database contents must be exactly as they were
// before xUpdate was called. By contrast, if SQLITE_INDEX_SCAN_UNIQUE is not
// set and xUpdate returns SQLITE_CONSTRAINT, any database changes made by
// the xUpdate method are automatically rolled back by SQLite.
//
// IMPORTANT: The estimatedRows field was added to the sqlite3_index_info
// structure for SQLite [version 3.8.2] ([dateof:3.8.2]).
// If a virtual table extension is
// used with an SQLite version earlier than 3.8.2, the results of attempting
// to read or write the estimatedRows field are undefined (but are likely
// to include crashing the application). The estimatedRows field should
// therefore only be used if [sqlite3_libversion_number()] returns a
// value greater than or equal to 3008002. Similarly, the idxFlags field
// was added for [version 3.9.0] ([dateof:3.9.0]).
// It may therefore only be used if
// sqlite3_libversion_number() returns a value greater than or equal to
// 3009000.
type sqlite3_index_orderby = struct {
	FiColumn int32
	Fdesc    uint8
	_        [3]byte
}

// CAPI3REF: Virtual Table Indexing Information
// KEYWORDS: sqlite3_index_info
//
// The sqlite3_index_info structure and its substructures is used as part
// of the [virtual table] interface to
// pass information into and receive the reply from the [xBestIndex]
// method of a [virtual table module].  The fields under **Inputs** are the
// inputs to xBestIndex and are read-only.  xBestIndex inserts its
// results into the **Outputs** fields.
//
// ^(The aConstraint[] array records WHERE clause constraints of the form:
//
// <blockquote>column OP expr</blockquote>
//
// where OP is =, &lt;, &lt;=, &gt;, or &gt;=.)^  ^(The particular operator is
// stored in aConstraint[].op using one of the
// [SQLITE_INDEX_CONSTRAINT_EQ | SQLITE_INDEX_CONSTRAINT_ values].)^
// ^(The index of the column is stored in
// aConstraint[].iColumn.)^  ^(aConstraint[].usable is TRUE if the
// expr on the right-hand side can be evaluated (and thus the constraint
// is usable) and false if it cannot.)^
//
// ^The optimizer automatically inverts terms of the form "expr OP column"
// and makes other simplifications to the WHERE clause in an attempt to
// get as many WHERE clause terms into the form shown above as possible.
// ^The aConstraint[] array only reports WHERE clause terms that are
// relevant to the particular virtual table being queried.
//
// ^Information about the ORDER BY clause is stored in aOrderBy[].
// ^Each term of aOrderBy records a column of the ORDER BY clause.
//
// The colUsed field indicates which columns of the virtual table may be
// required by the current scan. Virtual table columns are numbered from
// zero in the order in which they appear within the CREATE TABLE statement
// passed to sqlite3_declare_vtab(). For the first 63 columns (columns 0-62),
// the corresponding bit is set within the colUsed mask if the column may be
// required by SQLite. If the table has at least 64 columns and any column
// to the right of the first 63 is required, then bit 63 of colUsed is also
// set. In other words, column iCol may be required if the expression
// (colUsed & ((sqlite3_uint64)1 << (iCol>=63 ? 63 : iCol))) evaluates to
// non-zero.
//
// The [xBestIndex] method must fill aConstraintUsage[] with information
// about what parameters to pass to xFilter.  ^If argvIndex>0 then
// the right-hand side of the corresponding aConstraint[] is evaluated
// and becomes the argvIndex-th entry in argv.  ^(If aConstraintUsage[].omit
// is true, then the constraint is assumed to be fully handled by the
// virtual table and might not be checked again by the byte code.)^ ^(The
// aConstraintUsage[].omit flag is an optimization hint. When the omit flag
// is left in its default setting of false, the constraint will always be
// checked separately in byte code.  If the omit flag is change to true, then
// the constraint may or may not be checked in byte code.  In other words,
// when the omit flag is true there is no guarantee that the constraint will
// not be checked again using byte code.)^
//
// ^The idxNum and idxPtr values are recorded and passed into the
// [xFilter] method.
// ^[sqlite3_free()] is used to free idxPtr if and only if
// needToFreeIdxPtr is true.
//
// ^The orderByConsumed means that output from [xFilter]/[xNext] will occur in
// the correct order to satisfy the ORDER BY clause so that no separate
// sorting step is required.
//
// ^The estimatedCost value is an estimate of the cost of a particular
// strategy. A cost of N indicates that the cost of the strategy is similar
// to a linear scan of an SQLite table with N rows. A cost of log(N)
// indicates that the expense of the operation is similar to that of a
// binary search on a unique indexed field of an SQLite table with N rows.
//
// ^The estimatedRows value is an estimate of the number of rows that
// will be returned by the strategy.
//
// The xBestIndex method may optionally populate the idxFlags field with a
// mask of SQLITE_INDEX_SCAN_* flags. Currently there is only one such flag -
// SQLITE_INDEX_SCAN_UNIQUE. If the xBestIndex method sets this flag, SQLite
// assumes that the strategy may visit at most one row.
//
// Additionally, if xBestIndex sets the SQLITE_INDEX_SCAN_UNIQUE flag, then
// SQLite also assumes that if a call to the xUpdate() method is made as
// part of the same statement to delete or update a virtual table row and the
// implementation returns SQLITE_CONSTRAINT, then there is no need to rollback
// any database changes. In other words, if the xUpdate() returns
// SQLITE_CONSTRAINT, the database contents must be exactly as they were
// before xUpdate was called. By contrast, if SQLITE_INDEX_SCAN_UNIQUE is not
// set and xUpdate returns SQLITE_CONSTRAINT, any database changes made by
// the xUpdate method are automatically rolled back by SQLite.
//
// IMPORTANT: The estimatedRows field was added to the sqlite3_index_info
// structure for SQLite [version 3.8.2] ([dateof:3.8.2]).
// If a virtual table extension is
// used with an SQLite version earlier than 3.8.2, the results of attempting
// to read or write the estimatedRows field are undefined (but are likely
// to include crashing the application). The estimatedRows field should
// therefore only be used if [sqlite3_libversion_number()] returns a
// value greater than or equal to 3008002. Similarly, the idxFlags field
// was added for [version 3.9.0] ([dateof:3.9.0]).
// It may therefore only be used if
// sqlite3_libversion_number() returns a value greater than or equal to
// 3009000.
type sqlite3_index_constraint_usage = struct {
	FargvIndex int32
	Fomit      uint8
	_          [3]byte
}

// CAPI3REF: Mutex Methods Object
//
// An instance of this structure defines the low-level routines
// used to allocate and use mutexes.
//
// Usually, the default mutex implementations provided by SQLite are
// sufficient, however the application has the option of substituting a custom
// implementation for specialized deployments or systems for which SQLite
// does not provide a suitable implementation. In this case, the application
// creates and populates an instance of this structure to pass
// to sqlite3_config() along with the [SQLITE_CONFIG_MUTEX] option.
// Additionally, an instance of this structure can be used as an
// output variable when querying the system for the current mutex
// implementation, using the [SQLITE_CONFIG_GETMUTEX] option.
//
// ^The xMutexInit method defined by this structure is invoked as
// part of system initialization by the sqlite3_initialize() function.
// ^The xMutexInit routine is called by SQLite exactly once for each
// effective call to [sqlite3_initialize()].
//
// ^The xMutexEnd method defined by this structure is invoked as
// part of system shutdown by the sqlite3_shutdown() function. The
// implementation of this method is expected to release all outstanding
// resources obtained by the mutex methods implementation, especially
// those obtained by the xMutexInit method.  ^The xMutexEnd()
// interface is invoked exactly once for each call to [sqlite3_shutdown()].
//
// ^(The remaining seven methods defined by this structure (xMutexAlloc,
// xMutexFree, xMutexEnter, xMutexTry, xMutexLeave, xMutexHeld and
// xMutexNotheld) implement the following interfaces (respectively):
//
// <ul>
//   <li>  [sqlite3_mutex_alloc()] </li>
//   <li>  [sqlite3_mutex_free()] </li>
//   <li>  [sqlite3_mutex_enter()] </li>
//   <li>  [sqlite3_mutex_try()] </li>
//   <li>  [sqlite3_mutex_leave()] </li>
//   <li>  [sqlite3_mutex_held()] </li>
//   <li>  [sqlite3_mutex_notheld()] </li>
// </ul>)^
//
// The only difference is that the public sqlite3_XXX functions enumerated
// above silently ignore any invocations that pass a NULL pointer instead
// of a valid mutex handle. The implementations of the methods defined
// by this structure are not required to handle this case. The results
// of passing a NULL pointer instead of a valid mutex handle are undefined
// (i.e. it is acceptable to provide an implementation that segfaults if
// it is passed a NULL pointer).
//
// The xMutexInit() method must be threadsafe.  It must be harmless to
// invoke xMutexInit() multiple times within the same process and without
// intervening calls to xMutexEnd().  Second and subsequent calls to
// xMutexInit() must be no-ops.
//
// xMutexInit() must not use SQLite memory allocation ([sqlite3_malloc()]
// and its associates).  Similarly, xMutexAlloc() must not use SQLite memory
// allocation for a static mutex.  ^However xMutexAlloc() may use SQLite
// memory allocation for a fast or recursive mutex.
//
// ^SQLite will invoke the xMutexEnd() method when [sqlite3_shutdown()] is
// called, but only if the prior call to xMutexInit returned SQLITE_OK.
// If xMutexInit fails in any way, it is expected to clean up after itself
// prior to returning.
type sqlite3_mutex_methods1 = struct {
	FxMutexInit    uintptr
	FxMutexEnd     uintptr
	FxMutexAlloc   uintptr
	FxMutexFree    uintptr
	FxMutexEnter   uintptr
	FxMutexTry     uintptr
	FxMutexLeave   uintptr
	FxMutexHeld    uintptr
	FxMutexNotheld uintptr
}

// CAPI3REF: Mutex Methods Object
//
// An instance of this structure defines the low-level routines
// used to allocate and use mutexes.
//
// Usually, the default mutex implementations provided by SQLite are
// sufficient, however the application has the option of substituting a custom
// implementation for specialized deployments or systems for which SQLite
// does not provide a suitable implementation. In this case, the application
// creates and populates an instance of this structure to pass
// to sqlite3_config() along with the [SQLITE_CONFIG_MUTEX] option.
// Additionally, an instance of this structure can be used as an
// output variable when querying the system for the current mutex
// implementation, using the [SQLITE_CONFIG_GETMUTEX] option.
//
// ^The xMutexInit method defined by this structure is invoked as
// part of system initialization by the sqlite3_initialize() function.
// ^The xMutexInit routine is called by SQLite exactly once for each
// effective call to [sqlite3_initialize()].
//
// ^The xMutexEnd method defined by this structure is invoked as
// part of system shutdown by the sqlite3_shutdown() function. The
// implementation of this method is expected to release all outstanding
// resources obtained by the mutex methods implementation, especially
// those obtained by the xMutexInit method.  ^The xMutexEnd()
// interface is invoked exactly once for each call to [sqlite3_shutdown()].
//
// ^(The remaining seven methods defined by this structure (xMutexAlloc,
// xMutexFree, xMutexEnter, xMutexTry, xMutexLeave, xMutexHeld and
// xMutexNotheld) implement the following interfaces (respectively):
//
// <ul>
//   <li>  [sqlite3_mutex_alloc()] </li>
//   <li>  [sqlite3_mutex_free()] </li>
//   <li>  [sqlite3_mutex_enter()] </li>
//   <li>  [sqlite3_mutex_try()] </li>
//   <li>  [sqlite3_mutex_leave()] </li>
//   <li>  [sqlite3_mutex_held()] </li>
//   <li>  [sqlite3_mutex_notheld()] </li>
// </ul>)^
//
// The only difference is that the public sqlite3_XXX functions enumerated
// above silently ignore any invocations that pass a NULL pointer instead
// of a valid mutex handle. The implementations of the methods defined
// by this structure are not required to handle this case. The results
// of passing a NULL pointer instead of a valid mutex handle are undefined
// (i.e. it is acceptable to provide an implementation that segfaults if
// it is passed a NULL pointer).
//
// The xMutexInit() method must be threadsafe.  It must be harmless to
// invoke xMutexInit() multiple times within the same process and without
// intervening calls to xMutexEnd().  Second and subsequent calls to
// xMutexInit() must be no-ops.
//
// xMutexInit() must not use SQLite memory allocation ([sqlite3_malloc()]
// and its associates).  Similarly, xMutexAlloc() must not use SQLite memory
// allocation for a static mutex.  ^However xMutexAlloc() may use SQLite
// memory allocation for a fast or recursive mutex.
//
// ^SQLite will invoke the xMutexEnd() method when [sqlite3_shutdown()] is
// called, but only if the prior call to xMutexInit returned SQLITE_OK.
// If xMutexInit fails in any way, it is expected to clean up after itself
// prior to returning.
type sqlite3_mutex_methods = sqlite3_mutex_methods1 /* sqlite3.h:7522:38 */

// CAPI3REF: Dynamic String Object
// KEYWORDS: {dynamic string}
//
// An instance of the sqlite3_str object contains a dynamically-sized
// string under construction.
//
// The lifecycle of an sqlite3_str object is as follows:
// <ol>
// <li> ^The sqlite3_str object is created using [sqlite3_str_new()].
// <li> ^Text is appended to the sqlite3_str object using various
// methods, such as [sqlite3_str_appendf()].
// <li> ^The sqlite3_str object is destroyed and the string it created
// is returned using the [sqlite3_str_finish()] interface.
// </ol>
type sqlite3_str1 = struct {
	Fdb          uintptr
	FzText       uintptr
	FnAlloc      u32
	FmxAlloc     u32
	FnChar       u32
	FaccError    u8
	FprintfFlags u8
	_            [2]byte
}

// CAPI3REF: Custom Page Cache Object
//
// The sqlite3_pcache_page object represents a single page in the
// page cache.  The page cache will allocate instances of this
// object.  Various methods of the page cache use pointers to instances
// of this object as parameters or as their return value.
//
// See [sqlite3_pcache_methods2] for additional information.
type sqlite3_pcache_page1 = struct {
	FpBuf   uintptr
	FpExtra uintptr
}

// CAPI3REF: Custom Page Cache Object
//
// The sqlite3_pcache_page object represents a single page in the
// page cache.  The page cache will allocate instances of this
// object.  Various methods of the page cache use pointers to instances
// of this object as parameters or as their return value.
//
// See [sqlite3_pcache_methods2] for additional information.
type sqlite3_pcache_page = sqlite3_pcache_page1 /* sqlite3.h:8271:36 */

// CAPI3REF: Application Defined Page Cache.
// KEYWORDS: {page cache}
//
// ^(The [sqlite3_config]([SQLITE_CONFIG_PCACHE2], ...) interface can
// register an alternative page cache implementation by passing in an
// instance of the sqlite3_pcache_methods2 structure.)^
// In many applications, most of the heap memory allocated by
// SQLite is used for the page cache.
// By implementing a
// custom page cache using this API, an application can better control
// the amount of memory consumed by SQLite, the way in which
// that memory is allocated and released, and the policies used to
// determine exactly which parts of a database file are cached and for
// how long.
//
// The alternative page cache mechanism is an
// extreme measure that is only needed by the most demanding applications.
// The built-in page cache is recommended for most uses.
//
// ^(The contents of the sqlite3_pcache_methods2 structure are copied to an
// internal buffer by SQLite within the call to [sqlite3_config].  Hence
// the application may discard the parameter after the call to
// [sqlite3_config()] returns.)^
//
// [[the xInit() page cache method]]
// ^(The xInit() method is called once for each effective
// call to [sqlite3_initialize()])^
// (usually only once during the lifetime of the process). ^(The xInit()
// method is passed a copy of the sqlite3_pcache_methods2.pArg value.)^
// The intent of the xInit() method is to set up global data structures
// required by the custom page cache implementation.
// ^(If the xInit() method is NULL, then the
// built-in default page cache is used instead of the application defined
// page cache.)^
//
// [[the xShutdown() page cache method]]
// ^The xShutdown() method is called by [sqlite3_shutdown()].
// It can be used to clean up
// any outstanding resources before process shutdown, if required.
// ^The xShutdown() method may be NULL.
//
// ^SQLite automatically serializes calls to the xInit method,
// so the xInit method need not be threadsafe.  ^The
// xShutdown method is only called from [sqlite3_shutdown()] so it does
// not need to be threadsafe either.  All other methods must be threadsafe
// in multithreaded applications.
//
// ^SQLite will never invoke xInit() more than once without an intervening
// call to xShutdown().
//
// [[the xCreate() page cache methods]]
// ^SQLite invokes the xCreate() method to construct a new cache instance.
// SQLite will typically create one cache instance for each open database file,
// though this is not guaranteed. ^The
// first parameter, szPage, is the size in bytes of the pages that must
// be allocated by the cache.  ^szPage will always a power of two.  ^The
// second parameter szExtra is a number of bytes of extra storage
// associated with each page cache entry.  ^The szExtra parameter will
// a number less than 250.  SQLite will use the
// extra szExtra bytes on each page to store metadata about the underlying
// database page on disk.  The value passed into szExtra depends
// on the SQLite version, the target platform, and how SQLite was compiled.
// ^The third argument to xCreate(), bPurgeable, is true if the cache being
// created will be used to cache database pages of a file stored on disk, or
// false if it is used for an in-memory database. The cache implementation
// does not have to do anything special based with the value of bPurgeable;
// it is purely advisory.  ^On a cache where bPurgeable is false, SQLite will
// never invoke xUnpin() except to deliberately delete a page.
// ^In other words, calls to xUnpin() on a cache with bPurgeable set to
// false will always have the "discard" flag set to true.
// ^Hence, a cache created with bPurgeable false will
// never contain any unpinned pages.
//
// [[the xCachesize() page cache method]]
// ^(The xCachesize() method may be called at any time by SQLite to set the
// suggested maximum cache-size (number of pages stored by) the cache
// instance passed as the first argument. This is the value configured using
// the SQLite "[PRAGMA cache_size]" command.)^  As with the bPurgeable
// parameter, the implementation is not required to do anything with this
// value; it is advisory only.
//
// [[the xPagecount() page cache methods]]
// The xPagecount() method must return the number of pages currently
// stored in the cache, both pinned and unpinned.
//
// [[the xFetch() page cache methods]]
// The xFetch() method locates a page in the cache and returns a pointer to
// an sqlite3_pcache_page object associated with that page, or a NULL pointer.
// The pBuf element of the returned sqlite3_pcache_page object will be a
// pointer to a buffer of szPage bytes used to store the content of a
// single database page.  The pExtra element of sqlite3_pcache_page will be
// a pointer to the szExtra bytes of extra storage that SQLite has requested
// for each entry in the page cache.
//
// The page to be fetched is determined by the key. ^The minimum key value
// is 1.  After it has been retrieved using xFetch, the page is considered
// to be "pinned".
//
// If the requested page is already in the page cache, then the page cache
// implementation must return a pointer to the page buffer with its content
// intact.  If the requested page is not already in the cache, then the
// cache implementation should use the value of the createFlag
// parameter to help it determined what action to take:
//
// <table border=1 width=85% align=center>
// <tr><th> createFlag <th> Behavior when page is not already in cache
// <tr><td> 0 <td> Do not allocate a new page.  Return NULL.
// <tr><td> 1 <td> Allocate a new page if it easy and convenient to do so.
//                 Otherwise return NULL.
// <tr><td> 2 <td> Make every effort to allocate a new page.  Only return
//                 NULL if allocating a new page is effectively impossible.
// </table>
//
// ^(SQLite will normally invoke xFetch() with a createFlag of 0 or 1.  SQLite
// will only use a createFlag of 2 after a prior call with a createFlag of 1
// failed.)^  In between the xFetch() calls, SQLite may
// attempt to unpin one or more cache pages by spilling the content of
// pinned pages to disk and synching the operating system disk cache.
//
// [[the xUnpin() page cache method]]
// ^xUnpin() is called by SQLite with a pointer to a currently pinned page
// as its second argument.  If the third parameter, discard, is non-zero,
// then the page must be evicted from the cache.
// ^If the discard parameter is
// zero, then the page may be discarded or retained at the discretion of
// page cache implementation. ^The page cache implementation
// may choose to evict unpinned pages at any time.
//
// The cache must not perform any reference counting. A single
// call to xUnpin() unpins the page regardless of the number of prior calls
// to xFetch().
//
// [[the xRekey() page cache methods]]
// The xRekey() method is used to change the key value associated with the
// page passed as the second argument. If the cache
// previously contains an entry associated with newKey, it must be
// discarded. ^Any prior cache entry associated with newKey is guaranteed not
// to be pinned.
//
// When SQLite calls the xTruncate() method, the cache must discard all
// existing cache entries with page numbers (keys) greater than or equal
// to the value of the iLimit parameter passed to xTruncate(). If any
// of these pages are pinned, they are implicitly unpinned, meaning that
// they can be safely discarded.
//
// [[the xDestroy() page cache method]]
// ^The xDestroy() method is used to delete a cache allocated by xCreate().
// All resources associated with the specified cache should be freed. ^After
// calling the xDestroy() method, SQLite considers the [sqlite3_pcache*]
// handle invalid, and will not use it with any other sqlite3_pcache_methods2
// functions.
//
// [[the xShrink() page cache method]]
// ^SQLite invokes the xShrink() method when it wants the page cache to
// free up as much of heap memory as possible.  The page cache implementation
// is not obligated to free any memory, but well-behaved implementations should
// do their best.
type sqlite3_pcache_methods21 = struct {
	FiVersion   int32
	FpArg       uintptr
	FxInit      uintptr
	FxShutdown  uintptr
	FxCreate    uintptr
	FxCachesize uintptr
	FxPagecount uintptr
	FxFetch     uintptr
	FxUnpin     uintptr
	FxRekey     uintptr
	FxTruncate  uintptr
	FxDestroy   uintptr
	FxShrink    uintptr
}

// CAPI3REF: Application Defined Page Cache.
// KEYWORDS: {page cache}
//
// ^(The [sqlite3_config]([SQLITE_CONFIG_PCACHE2], ...) interface can
// register an alternative page cache implementation by passing in an
// instance of the sqlite3_pcache_methods2 structure.)^
// In many applications, most of the heap memory allocated by
// SQLite is used for the page cache.
// By implementing a
// custom page cache using this API, an application can better control
// the amount of memory consumed by SQLite, the way in which
// that memory is allocated and released, and the policies used to
// determine exactly which parts of a database file are cached and for
// how long.
//
// The alternative page cache mechanism is an
// extreme measure that is only needed by the most demanding applications.
// The built-in page cache is recommended for most uses.
//
// ^(The contents of the sqlite3_pcache_methods2 structure are copied to an
// internal buffer by SQLite within the call to [sqlite3_config].  Hence
// the application may discard the parameter after the call to
// [sqlite3_config()] returns.)^
//
// [[the xInit() page cache method]]
// ^(The xInit() method is called once for each effective
// call to [sqlite3_initialize()])^
// (usually only once during the lifetime of the process). ^(The xInit()
// method is passed a copy of the sqlite3_pcache_methods2.pArg value.)^
// The intent of the xInit() method is to set up global data structures
// required by the custom page cache implementation.
// ^(If the xInit() method is NULL, then the
// built-in default page cache is used instead of the application defined
// page cache.)^
//
// [[the xShutdown() page cache method]]
// ^The xShutdown() method is called by [sqlite3_shutdown()].
// It can be used to clean up
// any outstanding resources before process shutdown, if required.
// ^The xShutdown() method may be NULL.
//
// ^SQLite automatically serializes calls to the xInit method,
// so the xInit method need not be threadsafe.  ^The
// xShutdown method is only called from [sqlite3_shutdown()] so it does
// not need to be threadsafe either.  All other methods must be threadsafe
// in multithreaded applications.
//
// ^SQLite will never invoke xInit() more than once without an intervening
// call to xShutdown().
//
// [[the xCreate() page cache methods]]
// ^SQLite invokes the xCreate() method to construct a new cache instance.
// SQLite will typically create one cache instance for each open database file,
// though this is not guaranteed. ^The
// first parameter, szPage, is the size in bytes of the pages that must
// be allocated by the cache.  ^szPage will always a power of two.  ^The
// second parameter szExtra is a number of bytes of extra storage
// associated with each page cache entry.  ^The szExtra parameter will
// a number less than 250.  SQLite will use the
// extra szExtra bytes on each page to store metadata about the underlying
// database page on disk.  The value passed into szExtra depends
// on the SQLite version, the target platform, and how SQLite was compiled.
// ^The third argument to xCreate(), bPurgeable, is true if the cache being
// created will be used to cache database pages of a file stored on disk, or
// false if it is used for an in-memory database. The cache implementation
// does not have to do anything special based with the value of bPurgeable;
// it is purely advisory.  ^On a cache where bPurgeable is false, SQLite will
// never invoke xUnpin() except to deliberately delete a page.
// ^In other words, calls to xUnpin() on a cache with bPurgeable set to
// false will always have the "discard" flag set to true.
// ^Hence, a cache created with bPurgeable false will
// never contain any unpinned pages.
//
// [[the xCachesize() page cache method]]
// ^(The xCachesize() method may be called at any time by SQLite to set the
// suggested maximum cache-size (number of pages stored by) the cache
// instance passed as the first argument. This is the value configured using
// the SQLite "[PRAGMA cache_size]" command.)^  As with the bPurgeable
// parameter, the implementation is not required to do anything with this
// value; it is advisory only.
//
// [[the xPagecount() page cache methods]]
// The xPagecount() method must return the number of pages currently
// stored in the cache, both pinned and unpinned.
//
// [[the xFetch() page cache methods]]
// The xFetch() method locates a page in the cache and returns a pointer to
// an sqlite3_pcache_page object associated with that page, or a NULL pointer.
// The pBuf element of the returned sqlite3_pcache_page object will be a
// pointer to a buffer of szPage bytes used to store the content of a
// single database page.  The pExtra element of sqlite3_pcache_page will be
// a pointer to the szExtra bytes of extra storage that SQLite has requested
// for each entry in the page cache.
//
// The page to be fetched is determined by the key. ^The minimum key value
// is 1.  After it has been retrieved using xFetch, the page is considered
// to be "pinned".
//
// If the requested page is already in the page cache, then the page cache
// implementation must return a pointer to the page buffer with its content
// intact.  If the requested page is not already in the cache, then the
// cache implementation should use the value of the createFlag
// parameter to help it determined what action to take:
//
// <table border=1 width=85% align=center>
// <tr><th> createFlag <th> Behavior when page is not already in cache
// <tr><td> 0 <td> Do not allocate a new page.  Return NULL.
// <tr><td> 1 <td> Allocate a new page if it easy and convenient to do so.
//                 Otherwise return NULL.
// <tr><td> 2 <td> Make every effort to allocate a new page.  Only return
//                 NULL if allocating a new page is effectively impossible.
// </table>
//
// ^(SQLite will normally invoke xFetch() with a createFlag of 0 or 1.  SQLite
// will only use a createFlag of 2 after a prior call with a createFlag of 1
// failed.)^  In between the xFetch() calls, SQLite may
// attempt to unpin one or more cache pages by spilling the content of
// pinned pages to disk and synching the operating system disk cache.
//
// [[the xUnpin() page cache method]]
// ^xUnpin() is called by SQLite with a pointer to a currently pinned page
// as its second argument.  If the third parameter, discard, is non-zero,
// then the page must be evicted from the cache.
// ^If the discard parameter is
// zero, then the page may be discarded or retained at the discretion of
// page cache implementation. ^The page cache implementation
// may choose to evict unpinned pages at any time.
//
// The cache must not perform any reference counting. A single
// call to xUnpin() unpins the page regardless of the number of prior calls
// to xFetch().
//
// [[the xRekey() page cache methods]]
// The xRekey() method is used to change the key value associated with the
// page passed as the second argument. If the cache
// previously contains an entry associated with newKey, it must be
// discarded. ^Any prior cache entry associated with newKey is guaranteed not
// to be pinned.
//
// When SQLite calls the xTruncate() method, the cache must discard all
// existing cache entries with page numbers (keys) greater than or equal
// to the value of the iLimit parameter passed to xTruncate(). If any
// of these pages are pinned, they are implicitly unpinned, meaning that
// they can be safely discarded.
//
// [[the xDestroy() page cache method]]
// ^The xDestroy() method is used to delete a cache allocated by xCreate().
// All resources associated with the specified cache should be freed. ^After
// calling the xDestroy() method, SQLite considers the [sqlite3_pcache*]
// handle invalid, and will not use it with any other sqlite3_pcache_methods2
// functions.
//
// [[the xShrink() page cache method]]
// ^SQLite invokes the xShrink() method when it wants the page cache to
// free up as much of heap memory as possible.  The page cache implementation
// is not obligated to free any memory, but well-behaved implementations should
// do their best.
type sqlite3_pcache_methods2 = sqlite3_pcache_methods21 /* sqlite3.h:8436:40 */

// This is the obsolete pcache_methods object that has now been replaced
// by sqlite3_pcache_methods2.  This object is not used by SQLite.  It is
// retained in the header file for backwards compatibility only.
type sqlite3_pcache_methods1 = struct {
	FpArg       uintptr
	FxInit      uintptr
	FxShutdown  uintptr
	FxCreate    uintptr
	FxCachesize uintptr
	FxPagecount uintptr
	FxFetch     uintptr
	FxUnpin     uintptr
	FxRekey     uintptr
	FxTruncate  uintptr
	FxDestroy   uintptr
}

// This is the obsolete pcache_methods object that has now been replaced
// by sqlite3_pcache_methods2.  This object is not used by SQLite.  It is
// retained in the header file for backwards compatibility only.
type sqlite3_pcache_methods = sqlite3_pcache_methods1 /* sqlite3.h:8459:39 */

// CAPI3REF: Database Snapshot
// KEYWORDS: {snapshot} {sqlite3_snapshot}
//
// An instance of the snapshot object records the state of a [WAL mode]
// database for some specific point in history.
//
// In [WAL mode], multiple [database connections] that are open on the
// same database file can each be reading a different historical version
// of the database file.  When a [database connection] begins a read
// transaction, that connection sees an unchanging copy of the database
// as it existed for the point in time when the transaction first started.
// Subsequent changes to the database from other connections are not seen
// by the reader until a new read transaction is started.
//
// The sqlite3_snapshot object records state information about an historical
// version of the database file so that it is possible to later open a new read
// transaction that sees that historical version of the database rather than
// the most recent version.
type sqlite3_snapshot1 = struct{ Fhidden [48]uint8 }

// CAPI3REF: Database Snapshot
// KEYWORDS: {snapshot} {sqlite3_snapshot}
//
// An instance of the snapshot object records the state of a [WAL mode]
// database for some specific point in history.
//
// In [WAL mode], multiple [database connections] that are open on the
// same database file can each be reading a different historical version
// of the database file.  When a [database connection] begins a read
// transaction, that connection sees an unchanging copy of the database
// as it existed for the point in time when the transaction first started.
// Subsequent changes to the database from other connections are not seen
// by the reader until a new read transaction is started.
//
// The sqlite3_snapshot object records state information about an historical
// version of the database file so that it is possible to later open a new read
// transaction that sees that historical version of the database rather than
// the most recent version.
type sqlite3_snapshot = sqlite3_snapshot1 /* sqlite3.h:9508:3 */

// CAPI3REF: Flags for sqlite3_deserialize()
//
// The following are allowed values for 6th argument (the F argument) to
// the [sqlite3_deserialize(D,S,P,N,M,F)] interface.
//
// The SQLITE_DESERIALIZE_FREEONCLOSE means that the database serialization
// in the P argument is held in memory obtained from [sqlite3_malloc64()]
// and that SQLite should take ownership of this memory and automatically
// free it when it has finished using it.  Without this flag, the caller
// is responsible for freeing any dynamically allocated memory.
//
// The SQLITE_DESERIALIZE_RESIZEABLE flag means that SQLite is allowed to
// grow the size of the database using calls to [sqlite3_realloc64()].  This
// flag should only be used if SQLITE_DESERIALIZE_FREEONCLOSE is also used.
// Without this flag, the deserialized database cannot increase in size beyond
// the number of bytes specified by the M parameter.
//
// The SQLITE_DESERIALIZE_READONLY flag means that the deserialized database
// should be treated as read-only.

// Undo the hack that converts floating point types to integer for
// builds on processors without floating point support.

//******* Begin file sqlite3rtree.h ********
// 2010 August 30
//
// The author disclaims copyright to this source code.  In place of
// a legal notice, here is a blessing:
//
//    May you do good and not evil.
//    May you find forgiveness for yourself and forgive others.
//    May you share freely, never taking more than you give.
//
//

type sqlite3_rtree_geometry1 = struct {
	FpContext uintptr
	FnParam   int32
	FaParam   uintptr
	FpUser    uintptr
	FxDelUser uintptr
}

// CAPI3REF: Flags for sqlite3_deserialize()
//
// The following are allowed values for 6th argument (the F argument) to
// the [sqlite3_deserialize(D,S,P,N,M,F)] interface.
//
// The SQLITE_DESERIALIZE_FREEONCLOSE means that the database serialization
// in the P argument is held in memory obtained from [sqlite3_malloc64()]
// and that SQLite should take ownership of this memory and automatically
// free it when it has finished using it.  Without this flag, the caller
// is responsible for freeing any dynamically allocated memory.
//
// The SQLITE_DESERIALIZE_RESIZEABLE flag means that SQLite is allowed to
// grow the size of the database using calls to [sqlite3_realloc64()].  This
// flag should only be used if SQLITE_DESERIALIZE_FREEONCLOSE is also used.
// Without this flag, the deserialized database cannot increase in size beyond
// the number of bytes specified by the M parameter.
//
// The SQLITE_DESERIALIZE_READONLY flag means that the deserialized database
// should be treated as read-only.

// Undo the hack that converts floating point types to integer for
// builds on processors without floating point support.

//******* Begin file sqlite3rtree.h ********
// 2010 August 30
//
// The author disclaims copyright to this source code.  In place of
// a legal notice, here is a blessing:
//
//    May you do good and not evil.
//    May you find forgiveness for yourself and forgive others.
//    May you share freely, never taking more than you give.
//
//

type sqlite3_rtree_geometry = sqlite3_rtree_geometry1 /* sqlite3.h:9833:39 */
type sqlite3_rtree_query_info1 = struct {
	FpContext      uintptr
	FnParam        int32
	FaParam        uintptr
	FpUser         uintptr
	FxDelUser      uintptr
	FaCoord        uintptr
	FanQueue       uintptr
	FnCoord        int32
	FiLevel        int32
	FmxLevel       int32
	FiRowid        sqlite3_int64
	FrParentScore  sqlite3_rtree_dbl
	FeParentWithin int32
	FeWithin       int32
	FrScore        sqlite3_rtree_dbl
	FapSqlParam    uintptr
}

type sqlite3_rtree_query_info = sqlite3_rtree_query_info1 /* sqlite3.h:9834:41 */

// The double-precision datatype used by RTree depends on the
// SQLITE_RTREE_INT_ONLY compile-time option.
type sqlite3_rtree_dbl = float64 /* sqlite3.h:9842:18 */

// Allowed values for sqlite3_rtree_query.eWithin and .eParentWithin.

//******* End of sqlite3rtree.h ********
//******* Begin file sqlite3session.h ********

//******* End of sqlite3session.h ********
//******* Begin file fts5.h ********
// 2014 May 31
//
// The author disclaims copyright to this source code.  In place of
// a legal notice, here is a blessing:
//
//    May you do good and not evil.
//    May you find forgiveness for yourself and forgive others.
//    May you share freely, never taking more than you give.
//
//
//
// Interfaces to extend FTS5. Using the interfaces defined in this file,
// FTS5 may be extended with:
//
//     * custom tokenizers, and
//     * custom auxiliary functions.

// ************************************************************************
//
// CUSTOM AUXILIARY FUNCTIONS
//
// Virtual table implementations may overload SQL functions by implementing
// the sqlite3_module.xFindFunction() method.

type Fts5ExtensionApi1 = struct {
	FiVersion           int32
	FxUserData          uintptr
	FxColumnCount       uintptr
	FxRowCount          uintptr
	FxColumnTotalSize   uintptr
	FxTokenize          uintptr
	FxPhraseCount       uintptr
	FxPhraseSize        uintptr
	FxInstCount         uintptr
	FxInst              uintptr
	FxRowid             uintptr
	FxColumnText        uintptr
	FxColumnSize        uintptr
	FxQueryPhrase       uintptr
	FxSetAuxdata        uintptr
	FxGetAuxdata        uintptr
	FxPhraseFirst       uintptr
	FxPhraseNext        uintptr
	FxPhraseFirstColumn uintptr
	FxPhraseNextColumn  uintptr
}

// Allowed values for sqlite3_rtree_query.eWithin and .eParentWithin.

//******* End of sqlite3rtree.h ********
//******* Begin file sqlite3session.h ********

//******* End of sqlite3session.h ********
//******* Begin file fts5.h ********
// 2014 May 31
//
// The author disclaims copyright to this source code.  In place of
// a legal notice, here is a blessing:
//
//    May you do good and not evil.
//    May you find forgiveness for yourself and forgive others.
//    May you share freely, never taking more than you give.
//
//
//
// Interfaces to extend FTS5. Using the interfaces defined in this file,
// FTS5 may be extended with:
//
//     * custom tokenizers, and
//     * custom auxiliary functions.

// ************************************************************************
//
// CUSTOM AUXILIARY FUNCTIONS
//
// Virtual table implementations may overload SQL functions by implementing
// the sqlite3_module.xFindFunction() method.

type Fts5ExtensionApi = Fts5ExtensionApi1 /* sqlite3.h:11628:33 */
type Fts5PhraseIter1 = struct {
	Fa uintptr
	Fb uintptr
}

type Fts5PhraseIter = Fts5PhraseIter1 /* sqlite3.h:11630:31 */

type fts5_extension_function = uintptr /* sqlite3.h:11632:14 */
type fts5_tokenizer1 = struct {
	FxCreate   uintptr
	FxDelete   uintptr
	FxTokenize uintptr
}

type fts5_tokenizer = fts5_tokenizer1 /* sqlite3.h:12091:31 */

// Flags that may be passed as the third argument to xTokenize()

// Flags that may be passed by the tokenizer implementation back to FTS5
// as the third argument to the supplied xToken callback.

//
// END OF CUSTOM TOKENIZERS
//

// ************************************************************************
//
// FTS5 EXTENSION REGISTRATION API
type fts5_api1 = struct {
	FiVersion         int32
	FxCreateTokenizer uintptr
	FxFindTokenizer   uintptr
	FxCreateFunction  uintptr
}

// Flags that may be passed as the third argument to xTokenize()

// Flags that may be passed by the tokenizer implementation back to FTS5
// as the third argument to the supplied xToken callback.

//
// END OF CUSTOM TOKENIZERS
//

// ************************************************************************
//
// FTS5 EXTENSION REGISTRATION API
type fts5_api = fts5_api1 /* sqlite3.h:12127:25 */

//
// END OF REGISTRATION API
//

//******* End of fts5.h ********

type sqlite3expert1 = struct {
	FiSample     int32
	Fdb          uintptr
	Fdbm         uintptr
	Fdbv         uintptr
	FpTable      uintptr
	FpScan       uintptr
	FpWrite      uintptr
	FpStatement  uintptr
	FbRun        int32
	FpzErrmsg    uintptr
	Frc          int32
	FhIdx        IdxHash
	FzCandidates uintptr
}

//
// END OF REGISTRATION API
//

//******* End of fts5.h ********

type sqlite3expert = sqlite3expert1 /* sqlite3expert.h:17:30 */

// POSIX.1-2008 extended locale interface (see locale.h).
// Definition of locale_t.
//   Copyright (C) 2017-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// Definition of struct __locale_struct and __locale_t.
//   Copyright (C) 1997-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// POSIX.1-2008: the locale_t type, representing a locale context
//   (implementation-namespace version).  This type should be treated
//   as opaque by applications; some details are exposed for the sake of
//   efficiency in e.g. ctype functions.

type __locale_struct = struct {
	F__locales       [13]uintptr
	F__ctype_b       uintptr
	F__ctype_tolower uintptr
	F__ctype_toupper uintptr
	F__names         [13]uintptr
}

type locale_t = uintptr /* locale_t.h:24:20 */

// The tag name of this struct is _G_fpos_t to preserve historic
//   C++ mangled names for functions taking fpos_t arguments.
//   That name should not be used in new code.
type _G_fpos_t = struct {
	F__pos   int64
	F__state struct {
		F__count int32
		F__value struct{ F__wch uint32 }
	}
}

// bits/types.h -- definitions of __*_t types underlying *_t types.
//   Copyright (C) 2002-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// The tag name of this struct is _G_fpos64_t to preserve historic
//   C++ mangled names for functions taking fpos_t and/or fpos64_t
//   arguments.  That name should not be used in new code.
type _G_fpos64_t = struct {
	F__pos   int64
	F__state struct {
		F__count int32
		F__value struct{ F__wch uint32 }
	}
}

type _IO_FILE = struct {
	F_flags          int32
	F_IO_read_ptr    uintptr
	F_IO_read_end    uintptr
	F_IO_read_base   uintptr
	F_IO_write_base  uintptr
	F_IO_write_ptr   uintptr
	F_IO_write_end   uintptr
	F_IO_buf_base    uintptr
	F_IO_buf_end     uintptr
	F_IO_save_base   uintptr
	F_IO_backup_base uintptr
	F_IO_save_end    uintptr
	F_markers        uintptr
	F_chain          uintptr
	F_fileno         int32
	F_flags2         int32
	F_old_offset     int64
	F_cur_column     uint16
	F_vtable_offset  int8
	F_shortbuf       [1]int8
	F_lock           uintptr
	F_offset         int64
	F_codecvt        uintptr
	F_wide_data      uintptr
	F_freeres_list   uintptr
	F_freeres_buf    uintptr
	F__pad5          size_t
	F_mode           int32
	F_unused2        [20]int8
}

// The opaque type of streams.  This is the definition used elsewhere.
type FILE = _IO_FILE /* FILE.h:7:25 */

// These macros are used by bits/stdio.h and internal headers.

// Many more flag bits are defined internally.

// Copyright (C) 1989-2018 Free Software Foundation, Inc.
//
//This file is part of GCC.
//
//GCC is free software; you can redistribute it and/or modify
//it under the terms of the GNU General Public License as published by
//the Free Software Foundation; either version 3, or (at your option)
//any later version.
//
//GCC is distributed in the hope that it will be useful,
//but WITHOUT ANY WARRANTY; without even the implied warranty of
//MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//GNU General Public License for more details.
//
//Under Section 7 of GPL version 3, you are granted additional
//permissions described in the GCC Runtime Library Exception, version
//3.1, as published by the Free Software Foundation.
//
//You should have received a copy of the GNU General Public License and
//a copy of the GCC Runtime Library Exception along with this program;
//see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
//<http://www.gnu.org/licenses/>.

// ISO C Standard:  7.15  Variable arguments  <stdarg.h>

type off_t = int64 /* stdio.h:63:17 */

type ssize_t = int64 /* stdio.h:77:19 */

// The type of the second argument to `fgetpos' and `fsetpos'.
type fpos_t = _G_fpos_t /* stdio.h:84:18 */

// If we are compiling with optimizing read this file.  It contains
//   several optimizing inline functions and macros.

type i64 = sqlite3_int64  /* sqlite3expert.c:20:23 */
type u64 = sqlite3_uint64 /* sqlite3expert.c:21:24 */

type IdxColumn1 = struct {
	FzName uintptr
	FzColl uintptr
	FiPk   int32
	_      [4]byte
}

type IdxColumn = IdxColumn1 /* sqlite3expert.c:23:26 */
type IdxConstraint1 = struct {
	FzColl  uintptr
	FbRange int32
	FiCol   int32
	FbFlag  int32
	FbDesc  int32
	FpNext  uintptr
	FpLink  uintptr
}

type IdxConstraint = IdxConstraint1 /* sqlite3expert.c:24:30 */
type IdxScan1 = struct {
	FpTab      uintptr
	FiDb       int32
	Fcovering  i64
	FpOrder    uintptr
	FpEq       uintptr
	FpRange    uintptr
	FpNextScan uintptr
}

type IdxScan = IdxScan1 /* sqlite3expert.c:25:24 */
type IdxStatement1 = struct {
	FiId   int32
	FzSql  uintptr
	FzIdx  uintptr
	FzEQP  uintptr
	FpNext uintptr
}

type IdxStatement = IdxStatement1 /* sqlite3expert.c:26:29 */
type IdxTable1 = struct {
	FnCol  int32
	FzName uintptr
	FaCol  uintptr
	FpNext uintptr
}

type IdxTable = IdxTable1 /* sqlite3expert.c:27:25 */
type IdxWrite1 = struct {
	FpTab  uintptr
	FeOp   int32
	FpNext uintptr
}

type IdxWrite = IdxWrite1 /* sqlite3expert.c:28:25 */

// A hash table for storing strings. With space for a payload string
// with each entry. Methods are:
//
//   idxHashInit()
//   idxHashClear()
//   idxHashAdd()
//   idxHashSearch()
type IdxHashEntry1 = struct {
	FzKey      uintptr
	FzVal      uintptr
	FzVal2     uintptr
	FpHashNext uintptr
	FpNext     uintptr
}

// A hash table for storing strings. With space for a payload string
// with each entry. Methods are:
//
//   idxHashInit()
//   idxHashClear()
//   idxHashAdd()
//   idxHashSearch()
type IdxHashEntry = IdxHashEntry1 /* sqlite3expert.c:120:29 */
type IdxHash1 = struct {
	FpFirst uintptr
	FaHash  [1023]uintptr
}

type IdxHash = IdxHash1 /* sqlite3expert.c:121:24 */

// Allocate and return nByte bytes of zeroed memory using sqlite3_malloc().
// If the allocation fails, set *pRc to SQLITE_NOMEM and return NULL.
func idxMalloc(tls *crt.TLS, pRc uintptr, nByte int32) uintptr { /* sqlite3expert.c:158:13: */
	var pRet uintptr
	if !(*(*int32)(unsafe.Pointer(pRc)) == 0) {
		crt.X__assert_fail(tls, ts /* "*pRc==0" */, ts+8 /* "testdata/sqlite-..." */, uint32(160), uintptr(unsafe.Pointer(&__func__)))
	}
	if !(nByte > 0) {
		crt.X__assert_fail(tls, ts+63 /* "nByte>0" */, ts+8 /* "testdata/sqlite-..." */, uint32(161), uintptr(unsafe.Pointer(&__func__)))
	}
	pRet = sqlite3.Xsqlite3_malloc(tls, nByte)
	if pRet != 0 {
		crt.Xmemset(tls, pRet, 0, uint64(nByte))
	} else {
		*(*int32)(unsafe.Pointer(pRc)) = 7
	}
	return pRet
}

var __func__ = *(*[10]int8)(unsafe.Pointer(ts + 71 /* "idxMalloc" */)) /* sqlite3expert.c:158:44 */

// Initialize an IdxHash hash table.
func idxHashInit(tls *crt.TLS, pHash uintptr) { /* sqlite3expert.c:174:13: */
	crt.Xmemset(tls, pHash, 0, uint64(unsafe.Sizeof(IdxHash{})))
}

// Reset an IdxHash hash table.
func idxHashClear(tls *crt.TLS, pHash uintptr) { /* sqlite3expert.c:181:13: */
	var i int32
	for i = 0; i < 1023; i++ {
		var pEntry uintptr
		var pNext uintptr
		for pEntry = *(*uintptr)(unsafe.Pointer((pHash + 8 /* &.aHash */) + uintptr(i)*8)); pEntry != 0; pEntry = pNext {
			pNext = (*IdxHashEntry)(unsafe.Pointer(pEntry)).FpHashNext
			sqlite3.Xsqlite3_free(tls, (*IdxHashEntry)(unsafe.Pointer(pEntry)).FzVal2)
			sqlite3.Xsqlite3_free(tls, pEntry)
		}
	}
	crt.Xmemset(tls, pHash, 0, uint64(unsafe.Sizeof(IdxHash{})))
}

// Return the index of the hash bucket that the string specified by the
// arguments to this function belongs.
func idxHashString(tls *crt.TLS, z uintptr, n int32) int32 { /* sqlite3expert.c:199:12: */
	var ret uint32 = uint32(0)
	var i int32
	for i = 0; i < n; i++ {
		ret = ret + ((ret << 3) + uint32((uint8(*(*int8)(unsafe.Pointer(z + uintptr(i)))))))
	}
	return (int32(ret % uint32(1023)))
}

// If zKey is already present in the hash table, return non-zero and do
// nothing. Otherwise, add an entry with key zKey and payload string zVal to
// the hash table passed as the second argument.
func idxHashAdd(tls *crt.TLS, pRc uintptr, pHash uintptr, zKey uintptr, zVal uintptr) int32 { /* sqlite3expert.c:213:12: */
	var nKey int32 = int32(crt.Xstrlen(tls, zKey))
	var iHash int32 = idxHashString(tls, zKey, nKey)
	var nVal int32 = func() int32 {
		if zVal != 0 {
			return int32(crt.Xstrlen(tls, zVal))
		}
		return 0
	}()
	var pEntry uintptr
	if !(iHash >= 0) {
		crt.X__assert_fail(tls, ts+81 /* "iHash>=0" */, ts+8 /* "testdata/sqlite-..." */, uint32(223), uintptr(unsafe.Pointer(&__func__1)))
	}
	for pEntry = *(*uintptr)(unsafe.Pointer((pHash + 8 /* &.aHash */) + uintptr(iHash)*8)); pEntry != 0; pEntry = (*IdxHashEntry)(unsafe.Pointer(pEntry)).FpHashNext {
		if (int32(crt.Xstrlen(tls, (*IdxHashEntry)(unsafe.Pointer(pEntry)).FzKey)) == nKey) && (0 == crt.Xmemcmp(tls, (*IdxHashEntry)(unsafe.Pointer(pEntry)).FzKey, zKey, uint64(nKey))) {
			return 1
		}
	}
	pEntry = idxMalloc(tls, pRc, (int32((((uint64(unsafe.Sizeof(IdxHashEntry{})) + uint64(nKey)) + uint64(1)) + uint64(nVal)) + uint64(1))))
	if pEntry != 0 {
		(*IdxHashEntry)(unsafe.Pointer(pEntry)).FzKey = (pEntry + uintptr(1)*40)
		crt.Xmemcpy(tls, (*IdxHashEntry)(unsafe.Pointer(pEntry)).FzKey, zKey, uint64(nKey))
		if zVal != 0 {
			(*IdxHashEntry)(unsafe.Pointer(pEntry)).FzVal = ((*IdxHashEntry)(unsafe.Pointer(pEntry)).FzKey + uintptr((nKey + 1)))
			crt.Xmemcpy(tls, (*IdxHashEntry)(unsafe.Pointer(pEntry)).FzVal, zVal, uint64(nVal))
		}
		(*IdxHashEntry)(unsafe.Pointer(pEntry)).FpHashNext = *(*uintptr)(unsafe.Pointer((pHash + 8 /* &.aHash */) + uintptr(iHash)*8))
		*(*uintptr)(unsafe.Pointer((pHash + 8 /* &.aHash */) + uintptr(iHash)*8)) = pEntry

		(*IdxHashEntry)(unsafe.Pointer(pEntry)).FpNext = (*IdxHash)(unsafe.Pointer(pHash)).FpFirst
		(*IdxHash)(unsafe.Pointer(pHash)).FpFirst = pEntry
	}
	return 0
}

var __func__1 = *(*[11]int8)(unsafe.Pointer(ts + 90 /* "idxHashAdd" */)) /* sqlite3expert.c:218:2 */

// If zKey/nKey is present in the hash table, return a pointer to the
// hash-entry object.
func idxHashFind(tls *crt.TLS, pHash uintptr, zKey uintptr, nKey int32) uintptr { /* sqlite3expert.c:250:21: */
	var iHash int32
	var pEntry uintptr
	if nKey < 0 {
		nKey = int32(crt.Xstrlen(tls, zKey))
	}
	iHash = idxHashString(tls, zKey, nKey)
	if !(iHash >= 0) {
		crt.X__assert_fail(tls, ts+81 /* "iHash>=0" */, ts+8 /* "testdata/sqlite-..." */, uint32(255), uintptr(unsafe.Pointer(&__func__2)))
	}
	for pEntry = *(*uintptr)(unsafe.Pointer((pHash + 8 /* &.aHash */) + uintptr(iHash)*8)); pEntry != 0; pEntry = (*IdxHashEntry)(unsafe.Pointer(pEntry)).FpHashNext {
		if (int32(crt.Xstrlen(tls, (*IdxHashEntry)(unsafe.Pointer(pEntry)).FzKey)) == nKey) && (0 == crt.Xmemcmp(tls, (*IdxHashEntry)(unsafe.Pointer(pEntry)).FzKey, zKey, uint64(nKey))) {
			return pEntry
		}
	}
	return uintptr(0)
}

var __func__2 = *(*[12]int8)(unsafe.Pointer(ts + 101 /* "idxHashFind" */)) /* sqlite3expert.c:250:77 */

// If the hash table contains an entry with a key equal to the string
// passed as the final two arguments to this function, return a pointer
// to the payload string. Otherwise, if zKey/nKey is not present in the
// hash table, return NULL.
func idxHashSearch(tls *crt.TLS, pHash uintptr, zKey uintptr, nKey int32) uintptr { /* sqlite3expert.c:270:19: */
	var pEntry uintptr = idxHashFind(tls, pHash, zKey, nKey)
	if pEntry != 0 {
		return (*IdxHashEntry)(unsafe.Pointer(pEntry)).FzVal
	}
	return uintptr(0)
}

// Allocate and return a new IdxConstraint object. Set the IdxConstraint.zColl
// variable to point to a copy of nul-terminated string zColl.
func idxNewConstraint(tls *crt.TLS, pRc uintptr, zColl uintptr) uintptr { /* sqlite3expert.c:280:22: */
	var pNew uintptr
	var nColl int32 = int32(crt.Xstrlen(tls, zColl))

	if !(*(*int32)(unsafe.Pointer(pRc)) == 0) {
		crt.X__assert_fail(tls, ts /* "*pRc==0" */, ts+8 /* "testdata/sqlite-..." */, uint32(284), uintptr(unsafe.Pointer(&__func__3)))
	}
	pNew = idxMalloc(tls, pRc, (int32((uint64(unsafe.Sizeof(IdxConstraint{})) * uint64(nColl)) + uint64(1))))
	if pNew != 0 {
		(*IdxConstraint)(unsafe.Pointer(pNew)).FzColl = (pNew + uintptr(1)*40)
		crt.Xmemcpy(tls, (*IdxConstraint)(unsafe.Pointer(pNew)).FzColl, zColl, (uint64(nColl + 1)))
	}
	return pNew
}

var __func__3 = *(*[17]int8)(unsafe.Pointer(ts + 113 /* "idxNewConstraint" */)) /* sqlite3expert.c:280:68 */

// An error associated with database handle db has just occurred. Pass
// the error message to callback function xOut.
func idxDatabaseError(tls *crt.TLS, db uintptr, pzErrmsg uintptr) { /* sqlite3expert.c:297:13: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	*(*uintptr)(unsafe.Pointer(pzErrmsg)) = sqlite3.Xsqlite3_mprintf(tls, ts+130 /* "%s" */, crt.VaList(bp, sqlite3.Xsqlite3_errmsg(tls, db)))
}

// Prepare an SQL statement.
func idxPrepareStmt(tls *crt.TLS, db uintptr, ppStmt uintptr, pzErrmsg uintptr, zSql uintptr) int32 { /* sqlite3expert.c:307:12: */
	var rc int32 = sqlite3.Xsqlite3_prepare_v2(tls, db, zSql, -1, ppStmt, uintptr(0))
	if rc != 0 {
		*(*uintptr)(unsafe.Pointer(ppStmt)) = uintptr(0)
		idxDatabaseError(tls, db, pzErrmsg)
	}
	return rc
}

// Prepare an SQL statement using the results of a printf() formatting.
func idxPrintfPrepareStmt(tls *crt.TLS, db uintptr, ppStmt uintptr, pzErrmsg uintptr, zFmt uintptr, va uintptr) int32 { /* sqlite3expert.c:324:12: */
	var ap va_list
	_ = ap
	var rc int32
	var zSql uintptr
	ap = va
	zSql = sqlite3.Xsqlite3_vmprintf(tls, zFmt, ap)
	if zSql == uintptr(0) {
		rc = 7
	} else {
		rc = idxPrepareStmt(tls, db, ppStmt, pzErrmsg, zSql)
		sqlite3.Xsqlite3_free(tls, zSql)
	}
	_ = ap
	return rc
}

// ************************************************************************
//
// Beginning of virtual table implementation.
type ExpertVtab1 = struct {
	Fbase    sqlite3_vtab
	FpTab    uintptr
	FpExpert uintptr
}

// ************************************************************************
//
// Beginning of virtual table implementation.
type ExpertVtab = ExpertVtab1 /* sqlite3expert.c:350:27 */

type ExpertCsr1 = struct {
	Fbase  sqlite3_vtab_cursor
	FpData uintptr
}

type ExpertCsr = ExpertCsr1 /* sqlite3expert.c:357:26 */

func expertDequote(tls *crt.TLS, zIn uintptr) uintptr { /* sqlite3expert.c:363:13: */
	var n int32 = int32(crt.Xstrlen(tls, zIn))
	var zRet uintptr = sqlite3.Xsqlite3_malloc(tls, n)

	if !(int32(*(*int8)(unsafe.Pointer(zIn + uintptr(0)))) == '\'') {
		crt.X__assert_fail(tls, ts+133 /* "zIn[0]=='\\''" */, ts+8 /* "testdata/sqlite-..." */, uint32(367), uintptr(unsafe.Pointer(&__func__4)))
	}
	if !(int32(*(*int8)(unsafe.Pointer(zIn + uintptr((n - 1))))) == '\'') {
		crt.X__assert_fail(tls, ts+146 /* "zIn[n-1]=='\\''" */, ts+8 /* "testdata/sqlite-..." */, uint32(368), uintptr(unsafe.Pointer(&__func__4)))
	}

	if zRet != 0 {
		var iOut int32 = 0
		var iIn int32 = 0
		for iIn = 1; iIn < (n - 1); iIn++ {
			if int32(*(*int8)(unsafe.Pointer(zIn + uintptr(iIn)))) == '\'' {
				if !(int32(*(*int8)(unsafe.Pointer(zIn + uintptr((iIn + 1))))) == '\'') {
					crt.X__assert_fail(tls, ts+161 /* "zIn[iIn+1]=='\\''" */, ts+8 /* "testdata/sqlite-..." */, uint32(375), uintptr(unsafe.Pointer(&__func__4)))
				}
				iIn++
			}
			*(*int8)(unsafe.Pointer(zRet + uintptr(crt.PostIncInt32(&iOut, 1)))) = *(*int8)(unsafe.Pointer(zIn + uintptr(iIn)))
		}
		*(*int8)(unsafe.Pointer(zRet + uintptr(iOut))) = int8(0)
	}

	return zRet
}

var __func__4 = *(*[14]int8)(unsafe.Pointer(ts + 178 /* "expertDequote" */)) /* sqlite3expert.c:363:44 */

// This function is the implementation of both the xConnect and xCreate
// methods of the r-tree virtual table.
//
//   argv[0]   -> module name
//   argv[1]   -> database name
//   argv[2]   -> table name
//   argv[...] -> column names...
func expertConnect(tls *crt.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVtab uintptr, pzErr uintptr) int32 { /* sqlite3expert.c:395:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var pExpert uintptr = pAux
	var p uintptr = uintptr(0)
	// var rc int32 at bp, 4

	if argc != 4 {
		*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+192 /* "internal error!" */, 0)
		*(*int32)(unsafe.Pointer(bp /* rc */)) = 1
	} else {
		var zCreateTable uintptr = expertDequote(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(3)*8)))
		if zCreateTable != 0 {
			*(*int32)(unsafe.Pointer(bp /* rc */)) = sqlite3.Xsqlite3_declare_vtab(tls, db, zCreateTable)
			if *(*int32)(unsafe.Pointer(bp /* rc */)) == 0 {
				p = idxMalloc(tls, bp /* &rc */, int32(unsafe.Sizeof(ExpertVtab{})))
			}
			if *(*int32)(unsafe.Pointer(bp /* rc */)) == 0 {
				(*ExpertVtab)(unsafe.Pointer(p)).FpExpert = pExpert
				(*ExpertVtab)(unsafe.Pointer(p)).FpTab = (*sqlite3expert)(unsafe.Pointer(pExpert)).FpTable
				if !(sqlite3.Xsqlite3_stricmp(tls, (*IdxTable)(unsafe.Pointer((*ExpertVtab)(unsafe.Pointer(p)).FpTab)).FzName, *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8))) == 0) {
					crt.X__assert_fail(tls, ts+208 /* "sqlite3_stricmp(..." */, ts+8 /* "testdata/sqlite-..." */, uint32(419), uintptr(unsafe.Pointer(&__func__5)))
				}
			}
			sqlite3.Xsqlite3_free(tls, zCreateTable)
		} else {
			*(*int32)(unsafe.Pointer(bp /* rc */)) = 7
		}
	}

	*(*uintptr)(unsafe.Pointer(ppVtab)) = p
	return *(*int32)(unsafe.Pointer(bp /* rc */))
}

var __func__5 = *(*[14]int8)(unsafe.Pointer(ts + 252 /* "expertConnect" */)) /* sqlite3expert.c:401:2 */

func expertDisconnect(tls *crt.TLS, pVtab uintptr) int32 { /* sqlite3expert.c:431:12: */
	var p uintptr = pVtab
	sqlite3.Xsqlite3_free(tls, p)
	return 0
}

func expertBestIndex(tls *crt.TLS, pVtab uintptr, pIdxInfo uintptr) int32 { /* sqlite3expert.c:437:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var p uintptr = pVtab
	*(*int32)(unsafe.Pointer(bp /* rc */)) = 0
	var n int32 = 0
	var pScan uintptr
	var opmask int32 = ((((2 | 4) | 16) | 32) | 8)

	pScan = idxMalloc(tls, bp /* &rc */, int32(unsafe.Sizeof(IdxScan{})))
	if pScan != 0 {
		var i int32

		// Link the new scan object into the list
		(*IdxScan)(unsafe.Pointer(pScan)).FpTab = (*ExpertVtab)(unsafe.Pointer(p)).FpTab
		(*IdxScan)(unsafe.Pointer(pScan)).FpNextScan = (*sqlite3expert)(unsafe.Pointer((*ExpertVtab)(unsafe.Pointer(p)).FpExpert)).FpScan
		(*sqlite3expert)(unsafe.Pointer((*ExpertVtab)(unsafe.Pointer(p)).FpExpert)).FpScan = pScan

		// Add the constraints to the IdxScan object
		for i = 0; i < (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnConstraint; i++ {
			var pCons uintptr = ((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraint + uintptr(i)*12)
			if ((((*sqlite3_index_constraint)(unsafe.Pointer(pCons)).Fusable != 0) &&
				((*sqlite3_index_constraint)(unsafe.Pointer(pCons)).FiColumn >= 0)) &&
				((*IdxColumn)(unsafe.Pointer((*IdxTable)(unsafe.Pointer((*ExpertVtab)(unsafe.Pointer(p)).FpTab)).FaCol+uintptr((*sqlite3_index_constraint)(unsafe.Pointer(pCons)).FiColumn)*24)).FiPk == 0)) &&
				((int32((*sqlite3_index_constraint)(unsafe.Pointer(pCons)).Fop) & opmask) != 0) {
				var pNew uintptr
				var zColl uintptr = sqlite3.Xsqlite3_vtab_collation(tls, pIdxInfo, i)
				pNew = idxNewConstraint(tls, bp /* &rc */, zColl)
				if pNew != 0 {
					(*IdxConstraint)(unsafe.Pointer(pNew)).FiCol = (*sqlite3_index_constraint)(unsafe.Pointer(pCons)).FiColumn
					if int32((*sqlite3_index_constraint)(unsafe.Pointer(pCons)).Fop) == 2 {
						(*IdxConstraint)(unsafe.Pointer(pNew)).FpNext = (*IdxScan)(unsafe.Pointer(pScan)).FpEq
						(*IdxScan)(unsafe.Pointer(pScan)).FpEq = pNew
					} else {
						(*IdxConstraint)(unsafe.Pointer(pNew)).FbRange = 1
						(*IdxConstraint)(unsafe.Pointer(pNew)).FpNext = (*IdxScan)(unsafe.Pointer(pScan)).FpRange
						(*IdxScan)(unsafe.Pointer(pScan)).FpRange = pNew
					}
				}
				n++
				(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(i)*8)).FargvIndex = n
			}
		}

		// Add the ORDER BY to the IdxScan object
		for i = ((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnOrderBy - 1); i >= 0; i-- {
			var iCol int32 = (*sqlite3_index_orderby)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaOrderBy + uintptr(i)*8)).FiColumn
			if iCol >= 0 {
				var pNew uintptr = idxNewConstraint(tls, bp /* &rc */, (*IdxColumn)(unsafe.Pointer((*IdxTable)(unsafe.Pointer((*ExpertVtab)(unsafe.Pointer(p)).FpTab)).FaCol+uintptr(iCol)*24)).FzColl)
				if pNew != 0 {
					(*IdxConstraint)(unsafe.Pointer(pNew)).FiCol = iCol
					(*IdxConstraint)(unsafe.Pointer(pNew)).FbDesc = int32((*sqlite3_index_orderby)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaOrderBy + uintptr(i)*8)).Fdesc)
					(*IdxConstraint)(unsafe.Pointer(pNew)).FpNext = (*IdxScan)(unsafe.Pointer(pScan)).FpOrder
					(*IdxConstraint)(unsafe.Pointer(pNew)).FpLink = (*IdxScan)(unsafe.Pointer(pScan)).FpOrder
					(*IdxScan)(unsafe.Pointer(pScan)).FpOrder = pNew
					n++
				}
			}
		}
	}

	(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = (1000000.0 / (float64(n + 1)))
	return *(*int32)(unsafe.Pointer(bp /* rc */))
}

func expertUpdate(tls *crt.TLS, pVtab uintptr, nData int32, azData uintptr, pRowid uintptr) int32 { /* sqlite3expert.c:504:12: */
	_ = pVtab
	_ = nData
	_ = azData
	_ = pRowid
	return 0
}

// Virtual table module xOpen method.
func expertOpen(tls *crt.TLS, pVTab uintptr, ppCursor uintptr) int32 { /* sqlite3expert.c:520:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	*(*int32)(unsafe.Pointer(bp /* rc */)) = 0
	var pCsr uintptr
	_ = pVTab
	pCsr = idxMalloc(tls, bp /* &rc */, int32(unsafe.Sizeof(ExpertCsr{})))
	*(*uintptr)(unsafe.Pointer(ppCursor)) = pCsr
	return *(*int32)(unsafe.Pointer(bp /* rc */))
}

// Virtual table module xClose method.
func expertClose(tls *crt.TLS, cur uintptr) int32 { /* sqlite3expert.c:532:12: */
	var pCsr uintptr = cur
	sqlite3.Xsqlite3_finalize(tls, (*ExpertCsr)(unsafe.Pointer(pCsr)).FpData)
	sqlite3.Xsqlite3_free(tls, pCsr)
	return 0
}

// Virtual table module xEof method.
//
// Return non-zero if the cursor does not currently point to a valid
// record (i.e if the scan has finished), or zero otherwise.
func expertEof(tls *crt.TLS, cur uintptr) int32 { /* sqlite3expert.c:545:12: */
	var pCsr uintptr = cur
	return (crt.Bool32((*ExpertCsr)(unsafe.Pointer(pCsr)).FpData == uintptr(0)))
}

// Virtual table module xNext method.
func expertNext(tls *crt.TLS, cur uintptr) int32 { /* sqlite3expert.c:553:12: */
	var pCsr uintptr = cur
	var rc int32 = 0

	if !((*ExpertCsr)(unsafe.Pointer(pCsr)).FpData != 0) {
		crt.X__assert_fail(tls, ts+266 /* "pCsr->pData" */, ts+8 /* "testdata/sqlite-..." */, uint32(557), uintptr(unsafe.Pointer(&__func__6)))
	}
	rc = sqlite3.Xsqlite3_step(tls, (*ExpertCsr)(unsafe.Pointer(pCsr)).FpData)
	if rc != 100 {
		rc = sqlite3.Xsqlite3_finalize(tls, (*ExpertCsr)(unsafe.Pointer(pCsr)).FpData)
		(*ExpertCsr)(unsafe.Pointer(pCsr)).FpData = uintptr(0)
	} else {
		rc = 0
	}

	return rc
}

var __func__6 = *(*[11]int8)(unsafe.Pointer(ts + 278 /* "expertNext" */)) /* sqlite3expert.c:553:48 */

// Virtual table module xRowid method.
func expertRowid(tls *crt.TLS, cur uintptr, pRowid uintptr) int32 { /* sqlite3expert.c:572:12: */
	_ = cur
	*(*sqlite_int64)(unsafe.Pointer(pRowid)) = int64(0)
	return 0
}

// Virtual table module xColumn method.
func expertColumn(tls *crt.TLS, cur uintptr, ctx uintptr, i int32) int32 { /* sqlite3expert.c:581:12: */
	var pCsr uintptr = cur
	var pVal uintptr
	pVal = sqlite3.Xsqlite3_column_value(tls, (*ExpertCsr)(unsafe.Pointer(pCsr)).FpData, i)
	if pVal != 0 {
		sqlite3.Xsqlite3_result_value(tls, ctx, pVal)
	}
	return 0
}

// Virtual table module xFilter method.
func expertFilter(tls *crt.TLS, cur uintptr, idxNum int32, idxStr uintptr, argc int32, argv uintptr) int32 { /* sqlite3expert.c:594:12: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var pCsr uintptr = cur
	var pVtab uintptr = (*sqlite3_vtab_cursor)(unsafe.Pointer(cur)).FpVtab
	var pExpert uintptr = (*ExpertVtab)(unsafe.Pointer(pVtab)).FpExpert
	var rc int32

	_ = idxNum
	_ = idxStr
	_ = argc
	_ = argv
	rc = sqlite3.Xsqlite3_finalize(tls, (*ExpertCsr)(unsafe.Pointer(pCsr)).FpData)
	(*ExpertCsr)(unsafe.Pointer(pCsr)).FpData = uintptr(0)
	if rc == 0 {
		rc = idxPrintfPrepareStmt(tls, (*sqlite3expert)(unsafe.Pointer(pExpert)).Fdb, (pCsr + 8 /* &.pData */), (pVtab /* &.base */ + 16 /* &.zErrMsg */),
			ts+289 /* "SELECT * FROM ma..." */, crt.VaList(bp, (*IdxTable)(unsafe.Pointer((*ExpertVtab)(unsafe.Pointer(pVtab)).FpTab)).FzName))
	}

	if rc == 0 {
		rc = expertNext(tls, cur)
	}
	return rc
}

func idxRegisterVtab(tls *crt.TLS, p uintptr) int32 { /* sqlite3expert.c:622:12: */

	return sqlite3.Xsqlite3_create_module(tls, (*sqlite3expert)(unsafe.Pointer(p)).Fdbv, ts+326 /* "expert" */, uintptr(unsafe.Pointer(&expertModule)), p)
}

var expertModule = sqlite3_module{FiVersion: 2, FxCreate: // iVersion
0, FxConnect:// xCreate - create a table
0, FxBestIndex:// xConnect - connect to an existing table
0, FxDisconnect:// xBestIndex - Determine search strategy
0, FxDestroy:// xDisconnect - Disconnect from a table
0, FxOpen:// xDestroy - Drop a table
0, FxClose:// xOpen - open a cursor
0, FxFilter:// xClose - close a cursor
0, FxNext:// xFilter - configure scan constraints
0, FxEof:// xNext - advance a cursor
0, FxColumn:// xEof
0, FxRowid:// xColumn - read data
0, FxUpdate:// xRowid - read data
0, FxBegin:// xUpdate - write data
uintptr(0), FxSync:// xBegin - begin transaction
uintptr(0), FxCommit:// xSync - sync transaction
uintptr(0), FxRollback:// xCommit - commit transaction
uintptr(0), FxFindFunction:// xRollback - rollback transaction
uintptr(0), FxRename:// xFindFunction - function overloading
uintptr(0), FxSavepoint:// xRename - rename the table
uintptr(0), FxRelease:// xSavepoint
uintptr(0), FxRollbackTo:// xRelease
uintptr(0), FxShadowName:// xRollbackTo
uintptr(0), // xShadowName
} /* sqlite3expert.c:623:25 */
//
// End of virtual table implementation.
//
// Finalize SQL statement pStmt. If (*pRc) is SQLITE_OK when this function
// is called, set it to the return value of sqlite3_finalize() before
// returning. Otherwise, discard the sqlite3_finalize() return value.
func idxFinalize(tls *crt.TLS, pRc uintptr, pStmt uintptr) { /* sqlite3expert.c:660:13: */
	var rc int32 = sqlite3.Xsqlite3_finalize(tls, pStmt)
	if *(*int32)(unsafe.Pointer(pRc)) == 0 {
		*(*int32)(unsafe.Pointer(pRc)) = rc
	}
}

// Attempt to allocate an IdxTable structure corresponding to table zTab
// in the main database of connection db. If successful, set (*ppOut) to
// point to the new object and return SQLITE_OK. Otherwise, return an
// SQLite error code and set (*ppOut) to NULL. In this case *pzErrmsg may be
// set to point to an error string.
//
// It is the responsibility of the caller to eventually free either the
// IdxTable object or error message using sqlite3_free().
func idxGetTableInfo(tls *crt.TLS, db uintptr, zTab uintptr, ppOut uintptr, pzErrmsg uintptr) int32 { /* sqlite3expert.c:675:12: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	*(*uintptr)(unsafe.Pointer(bp + 8 /* p1 */)) = uintptr(0)
	var nCol int32 = 0
	var nTab int32 = int32(crt.Xstrlen(tls, zTab))
	var nByte int32 = (int32((uint64(unsafe.Sizeof(IdxTable{})) + uint64(nTab)) + uint64(1)))
	var pNew uintptr = uintptr(0)
	// var rc int32 at bp+24, 4

	var rc2 int32
	var pCsr uintptr = uintptr(0)

	*(*int32)(unsafe.Pointer(bp + 24 /* rc */)) = idxPrintfPrepareStmt(tls, db, bp+8 /* &p1 */, pzErrmsg, ts+333 /* "PRAGMA table_inf..." */, crt.VaList(bp, zTab))
	for (*(*int32)(unsafe.Pointer(bp + 24 /* rc */)) == 0) && (100 == sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 8 /* p1 */)))) {
		*(*uintptr)(unsafe.Pointer(bp + 16 /* zCol */)) = sqlite3.Xsqlite3_column_text(tls, *(*uintptr)(unsafe.Pointer(bp + 8 /* p1 */)), 1)
		nByte = nByte + (1 + int32(crt.Xstrlen(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* zCol */)))))
		*(*int32)(unsafe.Pointer(bp + 24 /* rc */)) = sqlite3.Xsqlite3_table_column_metadata(tls,
			db, ts+354 /* "main" */, zTab, *(*uintptr)(unsafe.Pointer(bp + 16 /* zCol */)), uintptr(0), bp+16 /* &zCol */, uintptr(0), uintptr(0), uintptr(0))
		nByte = nByte + (1 + int32(crt.Xstrlen(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* zCol */)))))
		nCol++
	}
	rc2 = sqlite3.Xsqlite3_reset(tls, *(*uintptr)(unsafe.Pointer(bp + 8 /* p1 */)))
	if *(*int32)(unsafe.Pointer(bp + 24 /* rc */)) == 0 {
		*(*int32)(unsafe.Pointer(bp + 24 /* rc */)) = rc2
	}

	nByte = int32(uint64(nByte) + (uint64(unsafe.Sizeof(IdxColumn{})) * uint64(nCol)))
	if *(*int32)(unsafe.Pointer(bp + 24 /* rc */)) == 0 {
		pNew = idxMalloc(tls, bp+24 /* &rc */, nByte)
	}
	if *(*int32)(unsafe.Pointer(bp + 24 /* rc */)) == 0 {
		(*IdxTable)(unsafe.Pointer(pNew)).FaCol = (pNew + uintptr(1)*32)
		(*IdxTable)(unsafe.Pointer(pNew)).FnCol = nCol
		pCsr = ((*IdxTable)(unsafe.Pointer(pNew)).FaCol + uintptr(nCol)*24)
	}

	nCol = 0
	for (*(*int32)(unsafe.Pointer(bp + 24 /* rc */)) == 0) && (100 == sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 8 /* p1 */)))) {
		*(*uintptr)(unsafe.Pointer(bp + 32 /* zCol */)) = sqlite3.Xsqlite3_column_text(tls, *(*uintptr)(unsafe.Pointer(bp + 8 /* p1 */)), 1)
		var nCopy int32 = (int32(crt.Xstrlen(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* zCol */)))) + 1)
		(*IdxColumn)(unsafe.Pointer((*IdxTable)(unsafe.Pointer(pNew)).FaCol + uintptr(nCol)*24)).FzName = pCsr
		(*IdxColumn)(unsafe.Pointer((*IdxTable)(unsafe.Pointer(pNew)).FaCol + uintptr(nCol)*24)).FiPk = sqlite3.Xsqlite3_column_int(tls, *(*uintptr)(unsafe.Pointer(bp + 8 /* p1 */)), 5)
		crt.Xmemcpy(tls, pCsr, *(*uintptr)(unsafe.Pointer(bp + 32 /* zCol */)), uint64(nCopy))
		pCsr += uintptr(nCopy)

		*(*int32)(unsafe.Pointer(bp + 24 /* rc */)) = sqlite3.Xsqlite3_table_column_metadata(tls,
			db, ts+354 /* "main" */, zTab, *(*uintptr)(unsafe.Pointer(bp + 32 /* zCol */)), uintptr(0), bp+32 /* &zCol */, uintptr(0), uintptr(0), uintptr(0))
		if *(*int32)(unsafe.Pointer(bp + 24 /* rc */)) == 0 {
			nCopy = (int32(crt.Xstrlen(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* zCol */)))) + 1)
			(*IdxColumn)(unsafe.Pointer((*IdxTable)(unsafe.Pointer(pNew)).FaCol + uintptr(nCol)*24)).FzColl = pCsr
			crt.Xmemcpy(tls, pCsr, *(*uintptr)(unsafe.Pointer(bp + 32 /* zCol */)), uint64(nCopy))
			pCsr += uintptr(nCopy)
		}

		nCol++
	}
	idxFinalize(tls, bp+24 /* &rc */, *(*uintptr)(unsafe.Pointer(bp + 8 /* p1 */)))

	if *(*int32)(unsafe.Pointer(bp + 24 /* rc */)) != 0 {
		sqlite3.Xsqlite3_free(tls, pNew)
		pNew = uintptr(0)
	} else {
		(*IdxTable)(unsafe.Pointer(pNew)).FzName = pCsr
		crt.Xmemcpy(tls, (*IdxTable)(unsafe.Pointer(pNew)).FzName, zTab, (uint64(nTab + 1)))
	}

	*(*uintptr)(unsafe.Pointer(ppOut)) = pNew
	return *(*int32)(unsafe.Pointer(bp + 24 /* rc */))
}

// This function is a no-op if *pRc is set to anything other than
// SQLITE_OK when it is called.
//
// If *pRc is initially set to SQLITE_OK, then the text specified by
// the printf() style arguments is appended to zIn and the result returned
// in a buffer allocated by sqlite3_malloc(). sqlite3_free() is called on
// zIn before returning.
func idxAppendText(tls *crt.TLS, pRc uintptr, zIn uintptr, zFmt uintptr, va uintptr) uintptr { /* sqlite3expert.c:756:13: */
	var ap va_list
	_ = ap
	var zAppend uintptr = uintptr(0)
	var zRet uintptr = uintptr(0)
	var nIn int32
	if zIn != 0 {
		nIn = int32(crt.Xstrlen(tls, zIn))
	} else {
		nIn = 0
	}
	var nAppend int32 = 0
	ap = va
	if *(*int32)(unsafe.Pointer(pRc)) == 0 {
		zAppend = sqlite3.Xsqlite3_vmprintf(tls, zFmt, ap)
		if zAppend != 0 {
			nAppend = int32(crt.Xstrlen(tls, zAppend))
			zRet = sqlite3.Xsqlite3_malloc(tls, ((nIn + nAppend) + 1))
		}
		if (zAppend != 0) && (zRet != 0) {
			if nIn != 0 {
				crt.Xmemcpy(tls, zRet, zIn, uint64(nIn))
			}
			crt.Xmemcpy(tls, (zRet + uintptr(nIn)), zAppend, (uint64(nAppend + 1)))
		} else {
			sqlite3.Xsqlite3_free(tls, zRet)
			zRet = uintptr(0)
			*(*int32)(unsafe.Pointer(pRc)) = 7
		}
		sqlite3.Xsqlite3_free(tls, zAppend)
		sqlite3.Xsqlite3_free(tls, zIn)
	}
	_ = ap
	return zRet
}

// Return true if zId must be quoted in order to use it as an SQL
// identifier, or false otherwise.
func idxIdentifierRequiresQuotes(tls *crt.TLS, zId uintptr) int32 { /* sqlite3expert.c:788:12: */
	var i int32
	for i = 0; *(*int8)(unsafe.Pointer(zId + uintptr(i))) != 0; i++ {
		if ((!(int32(*(*int8)(unsafe.Pointer(zId + uintptr(i)))) == '_') &&
			!((int32(*(*int8)(unsafe.Pointer(zId + uintptr(i)))) >= '0') && (int32(*(*int8)(unsafe.Pointer(zId + uintptr(i)))) <= '9'))) &&
			!((int32(*(*int8)(unsafe.Pointer(zId + uintptr(i)))) >= 'a') && (int32(*(*int8)(unsafe.Pointer(zId + uintptr(i)))) <= 'z'))) &&
			!((int32(*(*int8)(unsafe.Pointer(zId + uintptr(i)))) >= 'A') && (int32(*(*int8)(unsafe.Pointer(zId + uintptr(i)))) <= 'Z')) {
			return 1
		}
	}
	return 0
}

// This function appends an index column definition suitable for constraint
// pCons to the string passed as zIn and returns the result.
func idxAppendColDefn(tls *crt.TLS, pRc uintptr, zIn uintptr, pTab uintptr, pCons uintptr) uintptr { /* sqlite3expert.c:806:13: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var zRet uintptr = zIn
	var p uintptr = ((*IdxTable)(unsafe.Pointer(pTab)).FaCol + uintptr((*IdxConstraint)(unsafe.Pointer(pCons)).FiCol)*24)
	if zRet != 0 {
		zRet = idxAppendText(tls, pRc, zRet, ts+359 /* ", " */, 0)
	}

	if idxIdentifierRequiresQuotes(tls, (*IdxColumn)(unsafe.Pointer(p)).FzName) != 0 {
		zRet = idxAppendText(tls, pRc, zRet, ts+362 /* "%Q" */, crt.VaList(bp, (*IdxColumn)(unsafe.Pointer(p)).FzName))
	} else {
		zRet = idxAppendText(tls, pRc, zRet, ts+130 /* "%s" */, crt.VaList(bp+8, (*IdxColumn)(unsafe.Pointer(p)).FzName))
	}

	if sqlite3.Xsqlite3_stricmp(tls, (*IdxColumn)(unsafe.Pointer(p)).FzColl, (*IdxConstraint)(unsafe.Pointer(pCons)).FzColl) != 0 {
		if idxIdentifierRequiresQuotes(tls, (*IdxConstraint)(unsafe.Pointer(pCons)).FzColl) != 0 {
			zRet = idxAppendText(tls, pRc, zRet, ts+365 /* " COLLATE %Q" */, crt.VaList(bp+16, (*IdxConstraint)(unsafe.Pointer(pCons)).FzColl))
		} else {
			zRet = idxAppendText(tls, pRc, zRet, ts+377 /* " COLLATE %s" */, crt.VaList(bp+24, (*IdxConstraint)(unsafe.Pointer(pCons)).FzColl))
		}
	}

	if (*IdxConstraint)(unsafe.Pointer(pCons)).FbDesc != 0 {
		zRet = idxAppendText(tls, pRc, zRet, ts+389 /* " DESC" */, 0)
	}
	return zRet
}

// Search database dbm for an index compatible with the one idxCreateFromCons()
// would create from arguments pScan, pEq and pTail. If no error occurs and
// such an index is found, return non-zero. Or, if no such index is found,
// return zero.
//
// If an error occurs, set *pRc to an SQLite error code and return zero.
func idxFindCompatible(tls *crt.TLS, pRc uintptr, dbm uintptr, pScan uintptr, pEq uintptr, pTail uintptr) int32 { /* sqlite3expert.c:844:12: */
	bp := tls.Alloc(36)
	defer tls.Free(36)

	var zTbl uintptr = (*IdxTable)(unsafe.Pointer((*IdxScan)(unsafe.Pointer(pScan)).FpTab)).FzName
	*(*uintptr)(unsafe.Pointer(bp + 16 /* pIdxList */)) = uintptr(0)
	var pIter uintptr
	var nEq int32 = 0 // Number of elements in pEq
	// var rc int32 at bp+32, 4

	// Count the elements in list pEq
	for pIter = pEq; pIter != 0; pIter = (*IdxConstraint)(unsafe.Pointer(pIter)).FpLink {
		nEq++
	}

	*(*int32)(unsafe.Pointer(bp + 32 /* rc */)) = idxPrintfPrepareStmt(tls, dbm, bp+16 /* &pIdxList */, uintptr(0), ts+395 /* "PRAGMA index_lis..." */, crt.VaList(bp, zTbl))
	for (*(*int32)(unsafe.Pointer(bp + 32 /* rc */)) == 0) && (sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* pIdxList */))) == 100) {
		var bMatch int32 = 1
		var pT uintptr = pTail
		*(*uintptr)(unsafe.Pointer(bp + 24 /* pInfo */)) = uintptr(0)
		var zIdx uintptr = sqlite3.Xsqlite3_column_text(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* pIdxList */)), 1)

		// Zero the IdxConstraint.bFlag values in the pEq list
		for pIter = pEq; pIter != 0; pIter = (*IdxConstraint)(unsafe.Pointer(pIter)).FpLink {
			(*IdxConstraint)(unsafe.Pointer(pIter)).FbFlag = 0
		}

		*(*int32)(unsafe.Pointer(bp + 32 /* rc */)) = idxPrintfPrepareStmt(tls, dbm, bp+24 /* &pInfo */, uintptr(0), ts+416 /* "PRAGMA index_xIn..." */, crt.VaList(bp+8, zIdx))
		for (*(*int32)(unsafe.Pointer(bp + 32 /* rc */)) == 0) && (sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 24 /* pInfo */))) == 100) {
			var iIdx int32 = sqlite3.Xsqlite3_column_int(tls, *(*uintptr)(unsafe.Pointer(bp + 24 /* pInfo */)), 0)
			var iCol int32 = sqlite3.Xsqlite3_column_int(tls, *(*uintptr)(unsafe.Pointer(bp + 24 /* pInfo */)), 1)
			var zColl uintptr = sqlite3.Xsqlite3_column_text(tls, *(*uintptr)(unsafe.Pointer(bp + 24 /* pInfo */)), 4)

			if iIdx < nEq {
				for pIter = pEq; pIter != 0; pIter = (*IdxConstraint)(unsafe.Pointer(pIter)).FpLink {
					if (*IdxConstraint)(unsafe.Pointer(pIter)).FbFlag != 0 {
						continue
					}
					if (*IdxConstraint)(unsafe.Pointer(pIter)).FiCol != iCol {
						continue
					}
					if sqlite3.Xsqlite3_stricmp(tls, (*IdxConstraint)(unsafe.Pointer(pIter)).FzColl, zColl) != 0 {
						continue
					}
					(*IdxConstraint)(unsafe.Pointer(pIter)).FbFlag = 1
					break
				}
				if pIter == uintptr(0) {
					bMatch = 0
					break
				}
			} else {
				if pT != 0 {
					if ((*IdxConstraint)(unsafe.Pointer(pT)).FiCol != iCol) || (sqlite3.Xsqlite3_stricmp(tls, (*IdxConstraint)(unsafe.Pointer(pT)).FzColl, zColl) != 0) {
						bMatch = 0
						break
					}
					pT = (*IdxConstraint)(unsafe.Pointer(pT)).FpLink
				}
			}
		}
		idxFinalize(tls, bp+32 /* &rc */, *(*uintptr)(unsafe.Pointer(bp + 24 /* pInfo */)))

		if (*(*int32)(unsafe.Pointer(bp + 32 /* rc */)) == 0) && (bMatch != 0) {
			sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* pIdxList */)))
			return 1
		}
	}
	idxFinalize(tls, bp+32 /* &rc */, *(*uintptr)(unsafe.Pointer(bp + 16 /* pIdxList */)))

	*(*int32)(unsafe.Pointer(pRc)) = *(*int32)(unsafe.Pointer(bp + 32 /* rc */))
	return 0
}

func idxCreateFromCons(tls *crt.TLS, p uintptr, pScan uintptr, pEq uintptr, pTail uintptr) int32 { /* sqlite3expert.c:911:12: */
	bp := tls.Alloc(44)
	defer tls.Free(44)

	var dbm uintptr = (*sqlite3expert)(unsafe.Pointer(p)).Fdbm
	*(*int32)(unsafe.Pointer(bp + 40 /* rc */)) = 0
	if ((pEq != 0) || (pTail != 0)) && (0 == idxFindCompatible(tls, bp+40 /* &rc */, dbm, pScan, pEq, pTail)) {
		var pTab uintptr = (*IdxScan)(unsafe.Pointer(pScan)).FpTab
		var zCols uintptr = uintptr(0)
		var zIdx uintptr = uintptr(0)
		var pCons uintptr
		var h uint32 = uint32(0)
		var zFmt uintptr

		for pCons = pEq; pCons != 0; pCons = (*IdxConstraint)(unsafe.Pointer(pCons)).FpLink {
			zCols = idxAppendColDefn(tls, bp+40 /* &rc */, zCols, pTab, pCons)
		}
		for pCons = pTail; pCons != 0; pCons = (*IdxConstraint)(unsafe.Pointer(pCons)).FpLink {
			zCols = idxAppendColDefn(tls, bp+40 /* &rc */, zCols, pTab, pCons)
		}

		if *(*int32)(unsafe.Pointer(bp + 40 /* rc */)) == 0 {
			// Hash the list of columns to come up with a name for the index
			var zTable uintptr = (*IdxTable)(unsafe.Pointer((*IdxScan)(unsafe.Pointer(pScan)).FpTab)).FzName
			var zName uintptr // Index name
			var i int32
			for i = 0; *(*int8)(unsafe.Pointer(zCols + uintptr(i))) != 0; i++ {
				h = h + ((h << 3) + uint32(*(*int8)(unsafe.Pointer(zCols + uintptr(i)))))
			}
			zName = sqlite3.Xsqlite3_mprintf(tls, ts+438 /* "%s_idx_%08x" */, crt.VaList(bp, zTable, h))
			if zName == uintptr(0) {
				*(*int32)(unsafe.Pointer(bp + 40 /* rc */)) = 7
			} else {
				if idxIdentifierRequiresQuotes(tls, zTable) != 0 {
					zFmt = ts + 450 /* "CREATE INDEX '%q..." */
				} else {
					zFmt = ts + 478 /* "CREATE INDEX %s ..." */
				}
				zIdx = sqlite3.Xsqlite3_mprintf(tls, zFmt, crt.VaList(bp+16, zName, zTable, zCols))
				if !(zIdx != 0) {
					*(*int32)(unsafe.Pointer(bp + 40 /* rc */)) = 7
				} else {
					*(*int32)(unsafe.Pointer(bp + 40 /* rc */)) = sqlite3.Xsqlite3_exec(tls, dbm, zIdx, uintptr(0), uintptr(0), (*sqlite3expert)(unsafe.Pointer(p)).FpzErrmsg)
					idxHashAdd(tls, bp+40 /* &rc */, (p + 88 /* &.hIdx */), zName, zIdx)
				}
				sqlite3.Xsqlite3_free(tls, zName)
				sqlite3.Xsqlite3_free(tls, zIdx)
			}
		}

		sqlite3.Xsqlite3_free(tls, zCols)
	}
	return *(*int32)(unsafe.Pointer(bp + 40 /* rc */))
}

// Return true if list pList (linked by IdxConstraint.pLink) contains
// a constraint compatible with *p. Otherwise return false.
func idxFindConstraint(tls *crt.TLS, pList uintptr, p uintptr) int32 { /* sqlite3expert.c:972:12: */
	var pCmp uintptr
	for pCmp = pList; pCmp != 0; pCmp = (*IdxConstraint)(unsafe.Pointer(pCmp)).FpLink {
		if (*IdxConstraint)(unsafe.Pointer(p)).FiCol == (*IdxConstraint)(unsafe.Pointer(pCmp)).FiCol {
			return 1
		}
	}
	return 0
}

func idxCreateFromWhere(tls *crt.TLS, p uintptr, pScan uintptr, pTail uintptr) int32 { /* sqlite3expert.c:980:12: */
	var p1 uintptr = uintptr(0)
	var pCon uintptr
	var rc int32

	// Gather up all the == constraints.
	for pCon = (*IdxScan)(unsafe.Pointer(pScan)).FpEq; pCon != 0; pCon = (*IdxConstraint)(unsafe.Pointer(pCon)).FpNext {
		if !(idxFindConstraint(tls, p1, pCon) != 0) && !(idxFindConstraint(tls, pTail, pCon) != 0) {
			(*IdxConstraint)(unsafe.Pointer(pCon)).FpLink = p1
			p1 = pCon
		}
	}

	// Create an index using the == constraints collected above. And the
	// range constraint/ORDER BY terms passed in by the caller, if any.
	rc = idxCreateFromCons(tls, p, pScan, p1, pTail)

	// If no range/ORDER BY passed by the caller, create a version of the
	// index for each range constraint.
	if pTail == uintptr(0) {
		for pCon = (*IdxScan)(unsafe.Pointer(pScan)).FpRange; (rc == 0) && (pCon != 0); pCon = (*IdxConstraint)(unsafe.Pointer(pCon)).FpNext {
			if !((*IdxConstraint)(unsafe.Pointer(pCon)).FpLink == uintptr(0)) {
				crt.X__assert_fail(tls, ts+504 /* "pCon->pLink==0" */, ts+8 /* "testdata/sqlite-..." */, uint32(1005), uintptr(unsafe.Pointer(&__func__7)))
			}
			if !(idxFindConstraint(tls, p1, pCon) != 0) && !(idxFindConstraint(tls, pTail, pCon) != 0) {
				rc = idxCreateFromCons(tls, p, pScan, p1, pCon)
			}
		}
	}

	return rc
}

var __func__7 = *(*[19]int8)(unsafe.Pointer(ts + 519 /* "idxCreateFromWhe..." */)) /* sqlite3expert.c:984:2 */

// Create candidate indexes in database [dbm] based on the data in
// linked-list pScan.
func idxCreateCandidates(tls *crt.TLS, p uintptr) int32 { /* sqlite3expert.c:1019:12: */
	var rc int32 = 0
	var pIter uintptr

	for pIter = (*sqlite3expert)(unsafe.Pointer(p)).FpScan; (pIter != 0) && (rc == 0); pIter = (*IdxScan)(unsafe.Pointer(pIter)).FpNextScan {
		rc = idxCreateFromWhere(tls, p, pIter, uintptr(0))
		if (rc == 0) && ((*IdxScan)(unsafe.Pointer(pIter)).FpOrder != 0) {
			rc = idxCreateFromWhere(tls, p, pIter, (*IdxScan)(unsafe.Pointer(pIter)).FpOrder)
		}
	}

	return rc
}

// Free all elements of the linked list starting at pConstraint.
func idxConstraintFree(tls *crt.TLS, pConstraint uintptr) { /* sqlite3expert.c:1036:13: */
	var pNext uintptr
	var p uintptr

	for p = pConstraint; p != 0; p = pNext {
		pNext = (*IdxConstraint)(unsafe.Pointer(p)).FpNext
		sqlite3.Xsqlite3_free(tls, p)
	}
}

// Free all elements of the linked list starting from pScan up until pLast
// (pLast is not freed).
func idxScanFree(tls *crt.TLS, pScan uintptr, pLast uintptr) { /* sqlite3expert.c:1050:13: */
	var p uintptr
	var pNext uintptr
	for p = pScan; p != pLast; p = pNext {
		pNext = (*IdxScan)(unsafe.Pointer(p)).FpNextScan
		idxConstraintFree(tls, (*IdxScan)(unsafe.Pointer(p)).FpOrder)
		idxConstraintFree(tls, (*IdxScan)(unsafe.Pointer(p)).FpEq)
		idxConstraintFree(tls, (*IdxScan)(unsafe.Pointer(p)).FpRange)
		sqlite3.Xsqlite3_free(tls, p)
	}
}

// Free all elements of the linked list starting from pStatement up
// until pLast (pLast is not freed).
func idxStatementFree(tls *crt.TLS, pStatement uintptr, pLast uintptr) { /* sqlite3expert.c:1066:13: */
	var p uintptr
	var pNext uintptr
	for p = pStatement; p != pLast; p = pNext {
		pNext = (*IdxStatement)(unsafe.Pointer(p)).FpNext
		sqlite3.Xsqlite3_free(tls, (*IdxStatement)(unsafe.Pointer(p)).FzEQP)
		sqlite3.Xsqlite3_free(tls, (*IdxStatement)(unsafe.Pointer(p)).FzIdx)
		sqlite3.Xsqlite3_free(tls, p)
	}
}

// Free the linked list of IdxTable objects starting at pTab.
func idxTableFree(tls *crt.TLS, pTab uintptr) { /* sqlite3expert.c:1080:13: */
	var pIter uintptr
	var pNext uintptr
	for pIter = pTab; pIter != 0; pIter = pNext {
		pNext = (*IdxTable)(unsafe.Pointer(pIter)).FpNext
		sqlite3.Xsqlite3_free(tls, pIter)
	}
}

// Free the linked list of IdxWrite objects starting at pTab.
func idxWriteFree(tls *crt.TLS, pTab uintptr) { /* sqlite3expert.c:1092:13: */
	var pIter uintptr
	var pNext uintptr
	for pIter = pTab; pIter != 0; pIter = pNext {
		pNext = (*IdxWrite)(unsafe.Pointer(pIter)).FpNext
		sqlite3.Xsqlite3_free(tls, pIter)
	}
}

// This function is called after candidate indexes have been created. It
// runs all the queries to see which indexes they prefer, and populates
// IdxStatement.zIdx and IdxStatement.zEQP with the results.
func idxFindIndexes(tls *crt.TLS, p uintptr, pzErr uintptr) int32 { /* sqlite3expert.c:1108:5: */
	bp := tls.Alloc(8228)
	defer tls.Free(8228)

	var pStmt uintptr
	var dbm uintptr
	// var rc int32 at bp+8224, 4

	// var hIdx IdxHash at bp+24, 8192

	var zSql uintptr
	var nIdx int32
	var zIdx uintptr
	// int iId = sqlite3_column_int(pExplain, 0);
	// int iParent = sqlite3_column_int(pExplain, 1);
	// int iNotUsed = sqlite3_column_int(pExplain, 2);
	var zDetail uintptr
	var nDetail int32
	var i int32
	var pEntry uintptr
	// var pExplain uintptr at bp+8216, 8
	dbm = (*sqlite3expert)(unsafe.Pointer(p)).Fdbm
	*(*int32)(unsafe.Pointer(bp + 8224 /* rc */)) = 0
	idxHashInit(tls, bp+24 /* &hIdx */)

	pStmt = (*sqlite3expert)(unsafe.Pointer(p)).FpStatement
__1:
	if !((*(*int32)(unsafe.Pointer(bp + 8224 /* rc */)) == 0) && (pStmt != 0)) {
		goto __3
	}
	*(*uintptr)(unsafe.Pointer(bp + 8216 /* pExplain */)) = uintptr(0)
	idxHashClear(tls, bp+24 /* &hIdx */)
	*(*int32)(unsafe.Pointer(bp + 8224 /* rc */)) = idxPrintfPrepareStmt(tls, dbm, bp+8216 /* &pExplain */, pzErr,
		ts+538 /* "EXPLAIN QUERY PL..." */, crt.VaList(bp, (*IdxStatement)(unsafe.Pointer(pStmt)).FzSql))
__4:
	if !((*(*int32)(unsafe.Pointer(bp + 8224 /* rc */)) == 0) && (sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 8216 /* pExplain */))) == 100)) {
		goto __5
	}
	// int iId = sqlite3_column_int(pExplain, 0);
	// int iParent = sqlite3_column_int(pExplain, 1);
	// int iNotUsed = sqlite3_column_int(pExplain, 2);
	zDetail = sqlite3.Xsqlite3_column_text(tls, *(*uintptr)(unsafe.Pointer(bp + 8216 /* pExplain */)), 3)

	if !(!(zDetail != 0)) {
		goto __6
	}
	goto __4
__6:
	;
	nDetail = int32(crt.Xstrlen(tls, zDetail))

	i = 0
__7:
	if !(i < nDetail) {
		goto __9
	}
	zIdx = uintptr(0)
	if !(((i + 13) < nDetail) && (crt.Xmemcmp(tls, (zDetail+uintptr(i)), ts+560 /* " USING INDEX " */, uint64(13)) == 0)) {
		goto __10
	}
	zIdx = (zDetail + uintptr((i + 13)))
	goto __11
__10:
	if !(((i + 22) < nDetail) &&
		(crt.Xmemcmp(tls, (zDetail+uintptr(i)), ts+574 /* " USING COVERING ..." */, uint64(22)) == 0)) {
		goto __12
	}
	zIdx = (zDetail + uintptr((i + 22)))
__12:
	;
__11:
	;
	if !(zIdx != 0) {
		goto __13
	}
	nIdx = 0
__14:
	if !((int32(*(*int8)(unsafe.Pointer(zIdx + uintptr(nIdx)))) != 0) && ((int32(*(*int8)(unsafe.Pointer(zIdx + uintptr(nIdx)))) != ' ') || (int32(*(*int8)(unsafe.Pointer(zIdx + uintptr((nIdx + 1))))) != '('))) {
		goto __15
	}
	nIdx++
	goto __14
__15:
	;
	zSql = idxHashSearch(tls, (p + 88 /* &.hIdx */), zIdx, nIdx)
	if !(zSql != 0) {
		goto __16
	}
	idxHashAdd(tls, bp+8224 /* &rc */, bp+24 /* &hIdx */, zSql, uintptr(0))
	if !(*(*int32)(unsafe.Pointer(bp + 8224 /* rc */)) != 0) {
		goto __17
	}
	goto find_indexes_out
__17:
	;
__16:
	;
	goto __9
__13:
	;
	goto __8
__8:
	i++
	goto __7
	goto __9
__9:
	;

	if !(int32(*(*int8)(unsafe.Pointer(zDetail + uintptr(0)))) != '-') {
		goto __18
	}
	(*IdxStatement)(unsafe.Pointer(pStmt)).FzEQP = idxAppendText(tls, bp+8224 /* &rc */, (*IdxStatement)(unsafe.Pointer(pStmt)).FzEQP, ts+597 /* "%s\n" */, crt.VaList(bp+8, zDetail))
__18:
	;
	goto __4
__5:
	;

	pEntry = (*IdxHash)(unsafe.Pointer(bp + 24 /* &hIdx */)).FpFirst
__19:
	if !(pEntry != 0) {
		goto __21
	}
	(*IdxStatement)(unsafe.Pointer(pStmt)).FzIdx = idxAppendText(tls, bp+8224 /* &rc */, (*IdxStatement)(unsafe.Pointer(pStmt)).FzIdx, ts+601 /* "%s;\n" */, crt.VaList(bp+16, (*IdxHashEntry)(unsafe.Pointer(pEntry)).FzKey))
	goto __20
__20:
	pEntry = (*IdxHashEntry)(unsafe.Pointer(pEntry)).FpNext
	goto __19
	goto __21
__21:
	;

	idxFinalize(tls, bp+8224 /* &rc */, *(*uintptr)(unsafe.Pointer(bp + 8216 /* pExplain */)))
	goto __2
__2:
	pStmt = (*IdxStatement)(unsafe.Pointer(pStmt)).FpNext
	goto __1
	goto __3
__3:
	;

find_indexes_out:
	idxHashClear(tls, bp+24 /* &hIdx */)
	return *(*int32)(unsafe.Pointer(bp + 8224 /* rc */))
}

func idxAuthCallback(tls *crt.TLS, pCtx uintptr, eOp int32, z3 uintptr, z4 uintptr, zDb uintptr, zTrigger uintptr) int32 { /* sqlite3expert.c:1178:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	*(*int32)(unsafe.Pointer(bp /* rc */)) = 0
	_ = z4
	_ = zTrigger
	if ((eOp == 18) || (eOp == 23)) || (eOp == 9) {
		if sqlite3.Xsqlite3_stricmp(tls, zDb, ts+354 /* "main" */) == 0 {
			var p uintptr = pCtx
			var pTab uintptr
			for pTab = (*sqlite3expert)(unsafe.Pointer(p)).FpTable; pTab != 0; pTab = (*IdxTable)(unsafe.Pointer(pTab)).FpNext {
				if 0 == sqlite3.Xsqlite3_stricmp(tls, z3, (*IdxTable)(unsafe.Pointer(pTab)).FzName) {
					break
				}
			}
			if pTab != 0 {
				var pWrite uintptr
				for pWrite = (*sqlite3expert)(unsafe.Pointer(p)).FpWrite; pWrite != 0; pWrite = (*IdxWrite)(unsafe.Pointer(pWrite)).FpNext {
					if ((*IdxWrite)(unsafe.Pointer(pWrite)).FpTab == pTab) && ((*IdxWrite)(unsafe.Pointer(pWrite)).FeOp == eOp) {
						break
					}
				}
				if pWrite == uintptr(0) {
					pWrite = idxMalloc(tls, bp /* &rc */, int32(unsafe.Sizeof(IdxWrite{})))
					if *(*int32)(unsafe.Pointer(bp /* rc */)) == 0 {
						(*IdxWrite)(unsafe.Pointer(pWrite)).FpTab = pTab
						(*IdxWrite)(unsafe.Pointer(pWrite)).FeOp = eOp
						(*IdxWrite)(unsafe.Pointer(pWrite)).FpNext = (*sqlite3expert)(unsafe.Pointer(p)).FpWrite
						(*sqlite3expert)(unsafe.Pointer(p)).FpWrite = pWrite
					}
				}
			}
		}
	}
	return *(*int32)(unsafe.Pointer(bp /* rc */))
}

func idxProcessOneTrigger(tls *crt.TLS, p uintptr, pWrite uintptr, pzErr uintptr) int32 { /* sqlite3expert.c:1216:12: */
	bp := tls.Alloc(104)
	defer tls.Free(104)

	var pTab uintptr = (*IdxWrite)(unsafe.Pointer(pWrite)).FpTab
	var zTab uintptr = (*IdxTable)(unsafe.Pointer(pTab)).FzName
	var zSql uintptr = ts + 606 /* "SELECT 'CREATE T..." */
	*(*uintptr)(unsafe.Pointer(bp + 80 /* pSelect */)) = uintptr(0)
	*(*int32)(unsafe.Pointer(bp + 88 /* rc */)) = 0
	var zWrite uintptr = uintptr(0)

	// Create the table and its triggers in the temp schema
	*(*int32)(unsafe.Pointer(bp + 88 /* rc */)) = idxPrintfPrepareStmt(tls, (*sqlite3expert)(unsafe.Pointer(p)).Fdb, bp+80 /* &pSelect */, pzErr, zSql, crt.VaList(bp, zTab, zTab))
	for (*(*int32)(unsafe.Pointer(bp + 88 /* rc */)) == 0) && (100 == sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 80 /* pSelect */)))) {
		var zCreate uintptr = sqlite3.Xsqlite3_column_text(tls, *(*uintptr)(unsafe.Pointer(bp + 80 /* pSelect */)), 0)
		*(*int32)(unsafe.Pointer(bp + 88 /* rc */)) = sqlite3.Xsqlite3_exec(tls, (*sqlite3expert)(unsafe.Pointer(p)).Fdbv, zCreate, uintptr(0), uintptr(0), pzErr)
	}
	idxFinalize(tls, bp+88 /* &rc */, *(*uintptr)(unsafe.Pointer(bp + 80 /* pSelect */)))

	// Rename the table in the temp schema to zInt
	if *(*int32)(unsafe.Pointer(bp + 88 /* rc */)) == 0 {
		var z uintptr = sqlite3.Xsqlite3_mprintf(tls, ts+732 /* "ALTER TABLE temp..." */, crt.VaList(bp+16, zTab, zInt))
		if z == uintptr(0) {
			*(*int32)(unsafe.Pointer(bp + 88 /* rc */)) = 7
		} else {
			*(*int32)(unsafe.Pointer(bp + 88 /* rc */)) = sqlite3.Xsqlite3_exec(tls, (*sqlite3expert)(unsafe.Pointer(p)).Fdbv, z, uintptr(0), uintptr(0), pzErr)
			sqlite3.Xsqlite3_free(tls, z)
		}
	}

	switch (*IdxWrite)(unsafe.Pointer(pWrite)).FeOp {
	case 18:
		{
			var i int32
			zWrite = idxAppendText(tls, bp+88 /* &rc */, zWrite, ts+765 /* "INSERT INTO %Q V..." */, crt.VaList(bp+32, zInt))
			for i = 0; i < (*IdxTable)(unsafe.Pointer(pTab)).FnCol; i++ {
				zWrite = idxAppendText(tls, bp+88 /* &rc */, zWrite, ts+788 /* "%s?" */, crt.VaList(bp+40, func() uintptr {
					if i == 0 {
						return ts + 792 /* "" */
					}
					return ts + 359 /* ", " */
				}()))
			}
			zWrite = idxAppendText(tls, bp+88 /* &rc */, zWrite, ts+793 /* ")" */, 0)
			break
		}
	case 23:
		{
			var i int32
			zWrite = idxAppendText(tls, bp+88 /* &rc */, zWrite, ts+795 /* "UPDATE %Q SET " */, crt.VaList(bp+48, zInt))
			for i = 0; i < (*IdxTable)(unsafe.Pointer(pTab)).FnCol; i++ {
				zWrite = idxAppendText(tls, bp+88 /* &rc */, zWrite, ts+810 /* "%s%Q=?" */, crt.VaList(bp+56, func() uintptr {
					if i == 0 {
						return ts + 792 /* "" */
					}
					return ts + 359 /* ", " */
				}(),
					(*IdxColumn)(unsafe.Pointer((*IdxTable)(unsafe.Pointer(pTab)).FaCol+uintptr(i)*24)).FzName))
			}
			break
		}
	default:
		{
			if !((*IdxWrite)(unsafe.Pointer(pWrite)).FeOp == 9) {
				crt.X__assert_fail(tls, ts+817 /* "pWrite->eOp==9" */, ts+8 /* "testdata/sqlite-..." */, uint32(1273), uintptr(unsafe.Pointer(&__func__8)))
			}
			if *(*int32)(unsafe.Pointer(bp + 88 /* rc */)) == 0 {
				zWrite = sqlite3.Xsqlite3_mprintf(tls, ts+832 /* "DELETE FROM %Q" */, crt.VaList(bp+72, zInt))
				if zWrite == uintptr(0) {
					*(*int32)(unsafe.Pointer(bp + 88 /* rc */)) = 7
				}
			}
		}
	}

	if *(*int32)(unsafe.Pointer(bp + 88 /* rc */)) == 0 {
		*(*uintptr)(unsafe.Pointer(bp + 96 /* pX */)) = uintptr(0)
		*(*int32)(unsafe.Pointer(bp + 88 /* rc */)) = sqlite3.Xsqlite3_prepare_v2(tls, (*sqlite3expert)(unsafe.Pointer(p)).Fdbv, zWrite, -1, bp+96 /* &pX */, uintptr(0))
		idxFinalize(tls, bp+88 /* &rc */, *(*uintptr)(unsafe.Pointer(bp + 96 /* pX */)))
		if *(*int32)(unsafe.Pointer(bp + 88 /* rc */)) != 0 {
			idxDatabaseError(tls, (*sqlite3expert)(unsafe.Pointer(p)).Fdbv, pzErr)
		}
	}
	sqlite3.Xsqlite3_free(tls, zWrite)

	if *(*int32)(unsafe.Pointer(bp + 88 /* rc */)) == 0 {
		*(*int32)(unsafe.Pointer(bp + 88 /* rc */)) = sqlite3.Xsqlite3_exec(tls, (*sqlite3expert)(unsafe.Pointer(p)).Fdbv, zDrop, uintptr(0), uintptr(0), pzErr)
	}

	return *(*int32)(unsafe.Pointer(bp + 88 /* rc */))
}

var __func__8 = *(*[21]int8)(unsafe.Pointer(ts + 847 /* "idxProcessOneTri..." */)) /* sqlite3expert.c:1220:2 */
var zInt uintptr = ts + 868                                                        /* "t592690916721053..." */ /* sqlite3expert.c:1221:21 */
var zDrop uintptr = ts + 906                                                       /* "DROP TABLE t5926..." */ /* sqlite3expert.c:1222:21 */

func idxProcessTriggers(tls *crt.TLS, p uintptr, pzErr uintptr) int32 { /* sqlite3expert.c:1298:12: */
	var rc int32 = 0
	var pEnd uintptr = uintptr(0)
	var pFirst uintptr = (*sqlite3expert)(unsafe.Pointer(p)).FpWrite

	for (rc == 0) && (pFirst != pEnd) {
		var pIter uintptr
		for pIter = pFirst; (rc == 0) && (pIter != pEnd); pIter = (*IdxWrite)(unsafe.Pointer(pIter)).FpNext {
			rc = idxProcessOneTrigger(tls, p, pIter, pzErr)
		}
		pEnd = pFirst
		pFirst = (*sqlite3expert)(unsafe.Pointer(p)).FpWrite
	}

	return rc
}

func idxCreateVtabSchema(tls *crt.TLS, p uintptr, pzErrmsg uintptr) int32 { /* sqlite3expert.c:1316:12: */
	bp := tls.Alloc(60)
	defer tls.Free(60)

	*(*int32)(unsafe.Pointer(bp + 56 /* rc */)) = idxRegisterVtab(tls, p)
	*(*uintptr)(unsafe.Pointer(bp + 40 /* pSchema */)) = uintptr(0)

	// For each table in the main db schema:
	//
	//   1) Add an entry to the p->pTable list, and
	//   2) Create the equivalent virtual table in dbv.
	*(*int32)(unsafe.Pointer(bp + 56 /* rc */)) = idxPrepareStmt(tls, (*sqlite3expert)(unsafe.Pointer(p)).Fdb, bp+40 /* &pSchema */, pzErrmsg,

		ts+955 /* "SELECT type, nam..." */)
	for (*(*int32)(unsafe.Pointer(bp + 56 /* rc */)) == 0) && (100 == sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 40 /* pSchema */)))) {
		var zType uintptr = sqlite3.Xsqlite3_column_text(tls, *(*uintptr)(unsafe.Pointer(bp + 40 /* pSchema */)), 0)
		var zName uintptr = sqlite3.Xsqlite3_column_text(tls, *(*uintptr)(unsafe.Pointer(bp + 40 /* pSchema */)), 1)
		var zSql uintptr = sqlite3.Xsqlite3_column_text(tls, *(*uintptr)(unsafe.Pointer(bp + 40 /* pSchema */)), 2)

		if (int32(*(*int8)(unsafe.Pointer(zType + uintptr(0)))) == 'v') || (int32(*(*int8)(unsafe.Pointer(zType + uintptr(1)))) == 'r') {
			*(*int32)(unsafe.Pointer(bp + 56 /* rc */)) = sqlite3.Xsqlite3_exec(tls, (*sqlite3expert)(unsafe.Pointer(p)).Fdbv, zSql, uintptr(0), uintptr(0), pzErrmsg)
		} else {
			// var pTab uintptr at bp+48, 8

			*(*int32)(unsafe.Pointer(bp + 56 /* rc */)) = idxGetTableInfo(tls, (*sqlite3expert)(unsafe.Pointer(p)).Fdb, zName, bp+48 /* &pTab */, pzErrmsg)
			if *(*int32)(unsafe.Pointer(bp + 56 /* rc */)) == 0 {
				var i int32
				var zInner uintptr = uintptr(0)
				var zOuter uintptr = uintptr(0)
				(*IdxTable)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 48 /* pTab */)))).FpNext = (*sqlite3expert)(unsafe.Pointer(p)).FpTable
				(*sqlite3expert)(unsafe.Pointer(p)).FpTable = *(*uintptr)(unsafe.Pointer(bp + 48 /* pTab */))

				// The statement the vtab will pass to sqlite3_declare_vtab()
				zInner = idxAppendText(tls, bp+56 /* &rc */, uintptr(0), ts+1223 /* "CREATE TABLE x(" */, 0)
				for i = 0; i < (*IdxTable)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 48 /* pTab */)))).FnCol; i++ {
					zInner = idxAppendText(tls, bp+56 /* &rc */, zInner, ts+1239, /* "%s%Q COLLATE %s" */
						crt.VaList(bp, func() uintptr {
							if i == 0 {
								return ts + 792 /* "" */
							}
							return ts + 359 /* ", " */
						}(), (*IdxColumn)(unsafe.Pointer((*IdxTable)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 48 /* pTab */)))).FaCol+uintptr(i)*24)).FzName, (*IdxColumn)(unsafe.Pointer((*IdxTable)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 48 /* pTab */)))).FaCol+uintptr(i)*24)).FzColl))
				}
				zInner = idxAppendText(tls, bp+56 /* &rc */, zInner, ts+793 /* ")" */, 0)

				// The CVT statement to create the vtab
				zOuter = idxAppendText(tls, bp+56 /* &rc */, uintptr(0),
					ts+1255 /* "CREATE VIRTUAL T..." */, crt.VaList(bp+24, zName, zInner))
				if *(*int32)(unsafe.Pointer(bp + 56 /* rc */)) == 0 {
					*(*int32)(unsafe.Pointer(bp + 56 /* rc */)) = sqlite3.Xsqlite3_exec(tls, (*sqlite3expert)(unsafe.Pointer(p)).Fdbv, zOuter, uintptr(0), uintptr(0), pzErrmsg)
				}
				sqlite3.Xsqlite3_free(tls, zInner)
				sqlite3.Xsqlite3_free(tls, zOuter)
			}
		}
	}
	idxFinalize(tls, bp+56 /* &rc */, *(*uintptr)(unsafe.Pointer(bp + 40 /* pSchema */)))
	return *(*int32)(unsafe.Pointer(bp + 56 /* rc */))
}

type IdxSampleCtx = struct {
	FiTarget int32
	Ftarget  float64
	FnRow    float64
	FnRet    float64
}

func idxSampleFunc(tls *crt.TLS, pCtx uintptr, argc int32, argv uintptr) { /* sqlite3expert.c:1383:13: */
	bp := tls.Alloc(2)
	defer tls.Free(2)

	var p uintptr = sqlite3.Xsqlite3_user_data(tls, pCtx)
	var bRet int32

	_ = argv
	if !(argc == 0) {
		crt.X__assert_fail(tls, ts+1296 /* "argc==0" */, ts+8 /* "testdata/sqlite-..." */, uint32(1392), uintptr(unsafe.Pointer(&__func__9)))
	}
	if (*IdxSampleCtx)(unsafe.Pointer(p)).FnRow == 0.0 {
		bRet = 1
	} else {
		bRet = (crt.Bool32(((*IdxSampleCtx)(unsafe.Pointer(p)).FnRet / (*IdxSampleCtx)(unsafe.Pointer(p)).FnRow) <= (*IdxSampleCtx)(unsafe.Pointer(p)).Ftarget))
		if bRet == 0 {
			// var rnd uint16 at bp, 2

			sqlite3.Xsqlite3_randomness(tls, 2, bp /* &rnd */)
			bRet = (crt.Bool32((int32(*(*uint16)(unsafe.Pointer(bp /* rnd */))) % 100) <= (*IdxSampleCtx)(unsafe.Pointer(p)).FiTarget))
		}
	}

	sqlite3.Xsqlite3_result_int(tls, pCtx, bRet)
	*(*float64)(unsafe.Pointer(p + 16 /* &.nRow */)) += (1.0)
	*(*float64)(unsafe.Pointer(p + 24 /* &.nRet */)) += (float64(bRet))
}

var __func__9 = *(*[14]int8)(unsafe.Pointer(ts + 1304 /* "idxSampleFunc" */)) /* sqlite3expert.c:1387:2 */

type IdxRemCtx = struct {
	FnSlot int32
	FaSlot [1]struct {
		FeType int32
		FiVal  i64
		FrVal  float64
		FnByte int32
		Fn     int32
		Fz     uintptr
	}
}

type IdxRemSlot = struct {
	FeType int32
	FiVal  i64
	FrVal  float64
	FnByte int32
	Fn     int32
	Fz     uintptr
}

// Implementation of scalar function rem().
func idxRemFunc(tls *crt.TLS, pCtx uintptr, argc int32, argv uintptr) { /* sqlite3expert.c:1424:13: */
	var p uintptr = sqlite3.Xsqlite3_user_data(tls, pCtx)
	var pSlot uintptr
	var iSlot int32
	if !(argc == 2) {
		crt.X__assert_fail(tls, ts+1318 /* "argc==2" */, ts+8 /* "testdata/sqlite-..." */, uint32(1432), uintptr(unsafe.Pointer(&__func__10)))
	}

	iSlot = sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)))
	if !(iSlot <= (*IdxRemCtx)(unsafe.Pointer(p)).FnSlot) {
		crt.X__assert_fail(tls, ts+1326 /* "iSlot<=p->nSlot" */, ts+8 /* "testdata/sqlite-..." */, uint32(1435), uintptr(unsafe.Pointer(&__func__10)))
	}
	pSlot = ((p + 8 /* &.aSlot */) + uintptr(iSlot)*40)

	switch (*IdxRemSlot)(unsafe.Pointer(pSlot)).FeType {
	case 5:
		// no-op
		break

	case 1:
		sqlite3.Xsqlite3_result_int64(tls, pCtx, (*IdxRemSlot)(unsafe.Pointer(pSlot)).FiVal)
		break

	case 2:
		sqlite3.Xsqlite3_result_double(tls, pCtx, (*IdxRemSlot)(unsafe.Pointer(pSlot)).FrVal)
		break

	case 4:
		sqlite3.Xsqlite3_result_blob(tls, pCtx, (*IdxRemSlot)(unsafe.Pointer(pSlot)).Fz, (*IdxRemSlot)(unsafe.Pointer(pSlot)).Fn, crt.UintptrFromInt32(-1))
		break

	case 3:
		sqlite3.Xsqlite3_result_text(tls, pCtx, (*IdxRemSlot)(unsafe.Pointer(pSlot)).Fz, (*IdxRemSlot)(unsafe.Pointer(pSlot)).Fn, crt.UintptrFromInt32(-1))
		break
	}

	(*IdxRemSlot)(unsafe.Pointer(pSlot)).FeType = sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)))
	switch (*IdxRemSlot)(unsafe.Pointer(pSlot)).FeType {
	case 5:
		// no-op
		break

	case 1:
		(*IdxRemSlot)(unsafe.Pointer(pSlot)).FiVal = sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)))
		break

	case 2:
		(*IdxRemSlot)(unsafe.Pointer(pSlot)).FrVal = sqlite3.Xsqlite3_value_double(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)))
		break

	case 4:
		fallthrough
	case 3:
		{
			var nByte int32 = sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)))
			if nByte > (*IdxRemSlot)(unsafe.Pointer(pSlot)).FnByte {
				var zNew uintptr = sqlite3.Xsqlite3_realloc(tls, (*IdxRemSlot)(unsafe.Pointer(pSlot)).Fz, (nByte * 2))
				if zNew == uintptr(0) {
					sqlite3.Xsqlite3_result_error_nomem(tls, pCtx)
					return
				}
				(*IdxRemSlot)(unsafe.Pointer(pSlot)).FnByte = (nByte * 2)
				(*IdxRemSlot)(unsafe.Pointer(pSlot)).Fz = zNew
			}
			(*IdxRemSlot)(unsafe.Pointer(pSlot)).Fn = nByte
			if (*IdxRemSlot)(unsafe.Pointer(pSlot)).FeType == 4 {
				crt.Xmemcpy(tls, (*IdxRemSlot)(unsafe.Pointer(pSlot)).Fz, sqlite3.Xsqlite3_value_blob(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8))), uint64(nByte))
			} else {
				crt.Xmemcpy(tls, (*IdxRemSlot)(unsafe.Pointer(pSlot)).Fz, sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8))), uint64(nByte))
			}
			break
		}
	}
}

var __func__10 = *(*[11]int8)(unsafe.Pointer(ts + 1342 /* "idxRemFunc" */)) /* sqlite3expert.c:1428:2 */

func idxLargestIndex(tls *crt.TLS, db uintptr, pnMax uintptr, pzErr uintptr) int32 { /* sqlite3expert.c:1497:12: */
	bp := tls.Alloc(12)
	defer tls.Free(12)

	*(*int32)(unsafe.Pointer(bp + 8 /* rc */)) = 0
	var zMax uintptr = ts + 1353 /* "SELECT max(i.seq..." */
	*(*uintptr)(unsafe.Pointer(bp /* pMax */)) = uintptr(0)

	*(*int32)(unsafe.Pointer(pnMax)) = 0
	*(*int32)(unsafe.Pointer(bp + 8 /* rc */)) = idxPrepareStmt(tls, db, bp /* &pMax */, pzErr, zMax)
	if (*(*int32)(unsafe.Pointer(bp + 8 /* rc */)) == 0) && (100 == sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp /* pMax */)))) {
		*(*int32)(unsafe.Pointer(pnMax)) = (sqlite3.Xsqlite3_column_int(tls, *(*uintptr)(unsafe.Pointer(bp /* pMax */)), 0) + 1)
	}
	idxFinalize(tls, bp+8 /* &rc */, *(*uintptr)(unsafe.Pointer(bp /* pMax */)))

	return *(*int32)(unsafe.Pointer(bp + 8 /* rc */))
}

func idxPopulateOneStat1(tls *crt.TLS, p uintptr, pIndexXInfo uintptr, pWriteStat uintptr, zTab uintptr, zIdx uintptr, pzErr uintptr) int32 { /* sqlite3expert.c:1517:12: */
	bp := tls.Alloc(128)
	defer tls.Free(128)

	var zCols uintptr = uintptr(0)
	var zOrder uintptr = uintptr(0)
	var zQuery uintptr = uintptr(0)
	var nCol int32 = 0
	var i int32
	*(*uintptr)(unsafe.Pointer(bp + 120 /* pQuery */)) = uintptr(0)
	var aStat uintptr = uintptr(0)
	*(*int32)(unsafe.Pointer(bp + 112 /* rc */)) = 0

	if !((*sqlite3expert)(unsafe.Pointer(p)).FiSample > 0) {
		crt.X__assert_fail(tls, ts+1490 /* "p->iSample>0" */, ts+8 /* "testdata/sqlite-..." */, uint32(1534), uintptr(unsafe.Pointer(&__func__11)))
	}

	// Formulate the query text
	sqlite3.Xsqlite3_bind_text(tls, pIndexXInfo, 1, zIdx, -1, uintptr(0))
	for (0 == *(*int32)(unsafe.Pointer(bp + 112 /* rc */))) && (100 == sqlite3.Xsqlite3_step(tls, pIndexXInfo)) {
		var zComma uintptr
		if zCols == uintptr(0) {
			zComma = ts + 792 /* "" */
		} else {
			zComma = ts + 359 /* ", " */
		}
		var zName uintptr = sqlite3.Xsqlite3_column_text(tls, pIndexXInfo, 0)
		var zColl uintptr = sqlite3.Xsqlite3_column_text(tls, pIndexXInfo, 1)
		zCols = idxAppendText(tls, bp+112 /* &rc */, zCols,
			ts+1503 /* "%sx.%Q IS rem(%d..." */, crt.VaList(bp, zComma, zName, nCol, zName, zColl))
		zOrder = idxAppendText(tls, bp+112 /* &rc */, zOrder, ts+1538 /* "%s%d" */, crt.VaList(bp+40, zComma, crt.PreIncInt32(&nCol, 1)))
	}
	sqlite3.Xsqlite3_reset(tls, pIndexXInfo)
	if *(*int32)(unsafe.Pointer(bp + 112 /* rc */)) == 0 {
		if (*sqlite3expert)(unsafe.Pointer(p)).FiSample == 100 {
			zQuery = sqlite3.Xsqlite3_mprintf(tls,
				ts+1543 /* "SELECT %s FROM %..." */, crt.VaList(bp+56, zCols, zTab, zOrder))
		} else {
			zQuery = sqlite3.Xsqlite3_mprintf(tls,
				ts+1575 /* "SELECT %s FROM t..." */, crt.VaList(bp+80, zCols, zOrder))
		}
	}
	sqlite3.Xsqlite3_free(tls, zCols)
	sqlite3.Xsqlite3_free(tls, zOrder)

	// Formulate the query text
	if *(*int32)(unsafe.Pointer(bp + 112 /* rc */)) == 0 {
		var dbrem uintptr = func() uintptr {
			if (*sqlite3expert)(unsafe.Pointer(p)).FiSample == 100 {
				return (*sqlite3expert)(unsafe.Pointer(p)).Fdb
			}
			return (*sqlite3expert)(unsafe.Pointer(p)).Fdbv
		}()
		*(*int32)(unsafe.Pointer(bp + 112 /* rc */)) = idxPrepareStmt(tls, dbrem, bp+120 /* &pQuery */, pzErr, zQuery)
	}
	sqlite3.Xsqlite3_free(tls, zQuery)

	if *(*int32)(unsafe.Pointer(bp + 112 /* rc */)) == 0 {
		aStat = idxMalloc(tls, bp+112 /* &rc */, (int32(uint64(unsafe.Sizeof(int32(0))) * (uint64(nCol + 1)))))
	}
	if (*(*int32)(unsafe.Pointer(bp + 112 /* rc */)) == 0) && (100 == sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 120 /* pQuery */)))) {
		var pEntry uintptr
		var zStat uintptr = uintptr(0)
		for i = 0; i <= nCol; i++ {
			*(*int32)(unsafe.Pointer(aStat + uintptr(i)*4)) = 1
		}
		for (*(*int32)(unsafe.Pointer(bp + 112 /* rc */)) == 0) && (100 == sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 120 /* pQuery */)))) {
			*(*int32)(unsafe.Pointer(aStat + uintptr(0)*4))++
			for i = 0; i < nCol; i++ {
				if sqlite3.Xsqlite3_column_int(tls, *(*uintptr)(unsafe.Pointer(bp + 120 /* pQuery */)), i) == 0 {
					break
				}
			}
			for ; i < nCol; i++ {
				*(*int32)(unsafe.Pointer(aStat + uintptr((i+1))*4))++
			}
		}

		if *(*int32)(unsafe.Pointer(bp + 112 /* rc */)) == 0 {
			var s0 int32 = *(*int32)(unsafe.Pointer(aStat + uintptr(0)*4))
			zStat = sqlite3.Xsqlite3_mprintf(tls, ts+1647 /* "%d" */, crt.VaList(bp+96, s0))
			if zStat == uintptr(0) {
				*(*int32)(unsafe.Pointer(bp + 112 /* rc */)) = 7
			}
			for i = 1; (*(*int32)(unsafe.Pointer(bp + 112 /* rc */)) == 0) && (i <= nCol); i++ {
				zStat = idxAppendText(tls, bp+112 /* &rc */, zStat, ts+1650 /* " %d" */, crt.VaList(bp+104, ((s0+(*(*int32)(unsafe.Pointer(aStat + uintptr(i)*4))/2)) / *(*int32)(unsafe.Pointer(aStat + uintptr(i)*4)))))
			}
		}

		if *(*int32)(unsafe.Pointer(bp + 112 /* rc */)) == 0 {
			sqlite3.Xsqlite3_bind_text(tls, pWriteStat, 1, zTab, -1, uintptr(0))
			sqlite3.Xsqlite3_bind_text(tls, pWriteStat, 2, zIdx, -1, uintptr(0))
			sqlite3.Xsqlite3_bind_text(tls, pWriteStat, 3, zStat, -1, uintptr(0))
			sqlite3.Xsqlite3_step(tls, pWriteStat)
			*(*int32)(unsafe.Pointer(bp + 112 /* rc */)) = sqlite3.Xsqlite3_reset(tls, pWriteStat)
		}

		pEntry = idxHashFind(tls, (p + 88 /* &.hIdx */), zIdx, int32(crt.Xstrlen(tls, zIdx)))
		if pEntry != 0 {
			if !((*IdxHashEntry)(unsafe.Pointer(pEntry)).FzVal2 == uintptr(0)) {
				crt.X__assert_fail(tls, ts+1654 /* "pEntry->zVal2==0" */, ts+8 /* "testdata/sqlite-..." */, uint32(1605), uintptr(unsafe.Pointer(&__func__11)))
			}
			(*IdxHashEntry)(unsafe.Pointer(pEntry)).FzVal2 = zStat
		} else {
			sqlite3.Xsqlite3_free(tls, zStat)
		}
	}
	sqlite3.Xsqlite3_free(tls, aStat)
	idxFinalize(tls, bp+112 /* &rc */, *(*uintptr)(unsafe.Pointer(bp + 120 /* pQuery */)))

	return *(*int32)(unsafe.Pointer(bp + 112 /* rc */))
}

var __func__11 = *(*[20]int8)(unsafe.Pointer(ts + 1671 /* "idxPopulateOneSt..." */)) /* sqlite3expert.c:1524:2 */

func idxBuildSampleTable(tls *crt.TLS, p uintptr, zTab uintptr) int32 { /* sqlite3expert.c:1617:12: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var rc int32
	var zSql uintptr

	rc = sqlite3.Xsqlite3_exec(tls, (*sqlite3expert)(unsafe.Pointer(p)).Fdbv, ts+1691 /* "DROP TABLE IF EX..." */, uintptr(0), uintptr(0), uintptr(0))
	if rc != 0 {
		return rc
	}

	zSql = sqlite3.Xsqlite3_mprintf(tls,
		ts+1755 /* "CREATE TABLE tem..." */, crt.VaList(bp, zTab))
	if zSql == uintptr(0) {
		return 7
	}
	rc = sqlite3.Xsqlite3_exec(tls, (*sqlite3expert)(unsafe.Pointer(p)).Fdbv, zSql, uintptr(0), uintptr(0), uintptr(0))
	sqlite3.Xsqlite3_free(tls, zSql)

	return rc
}

// This function is called as part of sqlite3_expert_analyze(). Candidate
// indexes have already been created in database sqlite3expert.dbm, this
// function populates sqlite_stat1 table in the same database.
//
// The stat1 data is generated by querying the
func idxPopulateStat1(tls *crt.TLS, p uintptr, pzErr uintptr) int32 { /* sqlite3expert.c:1641:12: */
	bp := tls.Alloc(64)
	defer tls.Free(64)

	*(*int32)(unsafe.Pointer(bp + 4 /* rc */)) = 0
	*(*int32)(unsafe.Pointer(bp /* nMax */)) = 0
	var pCtx uintptr = uintptr(0)
	// var samplectx IdxSampleCtx at bp+8, 32

	var i int32
	var iPrev i64 = int64(-100000)
	*(*uintptr)(unsafe.Pointer(bp + 40 /* pAllIndex */)) = uintptr(0)
	*(*uintptr)(unsafe.Pointer(bp + 48 /* pIndexXInfo */)) = uintptr(0)
	*(*uintptr)(unsafe.Pointer(bp + 56 /* pWrite */)) = uintptr(0)

	var zAllIndex uintptr = ts + 1831   /* "SELECT s.rowid, ..." */
	var zIndexXInfo uintptr = ts + 1945 /* "SELECT name, col..." */
	var zWrite uintptr = ts + 2000      /* "INSERT INTO sqli..." */

	// If iSample==0, no sqlite_stat1 data is required.
	if (*sqlite3expert)(unsafe.Pointer(p)).FiSample == 0 {
		return 0
	}

	*(*int32)(unsafe.Pointer(bp + 4 /* rc */)) = idxLargestIndex(tls, (*sqlite3expert)(unsafe.Pointer(p)).Fdbm, bp /* &nMax */, pzErr)
	if (*(*int32)(unsafe.Pointer(bp /* nMax */)) <= 0) || (*(*int32)(unsafe.Pointer(bp + 4 /* rc */)) != 0) {
		return *(*int32)(unsafe.Pointer(bp + 4 /* rc */))
	}

	*(*int32)(unsafe.Pointer(bp + 4 /* rc */)) = sqlite3.Xsqlite3_exec(tls, (*sqlite3expert)(unsafe.Pointer(p)).Fdbm, ts+2041 /* "ANALYZE; PRAGMA ..." */, uintptr(0), uintptr(0), uintptr(0))

	if *(*int32)(unsafe.Pointer(bp + 4 /* rc */)) == 0 {
		var nByte int32 = (int32(uint64(unsafe.Sizeof(IdxRemCtx{})) + (uint64(unsafe.Sizeof(IdxRemSlot{})) * uint64(*(*int32)(unsafe.Pointer(bp /* nMax */))))))
		pCtx = idxMalloc(tls, bp+4 /* &rc */, nByte)
	}

	if *(*int32)(unsafe.Pointer(bp + 4 /* rc */)) == 0 {
		var dbrem uintptr = func() uintptr {
			if (*sqlite3expert)(unsafe.Pointer(p)).FiSample == 100 {
				return (*sqlite3expert)(unsafe.Pointer(p)).Fdb
			}
			return (*sqlite3expert)(unsafe.Pointer(p)).Fdbv
		}()
		*(*int32)(unsafe.Pointer(bp + 4 /* rc */)) = sqlite3.Xsqlite3_create_function(tls,
			dbrem, ts+2075 /* "rem" */, 2, 1, pCtx, *(*uintptr)(unsafe.Pointer(&struct {
				f func(*crt.TLS, uintptr, int32, uintptr)
			}{idxRemFunc})), uintptr(0), uintptr(0))
	}
	if *(*int32)(unsafe.Pointer(bp + 4 /* rc */)) == 0 {
		*(*int32)(unsafe.Pointer(bp + 4 /* rc */)) = sqlite3.Xsqlite3_create_function(tls,
			(*sqlite3expert)(unsafe.Pointer(p)).Fdb, ts+2079 /* "sample" */, 0, 1, bp+8 /* &samplectx */, *(*uintptr)(unsafe.Pointer(&struct {
				f func(*crt.TLS, uintptr, int32, uintptr)
			}{idxSampleFunc})), uintptr(0), uintptr(0))
	}

	if *(*int32)(unsafe.Pointer(bp + 4 /* rc */)) == 0 {
		(*IdxRemCtx)(unsafe.Pointer(pCtx)).FnSlot = (*(*int32)(unsafe.Pointer(bp /* nMax */)) + 1)
		*(*int32)(unsafe.Pointer(bp + 4 /* rc */)) = idxPrepareStmt(tls, (*sqlite3expert)(unsafe.Pointer(p)).Fdbm, bp+40 /* &pAllIndex */, pzErr, zAllIndex)
	}
	if *(*int32)(unsafe.Pointer(bp + 4 /* rc */)) == 0 {
		*(*int32)(unsafe.Pointer(bp + 4 /* rc */)) = idxPrepareStmt(tls, (*sqlite3expert)(unsafe.Pointer(p)).Fdbm, bp+48 /* &pIndexXInfo */, pzErr, zIndexXInfo)
	}
	if *(*int32)(unsafe.Pointer(bp + 4 /* rc */)) == 0 {
		*(*int32)(unsafe.Pointer(bp + 4 /* rc */)) = idxPrepareStmt(tls, (*sqlite3expert)(unsafe.Pointer(p)).Fdbm, bp+56 /* &pWrite */, pzErr, zWrite)
	}

	for (*(*int32)(unsafe.Pointer(bp + 4 /* rc */)) == 0) && (100 == sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 40 /* pAllIndex */)))) {
		var iRowid i64 = sqlite3.Xsqlite3_column_int64(tls, *(*uintptr)(unsafe.Pointer(bp + 40 /* pAllIndex */)), 0)
		var zTab uintptr = sqlite3.Xsqlite3_column_text(tls, *(*uintptr)(unsafe.Pointer(bp + 40 /* pAllIndex */)), 1)
		var zIdx uintptr = sqlite3.Xsqlite3_column_text(tls, *(*uintptr)(unsafe.Pointer(bp + 40 /* pAllIndex */)), 2)
		if ((*sqlite3expert)(unsafe.Pointer(p)).FiSample < 100) && (iPrev != iRowid) {
			(*IdxSampleCtx)(unsafe.Pointer(bp + 8 /* &samplectx */)).Ftarget = (float64((*sqlite3expert)(unsafe.Pointer(p)).FiSample) / 100.0)
			(*IdxSampleCtx)(unsafe.Pointer(bp + 8 /* &samplectx */)).FiTarget = (*sqlite3expert)(unsafe.Pointer(p)).FiSample
			(*IdxSampleCtx)(unsafe.Pointer(bp + 8 /* &samplectx */)).FnRow = 0.0
			(*IdxSampleCtx)(unsafe.Pointer(bp + 8 /* &samplectx */)).FnRet = 0.0
			*(*int32)(unsafe.Pointer(bp + 4 /* rc */)) = idxBuildSampleTable(tls, p, zTab)
			if *(*int32)(unsafe.Pointer(bp + 4 /* rc */)) != 0 {
				break
			}
		}
		*(*int32)(unsafe.Pointer(bp + 4 /* rc */)) = idxPopulateOneStat1(tls, p, *(*uintptr)(unsafe.Pointer(bp + 48 /* pIndexXInfo */)), *(*uintptr)(unsafe.Pointer(bp + 56 /* pWrite */)), zTab, zIdx, pzErr)
		iPrev = iRowid
	}
	if (*(*int32)(unsafe.Pointer(bp + 4 /* rc */)) == 0) && ((*sqlite3expert)(unsafe.Pointer(p)).FiSample < 100) {
		*(*int32)(unsafe.Pointer(bp + 4 /* rc */)) = sqlite3.Xsqlite3_exec(tls, (*sqlite3expert)(unsafe.Pointer(p)).Fdbv,
			ts+1691 /* "DROP TABLE IF EX..." */, uintptr(0), uintptr(0), uintptr(0))
	}

	idxFinalize(tls, bp+4 /* &rc */, *(*uintptr)(unsafe.Pointer(bp + 40 /* pAllIndex */)))
	idxFinalize(tls, bp+4 /* &rc */, *(*uintptr)(unsafe.Pointer(bp + 48 /* pIndexXInfo */)))
	idxFinalize(tls, bp+4 /* &rc */, *(*uintptr)(unsafe.Pointer(bp + 56 /* pWrite */)))

	for i = 0; i < (*IdxRemCtx)(unsafe.Pointer(pCtx)).FnSlot; i++ {
		sqlite3.Xsqlite3_free(tls, (*IdxRemSlot)(unsafe.Pointer((pCtx+8 /* &.aSlot */)+uintptr(i)*40)).Fz)
	}
	sqlite3.Xsqlite3_free(tls, pCtx)

	if *(*int32)(unsafe.Pointer(bp + 4 /* rc */)) == 0 {
		*(*int32)(unsafe.Pointer(bp + 4 /* rc */)) = sqlite3.Xsqlite3_exec(tls, (*sqlite3expert)(unsafe.Pointer(p)).Fdbm, ts+2086 /* "ANALYZE sqlite_m..." */, uintptr(0), uintptr(0), uintptr(0))
	}

	sqlite3.Xsqlite3_exec(tls, (*sqlite3expert)(unsafe.Pointer(p)).Fdb, ts+1691 /* "DROP TABLE IF EX..." */, uintptr(0), uintptr(0), uintptr(0))
	return *(*int32)(unsafe.Pointer(bp + 4 /* rc */))
}

// Allocate a new sqlite3expert object.
func sqlite3_expert_new(tls *crt.TLS, db uintptr, pzErrmsg uintptr) uintptr { /* sqlite3expert.c:1738:15: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	*(*int32)(unsafe.Pointer(bp + 16 /* rc */)) = 0
	var pNew uintptr

	pNew = idxMalloc(tls, bp+16 /* &rc */, int32(unsafe.Sizeof(sqlite3expert{})))

	// Open two in-memory databases to work with. The "vtab database" (dbv)
	// will contain a virtual table corresponding to each real table in
	// the user database schema, and a copy of each view. It is used to
	// collect information regarding the WHERE, ORDER BY and other clauses
	// of the user's query.
	if *(*int32)(unsafe.Pointer(bp + 16 /* rc */)) == 0 {
		(*sqlite3expert)(unsafe.Pointer(pNew)).Fdb = db
		(*sqlite3expert)(unsafe.Pointer(pNew)).FiSample = 100
		*(*int32)(unsafe.Pointer(bp + 16 /* rc */)) = sqlite3.Xsqlite3_open(tls, ts+2108 /* ":memory:" */, (pNew + 24 /* &.dbv */))
	}
	if *(*int32)(unsafe.Pointer(bp + 16 /* rc */)) == 0 {
		*(*int32)(unsafe.Pointer(bp + 16 /* rc */)) = sqlite3.Xsqlite3_open(tls, ts+2108 /* ":memory:" */, (pNew + 16 /* &.dbm */))
		if *(*int32)(unsafe.Pointer(bp + 16 /* rc */)) == 0 {
			sqlite3.Xsqlite3_db_config(tls, (*sqlite3expert)(unsafe.Pointer(pNew)).Fdbm, 1008, crt.VaList(bp, 1, uintptr(0)))
		}
	}

	// Copy the entire schema of database [db] into [dbm].
	if *(*int32)(unsafe.Pointer(bp + 16 /* rc */)) == 0 {
		// var pSql uintptr at bp+24, 8

		*(*int32)(unsafe.Pointer(bp + 16 /* rc */)) = idxPrintfPrepareStmt(tls, (*sqlite3expert)(unsafe.Pointer(pNew)).Fdb, bp+24 /* &pSql */, pzErrmsg,

			ts+2117 /* "SELECT sql FROM ..." */, 0)
		for (*(*int32)(unsafe.Pointer(bp + 16 /* rc */)) == 0) && (100 == sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 24 /* pSql */)))) {
			var zSql uintptr = sqlite3.Xsqlite3_column_text(tls, *(*uintptr)(unsafe.Pointer(bp + 24 /* pSql */)), 0)
			*(*int32)(unsafe.Pointer(bp + 16 /* rc */)) = sqlite3.Xsqlite3_exec(tls, (*sqlite3expert)(unsafe.Pointer(pNew)).Fdbm, zSql, uintptr(0), uintptr(0), pzErrmsg)
		}
		idxFinalize(tls, bp+16 /* &rc */, *(*uintptr)(unsafe.Pointer(bp + 24 /* pSql */)))
	}

	// Create the vtab schema
	if *(*int32)(unsafe.Pointer(bp + 16 /* rc */)) == 0 {
		*(*int32)(unsafe.Pointer(bp + 16 /* rc */)) = idxCreateVtabSchema(tls, pNew, pzErrmsg)
	}

	// Register the auth callback with dbv
	if *(*int32)(unsafe.Pointer(bp + 16 /* rc */)) == 0 {
		sqlite3.Xsqlite3_set_authorizer(tls, (*sqlite3expert)(unsafe.Pointer(pNew)).Fdbv, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*crt.TLS, uintptr, int32, uintptr, uintptr, uintptr, uintptr) int32
		}{idxAuthCallback})), pNew)
	}

	// If an error has occurred, free the new object and reutrn NULL. Otherwise,
	// return the new sqlite3expert handle.
	if *(*int32)(unsafe.Pointer(bp + 16 /* rc */)) != 0 {
		sqlite3_expert_destroy(tls, pNew)
		pNew = uintptr(0)
	}
	return pNew
}

// Configure an sqlite3expert object.
func sqlite3_expert_config(tls *crt.TLS, p uintptr, op int32, va uintptr) int32 { /* sqlite3expert.c:1799:5: */
	var rc int32 = 0
	var ap va_list
	_ = ap
	ap = va
	switch op {
	case 1:
		{
			var iVal int32 = int32(crt.VaInt32(&ap))
			if iVal < 0 {
				iVal = 0
			}
			if iVal > 100 {
				iVal = 100
			}
			(*sqlite3expert)(unsafe.Pointer(p)).FiSample = iVal
			break
		}
	default:
		rc = 12
		break
	}

	_ = ap
	return rc
}

// Add an SQL statement to the analysis.
func sqlite3_expert_sql(tls *crt.TLS, p uintptr, zSql uintptr, pzErr uintptr) int32 { /* sqlite3expert.c:1823:5: */
	bp := tls.Alloc(20)
	defer tls.Free(20)

	var pScanOrig uintptr = (*sqlite3expert)(unsafe.Pointer(p)).FpScan
	var pStmtOrig uintptr = (*sqlite3expert)(unsafe.Pointer(p)).FpStatement
	*(*int32)(unsafe.Pointer(bp + 16 /* rc */)) = 0
	*(*uintptr)(unsafe.Pointer(bp + 8 /* zStmt */)) = zSql

	if (*sqlite3expert)(unsafe.Pointer(p)).FbRun != 0 {
		return 21
	}

	for ((*(*int32)(unsafe.Pointer(bp + 16 /* rc */)) == 0) && (*(*uintptr)(unsafe.Pointer(bp + 8 /* zStmt */)) != 0)) && (*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8 /* zStmt */)) + uintptr(0))) != 0) {
		*(*uintptr)(unsafe.Pointer(bp /* pStmt */)) = uintptr(0)
		*(*int32)(unsafe.Pointer(bp + 16 /* rc */)) = sqlite3.Xsqlite3_prepare_v2(tls, (*sqlite3expert)(unsafe.Pointer(p)).Fdbv, *(*uintptr)(unsafe.Pointer(bp + 8 /* zStmt */)), -1, bp /* &pStmt */, bp+8 /* &zStmt */)
		if *(*int32)(unsafe.Pointer(bp + 16 /* rc */)) == 0 {
			if *(*uintptr)(unsafe.Pointer(bp /* pStmt */)) != 0 {
				var pNew uintptr
				var z uintptr = sqlite3.Xsqlite3_sql(tls, *(*uintptr)(unsafe.Pointer(bp /* pStmt */)))
				var n int32 = int32(crt.Xstrlen(tls, z))
				pNew = idxMalloc(tls, bp+16 /* &rc */, (int32((uint64(unsafe.Sizeof(IdxStatement{})) + uint64(n)) + uint64(1))))
				if *(*int32)(unsafe.Pointer(bp + 16 /* rc */)) == 0 {
					(*IdxStatement)(unsafe.Pointer(pNew)).FzSql = (pNew + uintptr(1)*40)
					crt.Xmemcpy(tls, (*IdxStatement)(unsafe.Pointer(pNew)).FzSql, z, (uint64(n + 1)))
					(*IdxStatement)(unsafe.Pointer(pNew)).FpNext = (*sqlite3expert)(unsafe.Pointer(p)).FpStatement
					if (*sqlite3expert)(unsafe.Pointer(p)).FpStatement != 0 {
						(*IdxStatement)(unsafe.Pointer(pNew)).FiId = ((*IdxStatement)(unsafe.Pointer((*sqlite3expert)(unsafe.Pointer(p)).FpStatement)).FiId + 1)
					}
					(*sqlite3expert)(unsafe.Pointer(p)).FpStatement = pNew
				}
				sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp /* pStmt */)))
			}
		} else {
			idxDatabaseError(tls, (*sqlite3expert)(unsafe.Pointer(p)).Fdbv, pzErr)
		}
	}

	if *(*int32)(unsafe.Pointer(bp + 16 /* rc */)) != 0 {
		idxScanFree(tls, (*sqlite3expert)(unsafe.Pointer(p)).FpScan, pScanOrig)
		idxStatementFree(tls, (*sqlite3expert)(unsafe.Pointer(p)).FpStatement, pStmtOrig)
		(*sqlite3expert)(unsafe.Pointer(p)).FpScan = pScanOrig
		(*sqlite3expert)(unsafe.Pointer(p)).FpStatement = pStmtOrig
	}

	return *(*int32)(unsafe.Pointer(bp + 16 /* rc */))
}

func sqlite3_expert_analyze(tls *crt.TLS, p uintptr, pzErr uintptr) int32 { /* sqlite3expert.c:1868:5: */
	bp := tls.Alloc(28)
	defer tls.Free(28)

	// var rc int32 at bp+24, 4

	var pEntry uintptr

	// Do trigger processing to collect any extra IdxScan structures
	*(*int32)(unsafe.Pointer(bp + 24 /* rc */)) = idxProcessTriggers(tls, p, pzErr)

	// Create candidate indexes within the in-memory database file
	if *(*int32)(unsafe.Pointer(bp + 24 /* rc */)) == 0 {
		*(*int32)(unsafe.Pointer(bp + 24 /* rc */)) = idxCreateCandidates(tls, p)
	}

	// Generate the stat1 data
	if *(*int32)(unsafe.Pointer(bp + 24 /* rc */)) == 0 {
		*(*int32)(unsafe.Pointer(bp + 24 /* rc */)) = idxPopulateStat1(tls, p, pzErr)
	}

	// Formulate the EXPERT_REPORT_CANDIDATES text
	for pEntry = (*sqlite3expert)(unsafe.Pointer(p)).FhIdx.FpFirst; pEntry != 0; pEntry = (*IdxHashEntry)(unsafe.Pointer(pEntry)).FpNext {
		(*sqlite3expert)(unsafe.Pointer(p)).FzCandidates = idxAppendText(tls, bp+24 /* &rc */, (*sqlite3expert)(unsafe.Pointer(p)).FzCandidates,
			ts+2216 /* "%s;%s%s\n" */, crt.VaList(bp, (*IdxHashEntry)(unsafe.Pointer(pEntry)).FzVal,
				func() uintptr {
					if (*IdxHashEntry)(unsafe.Pointer(pEntry)).FzVal2 != 0 {
						return ts + 2225 /* " -- stat1: " */
					}
					return ts + 792 /* "" */
				}(), (*IdxHashEntry)(unsafe.Pointer(pEntry)).FzVal2))
	}

	// Figure out which of the candidate indexes are preferred by the query
	// planner and report the results to the user.
	if *(*int32)(unsafe.Pointer(bp + 24 /* rc */)) == 0 {
		*(*int32)(unsafe.Pointer(bp + 24 /* rc */)) = idxFindIndexes(tls, p, pzErr)
	}

	if *(*int32)(unsafe.Pointer(bp + 24 /* rc */)) == 0 {
		(*sqlite3expert)(unsafe.Pointer(p)).FbRun = 1
	}
	return *(*int32)(unsafe.Pointer(bp + 24 /* rc */))
}

// Return the total number of statements that have been added to this
// sqlite3expert using sqlite3_expert_sql().
func sqlite3_expert_count(tls *crt.TLS, p uintptr) int32 { /* sqlite3expert.c:1909:5: */
	var nRet int32 = 0
	if (*sqlite3expert)(unsafe.Pointer(p)).FpStatement != 0 {
		nRet = ((*IdxStatement)(unsafe.Pointer((*sqlite3expert)(unsafe.Pointer(p)).FpStatement)).FiId + 1)
	}
	return nRet
}

// Return a component of the report.
func sqlite3_expert_report(tls *crt.TLS, p uintptr, iStmt int32, eReport int32) uintptr { /* sqlite3expert.c:1918:12: */
	var zRet uintptr = uintptr(0)
	var pStmt uintptr

	if (*sqlite3expert)(unsafe.Pointer(p)).FbRun == 0 {
		return uintptr(0)
	}
	for pStmt = (*sqlite3expert)(unsafe.Pointer(p)).FpStatement; (pStmt != 0) && ((*IdxStatement)(unsafe.Pointer(pStmt)).FiId != iStmt); pStmt = (*IdxStatement)(unsafe.Pointer(pStmt)).FpNext {
	}
	switch eReport {
	case 1:
		if pStmt != 0 {
			zRet = (*IdxStatement)(unsafe.Pointer(pStmt)).FzSql
		}
		break
	case 2:
		if pStmt != 0 {
			zRet = (*IdxStatement)(unsafe.Pointer(pStmt)).FzIdx
		}
		break
	case 3:
		if pStmt != 0 {
			zRet = (*IdxStatement)(unsafe.Pointer(pStmt)).FzEQP
		}
		break
	case 4:
		zRet = (*sqlite3expert)(unsafe.Pointer(p)).FzCandidates
		break
	}
	return zRet
}

// Free an sqlite3expert object.
func sqlite3_expert_destroy(tls *crt.TLS, p uintptr) { /* sqlite3expert.c:1944:6: */
	if p != 0 {
		sqlite3.Xsqlite3_close(tls, (*sqlite3expert)(unsafe.Pointer(p)).Fdbm)
		sqlite3.Xsqlite3_close(tls, (*sqlite3expert)(unsafe.Pointer(p)).Fdbv)
		idxScanFree(tls, (*sqlite3expert)(unsafe.Pointer(p)).FpScan, uintptr(0))
		idxStatementFree(tls, (*sqlite3expert)(unsafe.Pointer(p)).FpStatement, uintptr(0))
		idxTableFree(tls, (*sqlite3expert)(unsafe.Pointer(p)).FpTable)
		idxWriteFree(tls, (*sqlite3expert)(unsafe.Pointer(p)).FpWrite)
		idxHashClear(tls, (p + 88 /* &.hIdx */))
		sqlite3.Xsqlite3_free(tls, (*sqlite3expert)(unsafe.Pointer(p)).FzCandidates)
		sqlite3.Xsqlite3_free(tls, p)
	}
}

// If we are compiling with optimizing read this file.  It contains
//   several optimizing inline functions and macros.

//----------------------------------------------------------------------------
// Support for functions with a variable number of arguments.
//
// The following TCL_VARARGS* macros are to support old extensions
// written for older versions of Tcl where the macros permitted
// support for the varargs.h system as well as stdarg.h .
//
// New code should just directly be written to use stdarg.h conventions.

// Copyright (C) 1989-2018 Free Software Foundation, Inc.
//
//This file is part of GCC.
//
//GCC is free software; you can redistribute it and/or modify
//it under the terms of the GNU General Public License as published by
//the Free Software Foundation; either version 3, or (at your option)
//any later version.
//
//GCC is distributed in the hope that it will be useful,
//but WITHOUT ANY WARRANTY; without even the implied warranty of
//MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//GNU General Public License for more details.
//
//Under Section 7 of GPL version 3, you are granted additional
//permissions described in the GCC Runtime Library Exception, version
//3.1, as published by the Free Software Foundation.
//
//You should have received a copy of the GNU General Public License and
//a copy of the GCC Runtime Library Exception along with this program;
//see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
//<http://www.gnu.org/licenses/>.

// ISO C Standard:  7.15  Variable arguments  <stdarg.h>

// Allow a part of Tcl's API to be explicitly marked as deprecated.
//
// Used to make TIP 330/336 generate moans even if people use the
// compatibility macros. Change your code, guys! We won't support you forever.

//----------------------------------------------------------------------------
// Macros used to declare a function to be exported by a DLL. Used by Windows,
// maps to no-op declarations on non-Windows systems. The default build on
// windows is for a DLL, which causes the DLLIMPORT and DLLEXPORT macros to be
// nonempty. To build a static library, the macro STATIC_BUILD should be
// defined.
//
// Note: when building static but linking dynamically to MSVCRT we must still
//       correctly decorate the C library imported function.  Use CRTIMPORT
//       for this purpose.  _DLL is defined by the compiler when linking to
//       MSVCRT.

// These macros are used to control whether functions are being declared for
// import or export. If a function is being declared while it is being built
// to be included in a shared library, then it should have the DLLEXPORT
// storage class. If is being declared for use by a module that is going to
// link against the shared library, then it should have the DLLIMPORT storage
// class. If the symbol is beind declared for a static build or for use from a
// stub library, then the storage class should be empty.
//
// The convention is that a macro called BUILD_xxxx, where xxxx is the name of
// a library we are building, is set on the compile line for sources that are
// to be placed in the library. When this macro is set, the storage class will
// be set to DLLEXPORT. At the end of the header file, the storage class will
// be reset to DLLIMPORT.

// The following _ANSI_ARGS_ macro is to support old extensions
// written for older versions of Tcl where it permitted support
// for compilers written in the pre-prototype era of C.
//
// New code should use prototypes.

// Definitions that allow this header file to be used either with or without
// ANSI C features.

// Make sure EXTERN isn't defined elsewhere.

//----------------------------------------------------------------------------
// The following code is copied from winnt.h. If we don't replicate it here,
// then <windows.h> can't be included after tcl.h, since tcl.h also defines
// VOID. This block is skipped under Cygwin and Mingw.

// Macro to use instead of "void" for arguments that must have type "void *"
// in ANSI C; maps them to type "char *" in non-ANSI systems.

// Miscellaneous declarations.

type ClientData = uintptr /* tcl.h:340:15 */

// Darwin specific configure overrides (to support fat compiles, where
// configure runs only once for multiple architectures):

// Define Tcl_WideInt to be a type that is (at least) 64-bits wide, and define
// Tcl_WideUInt to be the unsigned variant of that type (assuming that where
// we have one, we can have the other.)
//
// Also defines the following macros:
// TCL_WIDE_INT_IS_LONG - if wide ints are really longs (i.e. we're on a
//	LP64 system such as modern Solaris or Linux ... not including Win64)
// Tcl_WideAsLong - forgetful converter from wideInt to long.
// Tcl_LongAsWide - sign-extending converter from long to wideInt.
// Tcl_WideAsDouble - converter from wideInt to double.
// Tcl_DoubleAsWide - converter from double to wideInt.
//
// The following invariant should hold for any long value 'longVal':
//	longVal == Tcl_WideAsLong(Tcl_LongAsWide(longVal))
//
// Note on converting between Tcl_WideInt and strings. This implementation (in
// tclObj.c) depends on the function
// sprintf(...,"%" TCL_LL_MODIFIER "d",...).

// Don't know what platform it is and configure hasn't discovered what is
// going on for us. Try to guess...
// Copyright (C) 1992-2018 Free Software Foundation, Inc.
//
//This file is part of GCC.
//
//GCC is free software; you can redistribute it and/or modify it under
//the terms of the GNU General Public License as published by the Free
//Software Foundation; either version 3, or (at your option) any later
//version.
//
//GCC is distributed in the hope that it will be useful, but WITHOUT ANY
//WARRANTY; without even the implied warranty of MERCHANTABILITY or
//FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
//for more details.
//
//Under Section 7 of GPL version 3, you are granted additional
//permissions described in the GCC Runtime Library Exception, version
//3.1, as published by the Free Software Foundation.
//
//You should have received a copy of the GNU General Public License and
//a copy of the GCC Runtime Library Exception along with this program;
//see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
//<http://www.gnu.org/licenses/>.

// This administrivia gets added to the beginning of limits.h
//   if the system has its own version of limits.h.

// We use _GCC_LIMITS_H_ because we want this not to match
//   any macros that the system's limits.h uses for its own purposes.

// Use "..." so that we find syslimits.h only in this same directory.
// syslimits.h stands for the system's own limits.h file.
//   If we can use it ok unmodified, then we install this text.
//   If fixincludes fixes it, then the fixed version is installed
//   instead of this text.

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.10/5.2.4.2.1 Sizes of integer types	<limits.h>

// Handle feature test macros at the start of a header.
//   Copyright (C) 2016-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// This header is internal to glibc and should not be included outside
//   of glibc headers.  Headers including it must define
//   __GLIBC_INTERNAL_STARTING_HEADER_IMPLEMENTATION first.  This header
//   cannot have multiple include guards because ISO C feature test
//   macros depend on the definition of the macro when an affected
//   header is included, not when the first system header is
//   included.

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// ISO/IEC TR 24731-2:2010 defines the __STDC_WANT_LIB_EXT2__
//   macro.

// ISO/IEC TS 18661-1:2014 defines the __STDC_WANT_IEC_60559_BFP_EXT__
//   macro.

// ISO/IEC TS 18661-4:2015 defines the
//   __STDC_WANT_IEC_60559_FUNCS_EXT__ macro.

// ISO/IEC TS 18661-3:2015 defines the
//   __STDC_WANT_IEC_60559_TYPES_EXT__ macro.

// Maximum length of any multibyte character in any locale.
//   We define this value here since the gcc header does not define
//   the correct value.

// If we are not using GNU CC we have to define all the symbols ourself.
//   Otherwise use gcc's definitions (see below).

// We only protect from multiple inclusion here, because all the other
//   #include's protect themselves, and in GCC 2 we may #include_next through
//   multiple copies of this file before we get to GCC's.

// Determine the wordsize from the preprocessor defines.

// Both x86-64 and x32 use the 64-bit system call interface.

// We don't have #include_next.
//   Define ANSI <limits.h> for standard 32-bit words.

// These assume 8-bit `char's, 16-bit `short int's,
//   and 32-bit `int's and `long int's.

// Number of bits in a `char'.

// Minimum and maximum values a `signed char' can hold.

// Maximum value an `unsigned char' can hold.  (Minimum is 0.)

// Minimum and maximum values a `char' can hold.

// Minimum and maximum values a `signed short int' can hold.

// Maximum value an `unsigned short int' can hold.  (Minimum is 0.)

// Minimum and maximum values a `signed int' can hold.

// Maximum value an `unsigned int' can hold.  (Minimum is 0.)

// Minimum and maximum values a `signed long int' can hold.

// Maximum value an `unsigned long int' can hold.  (Minimum is 0.)

// Minimum and maximum values a `signed long long int' can hold.

// Maximum value an `unsigned long long int' can hold.  (Minimum is 0.)

// Get the compiler's limits.h, which defines almost all the ISO constants.
//
//    We put this #include_next outside the double inclusion check because
//    it should be possible to include this file more than once and still get
//    the definitions from gcc's header.

// The <limits.h> files in some gcc versions don't define LLONG_MIN,
//   LLONG_MAX, and ULLONG_MAX.  Instead only the values gcc defined for
//   ages are available.

// The integer width macros are not defined by GCC's <limits.h> before
//   GCC 7, or if _GNU_SOURCE rather than
//   __STDC_WANT_IEC_60559_BFP_EXT__ is used to enable this feature.

// POSIX adds things to <limits.h>.
// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

//	POSIX Standard: 2.9.2 Minimum Values	Added to <limits.h>
//
//	Never include this file directly; use <limits.h> instead.

// Determine the wordsize from the preprocessor defines.

// Both x86-64 and x32 use the 64-bit system call interface.

// These are the standard-mandated minimum values.

// Minimum number of operations in one list I/O call.

// Minimal number of outstanding asynchronous I/O operations.

// Maximum length of arguments to `execve', including environment.

// Maximum simultaneous processes per real user ID.

// Minimal number of timer expiration overruns.

// Maximum length of a host name (not including the terminating null)
//   as returned from the GETHOSTNAME function.

// Maximum link count of a file.

// Maximum length of login name.

// Number of bytes in a terminal canonical input queue.

// Number of bytes for which space will be
//   available in a terminal input queue.

// Maximum number of message queues open for a process.

// Maximum number of supported message priorities.

// Number of bytes in a filename.

// Number of simultaneous supplementary group IDs per process.

// Number of files one process can have open at once.

// Number of bytes in a pathname.

// Number of bytes than can be written atomically to a pipe.

// The number of repeated occurrences of a BRE permitted by the
//   REGEXEC and REGCOMP functions when using the interval notation.

// Minimal number of realtime signals reserved for the application.

// Number of semaphores a process can have.

// Maximal value of a semaphore.

// Number of pending realtime signals.

// Largest value of a `ssize_t'.

// Number of streams a process can have open at once.

// The number of bytes in a symbolic link.

// The number of symbolic links that can be traversed in the
//   resolution of a pathname in the absence of a loop.

// Number of timer for a process.

// Maximum number of characters in a tty name.

// Maximum length of a timezone name (element of `tzname').

// Maximum clock resolution in nanoseconds.

// Get the implementation-specific values for the above.
// Minimum guaranteed maximum values for system limits.  Linux version.
//   Copyright (C) 1993-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public License as
//   published by the Free Software Foundation; either version 2.1 of the
//   License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; see the file COPYING.LIB.  If
//   not, see <http://www.gnu.org/licenses/>.

// The kernel header pollutes the namespace with the NR_OPEN symbol
//   and defines LINK_MAX although filesystems have different maxima.  A
//   similar thing is true for OPEN_MAX: the limit can be changed at
//   runtime and therefore the macro must not be defined.  Remove this
//   after including the header if necessary.

// The kernel sources contain a file with all the needed information.
// SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note

// Have to remove NR_OPEN?
// Have to remove LINK_MAX?
// Have to remove OPEN_MAX?
// Have to remove ARG_MAX?

// The number of data keys per process.
// This is the value this implementation supports.

// Controlling the iterations of destructors for thread-specific data.
// Number of iterations this implementation does.

// The number of threads per process.
// We have no predefined limit on the number of threads.

// Maximum amount by which a process can descrease its asynchronous I/O
//   priority level.

// Minimum size for a thread.  We are free to choose a reasonable value.

// Maximum number of timer expiration overruns.

// Maximum tty name length.

// Maximum login name length.  This is arbitrary.

// Maximum host name length.

// Maximum message queue priority level.

// Maximum value the semaphore can have.

// ssize_t is not formally required to be the signed type
//   corresponding to size_t, but it is for all configurations supported
//   by glibc.

// This value is a guaranteed minimum maximum.
//   The current maximum can be got from `sysconf'.

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// Never include this file directly; include <limits.h> instead.

// The maximum `ibase' and `obase' values allowed by the `bc' utility.

// The maximum number of elements allowed in an array by the `bc' utility.

// The maximum `scale' value allowed by the `bc' utility.

// The maximum length of a string constant accepted by the `bc' utility.

// The maximum number of weights that can be assigned to an entry of
//   the LC_COLLATE `order' keyword in the locale definition file.

// The maximum number of expressions that can be nested
//   within parentheses by the `expr' utility.

// The maximum length, in bytes, of an input line.

// The maximum number of repeated occurrences of a regular expression
//   permitted when using the interval notation `\{M,N\}'.

// The maximum number of bytes in a character class name.  We have no
//   fixed limit, 2048 is a high number.

// These values are implementation-specific,
//   and may vary within the implementation.
//   Their precise values can be obtained from sysconf.

// This value is defined like this in regex.h.

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//
//This file is part of GCC.
//
//GCC is free software; you can redistribute it and/or modify it under
//the terms of the GNU General Public License as published by the Free
//Software Foundation; either version 3, or (at your option) any later
//version.
//
//GCC is distributed in the hope that it will be useful, but WITHOUT ANY
//WARRANTY; without even the implied warranty of MERCHANTABILITY or
//FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
//for more details.
//
//Under Section 7 of GPL version 3, you are granted additional
//permissions described in the GCC Runtime Library Exception, version
//3.1, as published by the Free Software Foundation.
//
//You should have received a copy of the GNU General Public License and
//a copy of the GCC Runtime Library Exception along with this program;
//see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
//<http://www.gnu.org/licenses/>.

// Number of bits in a `char'.

// Maximum length of a multibyte character.

// Minimum and maximum values a `signed char' can hold.

// Maximum value an `unsigned char' can hold.  (Minimum is 0).

// Minimum and maximum values a `char' can hold.

// Minimum and maximum values a `signed short int' can hold.

// Maximum value an `unsigned short int' can hold.  (Minimum is 0).

// Minimum and maximum values a `signed int' can hold.

// Maximum value an `unsigned int' can hold.  (Minimum is 0).

// Minimum and maximum values a `signed long int' can hold.
//   (Same as `int').

// Maximum value an `unsigned long int' can hold.  (Minimum is 0).

// Minimum and maximum values a `signed long long int' can hold.

// Maximum value an `unsigned long long int' can hold.  (Minimum is 0).

// This administrivia gets added to the end of limits.h
//   if the system has its own version of limits.h.

type Tcl_WideInt = int64   /* tcl.h:415:28 */
type Tcl_WideUInt = uint64 /* tcl.h:416:36 */

//----------------------------------------------------------------------------
// Data structures defined opaquely in this module. The definitions below just
// provide dummy types. A few fields are made visible in Tcl_Interp
// structures, namely those used for returning a string result from commands.
// Direct access to the result field is discouraged in Tcl 8.0. The
// interpreter result is either an object or a string, and the two values are
// kept consistent unless some C code sets interp->result directly.
// Programmers should use either the function Tcl_GetObjResult() or
// Tcl_GetStringResult() to read the interpreter's result. See the SetResult
// man page for details.
//
// Note: any change to the Tcl_Interp definition below must be mirrored in the
// "real" definition in tclInt.h.
//
// Note: Tcl_ObjCmdProc functions do not directly set result and freeProc.
// Instead, they set a Tcl_Obj member in the "real" structure that can be
// accessed with Tcl_GetObjResult() and Tcl_SetObjResult().

type Tcl_Interp1 = struct {
	FresultDontUse    uintptr
	FfreeProcDontUse  uintptr
	FerrorLineDontUse int32
	_                 [4]byte
}

//----------------------------------------------------------------------------
// Data structures defined opaquely in this module. The definitions below just
// provide dummy types. A few fields are made visible in Tcl_Interp
// structures, namely those used for returning a string result from commands.
// Direct access to the result field is discouraged in Tcl 8.0. The
// interpreter result is either an object or a string, and the two values are
// kept consistent unless some C code sets interp->result directly.
// Programmers should use either the function Tcl_GetObjResult() or
// Tcl_GetStringResult() to read the interpreter's result. See the SetResult
// man page for details.
//
// Note: any change to the Tcl_Interp definition below must be mirrored in the
// "real" definition in tclInt.h.
//
// Note: Tcl_ObjCmdProc functions do not directly set result and freeProc.
// Instead, they set a Tcl_Obj member in the "real" structure that can be
// accessed with Tcl_GetObjResult() and Tcl_SetObjResult().

type Tcl_Interp = Tcl_Interp1 /* tcl.h:525:1 */

type Tcl_AsyncHandler = uintptr       /* tcl.h:527:34 */
type Tcl_Channel = uintptr            /* tcl.h:528:29 */
type Tcl_ChannelTypeVersion = uintptr /* tcl.h:529:40 */
type Tcl_Command = uintptr            /* tcl.h:530:29 */
type Tcl_Condition = uintptr          /* tcl.h:531:31 */
type Tcl_Dict = uintptr               /* tcl.h:532:26 */
type Tcl_EncodingState = uintptr      /* tcl.h:533:35 */
type Tcl_Encoding = uintptr           /* tcl.h:534:30 */
type Tcl_Event1 = struct {
	Fproc    uintptr
	FnextPtr uintptr
}

type Tcl_Event = Tcl_Event1      /* tcl.h:535:26 */
type Tcl_InterpState = uintptr   /* tcl.h:536:33 */
type Tcl_LoadHandle = uintptr    /* tcl.h:537:32 */
type Tcl_Mutex = uintptr         /* tcl.h:538:27 */
type Tcl_Pid = uintptr           /* tcl.h:539:25 */
type Tcl_RegExp = uintptr        /* tcl.h:540:28 */
type Tcl_ThreadDataKey = uintptr /* tcl.h:541:35 */
type Tcl_ThreadId = uintptr      /* tcl.h:542:30 */
type Tcl_TimerToken = uintptr    /* tcl.h:543:32 */
type Tcl_Trace = uintptr         /* tcl.h:544:27 */
type Tcl_Var = uintptr           /* tcl.h:545:25 */
type Tcl_ZlibStream = uintptr    /* tcl.h:546:32 */

// Threading function return types used for abstracting away platform
// differences when writing a Tcl_ThreadCreateProc. See the NewThread function
// in generic/tclThreadTest.c for it's usage.

// Definition of values for default stacksize and the possible flags to be
// given to Tcl_CreateThread.

// Flag values passed to Tcl_StringCaseMatch.

// Flag values passed to Tcl_GetRegExpFromObj.

// Flags values passed to Tcl_RegExpExecObj.

// Structures filled in by Tcl_RegExpInfo. Note that all offset values are
// relative to the start of the match string, not the beginning of the entire
// string.

type Tcl_RegExpIndices1 = struct {
	Fstart int64
	Fend   int64
}

// Threading function return types used for abstracting away platform
// differences when writing a Tcl_ThreadCreateProc. See the NewThread function
// in generic/tclThreadTest.c for it's usage.

// Definition of values for default stacksize and the possible flags to be
// given to Tcl_CreateThread.

// Flag values passed to Tcl_StringCaseMatch.

// Flag values passed to Tcl_GetRegExpFromObj.

// Flags values passed to Tcl_RegExpExecObj.

// Structures filled in by Tcl_RegExpInfo. Note that all offset values are
// relative to the start of the match string, not the beginning of the entire
// string.

type Tcl_RegExpIndices = Tcl_RegExpIndices1 /* tcl.h:628:3 */

type Tcl_RegExpInfo1 = struct {
	Fnsubs       int32
	Fmatches     uintptr
	FextendStart int64
	Freserved    int64
}

type Tcl_RegExpInfo = Tcl_RegExpInfo1 /* tcl.h:637:3 */

// Picky compilers complain if this typdef doesn't appear before the struct's
// reference in tclDecls.h.

type Tcl_Stat_ = uintptr    /* tcl.h:644:21 */
type Tcl_OldStat_ = uintptr /* tcl.h:645:21 */

//----------------------------------------------------------------------------
// When a TCL command returns, the interpreter contains a result from the
// command. Programmers are strongly encouraged to use one of the functions
// Tcl_GetObjResult() or Tcl_GetStringResult() to read the interpreter's
// result. See the SetResult man page for details. Besides this result, the
// command function returns an integer code, which is one of the following:
//
// TCL_OK		Command completed normally; the interpreter's result
//			contains the command's result.
// TCL_ERROR		The command couldn't be completed successfully; the
//			interpreter's result describes what went wrong.
// TCL_RETURN		The command requests that the current function return;
//			the interpreter's result contains the function's
//			return value.
// TCL_BREAK		The command requests that the innermost loop be
//			exited; the interpreter's result is meaningless.
// TCL_CONTINUE		Go on to the next iteration of the current loop; the
//			interpreter's result is meaningless.

//----------------------------------------------------------------------------
// Flags to control what substitutions are performed by Tcl_SubstObj():

// Argument descriptors for math function callbacks in expressions:

type Tcl_ValueType = uint32 /* tcl.h:692:3 */

type Tcl_Value1 = struct {
	Ftype        Tcl_ValueType
	FintValue    int64
	FdoubleValue float64
	FwideValue   Tcl_WideInt
}

type Tcl_Value = Tcl_Value1 /* tcl.h:700:3 */

// Forward declaration of Tcl_Obj to prevent an error when the forward
// reference to Tcl_Obj is encountered in the function types declared below.

type Tcl_Obj1 = struct {
	FrefCount    int32
	Fbytes       uintptr
	Flength      int32
	FtypePtr     uintptr
	FinternalRep struct {
		FlongValue int64
		_          [8]byte
	}
}

//----------------------------------------------------------------------------
// The following structure represents a type of object, which is a particular
// internal representation for an object plus a set of functions that provide
// standard operations on objects of that type.

type Tcl_ObjType1 = struct {
	Fname             uintptr
	FfreeIntRepProc   uintptr
	FdupIntRepProc    uintptr
	FupdateStringProc uintptr
	FsetFromAnyProc   uintptr
}

//----------------------------------------------------------------------------
// The following structure represents a type of object, which is a particular
// internal representation for an object plus a set of functions that provide
// standard operations on objects of that type.

type Tcl_ObjType = Tcl_ObjType1 /* tcl.h:796:3 */

// One of the following structures exists for each object in the Tcl system.
// An object stores a value as either a string, some internal representation,
// or both.

type Tcl_Obj = Tcl_Obj1 /* tcl.h:843:3 */

//----------------------------------------------------------------------------
// The following structure contains the state needed by Tcl_SaveResult. No-one
// outside of Tcl should access any of these fields. This structure is
// typically allocated on the stack.

type Tcl_SavedResult1 = struct {
	Fresult       uintptr
	FfreeProc     uintptr
	FobjResultPtr uintptr
	FappendResult uintptr
	FappendAvl    int32
	FappendUsed   int32
	FresultSpace  [201]int8
	_             [7]byte
}

//----------------------------------------------------------------------------
// The following structure contains the state needed by Tcl_SaveResult. No-one
// outside of Tcl should access any of these fields. This structure is
// typically allocated on the stack.

type Tcl_SavedResult = Tcl_SavedResult1 /* tcl.h:872:3 */

//----------------------------------------------------------------------------
// The following definitions support Tcl's namespace facility. Note: the first
// five fields must match exactly the fields in a Namespace structure (see
// tclInt.h).

type Tcl_Namespace1 = struct {
	Fname       uintptr
	FfullName   uintptr
	FclientData ClientData
	FdeleteProc uintptr
	FparentPtr  uintptr
}

//----------------------------------------------------------------------------
// The following definitions support Tcl's namespace facility. Note: the first
// five fields must match exactly the fields in a Namespace structure (see
// tclInt.h).

type Tcl_Namespace = Tcl_Namespace1 /* tcl.h:897:3 */

//----------------------------------------------------------------------------
// The following structure represents a call frame, or activation record. A
// call frame defines a naming context for a procedure call: its local scope
// (for local variables) and its namespace scope (used for non-local
// variables; often the global :: namespace). A call frame can also define the
// naming context for a namespace eval or namespace inscope command: the
// namespace in which the command's code should execute. The Tcl_CallFrame
// structures exist only while procedures or namespace eval/inscope's are
// being executed, and provide a Tcl call stack.
//
// A call frame is initialized and pushed using Tcl_PushCallFrame and popped
// using Tcl_PopCallFrame. Storage for a Tcl_CallFrame must be provided by the
// Tcl_PushCallFrame caller, and callers typically allocate them on the C call
// stack for efficiency. For this reason, Tcl_CallFrame is defined as a
// structure and not as an opaque token. However, most Tcl_CallFrame fields
// are hidden since applications should not access them directly; others are
// declared as "dummyX".
//
// WARNING!! The structure definition must be kept consistent with the
// CallFrame structure in tclInt.h. If you change one, change the other.

type Tcl_CallFrame1 = struct {
	FnsPtr   uintptr
	Fdummy1  int32
	Fdummy2  int32
	Fdummy3  uintptr
	Fdummy4  uintptr
	Fdummy5  uintptr
	Fdummy6  int32
	Fdummy7  uintptr
	Fdummy8  uintptr
	Fdummy9  int32
	Fdummy10 uintptr
	Fdummy11 uintptr
	Fdummy12 uintptr
	Fdummy13 uintptr
}

//----------------------------------------------------------------------------
// The following structure represents a call frame, or activation record. A
// call frame defines a naming context for a procedure call: its local scope
// (for local variables) and its namespace scope (used for non-local
// variables; often the global :: namespace). A call frame can also define the
// naming context for a namespace eval or namespace inscope command: the
// namespace in which the command's code should execute. The Tcl_CallFrame
// structures exist only while procedures or namespace eval/inscope's are
// being executed, and provide a Tcl call stack.
//
// A call frame is initialized and pushed using Tcl_PushCallFrame and popped
// using Tcl_PopCallFrame. Storage for a Tcl_CallFrame must be provided by the
// Tcl_PushCallFrame caller, and callers typically allocate them on the C call
// stack for efficiency. For this reason, Tcl_CallFrame is defined as a
// structure and not as an opaque token. However, most Tcl_CallFrame fields
// are hidden since applications should not access them directly; others are
// declared as "dummyX".
//
// WARNING!! The structure definition must be kept consistent with the
// CallFrame structure in tclInt.h. If you change one, change the other.

type Tcl_CallFrame = Tcl_CallFrame1 /* tcl.h:937:3 */

//----------------------------------------------------------------------------
// Information about commands that is returned by Tcl_GetCommandInfo and
// passed to Tcl_SetCommandInfo. objProc is an objc/objv object-based command
// function while proc is a traditional Tcl argc/argv string-based function.
// Tcl_CreateObjCommand and Tcl_CreateCommand ensure that both objProc and
// proc are non-NULL and can be called to execute the command. However, it may
// be faster to call one instead of the other. The member isNativeObjectProc
// is set to 1 if an object-based function was registered by
// Tcl_CreateObjCommand, and to 0 if a string-based function was registered by
// Tcl_CreateCommand. The other function is typically set to a compatibility
// wrapper that does string-to-object or object-to-string argument conversions
// then calls the other function.

type Tcl_CmdInfo1 = struct {
	FisNativeObjectProc int32
	FobjProc            uintptr
	FobjClientData      ClientData
	Fproc               uintptr
	FclientData         ClientData
	FdeleteProc         uintptr
	FdeleteData         ClientData
	FnamespacePtr       uintptr
}

//----------------------------------------------------------------------------
// Information about commands that is returned by Tcl_GetCommandInfo and
// passed to Tcl_SetCommandInfo. objProc is an objc/objv object-based command
// function while proc is a traditional Tcl argc/argv string-based function.
// Tcl_CreateObjCommand and Tcl_CreateCommand ensure that both objProc and
// proc are non-NULL and can be called to execute the command. However, it may
// be faster to call one instead of the other. The member isNativeObjectProc
// is set to 1 if an object-based function was registered by
// Tcl_CreateObjCommand, and to 0 if a string-based function was registered by
// Tcl_CreateCommand. The other function is typically set to a compatibility
// wrapper that does string-to-object or object-to-string argument conversions
// then calls the other function.

type Tcl_CmdInfo = Tcl_CmdInfo1 /* tcl.h:973:3 */

//----------------------------------------------------------------------------
// The structure defined below is used to hold dynamic strings. The only
// fields that clients should use are string and length, accessible via the
// macros Tcl_DStringValue and Tcl_DStringLength.

type Tcl_DString1 = struct {
	Fstring      uintptr
	Flength      int32
	FspaceAvl    int32
	FstaticSpace [200]int8
}

//----------------------------------------------------------------------------
// The structure defined below is used to hold dynamic strings. The only
// fields that clients should use are string and length, accessible via the
// macros Tcl_DStringValue and Tcl_DStringLength.

type Tcl_DString = Tcl_DString1 /* tcl.h:993:3 */

// Definitions for the maximum number of digits of precision that may be
// specified in the "tcl_precision" variable, and the number of bytes of
// buffer space required by Tcl_PrintDouble.

// Definition for a number of bytes of buffer space sufficient to hold the
// string representation of an integer in base 10 (assuming the existence of
// 64-bit integers).

// Flag values passed to Tcl_ConvertElement.
// TCL_DONT_USE_BRACES forces it not to enclose the element in braces, but to
//	use backslash quoting instead.
// TCL_DONT_QUOTE_HASH disables the default quoting of the '#' character. It
//	is safe to leave the hash unquoted when the element is not the first
//	element of a list, and this flag can be used by the caller to indicate
//	that condition.

// Flag that may be passed to Tcl_GetIndexFromObj to force it to disallow
// abbreviated strings.

//----------------------------------------------------------------------------
// Flag values passed to Tcl_RecordAndEval, Tcl_EvalObj, Tcl_EvalObjv.
// WARNING: these bit choices must not conflict with the bit choices for
// evalFlag bits in tclInt.h!
//
// Meanings:
//	TCL_NO_EVAL:		Just record this command
//	TCL_EVAL_GLOBAL:	Execute script in global namespace
//	TCL_EVAL_DIRECT:	Do not compile this script
//	TCL_EVAL_INVOKE:	Magical Tcl_EvalObjv mode for aliases/ensembles
//				o Run in iPtr->lookupNsPtr or global namespace
//				o Cut out of error traces
//				o Don't reset the flags controlling ensemble
//				  error message rewriting.
//	TCL_CANCEL_UNWIND:	Magical Tcl_CancelEval mode that causes the
//				stack for the script in progress to be
//				completely unwound.
//	TCL_EVAL_NOERR:	Do no exception reporting at all, just return
//				as the caller will report.

// Special freeProc values that may be passed to Tcl_SetResult (see the man
// page for details):

// Flag values passed to variable-related functions.
// WARNING: these bit choices must not conflict with the bit choice for
// TCL_CANCEL_UNWIND, above.

// Required to support old variable/vdelete/vinfo traces.
// Indicate the semantics of the result of a trace.

// Flag values for ensemble commands.

// Flag values passed to command-related functions.

// The TCL_PARSE_PART1 flag is deprecated and has no effect. The part1 is now
// always parsed whenever the part2 is NULL. (This is to avoid a common error
// when converting code to use the new object based APIs and forgetting to
// give the flag)

// Types for linked variables:

//----------------------------------------------------------------------------
// Forward declarations of Tcl_HashTable and related types.

type Tcl_HashKeyType1 = struct {
	Fversion         int32
	Fflags           int32
	FhashKeyProc     uintptr
	FcompareKeysProc uintptr
	FallocEntryProc  uintptr
	FfreeEntryProc   uintptr
}

// Definitions for the maximum number of digits of precision that may be
// specified in the "tcl_precision" variable, and the number of bytes of
// buffer space required by Tcl_PrintDouble.

// Definition for a number of bytes of buffer space sufficient to hold the
// string representation of an integer in base 10 (assuming the existence of
// 64-bit integers).

// Flag values passed to Tcl_ConvertElement.
// TCL_DONT_USE_BRACES forces it not to enclose the element in braces, but to
//	use backslash quoting instead.
// TCL_DONT_QUOTE_HASH disables the default quoting of the '#' character. It
//	is safe to leave the hash unquoted when the element is not the first
//	element of a list, and this flag can be used by the caller to indicate
//	that condition.

// Flag that may be passed to Tcl_GetIndexFromObj to force it to disallow
// abbreviated strings.

//----------------------------------------------------------------------------
// Flag values passed to Tcl_RecordAndEval, Tcl_EvalObj, Tcl_EvalObjv.
// WARNING: these bit choices must not conflict with the bit choices for
// evalFlag bits in tclInt.h!
//
// Meanings:
//	TCL_NO_EVAL:		Just record this command
//	TCL_EVAL_GLOBAL:	Execute script in global namespace
//	TCL_EVAL_DIRECT:	Do not compile this script
//	TCL_EVAL_INVOKE:	Magical Tcl_EvalObjv mode for aliases/ensembles
//				o Run in iPtr->lookupNsPtr or global namespace
//				o Cut out of error traces
//				o Don't reset the flags controlling ensemble
//				  error message rewriting.
//	TCL_CANCEL_UNWIND:	Magical Tcl_CancelEval mode that causes the
//				stack for the script in progress to be
//				completely unwound.
//	TCL_EVAL_NOERR:	Do no exception reporting at all, just return
//				as the caller will report.

// Special freeProc values that may be passed to Tcl_SetResult (see the man
// page for details):

// Flag values passed to variable-related functions.
// WARNING: these bit choices must not conflict with the bit choice for
// TCL_CANCEL_UNWIND, above.

// Required to support old variable/vdelete/vinfo traces.
// Indicate the semantics of the result of a trace.

// Flag values for ensemble commands.

// Flag values passed to command-related functions.

// The TCL_PARSE_PART1 flag is deprecated and has no effect. The part1 is now
// always parsed whenever the part2 is NULL. (This is to avoid a common error
// when converting code to use the new object based APIs and forgetting to
// give the flag)

// Types for linked variables:

//----------------------------------------------------------------------------
// Forward declarations of Tcl_HashTable and related types.

type Tcl_HashKeyType = Tcl_HashKeyType1 /* tcl.h:1152:32 */
type Tcl_HashTable1 = struct {
	Fbuckets       uintptr
	FstaticBuckets [4]uintptr
	FnumBuckets    int32
	FnumEntries    int32
	FrebuildSize   int32
	FdownShift     int32
	Fmask          int32
	FkeyType       int32
	FfindProc      uintptr
	FcreateProc    uintptr
	FtypePtr       uintptr
}

type Tcl_HashTable = Tcl_HashTable1 /* tcl.h:1153:30 */
type Tcl_HashEntry1 = struct {
	FnextPtr    uintptr
	FtablePtr   uintptr
	Fhash       uintptr
	FclientData ClientData
	Fkey        struct{ FoneWordValue uintptr }
}

type Tcl_HashEntry = Tcl_HashEntry1 /* tcl.h:1154:30 */

// Structure definition for information used to keep track of searches through
// hash tables:

type Tcl_HashSearch1 = struct {
	FtablePtr     uintptr
	FnextIndex    int32
	FnextEntryPtr uintptr
}

// Structure definition for information used to keep track of searches through
// hash tables:

type Tcl_HashSearch = Tcl_HashSearch1 /* tcl.h:1314:3 */

// Acceptable key types for hash tables:
//
// TCL_STRING_KEYS:		The keys are strings, they are copied into the
//				entry.
// TCL_ONE_WORD_KEYS:		The keys are pointers, the pointer is stored
//				in the entry.
// TCL_CUSTOM_TYPE_KEYS:	The keys are arbitrary types which are copied
//				into the entry.
// TCL_CUSTOM_PTR_KEYS:		The keys are pointers to arbitrary types, the
//				pointer is stored in the entry.
//
// While maintaining binary compatibility the above have to be distinct values
// as they are used to differentiate between old versions of the hash table
// which don't have a typePtr and new ones which do. Once binary compatibility
// is discarded in favour of making more wide spread changes TCL_STRING_KEYS
// can be the same as TCL_CUSTOM_TYPE_KEYS, and TCL_ONE_WORD_KEYS can be the
// same as TCL_CUSTOM_PTR_KEYS because they simply determine how the key is
// accessed from the entry and not the behaviour.

// Structure definition for information used to keep track of searches through
// dictionaries. These fields should not be accessed by code outside
// tclDictObj.c

type Tcl_DictSearch = struct {
	Fnext          uintptr
	Fepoch         int32
	FdictionaryPtr Tcl_Dict
} /* tcl.h:1354:3 */

// Positions to pass to Tcl_QueueEvent:

type Tcl_QueuePosition = uint32 /* tcl.h:1389:3 */

// Values to pass to Tcl_SetServiceMode to specify the behavior of notifier
// event routines.

// The following structure keeps is used to hold a time value, either as an
// absolute time (the number of seconds from the epoch) or as an elapsed time.
// On Unix systems the epoch is Midnight Jan 1, 1970 GMT.

type Tcl_Time1 = struct {
	Fsec  int64
	Fusec int64
}

// Values to pass to Tcl_SetServiceMode to specify the behavior of notifier
// event routines.

// The following structure keeps is used to hold a time value, either as an
// absolute time (the number of seconds from the epoch) or as an elapsed time.
// On Unix systems the epoch is Midnight Jan 1, 1970 GMT.

type Tcl_Time = Tcl_Time1 /* tcl.h:1408:3 */

// struct Tcl_ChannelType:
//
// One such structure exists for each type (kind) of channel. It collects
// together in one place all the functions that are part of the specific
// channel type.
//
// It is recommend that the Tcl_Channel* functions are used to access elements
// of this structure, instead of direct accessing.

type Tcl_ChannelType1 = struct {
	FtypeName         uintptr
	Fversion          Tcl_ChannelTypeVersion
	FcloseProc        uintptr
	FinputProc        uintptr
	FoutputProc       uintptr
	FseekProc         uintptr
	FsetOptionProc    uintptr
	FgetOptionProc    uintptr
	FwatchProc        uintptr
	FgetHandleProc    uintptr
	Fclose2Proc       uintptr
	FblockModeProc    uintptr
	FflushProc        uintptr
	FhandlerProc      uintptr
	FwideSeekProc     uintptr
	FthreadActionProc uintptr
	FtruncateProc     uintptr
}

// struct Tcl_ChannelType:
//
// One such structure exists for each type (kind) of channel. It collects
// together in one place all the functions that are part of the specific
// channel type.
//
// It is recommend that the Tcl_Channel* functions are used to access elements
// of this structure, instead of direct accessing.

type Tcl_ChannelType = Tcl_ChannelType1 /* tcl.h:1592:3 */

// The following flags determine whether the blockModeProc above should set
// the channel into blocking or nonblocking mode. They are passed as arguments
// to the blockModeProc function in the above structure.

//----------------------------------------------------------------------------
// Enum for different types of file paths.

type Tcl_PathType = uint32 /* tcl.h:1613:3 */

// The following structure is used to pass glob type data amongst the various
// glob routines and Tcl_FSMatchInDirectory.

type Tcl_GlobTypeData1 = struct {
	Ftype       int32
	Fperm       int32
	FmacType    uintptr
	FmacCreator uintptr
}

// The following structure is used to pass glob type data amongst the various
// glob routines and Tcl_FSMatchInDirectory.

type Tcl_GlobTypeData = Tcl_GlobTypeData1 /* tcl.h:1625:3 */

type Tcl_FSVersion = uintptr /* tcl.h:1700:31 */

//----------------------------------------------------------------------------
// Data structures related to hooking into the filesystem

// Filesystem version tag.  This was introduced in 8.4.

// struct Tcl_Filesystem:
//
// One such structure exists for each type (kind) of filesystem. It collects
// together in one place all the functions that are part of the specific
// filesystem. Tcl always accesses the filesystem through one of these
// structures.
//
// Not all entries need be non-NULL; any which are NULL are simply ignored.
// However, a complete filesystem should provide all of these functions. The
// explanations in the structure show the importance of each function.

type Tcl_Filesystem1 = struct {
	FtypeName                 uintptr
	FstructureLength          int32
	Fversion                  Tcl_FSVersion
	FpathInFilesystemProc     uintptr
	FdupInternalRepProc       uintptr
	FfreeInternalRepProc      uintptr
	FinternalToNormalizedProc uintptr
	FcreateInternalRepProc    uintptr
	FnormalizePathProc        uintptr
	FfilesystemPathTypeProc   uintptr
	FfilesystemSeparatorProc  uintptr
	FstatProc                 uintptr
	FaccessProc               uintptr
	FopenFileChannelProc      uintptr
	FmatchInDirectoryProc     uintptr
	FutimeProc                uintptr
	FlinkProc                 uintptr
	FlistVolumesProc          uintptr
	FfileAttrStringsProc      uintptr
	FfileAttrsGetProc         uintptr
	FfileAttrsSetProc         uintptr
	FcreateDirectoryProc      uintptr
	FremoveDirectoryProc      uintptr
	FdeleteFileProc           uintptr
	FcopyFileProc             uintptr
	FrenameFileProc           uintptr
	FcopyDirectoryProc        uintptr
	FlstatProc                uintptr
	FloadFileProc             uintptr
	FgetCwdProc               uintptr
	FchdirProc                uintptr
}

//----------------------------------------------------------------------------
// Data structures related to hooking into the filesystem

// Filesystem version tag.  This was introduced in 8.4.

// struct Tcl_Filesystem:
//
// One such structure exists for each type (kind) of filesystem. It collects
// together in one place all the functions that are part of the specific
// filesystem. Tcl always accesses the filesystem through one of these
// structures.
//
// Not all entries need be non-NULL; any which are NULL are simply ignored.
// However, a complete filesystem should provide all of these functions. The
// explanations in the structure show the importance of each function.

type Tcl_Filesystem = Tcl_Filesystem1 /* tcl.h:1873:3 */

// The following definitions are used as values for the 'linkAction' flag to
// Tcl_FSLink, or the linkProc of any filesystem. Any combination of flags can
// be given. For link creation, the linkProc should create a link which
// matches any of the types given.
//
// TCL_CREATE_SYMBOLIC_LINK -	Create a symbolic or soft link.
// TCL_CREATE_HARD_LINK -	Create a hard link.

//----------------------------------------------------------------------------
// The following structure represents the Notifier functions that you can
// override with the Tcl_SetNotifier call.

type Tcl_NotifierProcs1 = struct {
	FsetTimerProc          uintptr
	FwaitForEventProc      uintptr
	FcreateFileHandlerProc uintptr
	FdeleteFileHandlerProc uintptr
	FinitNotifierProc      uintptr
	FfinalizeNotifierProc  uintptr
	FalertNotifierProc     uintptr
	FserviceModeHookProc   uintptr
}

// The following definitions are used as values for the 'linkAction' flag to
// Tcl_FSLink, or the linkProc of any filesystem. Any combination of flags can
// be given. For link creation, the linkProc should create a link which
// matches any of the types given.
//
// TCL_CREATE_SYMBOLIC_LINK -	Create a symbolic or soft link.
// TCL_CREATE_HARD_LINK -	Create a hard link.

//----------------------------------------------------------------------------
// The following structure represents the Notifier functions that you can
// override with the Tcl_SetNotifier call.

type Tcl_NotifierProcs = Tcl_NotifierProcs1 /* tcl.h:1903:3 */

//----------------------------------------------------------------------------
// The following data structures and declarations are for the new Tcl parser.
//
// For each word of a command, and for each piece of a word such as a variable
// reference, one of the following structures is created to describe the
// token.

type Tcl_Token1 = struct {
	Ftype          int32
	Fstart         uintptr
	Fsize          int32
	FnumComponents int32
}

//----------------------------------------------------------------------------
// The following data structures and declarations are for the new Tcl parser.
//
// For each word of a command, and for each piece of a word such as a variable
// reference, one of the following structures is created to describe the
// token.

type Tcl_Token = Tcl_Token1 /* tcl.h:1924:3 */

// Type values defined for Tcl_Token structures. These values are defined as
// mask bits so that it's easy to check for collections of types.
//
// TCL_TOKEN_WORD -		The token describes one word of a command,
//				from the first non-blank character of the word
//				(which may be " or {) up to but not including
//				the space, semicolon, or bracket that
//				terminates the word. NumComponents counts the
//				total number of sub-tokens that make up the
//				word. This includes, for example, sub-tokens
//				of TCL_TOKEN_VARIABLE tokens.
// TCL_TOKEN_SIMPLE_WORD -	This token is just like TCL_TOKEN_WORD except
//				that the word is guaranteed to consist of a
//				single TCL_TOKEN_TEXT sub-token.
// TCL_TOKEN_TEXT -		The token describes a range of literal text
//				that is part of a word. NumComponents is
//				always 0.
// TCL_TOKEN_BS -		The token describes a backslash sequence that
//				must be collapsed. NumComponents is always 0.
// TCL_TOKEN_COMMAND -		The token describes a command whose result
//				must be substituted into the word. The token
//				includes the enclosing brackets. NumComponents
//				is always 0.
// TCL_TOKEN_VARIABLE -		The token describes a variable substitution,
//				including the dollar sign, variable name, and
//				array index (if there is one) up through the
//				right parentheses. NumComponents tells how
//				many additional tokens follow to represent the
//				variable name. The first token will be a
//				TCL_TOKEN_TEXT token that describes the
//				variable name. If the variable is an array
//				reference then there will be one or more
//				additional tokens, of type TCL_TOKEN_TEXT,
//				TCL_TOKEN_BS, TCL_TOKEN_COMMAND, and
//				TCL_TOKEN_VARIABLE, that describe the array
//				index; numComponents counts the total number
//				of nested tokens that make up the variable
//				reference, including sub-tokens of
//				TCL_TOKEN_VARIABLE tokens.
// TCL_TOKEN_SUB_EXPR -		The token describes one subexpression of an
//				expression, from the first non-blank character
//				of the subexpression up to but not including
//				the space, brace, or bracket that terminates
//				the subexpression. NumComponents counts the
//				total number of following subtokens that make
//				up the subexpression; this includes all
//				subtokens for any nested TCL_TOKEN_SUB_EXPR
//				tokens. For example, a numeric value used as a
//				primitive operand is described by a
//				TCL_TOKEN_SUB_EXPR token followed by a
//				TCL_TOKEN_TEXT token. A binary subexpression
//				is described by a TCL_TOKEN_SUB_EXPR token
//				followed by the TCL_TOKEN_OPERATOR token for
//				the operator, then TCL_TOKEN_SUB_EXPR tokens
//				for the left then the right operands.
// TCL_TOKEN_OPERATOR -		The token describes one expression operator.
//				An operator might be the name of a math
//				function such as "abs". A TCL_TOKEN_OPERATOR
//				token is always preceded by one
//				TCL_TOKEN_SUB_EXPR token for the operator's
//				subexpression, and is followed by zero or more
//				TCL_TOKEN_SUB_EXPR tokens for the operator's
//				operands. NumComponents is always 0.
// TCL_TOKEN_EXPAND_WORD -	This token is just like TCL_TOKEN_WORD except
//				that it marks a word that began with the
//				literal character prefix "{*}". This word is
//				marked to be expanded - that is, broken into
//				words after substitution is complete.

// Parsing error types. On any parsing error, one of these values will be
// stored in the error field of the Tcl_Parse structure defined below.

// A structure of the following type is filled in by Tcl_ParseCommand. It
// describes a single command parsed from an input string.

type Tcl_Parse1 = struct {
	FcommentStart    uintptr
	FcommentSize     int32
	FcommandStart    uintptr
	FcommandSize     int32
	FnumWords        int32
	FtokenPtr        uintptr
	FnumTokens       int32
	FtokensAvailable int32
	FerrorType       int32
	Fstring          uintptr
	Fend             uintptr
	Finterp          uintptr
	Fterm            uintptr
	Fincomplete      int32
	FstaticTokens    [20]Tcl_Token
}

// Type values defined for Tcl_Token structures. These values are defined as
// mask bits so that it's easy to check for collections of types.
//
// TCL_TOKEN_WORD -		The token describes one word of a command,
//				from the first non-blank character of the word
//				(which may be " or {) up to but not including
//				the space, semicolon, or bracket that
//				terminates the word. NumComponents counts the
//				total number of sub-tokens that make up the
//				word. This includes, for example, sub-tokens
//				of TCL_TOKEN_VARIABLE tokens.
// TCL_TOKEN_SIMPLE_WORD -	This token is just like TCL_TOKEN_WORD except
//				that the word is guaranteed to consist of a
//				single TCL_TOKEN_TEXT sub-token.
// TCL_TOKEN_TEXT -		The token describes a range of literal text
//				that is part of a word. NumComponents is
//				always 0.
// TCL_TOKEN_BS -		The token describes a backslash sequence that
//				must be collapsed. NumComponents is always 0.
// TCL_TOKEN_COMMAND -		The token describes a command whose result
//				must be substituted into the word. The token
//				includes the enclosing brackets. NumComponents
//				is always 0.
// TCL_TOKEN_VARIABLE -		The token describes a variable substitution,
//				including the dollar sign, variable name, and
//				array index (if there is one) up through the
//				right parentheses. NumComponents tells how
//				many additional tokens follow to represent the
//				variable name. The first token will be a
//				TCL_TOKEN_TEXT token that describes the
//				variable name. If the variable is an array
//				reference then there will be one or more
//				additional tokens, of type TCL_TOKEN_TEXT,
//				TCL_TOKEN_BS, TCL_TOKEN_COMMAND, and
//				TCL_TOKEN_VARIABLE, that describe the array
//				index; numComponents counts the total number
//				of nested tokens that make up the variable
//				reference, including sub-tokens of
//				TCL_TOKEN_VARIABLE tokens.
// TCL_TOKEN_SUB_EXPR -		The token describes one subexpression of an
//				expression, from the first non-blank character
//				of the subexpression up to but not including
//				the space, brace, or bracket that terminates
//				the subexpression. NumComponents counts the
//				total number of following subtokens that make
//				up the subexpression; this includes all
//				subtokens for any nested TCL_TOKEN_SUB_EXPR
//				tokens. For example, a numeric value used as a
//				primitive operand is described by a
//				TCL_TOKEN_SUB_EXPR token followed by a
//				TCL_TOKEN_TEXT token. A binary subexpression
//				is described by a TCL_TOKEN_SUB_EXPR token
//				followed by the TCL_TOKEN_OPERATOR token for
//				the operator, then TCL_TOKEN_SUB_EXPR tokens
//				for the left then the right operands.
// TCL_TOKEN_OPERATOR -		The token describes one expression operator.
//				An operator might be the name of a math
//				function such as "abs". A TCL_TOKEN_OPERATOR
//				token is always preceded by one
//				TCL_TOKEN_SUB_EXPR token for the operator's
//				subexpression, and is followed by zero or more
//				TCL_TOKEN_SUB_EXPR tokens for the operator's
//				operands. NumComponents is always 0.
// TCL_TOKEN_EXPAND_WORD -	This token is just like TCL_TOKEN_WORD except
//				that it marks a word that began with the
//				literal character prefix "{*}". This word is
//				marked to be expanded - that is, broken into
//				words after substitution is complete.

// Parsing error types. On any parsing error, one of these values will be
// stored in the error field of the Tcl_Parse structure defined below.

// A structure of the following type is filled in by Tcl_ParseCommand. It
// describes a single command parsed from an input string.

type Tcl_Parse = Tcl_Parse1 /* tcl.h:2083:3 */

//----------------------------------------------------------------------------
// The following structure represents a user-defined encoding. It collects
// together all the functions that are used by the specific encoding.

type Tcl_EncodingType1 = struct {
	FencodingName uintptr
	FtoUtfProc    uintptr
	FfromUtfProc  uintptr
	FfreeProc     uintptr
	FclientData   ClientData
	FnullSize     int32
	_             [4]byte
}

//----------------------------------------------------------------------------
// The following structure represents a user-defined encoding. It collects
// together all the functions that are used by the specific encoding.

type Tcl_EncodingType = Tcl_EncodingType1 /* tcl.h:2111:3 */

// The following definitions are used as values for the conversion control
// flags argument when converting text from one character set to another:
//
// TCL_ENCODING_START -		Signifies that the source buffer is the first
//				block in a (potentially multi-block) input
//				stream. Tells the conversion function to reset
//				to an initial state and perform any
//				initialization that needs to occur before the
//				first byte is converted. If the source buffer
//				contains the entire input stream to be
//				converted, this flag should be set.
// TCL_ENCODING_END -		Signifies that the source buffer is the last
//				block in a (potentially multi-block) input
//				stream. Tells the conversion routine to
//				perform any finalization that needs to occur
//				after the last byte is converted and then to
//				reset to an initial state. If the source
//				buffer contains the entire input stream to be
//				converted, this flag should be set.
// TCL_ENCODING_STOPONERROR -	If set, then the converter will return
//				immediately upon encountering an invalid byte
//				sequence or a source character that has no
//				mapping in the target encoding. If clear, then
//				the converter will skip the problem,
//				substituting one or more "close" characters in
//				the destination buffer and then continue to
//				convert the source.
// TCL_ENCODING_NO_TERMINATE - 	If set, Tcl_ExternalToUtf will not append a
//				terminating NUL byte.  Knowing that it will
//				not need space to do so, it will fill all
//				dstLen bytes with encoded UTF-8 content, as
//				other circumstances permit.  If clear, the
//				default behavior is to reserve a byte in
//				the dst space for NUL termination, and to
//				append the NUL byte.
// TCL_ENCODING_CHAR_LIMIT -	If set and dstCharsPtr is not NULL, then
//				Tcl_ExternalToUtf takes the initial value
//				of *dstCharsPtr is taken as a limit of the
//				maximum number of chars to produce in the
//				encoded UTF-8 content.  Otherwise, the
//				number of chars produced is controlled only
//				by other limiting factors.

// The following definitions are the error codes returned by the conversion
// routines:
//
// TCL_OK -			All characters were converted.
// TCL_CONVERT_NOSPACE -	The output buffer would not have been large
//				enough for all of the converted data; as many
//				characters as could fit were converted though.
// TCL_CONVERT_MULTIBYTE -	The last few bytes in the source string were
//				the beginning of a multibyte sequence, but
//				more bytes were needed to complete this
//				sequence. A subsequent call to the conversion
//				routine should pass the beginning of this
//				unconverted sequence plus additional bytes
//				from the source stream to properly convert the
//				formerly split-up multibyte sequence.
// TCL_CONVERT_SYNTAX -		The source stream contained an invalid
//				character sequence. This may occur if the
//				input stream has been damaged or if the input
//				encoding method was misidentified. This error
//				is reported only if TCL_ENCODING_STOPONERROR
//				was specified.
// TCL_CONVERT_UNKNOWN -	The source string contained a character that
//				could not be represented in the target
//				encoding. This error is reported only if
//				TCL_ENCODING_STOPONERROR was specified.

// The maximum number of bytes that are necessary to represent a single
// Unicode character in UTF-8. The valid values should be 3, 4 or 6
// (or perhaps 1 if we want to support a non-unicode enabled core). If 3 or
// 4, then Tcl_UniChar must be 2-bytes in size (UCS-2) (the default). If 6,
// then Tcl_UniChar must be 4-bytes in size (UCS-4). At this time UCS-2 mode
// is the default and recommended mode. UCS-4 is experimental and not
// recommended. It works for the core, but most extensions expect UCS-2.

// This represents a Unicode character. Any changes to this should also be
// reflected in regcustom.h.

type Tcl_UniChar = uint16 /* tcl.h:2228:24 */

//----------------------------------------------------------------------------
// TIP #59: The following structure is used in calls 'Tcl_RegisterConfig' to
// provide the system with the embedded configuration data.

type Tcl_Config1 = struct {
	Fkey   uintptr
	Fvalue uintptr
}

//----------------------------------------------------------------------------
// TIP #59: The following structure is used in calls 'Tcl_RegisterConfig' to
// provide the system with the embedded configuration data.

type Tcl_Config = Tcl_Config1 /* tcl.h:2242:3 */
type mp_digit = uint32        /* tcl.h:2268:22 */

//----------------------------------------------------------------------------
// Definitions needed for Tcl_ParseArgvObj routines.
// Based on tkArgv.c.
// Modifications from the original are copyright (c) Sam Bromley 2006

type Tcl_ArgvInfo = struct {
	Ftype       int32
	FkeyStr     uintptr
	FsrcPtr     uintptr
	FdstPtr     uintptr
	FhelpStr    uintptr
	FclientData ClientData
} /* tcl.h:2289:3 */

type TclPlatStubs1 = struct {
	Fmagic int32
	Fhooks uintptr
}

type TclStubHooks = struct {
	FtclPlatStubs    uintptr
	FtclIntStubs     uintptr
	FtclIntPlatStubs uintptr
} /* tclDecls.h:1824:3 */

type TclStubs1 = struct {
	Fmagic                                  int32
	Fhooks                                  uintptr
	Ftcl_PkgProvideEx                       uintptr
	Ftcl_PkgRequireEx                       uintptr
	Ftcl_Panic                              uintptr
	Ftcl_Alloc                              uintptr
	Ftcl_Free                               uintptr
	Ftcl_Realloc                            uintptr
	Ftcl_DbCkalloc                          uintptr
	Ftcl_DbCkfree                           uintptr
	Ftcl_DbCkrealloc                        uintptr
	Ftcl_CreateFileHandler                  uintptr
	Ftcl_DeleteFileHandler                  uintptr
	Ftcl_SetTimer                           uintptr
	Ftcl_Sleep                              uintptr
	Ftcl_WaitForEvent                       uintptr
	Ftcl_AppendAllObjTypes                  uintptr
	Ftcl_AppendStringsToObj                 uintptr
	Ftcl_AppendToObj                        uintptr
	Ftcl_ConcatObj                          uintptr
	Ftcl_ConvertToType                      uintptr
	Ftcl_DbDecrRefCount                     uintptr
	Ftcl_DbIncrRefCount                     uintptr
	Ftcl_DbIsShared                         uintptr
	Ftcl_DbNewBooleanObj                    uintptr
	Ftcl_DbNewByteArrayObj                  uintptr
	Ftcl_DbNewDoubleObj                     uintptr
	Ftcl_DbNewListObj                       uintptr
	Ftcl_DbNewLongObj                       uintptr
	Ftcl_DbNewObj                           uintptr
	Ftcl_DbNewStringObj                     uintptr
	Ftcl_DuplicateObj                       uintptr
	FtclFreeObj                             uintptr
	Ftcl_GetBoolean                         uintptr
	Ftcl_GetBooleanFromObj                  uintptr
	Ftcl_GetByteArrayFromObj                uintptr
	Ftcl_GetDouble                          uintptr
	Ftcl_GetDoubleFromObj                   uintptr
	Ftcl_GetIndexFromObj                    uintptr
	Ftcl_GetInt                             uintptr
	Ftcl_GetIntFromObj                      uintptr
	Ftcl_GetLongFromObj                     uintptr
	Ftcl_GetObjType                         uintptr
	Ftcl_GetStringFromObj                   uintptr
	Ftcl_InvalidateStringRep                uintptr
	Ftcl_ListObjAppendList                  uintptr
	Ftcl_ListObjAppendElement               uintptr
	Ftcl_ListObjGetElements                 uintptr
	Ftcl_ListObjIndex                       uintptr
	Ftcl_ListObjLength                      uintptr
	Ftcl_ListObjReplace                     uintptr
	Ftcl_NewBooleanObj                      uintptr
	Ftcl_NewByteArrayObj                    uintptr
	Ftcl_NewDoubleObj                       uintptr
	Ftcl_NewIntObj                          uintptr
	Ftcl_NewListObj                         uintptr
	Ftcl_NewLongObj                         uintptr
	Ftcl_NewObj                             uintptr
	Ftcl_NewStringObj                       uintptr
	Ftcl_SetBooleanObj                      uintptr
	Ftcl_SetByteArrayLength                 uintptr
	Ftcl_SetByteArrayObj                    uintptr
	Ftcl_SetDoubleObj                       uintptr
	Ftcl_SetIntObj                          uintptr
	Ftcl_SetListObj                         uintptr
	Ftcl_SetLongObj                         uintptr
	Ftcl_SetObjLength                       uintptr
	Ftcl_SetStringObj                       uintptr
	Ftcl_AddErrorInfo                       uintptr
	Ftcl_AddObjErrorInfo                    uintptr
	Ftcl_AllowExceptions                    uintptr
	Ftcl_AppendElement                      uintptr
	Ftcl_AppendResult                       uintptr
	Ftcl_AsyncCreate                        uintptr
	Ftcl_AsyncDelete                        uintptr
	Ftcl_AsyncInvoke                        uintptr
	Ftcl_AsyncMark                          uintptr
	Ftcl_AsyncReady                         uintptr
	Ftcl_BackgroundError                    uintptr
	Ftcl_Backslash                          uintptr
	Ftcl_BadChannelOption                   uintptr
	Ftcl_CallWhenDeleted                    uintptr
	Ftcl_CancelIdleCall                     uintptr
	Ftcl_Close                              uintptr
	Ftcl_CommandComplete                    uintptr
	Ftcl_Concat                             uintptr
	Ftcl_ConvertElement                     uintptr
	Ftcl_ConvertCountedElement              uintptr
	Ftcl_CreateAlias                        uintptr
	Ftcl_CreateAliasObj                     uintptr
	Ftcl_CreateChannel                      uintptr
	Ftcl_CreateChannelHandler               uintptr
	Ftcl_CreateCloseHandler                 uintptr
	Ftcl_CreateCommand                      uintptr
	Ftcl_CreateEventSource                  uintptr
	Ftcl_CreateExitHandler                  uintptr
	Ftcl_CreateInterp                       uintptr
	Ftcl_CreateMathFunc                     uintptr
	Ftcl_CreateObjCommand                   uintptr
	Ftcl_CreateSlave                        uintptr
	Ftcl_CreateTimerHandler                 uintptr
	Ftcl_CreateTrace                        uintptr
	Ftcl_DeleteAssocData                    uintptr
	Ftcl_DeleteChannelHandler               uintptr
	Ftcl_DeleteCloseHandler                 uintptr
	Ftcl_DeleteCommand                      uintptr
	Ftcl_DeleteCommandFromToken             uintptr
	Ftcl_DeleteEvents                       uintptr
	Ftcl_DeleteEventSource                  uintptr
	Ftcl_DeleteExitHandler                  uintptr
	Ftcl_DeleteHashEntry                    uintptr
	Ftcl_DeleteHashTable                    uintptr
	Ftcl_DeleteInterp                       uintptr
	Ftcl_DetachPids                         uintptr
	Ftcl_DeleteTimerHandler                 uintptr
	Ftcl_DeleteTrace                        uintptr
	Ftcl_DontCallWhenDeleted                uintptr
	Ftcl_DoOneEvent                         uintptr
	Ftcl_DoWhenIdle                         uintptr
	Ftcl_DStringAppend                      uintptr
	Ftcl_DStringAppendElement               uintptr
	Ftcl_DStringEndSublist                  uintptr
	Ftcl_DStringFree                        uintptr
	Ftcl_DStringGetResult                   uintptr
	Ftcl_DStringInit                        uintptr
	Ftcl_DStringResult                      uintptr
	Ftcl_DStringSetLength                   uintptr
	Ftcl_DStringStartSublist                uintptr
	Ftcl_Eof                                uintptr
	Ftcl_ErrnoId                            uintptr
	Ftcl_ErrnoMsg                           uintptr
	Ftcl_Eval                               uintptr
	Ftcl_EvalFile                           uintptr
	Ftcl_EvalObj                            uintptr
	Ftcl_EventuallyFree                     uintptr
	Ftcl_Exit                               uintptr
	Ftcl_ExposeCommand                      uintptr
	Ftcl_ExprBoolean                        uintptr
	Ftcl_ExprBooleanObj                     uintptr
	Ftcl_ExprDouble                         uintptr
	Ftcl_ExprDoubleObj                      uintptr
	Ftcl_ExprLong                           uintptr
	Ftcl_ExprLongObj                        uintptr
	Ftcl_ExprObj                            uintptr
	Ftcl_ExprString                         uintptr
	Ftcl_Finalize                           uintptr
	Ftcl_FindExecutable                     uintptr
	Ftcl_FirstHashEntry                     uintptr
	Ftcl_Flush                              uintptr
	Ftcl_FreeResult                         uintptr
	Ftcl_GetAlias                           uintptr
	Ftcl_GetAliasObj                        uintptr
	Ftcl_GetAssocData                       uintptr
	Ftcl_GetChannel                         uintptr
	Ftcl_GetChannelBufferSize               uintptr
	Ftcl_GetChannelHandle                   uintptr
	Ftcl_GetChannelInstanceData             uintptr
	Ftcl_GetChannelMode                     uintptr
	Ftcl_GetChannelName                     uintptr
	Ftcl_GetChannelOption                   uintptr
	Ftcl_GetChannelType                     uintptr
	Ftcl_GetCommandInfo                     uintptr
	Ftcl_GetCommandName                     uintptr
	Ftcl_GetErrno                           uintptr
	Ftcl_GetHostName                        uintptr
	Ftcl_GetInterpPath                      uintptr
	Ftcl_GetMaster                          uintptr
	Ftcl_GetNameOfExecutable                uintptr
	Ftcl_GetObjResult                       uintptr
	Ftcl_GetOpenFile                        uintptr
	Ftcl_GetPathType                        uintptr
	Ftcl_Gets                               uintptr
	Ftcl_GetsObj                            uintptr
	Ftcl_GetServiceMode                     uintptr
	Ftcl_GetSlave                           uintptr
	Ftcl_GetStdChannel                      uintptr
	Ftcl_GetStringResult                    uintptr
	Ftcl_GetVar                             uintptr
	Ftcl_GetVar2                            uintptr
	Ftcl_GlobalEval                         uintptr
	Ftcl_GlobalEvalObj                      uintptr
	Ftcl_HideCommand                        uintptr
	Ftcl_Init                               uintptr
	Ftcl_InitHashTable                      uintptr
	Ftcl_InputBlocked                       uintptr
	Ftcl_InputBuffered                      uintptr
	Ftcl_InterpDeleted                      uintptr
	Ftcl_IsSafe                             uintptr
	Ftcl_JoinPath                           uintptr
	Ftcl_LinkVar                            uintptr
	Freserved188                            uintptr
	Ftcl_MakeFileChannel                    uintptr
	Ftcl_MakeSafe                           uintptr
	Ftcl_MakeTcpClientChannel               uintptr
	Ftcl_Merge                              uintptr
	Ftcl_NextHashEntry                      uintptr
	Ftcl_NotifyChannel                      uintptr
	Ftcl_ObjGetVar2                         uintptr
	Ftcl_ObjSetVar2                         uintptr
	Ftcl_OpenCommandChannel                 uintptr
	Ftcl_OpenFileChannel                    uintptr
	Ftcl_OpenTcpClient                      uintptr
	Ftcl_OpenTcpServer                      uintptr
	Ftcl_Preserve                           uintptr
	Ftcl_PrintDouble                        uintptr
	Ftcl_PutEnv                             uintptr
	Ftcl_PosixError                         uintptr
	Ftcl_QueueEvent                         uintptr
	Ftcl_Read                               uintptr
	Ftcl_ReapDetachedProcs                  uintptr
	Ftcl_RecordAndEval                      uintptr
	Ftcl_RecordAndEvalObj                   uintptr
	Ftcl_RegisterChannel                    uintptr
	Ftcl_RegisterObjType                    uintptr
	Ftcl_RegExpCompile                      uintptr
	Ftcl_RegExpExec                         uintptr
	Ftcl_RegExpMatch                        uintptr
	Ftcl_RegExpRange                        uintptr
	Ftcl_Release                            uintptr
	Ftcl_ResetResult                        uintptr
	Ftcl_ScanElement                        uintptr
	Ftcl_ScanCountedElement                 uintptr
	Ftcl_SeekOld                            uintptr
	Ftcl_ServiceAll                         uintptr
	Ftcl_ServiceEvent                       uintptr
	Ftcl_SetAssocData                       uintptr
	Ftcl_SetChannelBufferSize               uintptr
	Ftcl_SetChannelOption                   uintptr
	Ftcl_SetCommandInfo                     uintptr
	Ftcl_SetErrno                           uintptr
	Ftcl_SetErrorCode                       uintptr
	Ftcl_SetMaxBlockTime                    uintptr
	Ftcl_SetPanicProc                       uintptr
	Ftcl_SetRecursionLimit                  uintptr
	Ftcl_SetResult                          uintptr
	Ftcl_SetServiceMode                     uintptr
	Ftcl_SetObjErrorCode                    uintptr
	Ftcl_SetObjResult                       uintptr
	Ftcl_SetStdChannel                      uintptr
	Ftcl_SetVar                             uintptr
	Ftcl_SetVar2                            uintptr
	Ftcl_SignalId                           uintptr
	Ftcl_SignalMsg                          uintptr
	Ftcl_SourceRCFile                       uintptr
	Ftcl_SplitList                          uintptr
	Ftcl_SplitPath                          uintptr
	Ftcl_StaticPackage                      uintptr
	Ftcl_StringMatch                        uintptr
	Ftcl_TellOld                            uintptr
	Ftcl_TraceVar                           uintptr
	Ftcl_TraceVar2                          uintptr
	Ftcl_TranslateFileName                  uintptr
	Ftcl_Ungets                             uintptr
	Ftcl_UnlinkVar                          uintptr
	Ftcl_UnregisterChannel                  uintptr
	Ftcl_UnsetVar                           uintptr
	Ftcl_UnsetVar2                          uintptr
	Ftcl_UntraceVar                         uintptr
	Ftcl_UntraceVar2                        uintptr
	Ftcl_UpdateLinkedVar                    uintptr
	Ftcl_UpVar                              uintptr
	Ftcl_UpVar2                             uintptr
	Ftcl_VarEval                            uintptr
	Ftcl_VarTraceInfo                       uintptr
	Ftcl_VarTraceInfo2                      uintptr
	Ftcl_Write                              uintptr
	Ftcl_WrongNumArgs                       uintptr
	Ftcl_DumpActiveMemory                   uintptr
	Ftcl_ValidateAllMemory                  uintptr
	Ftcl_AppendResultVA                     uintptr
	Ftcl_AppendStringsToObjVA               uintptr
	Ftcl_HashStats                          uintptr
	Ftcl_ParseVar                           uintptr
	Ftcl_PkgPresent                         uintptr
	Ftcl_PkgPresentEx                       uintptr
	Ftcl_PkgProvide                         uintptr
	Ftcl_PkgRequire                         uintptr
	Ftcl_SetErrorCodeVA                     uintptr
	Ftcl_VarEvalVA                          uintptr
	Ftcl_WaitPid                            uintptr
	Ftcl_PanicVA                            uintptr
	Ftcl_GetVersion                         uintptr
	Ftcl_InitMemory                         uintptr
	Ftcl_StackChannel                       uintptr
	Ftcl_UnstackChannel                     uintptr
	Ftcl_GetStackedChannel                  uintptr
	Ftcl_SetMainLoop                        uintptr
	Freserved285                            uintptr
	Ftcl_AppendObjToObj                     uintptr
	Ftcl_CreateEncoding                     uintptr
	Ftcl_CreateThreadExitHandler            uintptr
	Ftcl_DeleteThreadExitHandler            uintptr
	Ftcl_DiscardResult                      uintptr
	Ftcl_EvalEx                             uintptr
	Ftcl_EvalObjv                           uintptr
	Ftcl_EvalObjEx                          uintptr
	Ftcl_ExitThread                         uintptr
	Ftcl_ExternalToUtf                      uintptr
	Ftcl_ExternalToUtfDString               uintptr
	Ftcl_FinalizeThread                     uintptr
	Ftcl_FinalizeNotifier                   uintptr
	Ftcl_FreeEncoding                       uintptr
	Ftcl_GetCurrentThread                   uintptr
	Ftcl_GetEncoding                        uintptr
	Ftcl_GetEncodingName                    uintptr
	Ftcl_GetEncodingNames                   uintptr
	Ftcl_GetIndexFromObjStruct              uintptr
	Ftcl_GetThreadData                      uintptr
	Ftcl_GetVar2Ex                          uintptr
	Ftcl_InitNotifier                       uintptr
	Ftcl_MutexLock                          uintptr
	Ftcl_MutexUnlock                        uintptr
	Ftcl_ConditionNotify                    uintptr
	Ftcl_ConditionWait                      uintptr
	Ftcl_NumUtfChars                        uintptr
	Ftcl_ReadChars                          uintptr
	Ftcl_RestoreResult                      uintptr
	Ftcl_SaveResult                         uintptr
	Ftcl_SetSystemEncoding                  uintptr
	Ftcl_SetVar2Ex                          uintptr
	Ftcl_ThreadAlert                        uintptr
	Ftcl_ThreadQueueEvent                   uintptr
	Ftcl_UniCharAtIndex                     uintptr
	Ftcl_UniCharToLower                     uintptr
	Ftcl_UniCharToTitle                     uintptr
	Ftcl_UniCharToUpper                     uintptr
	Ftcl_UniCharToUtf                       uintptr
	Ftcl_UtfAtIndex                         uintptr
	Ftcl_UtfCharComplete                    uintptr
	Ftcl_UtfBackslash                       uintptr
	Ftcl_UtfFindFirst                       uintptr
	Ftcl_UtfFindLast                        uintptr
	Ftcl_UtfNext                            uintptr
	Ftcl_UtfPrev                            uintptr
	Ftcl_UtfToExternal                      uintptr
	Ftcl_UtfToExternalDString               uintptr
	Ftcl_UtfToLower                         uintptr
	Ftcl_UtfToTitle                         uintptr
	Ftcl_UtfToUniChar                       uintptr
	Ftcl_UtfToUpper                         uintptr
	Ftcl_WriteChars                         uintptr
	Ftcl_WriteObj                           uintptr
	Ftcl_GetString                          uintptr
	Ftcl_GetDefaultEncodingDir              uintptr
	Ftcl_SetDefaultEncodingDir              uintptr
	Ftcl_AlertNotifier                      uintptr
	Ftcl_ServiceModeHook                    uintptr
	Ftcl_UniCharIsAlnum                     uintptr
	Ftcl_UniCharIsAlpha                     uintptr
	Ftcl_UniCharIsDigit                     uintptr
	Ftcl_UniCharIsLower                     uintptr
	Ftcl_UniCharIsSpace                     uintptr
	Ftcl_UniCharIsUpper                     uintptr
	Ftcl_UniCharIsWordChar                  uintptr
	Ftcl_UniCharLen                         uintptr
	Ftcl_UniCharNcmp                        uintptr
	Ftcl_UniCharToUtfDString                uintptr
	Ftcl_UtfToUniCharDString                uintptr
	Ftcl_GetRegExpFromObj                   uintptr
	Ftcl_EvalTokens                         uintptr
	Ftcl_FreeParse                          uintptr
	Ftcl_LogCommandInfo                     uintptr
	Ftcl_ParseBraces                        uintptr
	Ftcl_ParseCommand                       uintptr
	Ftcl_ParseExpr                          uintptr
	Ftcl_ParseQuotedString                  uintptr
	Ftcl_ParseVarName                       uintptr
	Ftcl_GetCwd                             uintptr
	Ftcl_Chdir                              uintptr
	Ftcl_Access                             uintptr
	Ftcl_Stat                               uintptr
	Ftcl_UtfNcmp                            uintptr
	Ftcl_UtfNcasecmp                        uintptr
	Ftcl_StringCaseMatch                    uintptr
	Ftcl_UniCharIsControl                   uintptr
	Ftcl_UniCharIsGraph                     uintptr
	Ftcl_UniCharIsPrint                     uintptr
	Ftcl_UniCharIsPunct                     uintptr
	Ftcl_RegExpExecObj                      uintptr
	Ftcl_RegExpGetInfo                      uintptr
	Ftcl_NewUnicodeObj                      uintptr
	Ftcl_SetUnicodeObj                      uintptr
	Ftcl_GetCharLength                      uintptr
	Ftcl_GetUniChar                         uintptr
	Ftcl_GetUnicode                         uintptr
	Ftcl_GetRange                           uintptr
	Ftcl_AppendUnicodeToObj                 uintptr
	Ftcl_RegExpMatchObj                     uintptr
	Ftcl_SetNotifier                        uintptr
	Ftcl_GetAllocMutex                      uintptr
	Ftcl_GetChannelNames                    uintptr
	Ftcl_GetChannelNamesEx                  uintptr
	Ftcl_ProcObjCmd                         uintptr
	Ftcl_ConditionFinalize                  uintptr
	Ftcl_MutexFinalize                      uintptr
	Ftcl_CreateThread                       uintptr
	Ftcl_ReadRaw                            uintptr
	Ftcl_WriteRaw                           uintptr
	Ftcl_GetTopChannel                      uintptr
	Ftcl_ChannelBuffered                    uintptr
	Ftcl_ChannelName                        uintptr
	Ftcl_ChannelVersion                     uintptr
	Ftcl_ChannelBlockModeProc               uintptr
	Ftcl_ChannelCloseProc                   uintptr
	Ftcl_ChannelClose2Proc                  uintptr
	Ftcl_ChannelInputProc                   uintptr
	Ftcl_ChannelOutputProc                  uintptr
	Ftcl_ChannelSeekProc                    uintptr
	Ftcl_ChannelSetOptionProc               uintptr
	Ftcl_ChannelGetOptionProc               uintptr
	Ftcl_ChannelWatchProc                   uintptr
	Ftcl_ChannelGetHandleProc               uintptr
	Ftcl_ChannelFlushProc                   uintptr
	Ftcl_ChannelHandlerProc                 uintptr
	Ftcl_JoinThread                         uintptr
	Ftcl_IsChannelShared                    uintptr
	Ftcl_IsChannelRegistered                uintptr
	Ftcl_CutChannel                         uintptr
	Ftcl_SpliceChannel                      uintptr
	Ftcl_ClearChannelHandlers               uintptr
	Ftcl_IsChannelExisting                  uintptr
	Ftcl_UniCharNcasecmp                    uintptr
	Ftcl_UniCharCaseMatch                   uintptr
	Ftcl_FindHashEntry                      uintptr
	Ftcl_CreateHashEntry                    uintptr
	Ftcl_InitCustomHashTable                uintptr
	Ftcl_InitObjHashTable                   uintptr
	Ftcl_CommandTraceInfo                   uintptr
	Ftcl_TraceCommand                       uintptr
	Ftcl_UntraceCommand                     uintptr
	Ftcl_AttemptAlloc                       uintptr
	Ftcl_AttemptDbCkalloc                   uintptr
	Ftcl_AttemptRealloc                     uintptr
	Ftcl_AttemptDbCkrealloc                 uintptr
	Ftcl_AttemptSetObjLength                uintptr
	Ftcl_GetChannelThread                   uintptr
	Ftcl_GetUnicodeFromObj                  uintptr
	Ftcl_GetMathFuncInfo                    uintptr
	Ftcl_ListMathFuncs                      uintptr
	Ftcl_SubstObj                           uintptr
	Ftcl_DetachChannel                      uintptr
	Ftcl_IsStandardChannel                  uintptr
	Ftcl_FSCopyFile                         uintptr
	Ftcl_FSCopyDirectory                    uintptr
	Ftcl_FSCreateDirectory                  uintptr
	Ftcl_FSDeleteFile                       uintptr
	Ftcl_FSLoadFile                         uintptr
	Ftcl_FSMatchInDirectory                 uintptr
	Ftcl_FSLink                             uintptr
	Ftcl_FSRemoveDirectory                  uintptr
	Ftcl_FSRenameFile                       uintptr
	Ftcl_FSLstat                            uintptr
	Ftcl_FSUtime                            uintptr
	Ftcl_FSFileAttrsGet                     uintptr
	Ftcl_FSFileAttrsSet                     uintptr
	Ftcl_FSFileAttrStrings                  uintptr
	Ftcl_FSStat                             uintptr
	Ftcl_FSAccess                           uintptr
	Ftcl_FSOpenFileChannel                  uintptr
	Ftcl_FSGetCwd                           uintptr
	Ftcl_FSChdir                            uintptr
	Ftcl_FSConvertToPathType                uintptr
	Ftcl_FSJoinPath                         uintptr
	Ftcl_FSSplitPath                        uintptr
	Ftcl_FSEqualPaths                       uintptr
	Ftcl_FSGetNormalizedPath                uintptr
	Ftcl_FSJoinToPath                       uintptr
	Ftcl_FSGetInternalRep                   uintptr
	Ftcl_FSGetTranslatedPath                uintptr
	Ftcl_FSEvalFile                         uintptr
	Ftcl_FSNewNativePath                    uintptr
	Ftcl_FSGetNativePath                    uintptr
	Ftcl_FSFileSystemInfo                   uintptr
	Ftcl_FSPathSeparator                    uintptr
	Ftcl_FSListVolumes                      uintptr
	Ftcl_FSRegister                         uintptr
	Ftcl_FSUnregister                       uintptr
	Ftcl_FSData                             uintptr
	Ftcl_FSGetTranslatedStringPath          uintptr
	Ftcl_FSGetFileSystemForPath             uintptr
	Ftcl_FSGetPathType                      uintptr
	Ftcl_OutputBuffered                     uintptr
	Ftcl_FSMountsChanged                    uintptr
	Ftcl_EvalTokensStandard                 uintptr
	Ftcl_GetTime                            uintptr
	Ftcl_CreateObjTrace                     uintptr
	Ftcl_GetCommandInfoFromToken            uintptr
	Ftcl_SetCommandInfoFromToken            uintptr
	Ftcl_DbNewWideIntObj                    uintptr
	Ftcl_GetWideIntFromObj                  uintptr
	Ftcl_NewWideIntObj                      uintptr
	Ftcl_SetWideIntObj                      uintptr
	Ftcl_AllocStatBuf                       uintptr
	Ftcl_Seek                               uintptr
	Ftcl_Tell                               uintptr
	Ftcl_ChannelWideSeekProc                uintptr
	Ftcl_DictObjPut                         uintptr
	Ftcl_DictObjGet                         uintptr
	Ftcl_DictObjRemove                      uintptr
	Ftcl_DictObjSize                        uintptr
	Ftcl_DictObjFirst                       uintptr
	Ftcl_DictObjNext                        uintptr
	Ftcl_DictObjDone                        uintptr
	Ftcl_DictObjPutKeyList                  uintptr
	Ftcl_DictObjRemoveKeyList               uintptr
	Ftcl_NewDictObj                         uintptr
	Ftcl_DbNewDictObj                       uintptr
	Ftcl_RegisterConfig                     uintptr
	Ftcl_CreateNamespace                    uintptr
	Ftcl_DeleteNamespace                    uintptr
	Ftcl_AppendExportList                   uintptr
	Ftcl_Export                             uintptr
	Ftcl_Import                             uintptr
	Ftcl_ForgetImport                       uintptr
	Ftcl_GetCurrentNamespace                uintptr
	Ftcl_GetGlobalNamespace                 uintptr
	Ftcl_FindNamespace                      uintptr
	Ftcl_FindCommand                        uintptr
	Ftcl_GetCommandFromObj                  uintptr
	Ftcl_GetCommandFullName                 uintptr
	Ftcl_FSEvalFileEx                       uintptr
	Ftcl_SetExitProc                        uintptr
	Ftcl_LimitAddHandler                    uintptr
	Ftcl_LimitRemoveHandler                 uintptr
	Ftcl_LimitReady                         uintptr
	Ftcl_LimitCheck                         uintptr
	Ftcl_LimitExceeded                      uintptr
	Ftcl_LimitSetCommands                   uintptr
	Ftcl_LimitSetTime                       uintptr
	Ftcl_LimitSetGranularity                uintptr
	Ftcl_LimitTypeEnabled                   uintptr
	Ftcl_LimitTypeExceeded                  uintptr
	Ftcl_LimitTypeSet                       uintptr
	Ftcl_LimitTypeReset                     uintptr
	Ftcl_LimitGetCommands                   uintptr
	Ftcl_LimitGetTime                       uintptr
	Ftcl_LimitGetGranularity                uintptr
	Ftcl_SaveInterpState                    uintptr
	Ftcl_RestoreInterpState                 uintptr
	Ftcl_DiscardInterpState                 uintptr
	Ftcl_SetReturnOptions                   uintptr
	Ftcl_GetReturnOptions                   uintptr
	Ftcl_IsEnsemble                         uintptr
	Ftcl_CreateEnsemble                     uintptr
	Ftcl_FindEnsemble                       uintptr
	Ftcl_SetEnsembleSubcommandList          uintptr
	Ftcl_SetEnsembleMappingDict             uintptr
	Ftcl_SetEnsembleUnknownHandler          uintptr
	Ftcl_SetEnsembleFlags                   uintptr
	Ftcl_GetEnsembleSubcommandList          uintptr
	Ftcl_GetEnsembleMappingDict             uintptr
	Ftcl_GetEnsembleUnknownHandler          uintptr
	Ftcl_GetEnsembleFlags                   uintptr
	Ftcl_GetEnsembleNamespace               uintptr
	Ftcl_SetTimeProc                        uintptr
	Ftcl_QueryTimeProc                      uintptr
	Ftcl_ChannelThreadActionProc            uintptr
	Ftcl_NewBignumObj                       uintptr
	Ftcl_DbNewBignumObj                     uintptr
	Ftcl_SetBignumObj                       uintptr
	Ftcl_GetBignumFromObj                   uintptr
	Ftcl_TakeBignumFromObj                  uintptr
	Ftcl_TruncateChannel                    uintptr
	Ftcl_ChannelTruncateProc                uintptr
	Ftcl_SetChannelErrorInterp              uintptr
	Ftcl_GetChannelErrorInterp              uintptr
	Ftcl_SetChannelError                    uintptr
	Ftcl_GetChannelError                    uintptr
	Ftcl_InitBignumFromDouble               uintptr
	Ftcl_GetNamespaceUnknownHandler         uintptr
	Ftcl_SetNamespaceUnknownHandler         uintptr
	Ftcl_GetEncodingFromObj                 uintptr
	Ftcl_GetEncodingSearchPath              uintptr
	Ftcl_SetEncodingSearchPath              uintptr
	Ftcl_GetEncodingNameFromEnvironment     uintptr
	Ftcl_PkgRequireProc                     uintptr
	Ftcl_AppendObjToErrorInfo               uintptr
	Ftcl_AppendLimitedToObj                 uintptr
	Ftcl_Format                             uintptr
	Ftcl_AppendFormatToObj                  uintptr
	Ftcl_ObjPrintf                          uintptr
	Ftcl_AppendPrintfToObj                  uintptr
	Ftcl_CancelEval                         uintptr
	Ftcl_Canceled                           uintptr
	Ftcl_CreatePipe                         uintptr
	Ftcl_NRCreateCommand                    uintptr
	Ftcl_NREvalObj                          uintptr
	Ftcl_NREvalObjv                         uintptr
	Ftcl_NRCmdSwap                          uintptr
	Ftcl_NRAddCallback                      uintptr
	Ftcl_NRCallObjProc                      uintptr
	Ftcl_GetFSDeviceFromStat                uintptr
	Ftcl_GetFSInodeFromStat                 uintptr
	Ftcl_GetModeFromStat                    uintptr
	Ftcl_GetLinkCountFromStat               uintptr
	Ftcl_GetUserIdFromStat                  uintptr
	Ftcl_GetGroupIdFromStat                 uintptr
	Ftcl_GetDeviceTypeFromStat              uintptr
	Ftcl_GetAccessTimeFromStat              uintptr
	Ftcl_GetModificationTimeFromStat        uintptr
	Ftcl_GetChangeTimeFromStat              uintptr
	Ftcl_GetSizeFromStat                    uintptr
	Ftcl_GetBlocksFromStat                  uintptr
	Ftcl_GetBlockSizeFromStat               uintptr
	Ftcl_SetEnsembleParameterList           uintptr
	Ftcl_GetEnsembleParameterList           uintptr
	Ftcl_ParseArgsObjv                      uintptr
	Ftcl_GetErrorLine                       uintptr
	Ftcl_SetErrorLine                       uintptr
	Ftcl_TransferResult                     uintptr
	Ftcl_InterpActive                       uintptr
	Ftcl_BackgroundException                uintptr
	Ftcl_ZlibDeflate                        uintptr
	Ftcl_ZlibInflate                        uintptr
	Ftcl_ZlibCRC32                          uintptr
	Ftcl_ZlibAdler32                        uintptr
	Ftcl_ZlibStreamInit                     uintptr
	Ftcl_ZlibStreamGetCommandName           uintptr
	Ftcl_ZlibStreamEof                      uintptr
	Ftcl_ZlibStreamChecksum                 uintptr
	Ftcl_ZlibStreamPut                      uintptr
	Ftcl_ZlibStreamGet                      uintptr
	Ftcl_ZlibStreamClose                    uintptr
	Ftcl_ZlibStreamReset                    uintptr
	Ftcl_SetStartupScript                   uintptr
	Ftcl_GetStartupScript                   uintptr
	Ftcl_CloseEx                            uintptr
	Ftcl_NRExprObj                          uintptr
	Ftcl_NRSubstObj                         uintptr
	Ftcl_LoadFile                           uintptr
	Ftcl_FindSymbol                         uintptr
	Ftcl_FSUnloadFile                       uintptr
	Ftcl_ZlibStreamSetCompressionDictionary uintptr
}

type TclStubs = TclStubs1 /* tclDecls.h:2485:3 */

// !END!: Do not edit above this line.

// Deprecated Tcl procedures:

// Include platform specific public function declarations that are accessible
// via the stubs table. Make all TclOO symbols MODULE_SCOPE (which only
// has effect on building it as a shared library). See ticket [3010352].

// tclPlatDecls.h --
//
//	Declarations of platform specific Tcl APIs.
//
// Copyright (c) 1998-1999 by Scriptics Corporation.
// All rights reserved.

// WARNING: This file is automatically generated by the tools/genStubs.tcl
// script.  Any modifications to the function declarations below should be made
// in the generic/tcl.decls script.

// TCHAR is needed here for win32, so if it is not defined yet do it here.
// This way, we don't need to include <tchar.h> just for one define.

// !BEGIN!: Do not edit below this line.

// Exported function declarations:

type TclPlatStubs = TclPlatStubs1 /* tclPlatDecls.h:86:3 */

// end block for C++

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:

// Extract an sqlite3* db handle from the object passed as the second
// argument. If successful, set *pDb to point to the db handle and return
// TCL_OK. Otherwise, return TCL_ERROR.
func dbHandleFromObj(tls *crt.TLS, interp uintptr, pObj uintptr, pDb uintptr) int32 { /* test_expert.c:36:12: */
	bp := tls.Alloc(88)
	defer tls.Free(88)

	// var info Tcl_CmdInfo at bp+24, 64

	if 0 == tcl.XTcl_GetCommandInfo(tls, interp, tcl.XTcl_GetString(tls, pObj), bp+24 /* &info */) {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+2237 /* "no such handle: " */, tcl.XTcl_GetString(tls, pObj), 0))
		return 1
	}

	*(*uintptr)(unsafe.Pointer(pDb)) = *(*uintptr)(unsafe.Pointer((*Tcl_CmdInfo)(unsafe.Pointer(bp + 24 /* &info */)).FobjClientData))
	return 0
}

// Tclcmd:  $expert sql SQL
//          $expert analyze
//          $expert count
//          $expert report STMT EREPORT
//          $expert destroy
func testExpertCmd(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_expert.c:55:26: */
	bp := tls.Alloc(212)
	defer tls.Free(212)

	var pExpert uintptr = clientData
	*(*[6]Subcmd)(unsafe.Pointer(bp /* aSub */)) = [6]Subcmd{
		{FzSub: ts + 2254 /* "sql" */, FnArg: 1, FzMsg: ts + 2258 /* "TABLE" */},           // 0
		{FzSub: ts + 2264 /* "analyze" */, FnArg: 0, FzMsg: ts + 792 /* "" */},             // 1
		{FzSub: ts + 2272 /* "count" */, FnArg: 0, FzMsg: ts + 792 /* "" */},               // 2
		{FzSub: ts + 2278 /* "report" */, FnArg: 2, FzMsg: ts + 2285 /* "STMT EREPORT" */}, // 3
		{FzSub: ts + 2298 /* "destroy" */, FnArg: 0, FzMsg: ts + 792 /* "" */},             // 4
		{FzSub: uintptr(0)},
	}
	// var iSub int32 at bp+144, 4

	var rc int32 = 0
	*(*uintptr)(unsafe.Pointer(bp + 152 /* zErr */)) = uintptr(0)

	if objc < 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+2306 /* "SUBCOMMAND ..." */)
		return 1
	}
	rc = tcl.XTcl_GetIndexFromObjStruct(tls, interp,
		*(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)), bp /* &aSub[0] */, int32(unsafe.Sizeof(Subcmd{})), ts+2321 /* "sub-command" */, 0, bp+144 /* &iSub */)
	if rc != 0 {
		return rc
	}
	if objc != (2 + (*Subcmd)(unsafe.Pointer(bp /* &aSub */ +uintptr(*(*int32)(unsafe.Pointer(bp + 144 /* iSub */)))*24)).FnArg) {
		tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, (*Subcmd)(unsafe.Pointer(bp /* &aSub */ +uintptr(*(*int32)(unsafe.Pointer(bp + 144 /* iSub */)))*24)).FzMsg)
		return 1
	}

	switch *(*int32)(unsafe.Pointer(bp + 144 /* iSub */)) {
	case 0:
		{ // sql
			var zArg uintptr = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)))
			rc = sqlite3_expert_sql(tls, pExpert, zArg, bp+152 /* &zErr */)
			break
		}

	case 1:
		{ // analyze
			rc = sqlite3_expert_analyze(tls, pExpert, bp+152 /* &zErr */)
			break
		}

	case 2:
		{ // count
			var n int32 = sqlite3_expert_count(tls, pExpert)
			tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, n))
			break
		}

	case 3:
		{ // report
			*(*[5]uintptr)(unsafe.Pointer(bp + 168 /* aEnum */)) = [5]uintptr{
				ts + 2254 /* "sql" */, ts + 2333 /* "indexes" */, ts + 2341 /* "plan" */, ts + 2346 /* "candidates" */, uintptr(0),
			}
			// var iEnum int32 at bp+208, 4

			// var iStmt int32 at bp+160, 4

			var zReport uintptr

			if (tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)), bp+160 /* &iStmt */) != 0) ||
				(tcl.XTcl_GetIndexFromObjStruct(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(3)*8)), bp+168 /* &aEnum[0] */, int32(unsafe.Sizeof(uintptr(0))), ts+2278 /* "report" */, 0, bp+208 /* &iEnum */) != 0) {
				return 1
			}

			if !(1 == 1) {
				crt.X__assert_fail(tls, ts+2357 /* "1==1" */, ts+2362 /* "testdata/sqlite-..." */, uint32(123), uintptr(unsafe.Pointer(&__func__12)))
			}
			if !(2 == 2) {
				crt.X__assert_fail(tls, ts+2415 /* "2==2" */, ts+2362 /* "testdata/sqlite-..." */, uint32(124), uintptr(unsafe.Pointer(&__func__12)))
			}
			if !(3 == 3) {
				crt.X__assert_fail(tls, ts+2420 /* "3==3" */, ts+2362 /* "testdata/sqlite-..." */, uint32(125), uintptr(unsafe.Pointer(&__func__12)))
			}
			if !(4 == 4) {
				crt.X__assert_fail(tls, ts+2425 /* "4==4" */, ts+2362 /* "testdata/sqlite-..." */, uint32(126), uintptr(unsafe.Pointer(&__func__12)))
			}
			zReport = sqlite3_expert_report(tls, pExpert, *(*int32)(unsafe.Pointer(bp + 160 /* iStmt */)), (1 + *(*int32)(unsafe.Pointer(bp + 208 /* iEnum */))))
			tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, zReport, -1))
			break
		}

	default: // destroy
		if !(*(*int32)(unsafe.Pointer(bp + 144 /* iSub */)) == 4) {
			crt.X__assert_fail(tls, ts+2430 /* "iSub==4" */, ts+2362 /* "testdata/sqlite-..." */, uint32(133), uintptr(unsafe.Pointer(&__func__12)))
		}
		tcl.XTcl_DeleteCommand(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(0)*8))))
		break
	}

	if rc != 0 {
		if *(*uintptr)(unsafe.Pointer(bp + 152 /* zErr */)) != 0 {
			tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, *(*uintptr)(unsafe.Pointer(bp + 152 /* zErr */)), -1))
		} else {
			tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3ErrName(tls, rc), -1))
		}
	}
	sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(bp + 152 /* zErr */)))
	return rc
}

type Subcmd = struct {
	FzSub uintptr
	FnArg int32
	FzMsg uintptr
}

var __func__12 = *(*[14]int8)(unsafe.Pointer(ts + 2438 /* "testExpertCmd" */)) /* test_expert.c:60:2 */

func testExpertDel(tls *crt.TLS, clientData uintptr) { /* test_expert.c:150:27: */
	var pExpert uintptr = clientData
	sqlite3_expert_destroy(tls, pExpert)
}

// sqlite3_expert_new DB
func test_sqlite3_expert_new(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_expert.c:158:26: */
	bp := tls.Alloc(56)
	defer tls.Free(56)

	// var db uintptr at bp+40, 8

	var zCmd uintptr = uintptr(0)
	*(*uintptr)(unsafe.Pointer(bp + 48 /* zErr */)) = uintptr(0)
	var pExpert uintptr
	var rc int32 = 0

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+2452 /* "DB" */)
		return 1
	}
	if dbHandleFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)), bp+40 /* &db */) != 0 {
		return 1
	}

	zCmd = sqlite3.Xsqlite3_mprintf(tls, ts+2455 /* "sqlite3expert%d" */, crt.VaList(bp, crt.PreIncInt32(&iCmd, 1)))
	if zCmd == uintptr(0) {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+8, ts+2471 /* "out of memory" */, uintptr(0)))
		return 1
	}

	pExpert = sqlite3_expert_new(tls, *(*uintptr)(unsafe.Pointer(bp + 40 /* db */)), bp+48 /* &zErr */)
	if pExpert == uintptr(0) {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+24, *(*uintptr)(unsafe.Pointer(bp + 48 /* zErr */)), uintptr(0)))
		rc = 1
	} else {
		var p uintptr = pExpert
		tcl.XTcl_CreateObjCommand(tls, interp, zCmd, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
		}{testExpertCmd})), p, *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, uintptr) }{testExpertDel})))
		tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, zCmd, -1))
	}

	sqlite3.Xsqlite3_free(tls, zCmd)
	sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(bp + 48 /* zErr */)))
	return rc
}

var iCmd int32 = 0 /* test_expert.c:164:14 */

func TestExpert_Init(tls *crt.TLS, interp uintptr) int32 { /* test_expert.c:202:5: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	*(*[1]Cmd)(unsafe.Pointer(bp /* aCmd */)) = [1]Cmd{
		{FzCmd: ts + 2485 /* "sqlite3_expert_n..." */, FxProc: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
		}{test_sqlite3_expert_new}))},
	}
	var i int32

	for i = 0; uint64(i) < (uint64(unsafe.Sizeof([1]Cmd{})) / uint64(unsafe.Sizeof(Cmd{}))); i++ {
		var p uintptr = (bp /* &aCmd */ + uintptr(i)*16)
		tcl.XTcl_CreateObjCommand(tls, interp, (*Cmd)(unsafe.Pointer(p)).FzCmd, (*Cmd)(unsafe.Pointer(p)).FxProc, uintptr(0), uintptr(0))
	}
	return 0
}

type Cmd = struct {
	FzCmd  uintptr
	FxProc uintptr
}

// end block for C++

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:

func Fts5tcl_Init(tls *crt.TLS, interp uintptr) int32 { /* fts5_tcl.c:1150:5: */
	return 0
}

// CAPI3REF: Loadable Extension Thunk
//
// A pointer to the opaque sqlite3_api_routines structure is passed as
// the third parameter to entry points of [loadable extensions].  This
// structure must be typedefed in order to work around compiler warnings
// on some platforms.
type sqlite3_api_routines = sqlite3_api_routines1 /* sqlite3.h:1193:37 */

// This is the function signature used for all extension entry points.  It
// is also defined in the file "loadext.c".
type sqlite3_loadext_entry = uintptr /* sqlite3ext.h:344:13 */

//  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
//    are already defined.
//  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.
//  NetBSD 5 requires the I386_ANSI_H and X86_64_ANSI_H checks here.

// A null pointer constant.

// XPG requires a few symbols from <sys/wait.h> being defined.
// Definitions of flag bits for `waitpid' et al.
//   Copyright (C) 1992-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// Bits in the third argument to `waitpid'.

// Bits in the fourth argument to `waitid'.

// The following values are used by the `waitid' function.

// The Linux kernel defines these bare, rather than an enum,
//   which causes a conflict if the include order is reversed.

type idtype_t = uint32 /* waitflags.h:57:3 */

// Returned by `div'.
type div_t = struct {
	Fquot int32
	Frem  int32
} /* stdlib.h:62:5 */

// Returned by `ldiv'.
type ldiv_t = struct {
	Fquot int64
	Frem  int64
} /* stdlib.h:70:5 */

// Returned by `lldiv'.
type lldiv_t = struct {
	Fquot int64
	Frem  int64
} /* stdlib.h:80:5 */

type u_char = uint8                     /* types.h:33:18 */
type u_short = uint16                   /* types.h:34:19 */
type u_int = uint32                     /* types.h:35:17 */
type u_long = uint64                    /* types.h:36:18 */
type quad_t = int64                     /* types.h:37:18 */
type u_quad_t = uint64                  /* types.h:38:20 */
type fsid_t = struct{ F__val [2]int32 } /* types.h:39:18 */
type loff_t = int64                     /* types.h:42:18 */

type ino_t = uint64 /* types.h:47:17 */

type dev_t = uint64 /* types.h:59:17 */

type gid_t = uint32 /* types.h:64:17 */

type mode_t = uint32 /* types.h:69:18 */

type nlink_t = uint64 /* types.h:74:19 */

type uid_t = uint32 /* types.h:79:17 */

type pid_t = int32 /* types.h:97:17 */

type id_t = uint32 /* types.h:103:16 */

type daddr_t = int32   /* types.h:114:19 */
type caddr_t = uintptr /* types.h:115:19 */

type key_t = int32 /* types.h:121:17 */

// bits/types.h -- definitions of __*_t types underlying *_t types.
//   Copyright (C) 2002-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Returned by `clock'.
type clock_t = int64 /* clock_t.h:7:19 */

// bits/types.h -- definitions of __*_t types underlying *_t types.
//   Copyright (C) 2002-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Clock ID used in clock and timer functions.
type clockid_t = int32 /* clockid_t.h:7:21 */

// bits/types.h -- definitions of __*_t types underlying *_t types.
//   Copyright (C) 2002-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Returned by `time'.
type time_t = int64 /* time_t.h:7:18 */

// bits/types.h -- definitions of __*_t types underlying *_t types.
//   Copyright (C) 2002-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Timer ID returned by `timer_create'.
type timer_t = uintptr /* timer_t.h:7:19 */

// Copyright (C) 1989-2018 Free Software Foundation, Inc.
//
//This file is part of GCC.
//
//GCC is free software; you can redistribute it and/or modify
//it under the terms of the GNU General Public License as published by
//the Free Software Foundation; either version 3, or (at your option)
//any later version.
//
//GCC is distributed in the hope that it will be useful,
//but WITHOUT ANY WARRANTY; without even the implied warranty of
//MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//GNU General Public License for more details.
//
//Under Section 7 of GPL version 3, you are granted additional
//permissions described in the GCC Runtime Library Exception, version
//3.1, as published by the Free Software Foundation.
//
//You should have received a copy of the GNU General Public License and
//a copy of the GCC Runtime Library Exception along with this program;
//see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
//<http://www.gnu.org/licenses/>.

// ISO C Standard:  7.17  Common definitions  <stddef.h>

// Any one of these symbols __need_* means that GNU libc
//   wants us just to define one data type.  So don't define
//   the symbols that indicate this file's entire job has been done.

// This avoids lossage on SunOS but only if stdtypes.h comes first.
//   There's no way to win with the other order!  Sun lossage.

// On 4.3bsd-net2, make sure ansi.h is included, so we have
//   one less case to deal with in the following.
// On FreeBSD 5, machine/ansi.h does not exist anymore...

// In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
//   defined if the corresponding type is *not* defined.
//   FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_.
//   NetBSD defines _I386_ANSI_H_ and _X86_64_ANSI_H_ instead of _ANSI_H_

// Sequent's header files use _PTRDIFF_T_ in some conflicting way.
//   Just ignore it.

// On VxWorks, <type/vxTypesBase.h> may have defined macros like
//   _TYPE_size_t which will typedef size_t.  fixincludes patched the
//   vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
//   not defined, and so that defining this macro defines _GCC_SIZE_T.
//   If we find that the macros are still defined at this point, we must
//   invoke them so that the type is defined as expected.

// In case nobody has defined these types, but we aren't running under
//   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
//   __WCHAR_TYPE__ have reasonable values.  This can happen if the
//   parts of GCC is compiled by an older compiler, that actually
//   include gstddef.h, such as collect2.

// Signed type of difference of two pointers.

// Define this type if we are doing the whole job,
//   or if we want this type in particular.

// Unsigned type of `sizeof' something.

// Define this type if we are doing the whole job,
//   or if we want this type in particular.

// Wide character type.
//   Locale-writers should change this as necessary to
//   be big enough to hold unique values not between 0 and 127,
//   and not (wchar_t) -1, for each defined multibyte character.

// Define this type if we are doing the whole job,
//   or if we want this type in particular.

//  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
//    are already defined.
//  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.
//  NetBSD 5 requires the I386_ANSI_H and X86_64_ANSI_H checks here.

// A null pointer constant.

// Old compatibility names for C types.
type ulong = uint64  /* types.h:148:27 */
type ushort = uint16 /* types.h:149:28 */
type uint = uint32   /* types.h:150:22 */

// These size-specific names are used by some of the inet code.

// Define intN_t types.
//   Copyright (C) 2017-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//   Copyright (C) 2002-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

type int8_t = int8   /* stdint-intn.h:24:18 */
type int16_t = int16 /* stdint-intn.h:25:19 */
type int32_t = int32 /* stdint-intn.h:26:19 */
type int64_t = int64 /* stdint-intn.h:27:19 */

// These were defined by ISO C without the first `_'.
type u_int8_t = uint8   /* types.h:160:23 */
type u_int16_t = uint16 /* types.h:161:28 */
type u_int32_t = uint32 /* types.h:162:22 */
type u_int64_t = uint64 /* types.h:164:27 */

type register_t = int32 /* types.h:169:13 */

// A set of signals to be blocked, unblocked, or waited for.
type sigset_t = struct{ F__val [16]uint64 } /* sigset_t.h:7:20 */

// Get definition of timer specification structures.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//   Copyright (C) 2002-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// A time value that is accurate to the nearest
//   microsecond but also has a range of years.
type timeval = struct {
	Ftv_sec  int64
	Ftv_usec int64
}

// NB: Include guard matches what <linux/time.h> uses.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//   Copyright (C) 2002-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// POSIX.1b structure for a time value.  This is like a `struct timeval' but
//   has nanoseconds instead of microseconds.
type timespec = struct {
	Ftv_sec  int64
	Ftv_nsec int64
}

type suseconds_t = int64 /* select.h:43:23 */

// Some versions of <linux/posix_types.h> define this macros.
// It's easier to assume 8-bit bytes than to get CHAR_BIT.

// fd_set for select and pselect.
type fd_set = struct{ F__fds_bits [16]int64 } /* select.h:70:5 */

// Maximum number of file descriptors in `fd_set'.

// Sometimes the fd_set member is assumed to have this type.
type fd_mask = int64 /* select.h:77:19 */

// Define some inlines helping to catch common problems.

type blksize_t = int64 /* types.h:202:21 */

// Types from the Large File Support interface.
type blkcnt_t = int64    /* types.h:209:20 */ // Type to count number of disk blocks.
type fsblkcnt_t = uint64 /* types.h:213:22 */ // Type to count file system blocks.
type fsfilcnt_t = uint64 /* types.h:217:22 */

// Thread identifiers.  The structure of the attribute type is not
//   exposed on purpose.
type pthread_t = uint64 /* pthreadtypes.h:27:27 */

// Data structures for mutex handling.  The structure of the attribute
//   type is not exposed on purpose.
type pthread_mutexattr_t = struct {
	_       [0]uint32
	F__size [4]int8
} /* pthreadtypes.h:36:3 */

// Data structure for condition variable handling.  The structure of
//   the attribute type is not exposed on purpose.
type pthread_condattr_t = struct {
	_       [0]uint32
	F__size [4]int8
} /* pthreadtypes.h:45:3 */

// Keys for thread-specific data
type pthread_key_t = uint32 /* pthreadtypes.h:49:22 */

// Once-only execution
type pthread_once_t = int32 /* pthreadtypes.h:53:30 */

type pthread_attr_t1 = struct {
	_       [0]uint64
	F__size [56]int8
}

type pthread_attr_t = pthread_attr_t1 /* pthreadtypes.h:62:30 */

type pthread_mutex_t = struct {
	F__data struct {
		F__lock    int32
		F__count   uint32
		F__owner   int32
		F__nusers  uint32
		F__kind    int32
		F__spins   int16
		F__elision int16
		F__list    struct {
			F__prev uintptr
			F__next uintptr
		}
	}
} /* pthreadtypes.h:72:3 */

type pthread_cond_t = struct {
	F__data struct {
		F__0            struct{ F__wseq uint64 }
		F__8            struct{ F__g1_start uint64 }
		F__g_refs       [2]uint32
		F__g_size       [2]uint32
		F__g1_orig_size uint32
		F__wrefs        uint32
		F__g_signals    [2]uint32
	}
} /* pthreadtypes.h:80:3 */

// Data structure for reader-writer lock variable handling.  The
//   structure of the attribute type is deliberately not exposed.
type pthread_rwlock_t = struct {
	F__data struct {
		F__readers       uint32
		F__writers       uint32
		F__wrphase_futex uint32
		F__writers_futex uint32
		F__pad3          uint32
		F__pad4          uint32
		F__cur_writer    int32
		F__shared        int32
		F__rwelision     int8
		F__pad1          [7]uint8
		F__pad2          uint64
		F__flags         uint32
		_                [4]byte
	}
} /* pthreadtypes.h:91:3 */

type pthread_rwlockattr_t = struct {
	_       [0]uint64
	F__size [8]int8
} /* pthreadtypes.h:97:3 */

// POSIX spinlock data type.
type pthread_spinlock_t = int32 /* pthreadtypes.h:103:22 */

// POSIX barriers data type.  The structure of the type is
//   deliberately not exposed.
type pthread_barrier_t = struct {
	_       [0]uint64
	F__size [32]int8
} /* pthreadtypes.h:112:3 */

type pthread_barrierattr_t = struct {
	_       [0]uint32
	F__size [4]int8
} /* pthreadtypes.h:118:3 */

// Forward declaration of objects used by this implementation
type amatch_vtab1 = struct {
	Fbase       sqlite3_vtab
	FzClassName uintptr
	FzDb        uintptr
	FzSelf      uintptr
	FzCostTab   uintptr
	FzVocabTab  uintptr
	FzVocabWord uintptr
	FzVocabLang uintptr
	FpRule      uintptr
	FrIns       amatch_cost
	FrDel       amatch_cost
	FrSub       amatch_cost
	Fdb         uintptr
	FpVCheck    uintptr
	FnCursor    int32
	_           [4]byte
}

// Forward declaration of objects used by this implementation
type amatch_vtab = amatch_vtab1 /* amatch.c:172:28 */
type amatch_cursor1 = struct {
	Fbase      sqlite3_vtab_cursor
	FiRowid    sqlite3_int64
	FiLang     amatch_langid
	FrLimit    amatch_cost
	FnBuf      int32
	FoomErr    int32
	FnWord     int32
	FzBuf      uintptr
	FzInput    uintptr
	FpVtab     uintptr
	FpAllWords uintptr
	FpCurrent  uintptr
	FpCost     uintptr
	FpWord     uintptr
}

type amatch_cursor = amatch_cursor1 /* amatch.c:173:30 */
type amatch_rule1 = struct {
	FpNext uintptr
	FzFrom uintptr
	FrCost amatch_cost
	FiLang amatch_langid
	FnFrom amatch_len
	FnTo   amatch_len
	FzTo   [4]int8
	_      [2]byte
}

type amatch_rule = amatch_rule1 /* amatch.c:174:28 */
type amatch_word1 = struct {
	FpNext  uintptr
	FsCost  amatch_avl
	FsWord  amatch_avl
	FrCost  amatch_cost
	FiSeq   int32
	FzCost  [10]int8
	FnMatch int16
	FzWord  [4]int8
}

type amatch_word = amatch_word1 /* amatch.c:175:28 */
type amatch_avl1 = struct {
	FpWord     uintptr
	FzKey      uintptr
	FpBefore   uintptr
	FpAfter    uintptr
	FpUp       uintptr
	Fheight    int16
	Fimbalance int16
	_          [4]byte
}

type amatch_avl = amatch_avl1 /* amatch.c:176:27 */

// Recompute the amatch_avl.height and amatch_avl.imbalance fields for p.
// Assume that the children of p have correct heights.
func amatchAvlRecomputeHeight(tls *crt.TLS, p uintptr) { /* amatch.c:199:13: */
	var hBefore int16
	if (*amatch_avl)(unsafe.Pointer(p)).FpBefore != 0 {
		hBefore = (*amatch_avl)(unsafe.Pointer((*amatch_avl)(unsafe.Pointer(p)).FpBefore)).Fheight
	} else {
		hBefore = int16(0)
	}
	var hAfter int16
	if (*amatch_avl)(unsafe.Pointer(p)).FpAfter != 0 {
		hAfter = (*amatch_avl)(unsafe.Pointer((*amatch_avl)(unsafe.Pointer(p)).FpAfter)).Fheight
	} else {
		hAfter = int16(0)
	}
	(*amatch_avl)(unsafe.Pointer(p)).Fimbalance = (int16(int32(hBefore) - int32(hAfter))) // -: pAfter higher.  +: pBefore higher
	(*amatch_avl)(unsafe.Pointer(p)).Fheight = (int16((func() int32 {
		if int32(hBefore) > int32(hAfter) {
			return int32(hBefore)
		}
		return int32(hAfter)
	}()) + 1))
}

//     P                B
//    / \              / **   B   Z    ==>     X   P
//  / \                  / ** X   Y                Y   Z
//
func amatchAvlRotateBefore(tls *crt.TLS, pP uintptr) uintptr { /* amatch.c:214:19: */
	var pB uintptr = (*amatch_avl)(unsafe.Pointer(pP)).FpBefore
	var pY uintptr = (*amatch_avl)(unsafe.Pointer(pB)).FpAfter
	(*amatch_avl)(unsafe.Pointer(pB)).FpUp = (*amatch_avl)(unsafe.Pointer(pP)).FpUp
	(*amatch_avl)(unsafe.Pointer(pB)).FpAfter = pP
	(*amatch_avl)(unsafe.Pointer(pP)).FpUp = pB
	(*amatch_avl)(unsafe.Pointer(pP)).FpBefore = pY
	if pY != 0 {
		(*amatch_avl)(unsafe.Pointer(pY)).FpUp = pP
	}
	amatchAvlRecomputeHeight(tls, pP)
	amatchAvlRecomputeHeight(tls, pB)
	return pB
}

//     P                A
//    / \              / **   X   A    ==>     P   Z
//      / \          / **     Y   Z        X   Y
//
func amatchAvlRotateAfter(tls *crt.TLS, pP uintptr) uintptr { /* amatch.c:235:19: */
	var pA uintptr = (*amatch_avl)(unsafe.Pointer(pP)).FpAfter
	var pY uintptr = (*amatch_avl)(unsafe.Pointer(pA)).FpBefore
	(*amatch_avl)(unsafe.Pointer(pA)).FpUp = (*amatch_avl)(unsafe.Pointer(pP)).FpUp
	(*amatch_avl)(unsafe.Pointer(pA)).FpBefore = pP
	(*amatch_avl)(unsafe.Pointer(pP)).FpUp = pA
	(*amatch_avl)(unsafe.Pointer(pP)).FpAfter = pY
	if pY != 0 {
		(*amatch_avl)(unsafe.Pointer(pY)).FpUp = pP
	}
	amatchAvlRecomputeHeight(tls, pP)
	amatchAvlRecomputeHeight(tls, pA)
	return pA
}

// Return a pointer to the pBefore or pAfter pointer in the parent
// of p that points to p.  Or if p is the root node, return pp.
func amatchAvlFromPtr(tls *crt.TLS, p uintptr, pp uintptr) uintptr { /* amatch.c:252:19: */
	var pUp uintptr = (*amatch_avl)(unsafe.Pointer(p)).FpUp
	if pUp == uintptr(0) {
		return pp
	}
	if (*amatch_avl)(unsafe.Pointer(pUp)).FpAfter == p {
		return (pUp + 24 /* &.pAfter */)
	}
	return (pUp + 16 /* &.pBefore */)
}

// Rebalance all nodes starting with p and working up to the root.
// Return the new root.
func amatchAvlBalance(tls *crt.TLS, p uintptr) uintptr { /* amatch.c:263:19: */
	bp := tls.Alloc(8)
	defer tls.Free(8)
	*(*uintptr)(unsafe.Pointer(bp)) = p

	var pTop uintptr = *(*uintptr)(unsafe.Pointer(bp /* p */))
	var pp uintptr
	for *(*uintptr)(unsafe.Pointer(bp /* p */)) != 0 {
		amatchAvlRecomputeHeight(tls, *(*uintptr)(unsafe.Pointer(bp /* p */)))
		if int32((*amatch_avl)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* p */)))).Fimbalance) >= 2 {
			var pB uintptr = (*amatch_avl)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* p */)))).FpBefore
			if int32((*amatch_avl)(unsafe.Pointer(pB)).Fimbalance) < 0 {
				(*amatch_avl)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* p */)))).FpBefore = amatchAvlRotateAfter(tls, pB)
			}
			pp = amatchAvlFromPtr(tls, *(*uintptr)(unsafe.Pointer(bp /* p */)), bp /* &p */)
			*(*uintptr)(unsafe.Pointer(bp /* p */)) = crt.AssignPtrUintptr(pp, amatchAvlRotateBefore(tls, *(*uintptr)(unsafe.Pointer(bp /* p */))))
		} else if int32((*amatch_avl)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* p */)))).Fimbalance) <= (-2) {
			var pA uintptr = (*amatch_avl)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* p */)))).FpAfter
			if int32((*amatch_avl)(unsafe.Pointer(pA)).Fimbalance) > 0 {
				(*amatch_avl)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* p */)))).FpAfter = amatchAvlRotateBefore(tls, pA)
			}
			pp = amatchAvlFromPtr(tls, *(*uintptr)(unsafe.Pointer(bp /* p */)), bp /* &p */)
			*(*uintptr)(unsafe.Pointer(bp /* p */)) = crt.AssignPtrUintptr(pp, amatchAvlRotateAfter(tls, *(*uintptr)(unsafe.Pointer(bp /* p */))))
		}
		pTop = *(*uintptr)(unsafe.Pointer(bp /* p */))
		*(*uintptr)(unsafe.Pointer(bp /* p */)) = (*amatch_avl)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* p */)))).FpUp
	}
	return pTop
}

// Search the tree rooted at p for an entry with zKey.  Return a pointer
// to the entry or return NULL.
func amatchAvlSearch(tls *crt.TLS, p uintptr, zKey uintptr) uintptr { /* amatch.c:288:19: */
	var c int32
	for (p != 0) && ((crt.AssignInt32(&c, crt.Xstrcmp(tls, zKey, (*amatch_avl)(unsafe.Pointer(p)).FzKey))) != 0) {
		if c < 0 {
			p = (*amatch_avl)(unsafe.Pointer(p)).FpBefore
		} else {
			p = (*amatch_avl)(unsafe.Pointer(p)).FpAfter
		}
	}
	return p
}

// Find the first node (the one with the smallest key).
func amatchAvlFirst(tls *crt.TLS, p uintptr) uintptr { /* amatch.c:298:19: */
	if p != 0 {
		for (*amatch_avl)(unsafe.Pointer(p)).FpBefore != 0 {
			p = (*amatch_avl)(unsafe.Pointer(p)).FpBefore
		}
	}
	return p
}

// Insert a new node pNew.  Return NULL on success.  If the key is not
// unique, then do not perform the insert but instead leave pNew unchanged
// and return a pointer to an existing node with the same key.
func amatchAvlInsert(tls *crt.TLS, ppHead uintptr, pNew uintptr) uintptr { /* amatch.c:356:19: */
	var c int32
	var p uintptr = *(*uintptr)(unsafe.Pointer(ppHead))
	if p == uintptr(0) {
		p = pNew
		(*amatch_avl)(unsafe.Pointer(pNew)).FpUp = uintptr(0)
	} else {
		for p != 0 {
			c = crt.Xstrcmp(tls, (*amatch_avl)(unsafe.Pointer(pNew)).FzKey, (*amatch_avl)(unsafe.Pointer(p)).FzKey)
			if c < 0 {
				if (*amatch_avl)(unsafe.Pointer(p)).FpBefore != 0 {
					p = (*amatch_avl)(unsafe.Pointer(p)).FpBefore
				} else {
					(*amatch_avl)(unsafe.Pointer(p)).FpBefore = pNew
					(*amatch_avl)(unsafe.Pointer(pNew)).FpUp = p
					break
				}
			} else if c > 0 {
				if (*amatch_avl)(unsafe.Pointer(p)).FpAfter != 0 {
					p = (*amatch_avl)(unsafe.Pointer(p)).FpAfter
				} else {
					(*amatch_avl)(unsafe.Pointer(p)).FpAfter = pNew
					(*amatch_avl)(unsafe.Pointer(pNew)).FpUp = p
					break
				}
			} else {
				return p
			}
		}
	}
	(*amatch_avl)(unsafe.Pointer(pNew)).FpBefore = uintptr(0)
	(*amatch_avl)(unsafe.Pointer(pNew)).FpAfter = uintptr(0)
	(*amatch_avl)(unsafe.Pointer(pNew)).Fheight = int16(1)
	(*amatch_avl)(unsafe.Pointer(pNew)).Fimbalance = int16(0)
	*(*uintptr)(unsafe.Pointer(ppHead)) = amatchAvlBalance(tls, p)
	// assert( amatchAvlIntegrity(*ppHead) );
	// assert( amatchAvlIntegrity2(*ppHead) );
	return uintptr(0)
}

// Remove node pOld from the tree.  pOld must be an element of the tree or
// the AVL tree will become corrupt.
func amatchAvlRemove(tls *crt.TLS, ppHead uintptr, pOld uintptr) { /* amatch.c:399:13: */
	var ppParent uintptr
	var pBalance uintptr = uintptr(0)
	// assert( amatchAvlSearch(*ppHead, pOld->zKey)==pOld );
	ppParent = amatchAvlFromPtr(tls, pOld, ppHead)
	if ((*amatch_avl)(unsafe.Pointer(pOld)).FpBefore == uintptr(0)) && ((*amatch_avl)(unsafe.Pointer(pOld)).FpAfter == uintptr(0)) {
		*(*uintptr)(unsafe.Pointer(ppParent)) = uintptr(0)
		pBalance = (*amatch_avl)(unsafe.Pointer(pOld)).FpUp
	} else if ((*amatch_avl)(unsafe.Pointer(pOld)).FpBefore != 0) && ((*amatch_avl)(unsafe.Pointer(pOld)).FpAfter != 0) {
		var pX uintptr
		var pY uintptr
		pX = amatchAvlFirst(tls, (*amatch_avl)(unsafe.Pointer(pOld)).FpAfter)
		*(*uintptr)(unsafe.Pointer(amatchAvlFromPtr(tls, pX, uintptr(0)))) = (*amatch_avl)(unsafe.Pointer(pX)).FpAfter
		if (*amatch_avl)(unsafe.Pointer(pX)).FpAfter != 0 {
			(*amatch_avl)(unsafe.Pointer((*amatch_avl)(unsafe.Pointer(pX)).FpAfter)).FpUp = (*amatch_avl)(unsafe.Pointer(pX)).FpUp
		}
		pBalance = (*amatch_avl)(unsafe.Pointer(pX)).FpUp
		(*amatch_avl)(unsafe.Pointer(pX)).FpAfter = (*amatch_avl)(unsafe.Pointer(pOld)).FpAfter
		if (*amatch_avl)(unsafe.Pointer(pX)).FpAfter != 0 {
			(*amatch_avl)(unsafe.Pointer((*amatch_avl)(unsafe.Pointer(pX)).FpAfter)).FpUp = pX
		} else {
			if !(pBalance == pOld) {
				crt.X__assert_fail(tls, ts+2504 /* "pBalance==pOld" */, ts+2519 /* "testdata/sqlite-..." */, uint32(417), uintptr(unsafe.Pointer(&__func__13)))
			}
			pBalance = pX
		}
		(*amatch_avl)(unsafe.Pointer(pX)).FpBefore = crt.AssignUintptr(&pY, (*amatch_avl)(unsafe.Pointer(pOld)).FpBefore)
		if pY != 0 {
			(*amatch_avl)(unsafe.Pointer(pY)).FpUp = pX
		}
		(*amatch_avl)(unsafe.Pointer(pX)).FpUp = (*amatch_avl)(unsafe.Pointer(pOld)).FpUp
		*(*uintptr)(unsafe.Pointer(ppParent)) = pX
	} else if (*amatch_avl)(unsafe.Pointer(pOld)).FpBefore == uintptr(0) {
		*(*uintptr)(unsafe.Pointer(ppParent)) = crt.AssignUintptr(&pBalance, (*amatch_avl)(unsafe.Pointer(pOld)).FpAfter)
		(*amatch_avl)(unsafe.Pointer(pBalance)).FpUp = (*amatch_avl)(unsafe.Pointer(pOld)).FpUp
	} else if (*amatch_avl)(unsafe.Pointer(pOld)).FpAfter == uintptr(0) {
		*(*uintptr)(unsafe.Pointer(ppParent)) = crt.AssignUintptr(&pBalance, (*amatch_avl)(unsafe.Pointer(pOld)).FpBefore)
		(*amatch_avl)(unsafe.Pointer(pBalance)).FpUp = (*amatch_avl)(unsafe.Pointer(pOld)).FpUp
	}
	*(*uintptr)(unsafe.Pointer(ppHead)) = amatchAvlBalance(tls, pBalance)
	(*amatch_avl)(unsafe.Pointer(pOld)).FpUp = uintptr(0)
	(*amatch_avl)(unsafe.Pointer(pOld)).FpBefore = uintptr(0)
	(*amatch_avl)(unsafe.Pointer(pOld)).FpAfter = uintptr(0)
	// assert( amatchAvlIntegrity(*ppHead) );
	// assert( amatchAvlIntegrity2(*ppHead) );
}

var __func__13 = *(*[16]int8)(unsafe.Pointer(ts + 2565 /* "amatchAvlRemove" */)) /* amatch.c:399:67 */
//
// End of the AVL Tree implementation
//

// Various types.
//
// amatch_cost is the "cost" of an edit operation.
//
// amatch_len is the length of a matching string.
//
// amatch_langid is an ruleset identifier.
type amatch_cost = int32   /* amatch.c:452:13 */
type amatch_len = int8     /* amatch.c:453:21 */
type amatch_langid = int32 /* amatch.c:454:13 */

// The two input rule lists are both sorted in order of increasing
// cost.  Merge them together into a single list, sorted by cost, and
// return a pointer to the head of that list.
func amatchMergeRules(tls *crt.TLS, pA uintptr, pB uintptr) uintptr { /* amatch.c:534:20: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	// var head amatch_rule at bp, 32

	var pTail uintptr

	pTail = bp /* &head */
	for (pA != 0) && (pB != 0) {
		if (*amatch_rule)(unsafe.Pointer(pA)).FrCost <= (*amatch_rule)(unsafe.Pointer(pB)).FrCost {
			(*amatch_rule)(unsafe.Pointer(pTail)).FpNext = pA
			pTail = pA
			pA = (*amatch_rule)(unsafe.Pointer(pA)).FpNext
		} else {
			(*amatch_rule)(unsafe.Pointer(pTail)).FpNext = pB
			pTail = pB
			pB = (*amatch_rule)(unsafe.Pointer(pB)).FpNext
		}
	}
	if pA == uintptr(0) {
		(*amatch_rule)(unsafe.Pointer(pTail)).FpNext = pB
	} else {
		(*amatch_rule)(unsafe.Pointer(pTail)).FpNext = pA
	}
	return (*amatch_rule)(unsafe.Pointer(bp /* &head */)).FpNext
}

// Statement pStmt currently points to a row in the amatch data table. This
// function allocates and populates a amatch_rule structure according to
// the content of the row.
//
// If successful, *ppRule is set to point to the new object and SQLITE_OK
// is returned. Otherwise, *ppRule is zeroed, *pzErr may be set to point
// to an error message and an SQLite error code returned.
func amatchLoadOneRule(tls *crt.TLS, p uintptr, pStmt uintptr, ppRule uintptr, pzErr uintptr) int32 { /* amatch.c:567:12: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var iLang sqlite3_int64 = sqlite3.Xsqlite3_column_int64(tls, pStmt, 0)
	var zFrom uintptr = sqlite3.Xsqlite3_column_text(tls, pStmt, 1)
	var zTo uintptr = sqlite3.Xsqlite3_column_text(tls, pStmt, 2)
	var rCost amatch_cost = sqlite3.Xsqlite3_column_int(tls, pStmt, 3)

	var rc int32 = 0               // Return code
	var nFrom int32                // Size of string zFrom, in bytes
	var nTo int32                  // Size of string zTo, in bytes
	var pRule uintptr = uintptr(0) // New rule object to return

	if zFrom == uintptr(0) {
		zFrom = ts + 792 /* "" */
	}
	if zTo == uintptr(0) {
		zTo = ts + 792 /* "" */
	}
	nFrom = int32(crt.Xstrlen(tls, zFrom))
	nTo = int32(crt.Xstrlen(tls, zTo))

	// Silently ignore null transformations
	if crt.Xstrcmp(tls, zFrom, zTo) == 0 {
		if (int32(*(*int8)(unsafe.Pointer(zFrom + uintptr(0)))) == '?') && (int32(*(*int8)(unsafe.Pointer(zFrom + uintptr(1)))) == 0) {
			if ((*amatch_vtab)(unsafe.Pointer(p)).FrSub == 0) || ((*amatch_vtab)(unsafe.Pointer(p)).FrSub > rCost) {
				(*amatch_vtab)(unsafe.Pointer(p)).FrSub = rCost
			}
		}
		*(*uintptr)(unsafe.Pointer(ppRule)) = uintptr(0)
		return 0
	}

	if (rCost <= 0) || (rCost > 1000) {
		*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+2581, /* "%s: cost must be..." */
			crt.VaList(bp, (*amatch_vtab)(unsafe.Pointer(p)).FzClassName, 1000))
		rc = 1
	} else if (nFrom > 50) || (nTo > 50) {
		*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+2615, /* "%s: maximum stri..." */
			crt.VaList(bp+16, (*amatch_vtab)(unsafe.Pointer(p)).FzClassName, 50))
		rc = 1
	} else if (iLang < int64(0)) || (iLang > int64(2147483647)) {
		*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+2647, /* "%s: iLang must b..." */
			crt.VaList(bp+32, (*amatch_vtab)(unsafe.Pointer(p)).FzClassName, 2147483647))
		rc = 1
	} else if (crt.Xstrcmp(tls, zFrom, ts+792 /* "" */) == 0) && (crt.Xstrcmp(tls, zTo, ts+2682 /* "?" */) == 0) {
		if ((*amatch_vtab)(unsafe.Pointer(p)).FrIns == 0) || ((*amatch_vtab)(unsafe.Pointer(p)).FrIns > rCost) {
			(*amatch_vtab)(unsafe.Pointer(p)).FrIns = rCost
		}
	} else if (crt.Xstrcmp(tls, zFrom, ts+2682 /* "?" */) == 0) && (crt.Xstrcmp(tls, zTo, ts+792 /* "" */) == 0) {
		if ((*amatch_vtab)(unsafe.Pointer(p)).FrDel == 0) || ((*amatch_vtab)(unsafe.Pointer(p)).FrDel > rCost) {
			(*amatch_vtab)(unsafe.Pointer(p)).FrDel = rCost
		}
	} else {
		pRule = sqlite3.Xsqlite3_malloc64(tls, (uint64((uint64(unsafe.Sizeof(amatch_rule{})) + uint64(nFrom)) + uint64(nTo))))
		if pRule == uintptr(0) {
			rc = 7
		} else {
			crt.Xmemset(tls, pRule, 0, uint64(unsafe.Sizeof(amatch_rule{})))
			(*amatch_rule)(unsafe.Pointer(pRule)).FzFrom = ((pRule + 26 /* &.zTo */) + uintptr((nTo + 1)))
			(*amatch_rule)(unsafe.Pointer(pRule)).FnFrom = amatch_len(nFrom)
			crt.Xmemcpy(tls, (*amatch_rule)(unsafe.Pointer(pRule)).FzFrom, zFrom, (uint64(nFrom + 1)))
			crt.Xmemcpy(tls, pRule+26 /* &.zTo */, zTo, (uint64(nTo + 1)))
			(*amatch_rule)(unsafe.Pointer(pRule)).FnTo = amatch_len(nTo)
			(*amatch_rule)(unsafe.Pointer(pRule)).FrCost = rCost
			(*amatch_rule)(unsafe.Pointer(pRule)).FiLang = int32(iLang)
		}
	}

	*(*uintptr)(unsafe.Pointer(ppRule)) = pRule
	return rc
}

// Free all the content in the edit-cost-table
func amatchFreeRules(tls *crt.TLS, p uintptr) { /* amatch.c:644:13: */
	for (*amatch_vtab)(unsafe.Pointer(p)).FpRule != 0 {
		var pRule uintptr = (*amatch_vtab)(unsafe.Pointer(p)).FpRule
		(*amatch_vtab)(unsafe.Pointer(p)).FpRule = (*amatch_rule)(unsafe.Pointer(pRule)).FpNext
		sqlite3.Xsqlite3_free(tls, pRule)
	}
	(*amatch_vtab)(unsafe.Pointer(p)).FpRule = uintptr(0)
}

// Load the content of the amatch data table into memory.
func amatchLoadRules(tls *crt.TLS, db uintptr, p uintptr, pzErr uintptr) int32 { /* amatch.c:656:12: */
	bp := tls.Alloc(192)
	defer tls.Free(192)

	var rc int32 = 0 // Return code
	var zSql uintptr // SELECT used to read from rules table
	var pHead uintptr = uintptr(0)

	zSql = sqlite3.Xsqlite3_mprintf(tls, ts+2684 /* "SELECT * FROM %Q..." */, crt.VaList(bp, (*amatch_vtab)(unsafe.Pointer(p)).FzDb, (*amatch_vtab)(unsafe.Pointer(p)).FzCostTab))
	if zSql == uintptr(0) {
		rc = 7
	} else {
		var rc2 int32 // finalize() return code
		*(*uintptr)(unsafe.Pointer(bp + 56 /* pStmt */)) = uintptr(0)
		rc = sqlite3.Xsqlite3_prepare_v2(tls, db, zSql, -1, bp+56 /* &pStmt */, uintptr(0))
		if rc != 0 {
			*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+2704 /* "%s: %s" */, crt.VaList(bp+16, (*amatch_vtab)(unsafe.Pointer(p)).FzClassName, sqlite3.Xsqlite3_errmsg(tls, db)))
		} else if sqlite3.Xsqlite3_column_count(tls, *(*uintptr)(unsafe.Pointer(bp + 56 /* pStmt */))) != 4 {
			*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+2711, /* "%s: %s has %d co..." */
				crt.VaList(bp+32, (*amatch_vtab)(unsafe.Pointer(p)).FzClassName, (*amatch_vtab)(unsafe.Pointer(p)).FzCostTab, sqlite3.Xsqlite3_column_count(tls, *(*uintptr)(unsafe.Pointer(bp + 56 /* pStmt */)))))
			rc = 1
		} else {
			for (rc == 0) && (100 == sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 56 /* pStmt */)))) {
				*(*uintptr)(unsafe.Pointer(bp + 64 /* pRule */)) = uintptr(0)
				rc = amatchLoadOneRule(tls, p, *(*uintptr)(unsafe.Pointer(bp + 56 /* pStmt */)), bp+64 /* &pRule */, pzErr)
				if *(*uintptr)(unsafe.Pointer(bp + 64 /* pRule */)) != 0 {
					(*amatch_rule)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 64 /* pRule */)))).FpNext = pHead
					pHead = *(*uintptr)(unsafe.Pointer(bp + 64 /* pRule */))
				}
			}
		}
		rc2 = sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 56 /* pStmt */)))
		if rc == 0 {
			rc = rc2
		}
	}
	sqlite3.Xsqlite3_free(tls, zSql)

	// All rules are now in a singly linked list starting at pHead. This
	// block sorts them by cost and then sets amatch_vtab.pRule to point to
	// point to the head of the sorted list.
	if rc == 0 {
		var i uint32
		var pX uintptr
		// var a [15]uintptr at bp+72, 120

		for i = uint32(0); uint64(i) < (uint64(unsafe.Sizeof([15]uintptr{})) / uint64(unsafe.Sizeof(uintptr(0)))); i++ {
			*(*uintptr)(unsafe.Pointer(bp + 72 /* &a[0] */ + uintptr(i)*8)) = uintptr(0)
		}
		for (crt.AssignUintptr(&pX, pHead)) != uintptr(0) {
			pHead = (*amatch_rule)(unsafe.Pointer(pX)).FpNext
			(*amatch_rule)(unsafe.Pointer(pX)).FpNext = uintptr(0)
			for i = uint32(0); (*(*uintptr)(unsafe.Pointer(bp + 72 /* &a[0] */ + uintptr(i)*8)) != 0) && (uint64(i) < ((uint64(unsafe.Sizeof([15]uintptr{})) / uint64(unsafe.Sizeof(uintptr(0)))) - uint64(1))); i++ {
				pX = amatchMergeRules(tls, *(*uintptr)(unsafe.Pointer(bp + 72 /* &a[0] */ + uintptr(i)*8)), pX)
				*(*uintptr)(unsafe.Pointer(bp + 72 /* &a[0] */ + uintptr(i)*8)) = uintptr(0)
			}
			*(*uintptr)(unsafe.Pointer(bp + 72 /* &a[0] */ + uintptr(i)*8)) = amatchMergeRules(tls, *(*uintptr)(unsafe.Pointer(bp + 72 /* &a[0] */ + uintptr(i)*8)), pX)
		}
		pX = *(*uintptr)(unsafe.Pointer(bp + 72 /* &a[0] */ + uintptr(0)*8))
		i = uint32(1)
		for ; uint64(i) < (uint64(unsafe.Sizeof([15]uintptr{})) / uint64(unsafe.Sizeof(uintptr(0)))); i++ {
			pX = amatchMergeRules(tls, *(*uintptr)(unsafe.Pointer(bp + 72 /* &a[0] */ + uintptr(i)*8)), pX)
		}
		(*amatch_vtab)(unsafe.Pointer(p)).FpRule = amatchMergeRules(tls, (*amatch_vtab)(unsafe.Pointer(p)).FpRule, pX)
	} else {
		// An error has occurred. Setting p->pRule to point to the head of the
		// allocated list ensures that the list will be cleaned up in this case.
		if !((*amatch_vtab)(unsafe.Pointer(p)).FpRule == uintptr(0)) {
			crt.X__assert_fail(tls, ts+2745 /* "p->pRule==0" */, ts+2519 /* "testdata/sqlite-..." */, uint32(720), uintptr(unsafe.Pointer(&__func__14)))
		}
		(*amatch_vtab)(unsafe.Pointer(p)).FpRule = pHead
	}

	return rc
}

var __func__14 = *(*[16]int8)(unsafe.Pointer(ts + 2757 /* "amatchLoadRules" */)) /* amatch.c:660:2 */

// This function converts an SQL quoted string into an unquoted string
// and returns a pointer to a buffer allocated using sqlite3_malloc()
// containing the result. The caller should eventually free this buffer
// using sqlite3_free.
//
// Examples:
//
//     "abc"   becomes   abc
//     'xyz'   becomes   xyz
//     [pqr]   becomes   pqr
//     `mno`   becomes   mno
func amatchDequote(tls *crt.TLS, zIn uintptr) uintptr { /* amatch.c:740:13: */
	var nIn sqlite3_int64 // Size of input string, in bytes
	var zOut uintptr      // Output (dequoted) string

	nIn = sqlite3_int64(crt.Xstrlen(tls, zIn))
	zOut = sqlite3.Xsqlite3_malloc64(tls, (uint64(nIn + int64(1))))
	if zOut != 0 {
		var q int8 = *(*int8)(unsafe.Pointer(zIn + uintptr(0))) // Quote character (if any )

		if (((int32(q) != '[') && (int32(q) != '\'')) && (int32(q) != '"')) && (int32(q) != '`') {
			crt.Xmemcpy(tls, zOut, zIn, (size_t(nIn + int64(1))))
		} else {
			var iOut int32 = 0 // Index of next byte to write to output
			var iIn int32      // Index of next byte to read from input

			if int32(q) == '[' {
				q = int8(']')
			}
			for iIn = 1; sqlite3_int64(iIn) < nIn; iIn++ {
				if int32(*(*int8)(unsafe.Pointer(zIn + uintptr(iIn)))) == int32(q) {
					iIn++
				}
				*(*int8)(unsafe.Pointer(zOut + uintptr(crt.PostIncInt32(&iOut, 1)))) = *(*int8)(unsafe.Pointer(zIn + uintptr(iIn)))
			}
		}
		if !(sqlite3_int64(int32(crt.Xstrlen(tls, zOut))) <= nIn) {
			crt.X__assert_fail(tls, ts+2773 /* "(int)strlen(zOut..." */, ts+2519 /* "testdata/sqlite-..." */, uint32(761), uintptr(unsafe.Pointer(&__func__15)))
		}
	}
	return zOut
}

var __func__15 = *(*[14]int8)(unsafe.Pointer(ts + 2796 /* "amatchDequote" */)) /* amatch.c:740:44 */

// Deallocate the pVCheck prepared statement.
func amatchVCheckClear(tls *crt.TLS, p uintptr) { /* amatch.c:769:13: */
	if (*amatch_vtab)(unsafe.Pointer(p)).FpVCheck != 0 {
		sqlite3.Xsqlite3_finalize(tls, (*amatch_vtab)(unsafe.Pointer(p)).FpVCheck)
		(*amatch_vtab)(unsafe.Pointer(p)).FpVCheck = uintptr(0)
	}
}

// Deallocate an amatch_vtab object
func amatchFree(tls *crt.TLS, p uintptr) { /* amatch.c:779:13: */
	if p != 0 {
		amatchFreeRules(tls, p)
		amatchVCheckClear(tls, p)
		sqlite3.Xsqlite3_free(tls, (*amatch_vtab)(unsafe.Pointer(p)).FzClassName)
		sqlite3.Xsqlite3_free(tls, (*amatch_vtab)(unsafe.Pointer(p)).FzDb)
		sqlite3.Xsqlite3_free(tls, (*amatch_vtab)(unsafe.Pointer(p)).FzCostTab)
		sqlite3.Xsqlite3_free(tls, (*amatch_vtab)(unsafe.Pointer(p)).FzVocabTab)
		sqlite3.Xsqlite3_free(tls, (*amatch_vtab)(unsafe.Pointer(p)).FzVocabWord)
		sqlite3.Xsqlite3_free(tls, (*amatch_vtab)(unsafe.Pointer(p)).FzVocabLang)
		sqlite3.Xsqlite3_free(tls, (*amatch_vtab)(unsafe.Pointer(p)).FzSelf)
		crt.Xmemset(tls, p, 0, uint64(unsafe.Sizeof(amatch_vtab{})))
		sqlite3.Xsqlite3_free(tls, p)
	}
}

// xDisconnect/xDestroy method for the amatch module.
func amatchDisconnect(tls *crt.TLS, pVtab uintptr) int32 { /* amatch.c:798:12: */
	var p uintptr = pVtab
	if !((*amatch_vtab)(unsafe.Pointer(p)).FnCursor == 0) {
		crt.X__assert_fail(tls, ts+2810 /* "p->nCursor==0" */, ts+2519 /* "testdata/sqlite-..." */, uint32(800), uintptr(unsafe.Pointer(&__func__16)))
	}
	amatchFree(tls, p)
	return 0
}

var __func__16 = *(*[17]int8)(unsafe.Pointer(ts + 2824 /* "amatchDisconnect" */)) /* amatch.c:798:49 */

// Check to see if the argument is of the form:
//
//       KEY = VALUE
//
// If it is, return a pointer to the first character of VALUE.
// If not, return NULL.  Spaces around the = are ignored.
func amatchValueOfKey(tls *crt.TLS, zKey uintptr, zStr uintptr) uintptr { /* amatch.c:813:19: */
	var nKey int32 = int32(crt.Xstrlen(tls, zKey))
	var nStr int32 = int32(crt.Xstrlen(tls, zStr))
	var i int32
	if nStr < (nKey + 1) {
		return uintptr(0)
	}
	if crt.Xmemcmp(tls, zStr, zKey, uint64(nKey)) != 0 {
		return uintptr(0)
	}
	for i = nKey; (int32(*(*uint16)(unsafe.Pointer((*(*uintptr)(unsafe.Pointer(crt.X__ctype_b_loc(tls)))) + uintptr(int32(uint8(*(*int8)(unsafe.Pointer(zStr + uintptr(i))))))*2))) & int32(uint16(8192))) != 0; i++ {
	}
	if int32(*(*int8)(unsafe.Pointer(zStr + uintptr(i)))) != '=' {
		return uintptr(0)
	}
	i++
	for (int32(*(*uint16)(unsafe.Pointer((*(*uintptr)(unsafe.Pointer(crt.X__ctype_b_loc(tls)))) + uintptr(int32(uint8(*(*int8)(unsafe.Pointer(zStr + uintptr(i))))))*2))) & int32(uint16(8192))) != 0 {
		i++
	}
	return (zStr + uintptr(i))
}

// xConnect/xCreate method for the amatch module. Arguments are:
//
//   argv[0]    -> module name  ("approximate_match")
//   argv[1]    -> database name
//   argv[2]    -> table name
//   argv[3...] -> arguments
func amatchConnect(tls *crt.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVtab uintptr, pzErr uintptr) int32 { /* amatch.c:834:12: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var rc int32     // Return code
	var pNew uintptr // New virtual table
	var zModule uintptr
	var zDb uintptr
	var zVal uintptr
	var i int32
	rc = 0
	pNew = uintptr(0)
	zModule = *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8))
	zDb = *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8))

	_ = pAux
	*(*uintptr)(unsafe.Pointer(ppVtab)) = uintptr(0)
	pNew = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(amatch_vtab{})))
	if !(pNew == uintptr(0)) {
		goto __1
	}
	return 7
__1:
	;
	rc = 7
	crt.Xmemset(tls, pNew, 0, uint64(unsafe.Sizeof(amatch_vtab{})))
	(*amatch_vtab)(unsafe.Pointer(pNew)).Fdb = db
	(*amatch_vtab)(unsafe.Pointer(pNew)).FzClassName = sqlite3.Xsqlite3_mprintf(tls, ts+130 /* "%s" */, crt.VaList(bp, zModule))
	if !((*amatch_vtab)(unsafe.Pointer(pNew)).FzClassName == uintptr(0)) {
		goto __2
	}
	goto amatchConnectError
__2:
	;
	(*amatch_vtab)(unsafe.Pointer(pNew)).FzDb = sqlite3.Xsqlite3_mprintf(tls, ts+130 /* "%s" */, crt.VaList(bp+8, zDb))
	if !((*amatch_vtab)(unsafe.Pointer(pNew)).FzDb == uintptr(0)) {
		goto __3
	}
	goto amatchConnectError
__3:
	;
	(*amatch_vtab)(unsafe.Pointer(pNew)).FzSelf = sqlite3.Xsqlite3_mprintf(tls, ts+130 /* "%s" */, crt.VaList(bp+16, *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8))))
	if !((*amatch_vtab)(unsafe.Pointer(pNew)).FzSelf == uintptr(0)) {
		goto __4
	}
	goto amatchConnectError
__4:
	;
	i = 3
__5:
	if !(i < argc) {
		goto __7
	}
	zVal = amatchValueOfKey(tls, ts+2841 /* "vocabulary_table" */, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8)))
	if !(zVal != 0) {
		goto __8
	}
	sqlite3.Xsqlite3_free(tls, (*amatch_vtab)(unsafe.Pointer(pNew)).FzVocabTab)
	(*amatch_vtab)(unsafe.Pointer(pNew)).FzVocabTab = amatchDequote(tls, zVal)
	if !((*amatch_vtab)(unsafe.Pointer(pNew)).FzVocabTab == uintptr(0)) {
		goto __9
	}
	goto amatchConnectError
__9:
	;
	goto __6
__8:
	;
	zVal = amatchValueOfKey(tls, ts+2858 /* "vocabulary_word" */, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8)))
	if !(zVal != 0) {
		goto __10
	}
	sqlite3.Xsqlite3_free(tls, (*amatch_vtab)(unsafe.Pointer(pNew)).FzVocabWord)
	(*amatch_vtab)(unsafe.Pointer(pNew)).FzVocabWord = amatchDequote(tls, zVal)
	if !((*amatch_vtab)(unsafe.Pointer(pNew)).FzVocabWord == uintptr(0)) {
		goto __11
	}
	goto amatchConnectError
__11:
	;
	goto __6
__10:
	;
	zVal = amatchValueOfKey(tls, ts+2874 /* "vocabulary_langu..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8)))
	if !(zVal != 0) {
		goto __12
	}
	sqlite3.Xsqlite3_free(tls, (*amatch_vtab)(unsafe.Pointer(pNew)).FzVocabLang)
	(*amatch_vtab)(unsafe.Pointer(pNew)).FzVocabLang = amatchDequote(tls, zVal)
	if !((*amatch_vtab)(unsafe.Pointer(pNew)).FzVocabLang == uintptr(0)) {
		goto __13
	}
	goto amatchConnectError
__13:
	;
	goto __6
__12:
	;
	zVal = amatchValueOfKey(tls, ts+2894 /* "edit_distances" */, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8)))
	if !(zVal != 0) {
		goto __14
	}
	sqlite3.Xsqlite3_free(tls, (*amatch_vtab)(unsafe.Pointer(pNew)).FzCostTab)
	(*amatch_vtab)(unsafe.Pointer(pNew)).FzCostTab = amatchDequote(tls, zVal)
	if !((*amatch_vtab)(unsafe.Pointer(pNew)).FzCostTab == uintptr(0)) {
		goto __15
	}
	goto amatchConnectError
__15:
	;
	goto __6
__14:
	;
	*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+2909 /* "unrecognized arg..." */, crt.VaList(bp+24, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8))))
	amatchFree(tls, pNew)
	*(*uintptr)(unsafe.Pointer(ppVtab)) = uintptr(0)
	return 1
	goto __6
__6:
	i++
	goto __5
	goto __7
__7:
	;
	rc = 0
	if !((*amatch_vtab)(unsafe.Pointer(pNew)).FzCostTab == uintptr(0)) {
		goto __16
	}
	*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+2938 /* "no edit_distance..." */, 0)
	rc = 1
	goto __17
__16:
	rc = amatchLoadRules(tls, db, pNew, pzErr)
__17:
	;
	if !(rc == 0) {
		goto __18
	}
	sqlite3.Xsqlite3_vtab_config(tls, db, 2, 0)
	rc = sqlite3.Xsqlite3_declare_vtab(tls, db,

		ts+2972 /* "CREATE TABLE x(w..." */)
__18:
	;
	if !(rc != 0) {
		goto __19
	}
	amatchFree(tls, pNew)
__19:
	;
	*(*uintptr)(unsafe.Pointer(ppVtab)) = (pNew /* &.base */)
	return rc

amatchConnectError:
	amatchFree(tls, pNew)
	return rc
}

// Open a new amatch cursor.
func amatchOpen(tls *crt.TLS, pVTab uintptr, ppCursor uintptr) int32 { /* amatch.c:928:12: */
	var p uintptr = pVTab
	var pCur uintptr
	pCur = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(amatch_cursor{})))
	if pCur == uintptr(0) {
		return 7
	}
	crt.Xmemset(tls, pCur, 0, uint64(unsafe.Sizeof(amatch_cursor{})))
	(*amatch_cursor)(unsafe.Pointer(pCur)).FpVtab = p
	*(*uintptr)(unsafe.Pointer(ppCursor)) = (pCur /* &.base */)
	(*amatch_vtab)(unsafe.Pointer(p)).FnCursor++
	return 0
}

// Free up all the memory allocated by a cursor.  Set it rLimit to 0
// to indicate that it is at EOF.
func amatchClearCursor(tls *crt.TLS, pCur uintptr) { /* amatch.c:944:13: */
	var pWord uintptr
	var pNextWord uintptr
	for pWord = (*amatch_cursor)(unsafe.Pointer(pCur)).FpAllWords; pWord != 0; pWord = pNextWord {
		pNextWord = (*amatch_word)(unsafe.Pointer(pWord)).FpNext
		sqlite3.Xsqlite3_free(tls, pWord)
	}
	(*amatch_cursor)(unsafe.Pointer(pCur)).FpAllWords = uintptr(0)
	sqlite3.Xsqlite3_free(tls, (*amatch_cursor)(unsafe.Pointer(pCur)).FzInput)
	(*amatch_cursor)(unsafe.Pointer(pCur)).FzInput = uintptr(0)
	sqlite3.Xsqlite3_free(tls, (*amatch_cursor)(unsafe.Pointer(pCur)).FzBuf)
	(*amatch_cursor)(unsafe.Pointer(pCur)).FzBuf = uintptr(0)
	(*amatch_cursor)(unsafe.Pointer(pCur)).FnBuf = 0
	(*amatch_cursor)(unsafe.Pointer(pCur)).FpCost = uintptr(0)
	(*amatch_cursor)(unsafe.Pointer(pCur)).FpWord = uintptr(0)
	(*amatch_cursor)(unsafe.Pointer(pCur)).FpCurrent = uintptr(0)
	(*amatch_cursor)(unsafe.Pointer(pCur)).FrLimit = 1000000
	(*amatch_cursor)(unsafe.Pointer(pCur)).FiLang = 0
	(*amatch_cursor)(unsafe.Pointer(pCur)).FnWord = 0
}

// Close a amatch cursor.
func amatchClose(tls *crt.TLS, cur uintptr) int32 { /* amatch.c:967:12: */
	var pCur uintptr = cur
	amatchClearCursor(tls, pCur)
	(*amatch_vtab)(unsafe.Pointer((*amatch_cursor)(unsafe.Pointer(pCur)).FpVtab)).FnCursor--
	sqlite3.Xsqlite3_free(tls, pCur)
	return 0
}

// Render a 24-bit unsigned integer as a 4-byte base-64 number.
func amatchEncodeInt(tls *crt.TLS, x int32, z uintptr) { /* amatch.c:978:13: */
	*(*int8)(unsafe.Pointer(z + uintptr(0))) = a[((x >> 18) & 0x3f)]
	*(*int8)(unsafe.Pointer(z + uintptr(1))) = a[((x >> 12) & 0x3f)]
	*(*int8)(unsafe.Pointer(z + uintptr(2))) = a[((x >> 6) & 0x3f)]
	*(*int8)(unsafe.Pointer(z + uintptr(3))) = a[(x & 0x3f)]
}

var a = *(*[65]int8)(unsafe.Pointer(ts + 3039 /* "0123456789ABCDEF..." */)) /* amatch.c:979:21 */

// Write the zCost[] field for a amatch_word object
func amatchWriteCost(tls *crt.TLS, pWord uintptr) { /* amatch.c:996:13: */
	amatchEncodeInt(tls, (*amatch_word)(unsafe.Pointer(pWord)).FrCost, pWord+112 /* &.zCost */)
	amatchEncodeInt(tls, (*amatch_word)(unsafe.Pointer(pWord)).FiSeq, ((pWord + 112 /* &.zCost */) + uintptr(4)))
	*(*int8)(unsafe.Pointer((pWord + 112 /* &.zCost */) + uintptr(8))) = int8(0)
}

// Circumvent compiler warnings about the use of strcpy() by supplying
// our own implementation.
func amatchStrcpy(tls *crt.TLS, dest uintptr, src uintptr) { /* amatch.c:1005:13: */
	for (int32(crt.AssignPtrInt8(crt.PostIncUintptr(&dest, 1), *(*int8)(unsafe.Pointer(crt.PostIncUintptr(&src, 1)))))) != 0 {
	}
}
func amatchStrcat(tls *crt.TLS, dest uintptr, src uintptr) { /* amatch.c:1008:13: */
	for *(*int8)(unsafe.Pointer(dest)) != 0 {
		dest++
	}
	amatchStrcpy(tls, dest, src)
}

// Add a new amatch_word object to the queue.
//
// If a prior amatch_word object with the same zWord, and nMatch
// already exists, update its rCost (if the new rCost is less) but
// otherwise leave it unchanged.  Do not add a duplicate.
//
// Do nothing if the cost exceeds threshold.
func amatchAddWord(tls *crt.TLS, pCur uintptr, rCost amatch_cost, nMatch int32, zWordBase uintptr, zWordTail uintptr) { /* amatch.c:1022:13: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var pWord uintptr
	var pNode uintptr
	var pOther uintptr
	_ = pOther
	var nBase int32
	var nTail int32
	// var zBuf [4]int8 at bp, 4

	if rCost > (*amatch_cursor)(unsafe.Pointer(pCur)).FrLimit {
		return
	}
	nBase = int32(crt.Xstrlen(tls, zWordBase))
	nTail = int32(crt.Xstrlen(tls, zWordTail))
	if ((nBase + nTail) + 3) > (*amatch_cursor)(unsafe.Pointer(pCur)).FnBuf {
		(*amatch_cursor)(unsafe.Pointer(pCur)).FnBuf = ((nBase + nTail) + 100)
		(*amatch_cursor)(unsafe.Pointer(pCur)).FzBuf = sqlite3.Xsqlite3_realloc(tls, (*amatch_cursor)(unsafe.Pointer(pCur)).FzBuf, (*amatch_cursor)(unsafe.Pointer(pCur)).FnBuf)
		if (*amatch_cursor)(unsafe.Pointer(pCur)).FzBuf == uintptr(0) {
			(*amatch_cursor)(unsafe.Pointer(pCur)).FnBuf = 0
			return
		}
	}
	amatchEncodeInt(tls, nMatch, bp /* &zBuf[0] */)
	crt.Xmemcpy(tls, (*amatch_cursor)(unsafe.Pointer(pCur)).FzBuf, (bp /* &zBuf[0] */ + uintptr(2)), uint64(2))
	crt.Xmemcpy(tls, ((*amatch_cursor)(unsafe.Pointer(pCur)).FzBuf + uintptr(2)), zWordBase, uint64(nBase))
	crt.Xmemcpy(tls, (((*amatch_cursor)(unsafe.Pointer(pCur)).FzBuf + uintptr(2)) + uintptr(nBase)), zWordTail, (uint64(nTail + 1)))
	pNode = amatchAvlSearch(tls, (*amatch_cursor)(unsafe.Pointer(pCur)).FpWord, (*amatch_cursor)(unsafe.Pointer(pCur)).FzBuf)
	if pNode != 0 {
		pWord = (*amatch_avl)(unsafe.Pointer(pNode)).FpWord
		if (*amatch_word)(unsafe.Pointer(pWord)).FrCost > rCost {
			amatchAvlRemove(tls, (pCur + 80 /* &.pCost */), (pWord + 8 /* &.sCost */))
			(*amatch_word)(unsafe.Pointer(pWord)).FrCost = rCost
			amatchWriteCost(tls, pWord)
			pOther = amatchAvlInsert(tls, (pCur + 80 /* &.pCost */), (pWord + 8 /* &.sCost */))
			if !(pOther == uintptr(0)) {
				crt.X__assert_fail(tls, ts+3104 /* "pOther==0" */, ts+2519 /* "testdata/sqlite-..." */, uint32(1069), uintptr(unsafe.Pointer(&__func__17)))
			}
			_ = pOther
		}
		return
	}
	pWord = sqlite3.Xsqlite3_malloc64(tls, (uint64(((uint64(unsafe.Sizeof(amatch_word{})) + uint64(nBase)) + uint64(nTail)) - uint64(1))))
	if pWord == uintptr(0) {
		return
	}
	crt.Xmemset(tls, pWord, 0, uint64(unsafe.Sizeof(amatch_word{})))
	(*amatch_word)(unsafe.Pointer(pWord)).FrCost = rCost
	(*amatch_word)(unsafe.Pointer(pWord)).FiSeq = crt.PostIncInt32(&(*amatch_cursor)(unsafe.Pointer(pCur)).FnWord, 1)
	amatchWriteCost(tls, pWord)
	(*amatch_word)(unsafe.Pointer(pWord)).FnMatch = int16(nMatch)
	(*amatch_word)(unsafe.Pointer(pWord)).FpNext = (*amatch_cursor)(unsafe.Pointer(pCur)).FpAllWords
	(*amatch_cursor)(unsafe.Pointer(pCur)).FpAllWords = pWord
	(*amatch_word)(unsafe.Pointer(pWord)).FsCost.FzKey = pWord + 112 /* &.zCost */
	(*amatch_word)(unsafe.Pointer(pWord)).FsCost.FpWord = pWord
	pOther = amatchAvlInsert(tls, (pCur + 80 /* &.pCost */), (pWord + 8 /* &.sCost */))
	if !(pOther == uintptr(0)) {
		crt.X__assert_fail(tls, ts+3104 /* "pOther==0" */, ts+2519 /* "testdata/sqlite-..." */, uint32(1085), uintptr(unsafe.Pointer(&__func__17)))
	}
	_ = pOther
	(*amatch_word)(unsafe.Pointer(pWord)).FsWord.FzKey = pWord + 124 /* &.zWord */
	(*amatch_word)(unsafe.Pointer(pWord)).FsWord.FpWord = pWord
	amatchStrcpy(tls, pWord+124 /* &.zWord */, (*amatch_cursor)(unsafe.Pointer(pCur)).FzBuf)
	pOther = amatchAvlInsert(tls, (pCur + 88 /* &.pWord */), (pWord + 56 /* &.sWord */))
	if !(pOther == uintptr(0)) {
		crt.X__assert_fail(tls, ts+3104 /* "pOther==0" */, ts+2519 /* "testdata/sqlite-..." */, uint32(1090), uintptr(unsafe.Pointer(&__func__17)))
	}
	_ = pOther
}

var __func__17 = *(*[14]int8)(unsafe.Pointer(ts + 3114 /* "amatchAddWord" */)) /* amatch.c:1028:2 */

// Advance a cursor to its next row of output
func amatchNext(tls *crt.TLS, cur uintptr) int32 { /* amatch.c:1102:12: */
	bp := tls.Alloc(80)
	defer tls.Free(80)

	var pCur uintptr = cur
	var pWord uintptr = uintptr(0)
	var pNode uintptr
	var isMatch int32 = 0
	var p uintptr = (*amatch_cursor)(unsafe.Pointer(pCur)).FpVtab
	var nWord int32
	var rc int32
	var i int32
	var zW uintptr
	var pRule uintptr
	var zBuf uintptr = uintptr(0)
	var nBuf int8 = int8(0)
	// var zNext [8]int8 at bp+64, 8

	// var zNextIn [8]int8 at bp+72, 8

	var nNextIn int32

	if (*amatch_vtab)(unsafe.Pointer(p)).FpVCheck == uintptr(0) {
		var zSql uintptr
		if ((*amatch_vtab)(unsafe.Pointer(p)).FzVocabLang != 0) && (*(*int8)(unsafe.Pointer((*amatch_vtab)(unsafe.Pointer(p)).FzVocabLang + uintptr(0))) != 0) {
			zSql = sqlite3.Xsqlite3_mprintf(tls,
				ts+3128, /* "SELECT \"%w\" FROM..." */

				crt.VaList(bp, ts+3150, /* " WHERE \"%w\">=?1 ..." */
					(*amatch_vtab)(unsafe.Pointer(p)).FzVocabWord, (*amatch_vtab)(unsafe.Pointer(p)).FzVocabTab,
					(*amatch_vtab)(unsafe.Pointer(p)).FzVocabWord, (*amatch_vtab)(unsafe.Pointer(p)).FzVocabLang))
		} else {
			zSql = sqlite3.Xsqlite3_mprintf(tls,

				ts+3189, /* "SELECT \"%w\" FROM..." */
				crt.VaList(bp+40, (*amatch_vtab)(unsafe.Pointer(p)).FzVocabWord, (*amatch_vtab)(unsafe.Pointer(p)).FzVocabTab,
					(*amatch_vtab)(unsafe.Pointer(p)).FzVocabWord))
		}
		rc = sqlite3.Xsqlite3_prepare_v2(tls, (*amatch_vtab)(unsafe.Pointer(p)).Fdb, zSql, -1, (p + 112 /* &.pVCheck */), uintptr(0))
		sqlite3.Xsqlite3_free(tls, zSql)
		if rc != 0 {
			return rc
		}
	}
	sqlite3.Xsqlite3_bind_int(tls, (*amatch_vtab)(unsafe.Pointer(p)).FpVCheck, 2, (*amatch_cursor)(unsafe.Pointer(pCur)).FiLang)

	for ok := true; ok; ok = !(isMatch != 0) {
		pNode = amatchAvlFirst(tls, (*amatch_cursor)(unsafe.Pointer(pCur)).FpCost)
		if pNode == uintptr(0) {
			pWord = uintptr(0)
			break
		}
		pWord = (*amatch_avl)(unsafe.Pointer(pNode)).FpWord
		amatchAvlRemove(tls, (pCur + 80 /* &.pCost */), (pWord + 8 /* &.sCost */))

		nWord = int32(crt.Xstrlen(tls, ((pWord + 124 /* &.zWord */) + uintptr(2))))
		if (nWord + 20) > int32(nBuf) {
			nBuf = (int8(nWord + 100))
			zBuf = sqlite3.Xsqlite3_realloc(tls, zBuf, int32(nBuf))
			if zBuf == uintptr(0) {
				return 7
			}
		}
		amatchStrcpy(tls, zBuf, ((pWord + 124 /* &.zWord */) + uintptr(2)))
		*(*int8)(unsafe.Pointer(bp + 64 /* &zNext[0] */ + uintptr(0))) = int8(0)
		*(*int8)(unsafe.Pointer(bp + 72 /* &zNextIn[0] */ + uintptr(0))) = *(*int8)(unsafe.Pointer((*amatch_cursor)(unsafe.Pointer(pCur)).FzInput + uintptr((*amatch_word)(unsafe.Pointer(pWord)).FnMatch)))
		if *(*int8)(unsafe.Pointer(bp + 72 /* &zNextIn[0] */ + uintptr(0))) != 0 {
			for i = 1; (i <= 4) && ((int32(*(*int8)(unsafe.Pointer((*amatch_cursor)(unsafe.Pointer(pCur)).FzInput + uintptr((int32((*amatch_word)(unsafe.Pointer(pWord)).FnMatch) + i))))) & 0xc0) == 0x80); i++ {
				*(*int8)(unsafe.Pointer(bp + 72 /* &zNextIn[0] */ + uintptr(i))) = *(*int8)(unsafe.Pointer((*amatch_cursor)(unsafe.Pointer(pCur)).FzInput + uintptr((int32((*amatch_word)(unsafe.Pointer(pWord)).FnMatch) + i))))
			}
			*(*int8)(unsafe.Pointer(bp + 72 /* &zNextIn[0] */ + uintptr(i))) = int8(0)
			nNextIn = i
		} else {
			nNextIn = 0
		}

		if (*(*int8)(unsafe.Pointer(bp + 72 /* &zNextIn[0] */ + uintptr(0))) != 0) && (int32(*(*int8)(unsafe.Pointer(bp + 72 /* &zNextIn[0] */ + uintptr(0)))) != '*') {
			sqlite3.Xsqlite3_reset(tls, (*amatch_vtab)(unsafe.Pointer(p)).FpVCheck)
			amatchStrcat(tls, zBuf, bp+72 /* &zNextIn[0] */)
			sqlite3.Xsqlite3_bind_text(tls, (*amatch_vtab)(unsafe.Pointer(p)).FpVCheck, 1, zBuf, (nWord + nNextIn), uintptr(0))
			rc = sqlite3.Xsqlite3_step(tls, (*amatch_vtab)(unsafe.Pointer(p)).FpVCheck)
			if rc == 100 {
				zW = sqlite3.Xsqlite3_column_text(tls, (*amatch_vtab)(unsafe.Pointer(p)).FpVCheck, 0)
				if crt.Xstrncmp(tls, zBuf, zW, (uint64(nWord+nNextIn))) == 0 {
					amatchAddWord(tls, pCur, (*amatch_word)(unsafe.Pointer(pWord)).FrCost, (int32((*amatch_word)(unsafe.Pointer(pWord)).FnMatch) + nNextIn), zBuf, ts+792 /* "" */)
				}
			}
			*(*int8)(unsafe.Pointer(zBuf + uintptr(nWord))) = int8(0)
		}

		for 1 != 0 {
			amatchStrcpy(tls, (zBuf + uintptr(nWord)), bp+64 /* &zNext[0] */)
			sqlite3.Xsqlite3_reset(tls, (*amatch_vtab)(unsafe.Pointer(p)).FpVCheck)
			sqlite3.Xsqlite3_bind_text(tls, (*amatch_vtab)(unsafe.Pointer(p)).FpVCheck, 1, zBuf, -1, crt.UintptrFromInt32(-1))
			rc = sqlite3.Xsqlite3_step(tls, (*amatch_vtab)(unsafe.Pointer(p)).FpVCheck)
			if rc != 100 {
				break
			}
			zW = sqlite3.Xsqlite3_column_text(tls, (*amatch_vtab)(unsafe.Pointer(p)).FpVCheck, 0)
			amatchStrcpy(tls, (zBuf + uintptr(nWord)), bp+64 /* &zNext[0] */)
			if crt.Xstrncmp(tls, zW, zBuf, uint64(nWord)) != 0 {
				break
			}
			if ((int32(*(*int8)(unsafe.Pointer(bp + 72 /* &zNextIn[0] */ + uintptr(0)))) == '*') && (int32(*(*int8)(unsafe.Pointer(bp + 72 /* &zNextIn[0] */ + uintptr(1)))) == 0)) ||
				((int32(*(*int8)(unsafe.Pointer(bp + 72 /* &zNextIn[0] */ + uintptr(0)))) == 0) && (int32(*(*int8)(unsafe.Pointer(zW + uintptr(nWord)))) == 0)) {
				isMatch = 1
				*(*int8)(unsafe.Pointer(bp + 72 /* &zNextIn[0] */ + uintptr(0))) = int8(0)
				nNextIn = 0
				break
			}
			*(*int8)(unsafe.Pointer(bp + 64 /* &zNext[0] */ + uintptr(0))) = *(*int8)(unsafe.Pointer(zW + uintptr(nWord)))
			for i = 1; (i <= 4) && ((int32(*(*int8)(unsafe.Pointer(zW + uintptr((nWord + i))))) & 0xc0) == 0x80); i++ {
				*(*int8)(unsafe.Pointer(bp + 64 /* &zNext[0] */ + uintptr(i))) = *(*int8)(unsafe.Pointer(zW + uintptr((nWord + i))))
			}
			*(*int8)(unsafe.Pointer(bp + 64 /* &zNext[0] */ + uintptr(i))) = int8(0)
			*(*int8)(unsafe.Pointer(zBuf + uintptr(nWord))) = int8(0)
			if (*amatch_vtab)(unsafe.Pointer(p)).FrIns > 0 {
				amatchAddWord(tls, pCur, ((*amatch_word)(unsafe.Pointer(pWord)).FrCost + (*amatch_vtab)(unsafe.Pointer(p)).FrIns), int32((*amatch_word)(unsafe.Pointer(pWord)).FnMatch),
					zBuf, bp+64 /* &zNext[0] */)
			}
			if (*amatch_vtab)(unsafe.Pointer(p)).FrSub > 0 {
				amatchAddWord(tls, pCur, ((*amatch_word)(unsafe.Pointer(pWord)).FrCost + (*amatch_vtab)(unsafe.Pointer(p)).FrSub), (int32((*amatch_word)(unsafe.Pointer(pWord)).FnMatch) + nNextIn),
					zBuf, bp+64 /* &zNext[0] */)
			}
			if ((*amatch_vtab)(unsafe.Pointer(p)).FrIns < 0) && ((*amatch_vtab)(unsafe.Pointer(p)).FrSub < 0) {
				break
			}
			*(*int8)(unsafe.Pointer(bp + 64 /* &zNext[0] */ + uintptr((i - 1))))++
		}
		sqlite3.Xsqlite3_reset(tls, (*amatch_vtab)(unsafe.Pointer(p)).FpVCheck)

		if (*amatch_vtab)(unsafe.Pointer(p)).FrDel > 0 {
			*(*int8)(unsafe.Pointer(zBuf + uintptr(nWord))) = int8(0)
			amatchAddWord(tls, pCur, ((*amatch_word)(unsafe.Pointer(pWord)).FrCost + (*amatch_vtab)(unsafe.Pointer(p)).FrDel), (int32((*amatch_word)(unsafe.Pointer(pWord)).FnMatch) + nNextIn),
				zBuf, ts+792 /* "" */)
		}

		for pRule = (*amatch_vtab)(unsafe.Pointer(p)).FpRule; pRule != 0; pRule = (*amatch_rule)(unsafe.Pointer(pRule)).FpNext {
			if (*amatch_rule)(unsafe.Pointer(pRule)).FiLang != (*amatch_cursor)(unsafe.Pointer(pCur)).FiLang {
				continue
			}
			if crt.Xstrncmp(tls, (*amatch_rule)(unsafe.Pointer(pRule)).FzFrom, ((*amatch_cursor)(unsafe.Pointer(pCur)).FzInput+uintptr((*amatch_word)(unsafe.Pointer(pWord)).FnMatch)), uint64((*amatch_rule)(unsafe.Pointer(pRule)).FnFrom)) == 0 {
				amatchAddWord(tls, pCur, ((*amatch_word)(unsafe.Pointer(pWord)).FrCost + (*amatch_rule)(unsafe.Pointer(pRule)).FrCost),
					(int32((*amatch_word)(unsafe.Pointer(pWord)).FnMatch) + int32((*amatch_rule)(unsafe.Pointer(pRule)).FnFrom)), ((pWord + 124 /* &.zWord */) + uintptr(2)), pRule+26 /* &.zTo */)
			}
		}
	}
	(*amatch_cursor)(unsafe.Pointer(pCur)).FpCurrent = pWord
	sqlite3.Xsqlite3_free(tls, zBuf)
	return 0
}

// Called to "rewind" a cursor back to the beginning so that
// it starts its output over again.  Always called at least once
// prior to any amatchColumn, amatchRowid, or amatchEof call.
func amatchFilter(tls *crt.TLS, pVtabCursor uintptr, idxNum int32, idxStr uintptr, argc int32, argv uintptr) int32 { /* amatch.c:1251:12: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var pCur uintptr = pVtabCursor
	var zWord uintptr = ts + 3237 /* "*" */
	var idx int32

	amatchClearCursor(tls, pCur)
	idx = 0
	if (idxNum & 1) != 0 {
		zWord = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)))
		idx++
	}
	if (idxNum & 2) != 0 {
		(*amatch_cursor)(unsafe.Pointer(pCur)).FrLimit = sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(idx)*8)))
		idx++
	}
	if (idxNum & 4) != 0 {
		(*amatch_cursor)(unsafe.Pointer(pCur)).FiLang = sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(idx)*8)))
		idx++
	}
	(*amatch_cursor)(unsafe.Pointer(pCur)).FzInput = sqlite3.Xsqlite3_mprintf(tls, ts+130 /* "%s" */, crt.VaList(bp, zWord))
	if (*amatch_cursor)(unsafe.Pointer(pCur)).FzInput == uintptr(0) {
		return 7
	}
	amatchAddWord(tls, pCur, 0, 0, ts+792 /* "" */, ts+792 /* "" */)
	amatchNext(tls, pVtabCursor)

	return 0
}

// Only the word and distance columns have values.  All other columns
// return NULL
func amatchColumn(tls *crt.TLS, cur uintptr, ctx uintptr, i int32) int32 { /* amatch.c:1286:12: */
	var pCur uintptr = cur
	switch i {
	case 0:
		{
			sqlite3.Xsqlite3_result_text(tls, ctx, (((*amatch_cursor)(unsafe.Pointer(pCur)).FpCurrent + 124 /* &.zWord */) + uintptr(2)), -1, uintptr(0))
			break
		}
	case 1:
		{
			sqlite3.Xsqlite3_result_int(tls, ctx, (*amatch_word)(unsafe.Pointer((*amatch_cursor)(unsafe.Pointer(pCur)).FpCurrent)).FrCost)
			break
		}
	case 2:
		{
			sqlite3.Xsqlite3_result_int(tls, ctx, (*amatch_cursor)(unsafe.Pointer(pCur)).FiLang)
			break
		}
	case 4:
		{
			sqlite3.Xsqlite3_result_int(tls, ctx, (*amatch_cursor)(unsafe.Pointer(pCur)).FnWord)
			break
		}
	default:
		{
			sqlite3.Xsqlite3_result_null(tls, ctx)
			break
		}
	}
	return 0
}

// The rowid.
func amatchRowid(tls *crt.TLS, cur uintptr, pRowid uintptr) int32 { /* amatch.c:1316:12: */
	var pCur uintptr = cur
	*(*sqlite_int64)(unsafe.Pointer(pRowid)) = (*amatch_cursor)(unsafe.Pointer(pCur)).FiRowid
	return 0
}

// EOF indicator
func amatchEof(tls *crt.TLS, cur uintptr) int32 { /* amatch.c:1325:12: */
	var pCur uintptr = cur
	return (crt.Bool32((*amatch_cursor)(unsafe.Pointer(pCur)).FpCurrent == uintptr(0)))
}

// Search for terms of these forms:
//
//   (A)    word MATCH $str
//   (B1)   distance < $value
//   (B2)   distance <= $value
//   (C)    language == $language
//
// The distance< and distance<= are both treated as distance<=.
// The query plan number is a bit vector:
//
//   bit 1:   Term of the form (A) found
//   bit 2:   Term like (B1) or (B2) found
//   bit 3:   Term like (C) found
//
// If bit-1 is set, $str is always in filter.argv[0].  If bit-2 is set
// then $value is in filter.argv[0] if bit-1 is clear and is in
// filter.argv[1] if bit-1 is set.  If bit-3 is set, then $ruleid is
// in filter.argv[0] if bit-1 and bit-2 are both zero, is in
// filter.argv[1] if exactly one of bit-1 and bit-2 are set, and is in
// filter.argv[2] if both bit-1 and bit-2 are set.
func amatchBestIndex(tls *crt.TLS, tab uintptr, pIdxInfo uintptr) int32 { /* amatch.c:1352:12: */
	var iPlan int32 = 0
	var iDistTerm int32 = -1
	var iLangTerm int32 = -1
	var i int32
	var pConstraint uintptr

	_ = tab
	pConstraint = (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraint
	i = 0
__1:
	if !(i < (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnConstraint) {
		goto __3
	}
	{
		if int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fusable) == 0 {
			goto __2
		}
		if (((iPlan & 1) == 0) &&
			((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).FiColumn == 0)) &&
			(int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == 64) {
			iPlan = iPlan | (1)
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(i)*8)).FargvIndex = 1
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(i)*8)).Fomit = uint8(1)
		}
		if (((iPlan & 2) == 0) &&
			((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).FiColumn == 1)) &&
			((int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == 16) ||
				(int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == 8)) {
			iPlan = iPlan | (2)
			iDistTerm = i
		}
		if (((iPlan & 4) == 0) &&
			((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).FiColumn == 2)) &&
			(int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == 2) {
			iPlan = iPlan | (4)
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(i)*8)).Fomit = uint8(1)
			iLangTerm = i
		}
	}
	goto __2
__2:
	i++
	pConstraint += 12
	goto __1
	goto __3
__3:
	;
	if (iPlan & 2) != 0 {
		(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(iDistTerm)*8)).FargvIndex = (1 + (crt.Bool32((iPlan & 1) != 0)))
	}
	if (iPlan & 4) != 0 {
		var idx int32 = 1
		if (iPlan & 1) != 0 {
			idx++
		}
		if (iPlan & 2) != 0 {
			idx++
		}
		(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(iLangTerm)*8)).FargvIndex = idx
	}
	(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxNum = iPlan
	if (((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnOrderBy == 1) &&
		((*sqlite3_index_orderby)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaOrderBy+uintptr(0)*8)).FiColumn == 1)) &&
		(int32((*sqlite3_index_orderby)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaOrderBy+uintptr(0)*8)).Fdesc) == 0) {
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).ForderByConsumed = 1
	}
	(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = float64(10000)

	return 0
}

// The xUpdate() method.
//
// This implementation disallows DELETE and UPDATE.  The only thing
// allowed is INSERT into the "command" column.
func amatchUpdate(tls *crt.TLS, pVTab uintptr, argc int32, argv uintptr, pRowid uintptr) int32 { /* amatch.c:1418:12: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	var p uintptr = pVTab
	var zCmd uintptr
	_ = pRowid
	if argc == 1 {
		(*sqlite3_vtab)(unsafe.Pointer(pVTab)).FzErrMsg = sqlite3.Xsqlite3_mprintf(tls, ts+3239, /* "DELETE from %s i..." */
			crt.VaList(bp, (*amatch_vtab)(unsafe.Pointer(p)).FzSelf))
		return 1
	}
	if sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8))) != 5 {
		(*sqlite3_vtab)(unsafe.Pointer(pVTab)).FzErrMsg = sqlite3.Xsqlite3_mprintf(tls, ts+3269, /* "UPDATE of %s is ..." */
			crt.VaList(bp+8, (*amatch_vtab)(unsafe.Pointer(p)).FzSelf))
		return 1
	}
	if ((sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr((2+0))*8))) != 5) ||
		(sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr((2+1))*8))) != 5)) ||
		(sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr((2+2))*8))) != 5) {
		(*sqlite3_vtab)(unsafe.Pointer(pVTab)).FzErrMsg = sqlite3.Xsqlite3_mprintf(tls,
			ts+3297 /* "INSERT INTO %s a..." */, crt.VaList(bp+16, (*amatch_vtab)(unsafe.Pointer(p)).FzSelf))
		return 1
	}
	zCmd = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr((2+3))*8)))
	if zCmd == uintptr(0) {
		return 0
	}

	return 0
}

// A virtual table module that implements the "approximate_match".
var amatchModule = sqlite3_module{FiVersion: 0, FxCreate: // iVersion
0, FxConnect:// xCreate
0, FxBestIndex:// xConnect
0, FxDisconnect:// xBestIndex
0, FxDestroy:// xDisconnect
0, FxOpen:// xDestroy
0, FxClose:// xOpen - open a cursor
0, FxFilter:// xClose - close a cursor
0, FxNext:// xFilter - configure scan constraints
0, FxEof:// xNext - advance a cursor
0, FxColumn:// xEof - check for end of scan
0, FxRowid:// xColumn - read data
0, FxUpdate:// xRowid - read data
0, FxBegin:// xUpdate
uintptr(0), FxSync:// xBegin
uintptr(0), FxCommit:// xSync
uintptr(0), FxRollback:// xCommit
uintptr(0), FxFindFunction:// xRollback
uintptr(0), FxRename:// xFindMethod
uintptr(0), FxSavepoint:// xRename
uintptr(0), FxRelease:// xSavepoint
uintptr(0), FxRollbackTo:// xRelease
uintptr(0), FxShadowName:// xRollbackTo
uintptr(0), // xShadowName
} /* amatch.c:1454:23 */

// Register the amatch virtual table
func sqlite3_amatch_init(tls *crt.TLS, db uintptr, pzErrMsg uintptr, pApi uintptr) int32 { /* amatch.c:1489:5: */
	var rc int32 = 0
	_ = pApi

	_ = pzErrMsg // Not used
	rc = sqlite3.Xsqlite3_create_module(tls, db, ts+3346 /* "approximate_matc..." */, uintptr(unsafe.Pointer(&amatchModule)), uintptr(0))
	return rc
}

// Allowed datatypes

// Names of types
var azType = [4]uintptr{ts + 3364 /* "int32" */, ts + 3370 /* "int64" */, ts + 3376 /* "double" */, ts + 3383 /* "char*" */} /* carray.c:73:19 */

// carray_cursor is a subclass of sqlite3_vtab_cursor which will
// serve as the underlying representation of a cursor that scans
// over rows of the result
type carray_cursor1 = struct {
	Fbase   sqlite3_vtab_cursor
	FiRowid sqlite3_int64
	FpPtr   uintptr
	FiCnt   sqlite3_int64
	FeType  uint8
	_       [7]byte
}

// carray_cursor is a subclass of sqlite3_vtab_cursor which will
// serve as the underlying representation of a cursor that scans
// over rows of the result
type carray_cursor = carray_cursor1 /* carray.c:80:30 */

// The carrayConnect() method is invoked to create a new
// carray_vtab that describes the carray virtual table.
//
// Think of this routine as the constructor for carray_vtab objects.
//
// All this routine needs to do is:
//
//    (1) Allocate the carray_vtab object and initialize all fields.
//
//    (2) Tell SQLite (via the sqlite3_declare_vtab() interface) what the
//        result set of queries against carray will look like.
func carrayConnect(tls *crt.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVtab uintptr, pzErr uintptr) int32 { /* carray.c:102:12: */
	var pNew uintptr
	var rc int32

	// Column numbers

	rc = sqlite3.Xsqlite3_declare_vtab(tls, db,
		ts+3389 /* "CREATE TABLE x(v..." */)
	if rc == 0 {
		pNew = crt.AssignPtrUintptr(ppVtab, sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(sqlite3_vtab{}))))
		if pNew == uintptr(0) {
			return 7
		}
		crt.Xmemset(tls, pNew, 0, uint64(unsafe.Sizeof(sqlite3_vtab{})))
	}
	return rc
}

// This method is the destructor for carray_cursor objects.
func carrayDisconnect(tls *crt.TLS, pVtab uintptr) int32 { /* carray.c:131:12: */
	sqlite3.Xsqlite3_free(tls, pVtab)
	return 0
}

// Constructor for a new carray_cursor object.
func carrayOpen(tls *crt.TLS, p uintptr, ppCursor uintptr) int32 { /* carray.c:139:12: */
	var pCur uintptr
	pCur = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(carray_cursor{})))
	if pCur == uintptr(0) {
		return 7
	}
	crt.Xmemset(tls, pCur, 0, uint64(unsafe.Sizeof(carray_cursor{})))
	*(*uintptr)(unsafe.Pointer(ppCursor)) = (pCur /* &.base */)
	return 0
}

// Destructor for a carray_cursor.
func carrayClose(tls *crt.TLS, cur uintptr) int32 { /* carray.c:151:12: */
	sqlite3.Xsqlite3_free(tls, cur)
	return 0
}

// Advance a carray_cursor to its next row of output.
func carrayNext(tls *crt.TLS, cur uintptr) int32 { /* carray.c:160:12: */
	var pCur uintptr = cur
	(*carray_cursor)(unsafe.Pointer(pCur)).FiRowid++
	return 0
}

// Return values of columns for the row at which the carray_cursor
// is currently pointing.
func carrayColumn(tls *crt.TLS, cur uintptr, ctx uintptr, i int32) int32 { /* carray.c:170:12: */
	var pCur uintptr = cur
	var x sqlite3_int64 = int64(0)
	switch i {
	case 1:
		return 0
	case 2:
		x = (*carray_cursor)(unsafe.Pointer(pCur)).FiCnt
		break
	case 3:
		{
			sqlite3.Xsqlite3_result_text(tls, ctx, azType[(*carray_cursor)(unsafe.Pointer(pCur)).FeType], -1, uintptr(0))
			return 0
		}
	default:
		{
			switch int32((*carray_cursor)(unsafe.Pointer(pCur)).FeType) {
			case 0:
				{
					var p uintptr = (*carray_cursor)(unsafe.Pointer(pCur)).FpPtr
					sqlite3.Xsqlite3_result_int(tls, ctx, *(*int32)(unsafe.Pointer(p + uintptr(((*carray_cursor)(unsafe.Pointer(pCur)).FiRowid-int64(1)))*4)))
					return 0
				}
			case 1:
				{
					var p uintptr = (*carray_cursor)(unsafe.Pointer(pCur)).FpPtr
					sqlite3.Xsqlite3_result_int64(tls, ctx, *(*sqlite3_int64)(unsafe.Pointer(p + uintptr(((*carray_cursor)(unsafe.Pointer(pCur)).FiRowid-int64(1)))*8)))
					return 0
				}
			case 2:
				{
					var p uintptr = (*carray_cursor)(unsafe.Pointer(pCur)).FpPtr
					sqlite3.Xsqlite3_result_double(tls, ctx, *(*float64)(unsafe.Pointer(p + uintptr(((*carray_cursor)(unsafe.Pointer(pCur)).FiRowid-int64(1)))*8)))
					return 0
				}
			case 3:
				{
					var p uintptr = (*carray_cursor)(unsafe.Pointer(pCur)).FpPtr
					sqlite3.Xsqlite3_result_text(tls, ctx, *(*uintptr)(unsafe.Pointer(p + uintptr(((*carray_cursor)(unsafe.Pointer(pCur)).FiRowid-int64(1)))*8)), -1, crt.UintptrFromInt32(-1))
					return 0
				}
			}
		}
	}
	sqlite3.Xsqlite3_result_int64(tls, ctx, x)
	return 0
}

// Return the rowid for the current row.  In this implementation, the
// rowid is the same as the output value.
func carrayRowid(tls *crt.TLS, cur uintptr, pRowid uintptr) int32 { /* carray.c:217:12: */
	var pCur uintptr = cur
	*(*sqlite_int64)(unsafe.Pointer(pRowid)) = (*carray_cursor)(unsafe.Pointer(pCur)).FiRowid
	return 0
}

// Return TRUE if the cursor has been moved off of the last
// row of output.
func carrayEof(tls *crt.TLS, cur uintptr) int32 { /* carray.c:227:12: */
	var pCur uintptr = cur
	return (crt.Bool32((*carray_cursor)(unsafe.Pointer(pCur)).FiRowid > (*carray_cursor)(unsafe.Pointer(pCur)).FiCnt))
}

// This method is called to "rewind" the carray_cursor object back
// to the first row of output.
func carrayFilter(tls *crt.TLS, pVtabCursor uintptr, idxNum int32, idxStr uintptr, argc int32, argv uintptr) int32 { /* carray.c:236:12: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var pCur uintptr = pVtabCursor
	if idxNum != 0 {
		(*carray_cursor)(unsafe.Pointer(pCur)).FpPtr = sqlite3.Xsqlite3_value_pointer(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)), ts+3452 /* "carray" */)
		(*carray_cursor)(unsafe.Pointer(pCur)).FiCnt = func() int64 {
			if (*carray_cursor)(unsafe.Pointer(pCur)).FpPtr != 0 {
				return sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)))
			}
			return int64(0)
		}()
		if idxNum < 3 {
			(*carray_cursor)(unsafe.Pointer(pCur)).FeType = uint8(0)
		} else {
			var i uint8
			var zType uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8)))
			for i = uint8(0); uint64(i) < (uint64(unsafe.Sizeof(azType)) / uint64(unsafe.Sizeof(uintptr(0)))); i++ {
				if sqlite3.Xsqlite3_stricmp(tls, zType, azType[i]) == 0 {
					break
				}
			}
			if uint64(i) >= (uint64(unsafe.Sizeof(azType)) / uint64(unsafe.Sizeof(uintptr(0)))) {
				(*sqlite3_vtab)(unsafe.Pointer((*sqlite3_vtab_cursor)(unsafe.Pointer(pVtabCursor)).FpVtab)).FzErrMsg = sqlite3.Xsqlite3_mprintf(tls,
					ts+3459 /* "unknown datatype..." */, crt.VaList(bp, zType))
				return 1
			} else {
				(*carray_cursor)(unsafe.Pointer(pCur)).FeType = i
			}
		}
	} else {
		(*carray_cursor)(unsafe.Pointer(pCur)).FpPtr = uintptr(0)
		(*carray_cursor)(unsafe.Pointer(pCur)).FiCnt = int64(0)
	}
	(*carray_cursor)(unsafe.Pointer(pCur)).FiRowid = int64(1)
	return 0
}

// SQLite will invoke this method one or more times while planning a query
// that uses the carray virtual table.  This routine needs to create
// a query plan for each invocation and compute an estimated cost for that
// plan.
//
// In this implementation idxNum is used to represent the
// query plan.  idxStr is unused.
//
// idxNum is 2 if the pointer= and count= constraints exist,
// 3 if the ctype= constraint also exists, and is 0 otherwise.
// If idxNum is 0, then carray becomes an empty table.
func carrayBestIndex(tls *crt.TLS, tab uintptr, pIdxInfo uintptr) int32 { /* carray.c:282:12: */
	var i int32             // Loop over constraints
	var ptrIdx int32 = -1   // Index of the pointer= constraint, or -1 if none
	var cntIdx int32 = -1   // Index of the count= constraint, or -1 if none
	var ctypeIdx int32 = -1 // Index of the ctype= constraint, or -1 if none

	var pConstraint uintptr
	pConstraint = (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraint
	i = 0
__1:
	if !(i < (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnConstraint) {
		goto __3
	}
	{
		if int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fusable) == 0 {
			goto __2
		}
		if int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) != 2 {
			goto __2
		}
		switch (*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).FiColumn {
		case 1:
			ptrIdx = i
			break
		case 2:
			cntIdx = i
			break
		case 3:
			ctypeIdx = i
			break
		}
	}
	goto __2
__2:
	i++
	pConstraint += 12
	goto __1
	goto __3
__3:
	;
	if (ptrIdx >= 0) && (cntIdx >= 0) {
		(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(ptrIdx)*8)).FargvIndex = 1
		(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(ptrIdx)*8)).Fomit = uint8(1)
		(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(cntIdx)*8)).FargvIndex = 2
		(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(cntIdx)*8)).Fomit = uint8(1)
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = float64(1)
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedRows = int64(100)
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxNum = 2
		if ctypeIdx >= 0 {
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(ctypeIdx)*8)).FargvIndex = 3
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(ctypeIdx)*8)).Fomit = uint8(1)
			(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxNum = 3
		}
	} else {
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = float64(2147483647)
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedRows = int64(2147483647)
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxNum = 0
	}
	return 0
}

// This following structure defines all the methods for the
// carray virtual table.
var carrayModule = sqlite3_module{FiVersion: 0, FxCreate: // iVersion
uintptr(0), FxConnect:// xCreate
0, FxBestIndex:// xConnect
0, FxDisconnect:// xBestIndex
0, FxDestroy:// xDisconnect
uintptr(0), FxOpen:// xDestroy
0, FxClose:// xOpen - open a cursor
0, FxFilter:// xClose - close a cursor
0, FxNext:// xFilter - configure scan constraints
0, FxEof:// xNext - advance a cursor
0, FxColumn:// xEof - check for end of scan
0, FxRowid:// xColumn - read data
0, FxUpdate:// xRowid - read data
uintptr(0), FxBegin:// xUpdate
uintptr(0), FxSync:// xBegin
uintptr(0), FxCommit:// xSync
uintptr(0), FxRollback:// xCommit
uintptr(0), FxFindFunction:// xRollback
uintptr(0), FxRename:// xFindMethod
uintptr(0), // xRename
} /* carray.c:333:23 */

// For testing purpose in the TCL test harness, we need a method for
// setting the pointer value.  The inttoptr(X) SQL function accomplishes
// this.  Tcl script will bind an integer to X and the inttoptr() SQL
// function will use sqlite3_result_pointer() to convert that integer into
// a pointer.
//
// This is for testing on TCL only.
func inttoptrFunc(tls *crt.TLS, context uintptr, argc int32, argv uintptr) { /* carray.c:366:13: */
	bp := tls.Alloc(20)
	defer tls.Free(20)

	// var p uintptr at bp, 8

	// var i64 sqlite3_int64 at bp+8, 8

	*(*sqlite3_int64)(unsafe.Pointer(bp + 8 /* i64 */)) = sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)))
	if uint64(unsafe.Sizeof(sqlite3_int64(0))) == uint64(unsafe.Sizeof(uintptr(0))) {
		crt.Xmemcpy(tls, bp /* &p */, bp+8 /* &i64 */, uint64(unsafe.Sizeof(uintptr(0))))
	} else {
		*(*int32)(unsafe.Pointer(bp + 16 /* i32 */)) = (int32(*(*sqlite3_int64)(unsafe.Pointer(bp + 8 /* i64 */)) & int64(0xffffffff)))
		crt.Xmemcpy(tls, bp /* &p */, bp+16 /* &i32 */, uint64(unsafe.Sizeof(uintptr(0))))
	}
	sqlite3.Xsqlite3_result_pointer(tls, context, *(*uintptr)(unsafe.Pointer(bp /* p */)), ts+3452 /* "carray" */, uintptr(0))
}

func sqlite3_carray_init(tls *crt.TLS, db uintptr, pzErrMsg uintptr, pApi uintptr) int32 { /* carray.c:389:5: */
	var rc int32 = 0
	_ = pApi

	rc = sqlite3.Xsqlite3_create_module(tls, db, ts+3452 /* "carray" */, uintptr(unsafe.Pointer(&carrayModule)), uintptr(0))
	if rc == 0 {
		rc = sqlite3.Xsqlite3_create_function(tls, db, ts+3480 /* "inttoptr" */, 1, 1, uintptr(0),
			*(*uintptr)(unsafe.Pointer(&struct {
				f func(*crt.TLS, uintptr, int32, uintptr)
			}{inttoptrFunc})), uintptr(0), uintptr(0))
	}
	return rc
}

// Forward declaration of objects used by this implementation
type closure_vtab1 = struct {
	Fbase          sqlite3_vtab
	FzDb           uintptr
	FzSelf         uintptr
	FzTableName    uintptr
	FzIdColumn     uintptr
	FzParentColumn uintptr
	Fdb            uintptr
	FnCursor       int32
	_              [4]byte
}

// Forward declaration of objects used by this implementation
type closure_vtab = closure_vtab1 /* closure.c:156:29 */
type closure_cursor1 = struct {
	Fbase          sqlite3_vtab_cursor
	FpVtab         uintptr
	FzTableName    uintptr
	FzIdColumn     uintptr
	FzParentColumn uintptr
	FpCurrent      uintptr
	FpClosure      uintptr
}

type closure_cursor = closure_cursor1 /* closure.c:157:31 */
type closure_queue1 = struct {
	FpFirst uintptr
	FpLast  uintptr
}

type closure_queue = closure_queue1 /* closure.c:158:30 */
type closure_avl1 = struct {
	Fid          sqlite3_int64
	FiGeneration int32
	FpList       uintptr
	FpBefore     uintptr
	FpAfter      uintptr
	FpUp         uintptr
	Fheight      int16
	Fimbalance   int16
	_            [4]byte
}

type closure_avl = closure_avl1 /* closure.c:159:28 */

// Recompute the closure_avl.height and closure_avl.imbalance fields for p.
// Assume that the children of p have correct heights.
func closureAvlRecomputeHeight(tls *crt.TLS, p uintptr) { /* closure.c:182:13: */
	var hBefore int16
	if (*closure_avl)(unsafe.Pointer(p)).FpBefore != 0 {
		hBefore = (*closure_avl)(unsafe.Pointer((*closure_avl)(unsafe.Pointer(p)).FpBefore)).Fheight
	} else {
		hBefore = int16(0)
	}
	var hAfter int16
	if (*closure_avl)(unsafe.Pointer(p)).FpAfter != 0 {
		hAfter = (*closure_avl)(unsafe.Pointer((*closure_avl)(unsafe.Pointer(p)).FpAfter)).Fheight
	} else {
		hAfter = int16(0)
	}
	(*closure_avl)(unsafe.Pointer(p)).Fimbalance = (int16(int32(hBefore) - int32(hAfter))) // -: pAfter higher.  +: pBefore higher
	(*closure_avl)(unsafe.Pointer(p)).Fheight = (int16((func() int32 {
		if int32(hBefore) > int32(hAfter) {
			return int32(hBefore)
		}
		return int32(hAfter)
	}()) + 1))
}

//     P                B
//    / \              / **   B   Z    ==>     X   P
//  / \                  / ** X   Y                Y   Z
//
func closureAvlRotateBefore(tls *crt.TLS, pP uintptr) uintptr { /* closure.c:197:20: */
	var pB uintptr = (*closure_avl)(unsafe.Pointer(pP)).FpBefore
	var pY uintptr = (*closure_avl)(unsafe.Pointer(pB)).FpAfter
	(*closure_avl)(unsafe.Pointer(pB)).FpUp = (*closure_avl)(unsafe.Pointer(pP)).FpUp
	(*closure_avl)(unsafe.Pointer(pB)).FpAfter = pP
	(*closure_avl)(unsafe.Pointer(pP)).FpUp = pB
	(*closure_avl)(unsafe.Pointer(pP)).FpBefore = pY
	if pY != 0 {
		(*closure_avl)(unsafe.Pointer(pY)).FpUp = pP
	}
	closureAvlRecomputeHeight(tls, pP)
	closureAvlRecomputeHeight(tls, pB)
	return pB
}

//     P                A
//    / \              / **   X   A    ==>     P   Z
//      / \          / **     Y   Z        X   Y
//
func closureAvlRotateAfter(tls *crt.TLS, pP uintptr) uintptr { /* closure.c:218:20: */
	var pA uintptr = (*closure_avl)(unsafe.Pointer(pP)).FpAfter
	var pY uintptr = (*closure_avl)(unsafe.Pointer(pA)).FpBefore
	(*closure_avl)(unsafe.Pointer(pA)).FpUp = (*closure_avl)(unsafe.Pointer(pP)).FpUp
	(*closure_avl)(unsafe.Pointer(pA)).FpBefore = pP
	(*closure_avl)(unsafe.Pointer(pP)).FpUp = pA
	(*closure_avl)(unsafe.Pointer(pP)).FpAfter = pY
	if pY != 0 {
		(*closure_avl)(unsafe.Pointer(pY)).FpUp = pP
	}
	closureAvlRecomputeHeight(tls, pP)
	closureAvlRecomputeHeight(tls, pA)
	return pA
}

// Return a pointer to the pBefore or pAfter pointer in the parent
// of p that points to p.  Or if p is the root node, return pp.
func closureAvlFromPtr(tls *crt.TLS, p uintptr, pp uintptr) uintptr { /* closure.c:235:20: */
	var pUp uintptr = (*closure_avl)(unsafe.Pointer(p)).FpUp
	if pUp == uintptr(0) {
		return pp
	}
	if (*closure_avl)(unsafe.Pointer(pUp)).FpAfter == p {
		return (pUp + 32 /* &.pAfter */)
	}
	return (pUp + 24 /* &.pBefore */)
}

// Rebalance all nodes starting with p and working up to the root.
// Return the new root.
func closureAvlBalance(tls *crt.TLS, p uintptr) uintptr { /* closure.c:246:20: */
	bp := tls.Alloc(8)
	defer tls.Free(8)
	*(*uintptr)(unsafe.Pointer(bp)) = p

	var pTop uintptr = *(*uintptr)(unsafe.Pointer(bp /* p */))
	var pp uintptr
	for *(*uintptr)(unsafe.Pointer(bp /* p */)) != 0 {
		closureAvlRecomputeHeight(tls, *(*uintptr)(unsafe.Pointer(bp /* p */)))
		if int32((*closure_avl)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* p */)))).Fimbalance) >= 2 {
			var pB uintptr = (*closure_avl)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* p */)))).FpBefore
			if int32((*closure_avl)(unsafe.Pointer(pB)).Fimbalance) < 0 {
				(*closure_avl)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* p */)))).FpBefore = closureAvlRotateAfter(tls, pB)
			}
			pp = closureAvlFromPtr(tls, *(*uintptr)(unsafe.Pointer(bp /* p */)), bp /* &p */)
			*(*uintptr)(unsafe.Pointer(bp /* p */)) = crt.AssignPtrUintptr(pp, closureAvlRotateBefore(tls, *(*uintptr)(unsafe.Pointer(bp /* p */))))
		} else if int32((*closure_avl)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* p */)))).Fimbalance) <= (-2) {
			var pA uintptr = (*closure_avl)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* p */)))).FpAfter
			if int32((*closure_avl)(unsafe.Pointer(pA)).Fimbalance) > 0 {
				(*closure_avl)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* p */)))).FpAfter = closureAvlRotateBefore(tls, pA)
			}
			pp = closureAvlFromPtr(tls, *(*uintptr)(unsafe.Pointer(bp /* p */)), bp /* &p */)
			*(*uintptr)(unsafe.Pointer(bp /* p */)) = crt.AssignPtrUintptr(pp, closureAvlRotateAfter(tls, *(*uintptr)(unsafe.Pointer(bp /* p */))))
		}
		pTop = *(*uintptr)(unsafe.Pointer(bp /* p */))
		*(*uintptr)(unsafe.Pointer(bp /* p */)) = (*closure_avl)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* p */)))).FpUp
	}
	return pTop
}

// Search the tree rooted at p for an entry with id.  Return a pointer
// to the entry or return NULL.
func closureAvlSearch(tls *crt.TLS, p uintptr, id sqlite3_int64) uintptr { /* closure.c:271:20: */
	for (p != 0) && (id != (*closure_avl)(unsafe.Pointer(p)).Fid) {
		if id < (*closure_avl)(unsafe.Pointer(p)).Fid {
			p = (*closure_avl)(unsafe.Pointer(p)).FpBefore
		} else {
			p = (*closure_avl)(unsafe.Pointer(p)).FpAfter
		}
	}
	return p
}

// Find the first node (the one with the smallest key).
func closureAvlFirst(tls *crt.TLS, p uintptr) uintptr { /* closure.c:280:20: */
	if p != 0 {
		for (*closure_avl)(unsafe.Pointer(p)).FpBefore != 0 {
			p = (*closure_avl)(unsafe.Pointer(p)).FpBefore
		}
	}
	return p
}

// Return the node with the next larger key after p.
func closureAvlNext(tls *crt.TLS, p uintptr) uintptr { /* closure.c:287:13: */
	var pPrev uintptr = uintptr(0)
	for (p != 0) && ((*closure_avl)(unsafe.Pointer(p)).FpAfter == pPrev) {
		pPrev = p
		p = (*closure_avl)(unsafe.Pointer(p)).FpUp
	}
	if (p != 0) && (pPrev == uintptr(0)) {
		p = closureAvlFirst(tls, (*closure_avl)(unsafe.Pointer(p)).FpAfter)
	}
	return p
}

// Insert a new node pNew.  Return NULL on success.  If the key is not
// unique, then do not perform the insert but instead leave pNew unchanged
// and return a pointer to an existing node with the same key.
func closureAvlInsert(tls *crt.TLS, ppHead uintptr, pNew uintptr) uintptr { /* closure.c:303:20: */
	var p uintptr = *(*uintptr)(unsafe.Pointer(ppHead))
	if p == uintptr(0) {
		p = pNew
		(*closure_avl)(unsafe.Pointer(pNew)).FpUp = uintptr(0)
	} else {
		for p != 0 {
			if (*closure_avl)(unsafe.Pointer(pNew)).Fid < (*closure_avl)(unsafe.Pointer(p)).Fid {
				if (*closure_avl)(unsafe.Pointer(p)).FpBefore != 0 {
					p = (*closure_avl)(unsafe.Pointer(p)).FpBefore
				} else {
					(*closure_avl)(unsafe.Pointer(p)).FpBefore = pNew
					(*closure_avl)(unsafe.Pointer(pNew)).FpUp = p
					break
				}
			} else if (*closure_avl)(unsafe.Pointer(pNew)).Fid > (*closure_avl)(unsafe.Pointer(p)).Fid {
				if (*closure_avl)(unsafe.Pointer(p)).FpAfter != 0 {
					p = (*closure_avl)(unsafe.Pointer(p)).FpAfter
				} else {
					(*closure_avl)(unsafe.Pointer(p)).FpAfter = pNew
					(*closure_avl)(unsafe.Pointer(pNew)).FpUp = p
					break
				}
			} else {
				return p
			}
		}
	}
	(*closure_avl)(unsafe.Pointer(pNew)).FpBefore = uintptr(0)
	(*closure_avl)(unsafe.Pointer(pNew)).FpAfter = uintptr(0)
	(*closure_avl)(unsafe.Pointer(pNew)).Fheight = int16(1)
	(*closure_avl)(unsafe.Pointer(pNew)).Fimbalance = int16(0)
	*(*uintptr)(unsafe.Pointer(ppHead)) = closureAvlBalance(tls, p)
	return uintptr(0)
}

// Walk the tree can call xDestroy on each node
func closureAvlDestroy(tls *crt.TLS, p uintptr, xDestroy uintptr) { /* closure.c:344:13: */
	if p != 0 {
		closureAvlDestroy(tls, (*closure_avl)(unsafe.Pointer(p)).FpBefore, xDestroy)
		closureAvlDestroy(tls, (*closure_avl)(unsafe.Pointer(p)).FpAfter, xDestroy)
		(*(*func(*crt.TLS, uintptr))(unsafe.Pointer(&xDestroy)))(tls, p)
	}
}

// Add a node to the end of the queue
func queuePush(tls *crt.TLS, pQueue uintptr, pNode uintptr) { /* closure.c:389:13: */
	(*closure_avl)(unsafe.Pointer(pNode)).FpList = uintptr(0)
	if (*closure_queue)(unsafe.Pointer(pQueue)).FpLast != 0 {
		(*closure_avl)(unsafe.Pointer((*closure_queue)(unsafe.Pointer(pQueue)).FpLast)).FpList = pNode
	} else {
		(*closure_queue)(unsafe.Pointer(pQueue)).FpFirst = pNode
	}
	(*closure_queue)(unsafe.Pointer(pQueue)).FpLast = pNode
}

// Extract the oldest element (the front element) from the queue.
func queuePull(tls *crt.TLS, pQueue uintptr) uintptr { /* closure.c:402:20: */
	var p uintptr = (*closure_queue)(unsafe.Pointer(pQueue)).FpFirst
	if p != 0 {
		(*closure_queue)(unsafe.Pointer(pQueue)).FpFirst = (*closure_avl)(unsafe.Pointer(p)).FpList
		if (*closure_queue)(unsafe.Pointer(pQueue)).FpFirst == uintptr(0) {
			(*closure_queue)(unsafe.Pointer(pQueue)).FpLast = uintptr(0)
		}
	}
	return p
}

// This function converts an SQL quoted string into an unquoted string
// and returns a pointer to a buffer allocated using sqlite3_malloc()
// containing the result. The caller should eventually free this buffer
// using sqlite3_free.
//
// Examples:
//
//     "abc"   becomes   abc
//     'xyz'   becomes   xyz
//     [pqr]   becomes   pqr
//     `mno`   becomes   mno
func closureDequote(tls *crt.TLS, zIn uintptr) uintptr { /* closure.c:424:13: */
	var nIn sqlite3_int64 // Size of input string, in bytes
	var zOut uintptr      // Output (dequoted) string

	nIn = sqlite3_int64(crt.Xstrlen(tls, zIn))
	zOut = sqlite3.Xsqlite3_malloc64(tls, (uint64(nIn + int64(1))))
	if zOut != 0 {
		var q int8 = *(*int8)(unsafe.Pointer(zIn + uintptr(0))) // Quote character (if any )

		if (((int32(q) != '[') && (int32(q) != '\'')) && (int32(q) != '"')) && (int32(q) != '`') {
			crt.Xmemcpy(tls, zOut, zIn, (size_t(nIn + int64(1))))
		} else {
			var iOut int32 = 0 // Index of next byte to write to output
			var iIn int32      // Index of next byte to read from input

			if int32(q) == '[' {
				q = int8(']')
			}
			for iIn = 1; sqlite3_int64(iIn) < nIn; iIn++ {
				if int32(*(*int8)(unsafe.Pointer(zIn + uintptr(iIn)))) == int32(q) {
					iIn++
				}
				*(*int8)(unsafe.Pointer(zOut + uintptr(crt.PostIncInt32(&iOut, 1)))) = *(*int8)(unsafe.Pointer(zIn + uintptr(iIn)))
			}
		}
		if !(sqlite3_int64(int32(crt.Xstrlen(tls, zOut))) <= nIn) {
			crt.X__assert_fail(tls, ts+2773 /* "(int)strlen(zOut..." */, ts+3489 /* "testdata/sqlite-..." */, uint32(445), uintptr(unsafe.Pointer(&__func__18)))
		}
	}
	return zOut
}

var __func__18 = *(*[15]int8)(unsafe.Pointer(ts + 3536 /* "closureDequote" */)) /* closure.c:424:45 */

// Deallocate an closure_vtab object
func closureFree(tls *crt.TLS, p uintptr) { /* closure.c:453:13: */
	if p != 0 {
		sqlite3.Xsqlite3_free(tls, (*closure_vtab)(unsafe.Pointer(p)).FzDb)
		sqlite3.Xsqlite3_free(tls, (*closure_vtab)(unsafe.Pointer(p)).FzSelf)
		sqlite3.Xsqlite3_free(tls, (*closure_vtab)(unsafe.Pointer(p)).FzTableName)
		sqlite3.Xsqlite3_free(tls, (*closure_vtab)(unsafe.Pointer(p)).FzIdColumn)
		sqlite3.Xsqlite3_free(tls, (*closure_vtab)(unsafe.Pointer(p)).FzParentColumn)
		crt.Xmemset(tls, p, 0, uint64(unsafe.Sizeof(closure_vtab{})))
		sqlite3.Xsqlite3_free(tls, p)
	}
}

// xDisconnect/xDestroy method for the closure module.
func closureDisconnect(tls *crt.TLS, pVtab uintptr) int32 { /* closure.c:468:12: */
	var p uintptr = pVtab
	if !((*closure_vtab)(unsafe.Pointer(p)).FnCursor == 0) {
		crt.X__assert_fail(tls, ts+2810 /* "p->nCursor==0" */, ts+3489 /* "testdata/sqlite-..." */, uint32(470), uintptr(unsafe.Pointer(&__func__19)))
	}
	closureFree(tls, p)
	return 0
}

var __func__19 = *(*[18]int8)(unsafe.Pointer(ts + 3551 /* "closureDisconnec..." */)) /* closure.c:468:50 */

// Check to see if the argument is of the form:
//
//       KEY = VALUE
//
// If it is, return a pointer to the first character of VALUE.
// If not, return NULL.  Spaces around the = are ignored.
func closureValueOfKey(tls *crt.TLS, zKey uintptr, zStr uintptr) uintptr { /* closure.c:483:19: */
	var nKey int32 = int32(crt.Xstrlen(tls, zKey))
	var nStr int32 = int32(crt.Xstrlen(tls, zStr))
	var i int32
	if nStr < (nKey + 1) {
		return uintptr(0)
	}
	if crt.Xmemcmp(tls, zStr, zKey, uint64(nKey)) != 0 {
		return uintptr(0)
	}
	for i = nKey; (int32(*(*uint16)(unsafe.Pointer((*(*uintptr)(unsafe.Pointer(crt.X__ctype_b_loc(tls)))) + uintptr(int32(uint8(*(*int8)(unsafe.Pointer(zStr + uintptr(i))))))*2))) & int32(uint16(8192))) != 0; i++ {
	}
	if int32(*(*int8)(unsafe.Pointer(zStr + uintptr(i)))) != '=' {
		return uintptr(0)
	}
	i++
	for (int32(*(*uint16)(unsafe.Pointer((*(*uintptr)(unsafe.Pointer(crt.X__ctype_b_loc(tls)))) + uintptr(int32(uint8(*(*int8)(unsafe.Pointer(zStr + uintptr(i))))))*2))) & int32(uint16(8192))) != 0 {
		i++
	}
	return (zStr + uintptr(i))
}

// xConnect/xCreate method for the closure module. Arguments are:
//
//   argv[0]    -> module name  ("transitive_closure")
//   argv[1]    -> database name
//   argv[2]    -> table name
//   argv[3...] -> arguments
func closureConnect(tls *crt.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVtab uintptr, pzErr uintptr) int32 { /* closure.c:504:12: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	var rc int32     // Return code
	var pNew uintptr // New virtual table
	var zDb uintptr
	var zVal uintptr
	var i int32
	rc = 0
	pNew = uintptr(0)
	zDb = *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8))

	_ = pAux
	*(*uintptr)(unsafe.Pointer(ppVtab)) = uintptr(0)
	pNew = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(closure_vtab{})))
	if !(pNew == uintptr(0)) {
		goto __1
	}
	return 7
__1:
	;
	rc = 7
	crt.Xmemset(tls, pNew, 0, uint64(unsafe.Sizeof(closure_vtab{})))
	(*closure_vtab)(unsafe.Pointer(pNew)).Fdb = db
	(*closure_vtab)(unsafe.Pointer(pNew)).FzDb = sqlite3.Xsqlite3_mprintf(tls, ts+130 /* "%s" */, crt.VaList(bp, zDb))
	if !((*closure_vtab)(unsafe.Pointer(pNew)).FzDb == uintptr(0)) {
		goto __2
	}
	goto closureConnectError
__2:
	;
	(*closure_vtab)(unsafe.Pointer(pNew)).FzSelf = sqlite3.Xsqlite3_mprintf(tls, ts+130 /* "%s" */, crt.VaList(bp+8, *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8))))
	if !((*closure_vtab)(unsafe.Pointer(pNew)).FzSelf == uintptr(0)) {
		goto __3
	}
	goto closureConnectError
__3:
	;
	i = 3
__4:
	if !(i < argc) {
		goto __6
	}
	zVal = closureValueOfKey(tls, ts+3569 /* "tablename" */, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8)))
	if !(zVal != 0) {
		goto __7
	}
	sqlite3.Xsqlite3_free(tls, (*closure_vtab)(unsafe.Pointer(pNew)).FzTableName)
	(*closure_vtab)(unsafe.Pointer(pNew)).FzTableName = closureDequote(tls, zVal)
	if !((*closure_vtab)(unsafe.Pointer(pNew)).FzTableName == uintptr(0)) {
		goto __8
	}
	goto closureConnectError
__8:
	;
	goto __5
__7:
	;
	zVal = closureValueOfKey(tls, ts+3579 /* "idcolumn" */, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8)))
	if !(zVal != 0) {
		goto __9
	}
	sqlite3.Xsqlite3_free(tls, (*closure_vtab)(unsafe.Pointer(pNew)).FzIdColumn)
	(*closure_vtab)(unsafe.Pointer(pNew)).FzIdColumn = closureDequote(tls, zVal)
	if !((*closure_vtab)(unsafe.Pointer(pNew)).FzIdColumn == uintptr(0)) {
		goto __10
	}
	goto closureConnectError
__10:
	;
	goto __5
__9:
	;
	zVal = closureValueOfKey(tls, ts+3588 /* "parentcolumn" */, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8)))
	if !(zVal != 0) {
		goto __11
	}
	sqlite3.Xsqlite3_free(tls, (*closure_vtab)(unsafe.Pointer(pNew)).FzParentColumn)
	(*closure_vtab)(unsafe.Pointer(pNew)).FzParentColumn = closureDequote(tls, zVal)
	if !((*closure_vtab)(unsafe.Pointer(pNew)).FzParentColumn == uintptr(0)) {
		goto __12
	}
	goto closureConnectError
__12:
	;
	goto __5
__11:
	;
	*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+2909 /* "unrecognized arg..." */, crt.VaList(bp+16, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8))))
	closureFree(tls, pNew)
	*(*uintptr)(unsafe.Pointer(ppVtab)) = uintptr(0)
	return 1
	goto __5
__5:
	i++
	goto __4
	goto __6
__6:
	;
	rc = sqlite3.Xsqlite3_declare_vtab(tls, db,

		ts+3601 /* "CREATE TABLE x(i..." */)
	if !(rc != 0) {
		goto __13
	}
	closureFree(tls, pNew)
__13:
	;
	*(*uintptr)(unsafe.Pointer(ppVtab)) = (pNew /* &.base */)
	return rc

closureConnectError:
	closureFree(tls, pNew)
	return rc
}

// Open a new closure cursor.
func closureOpen(tls *crt.TLS, pVTab uintptr, ppCursor uintptr) int32 { /* closure.c:579:12: */
	var p uintptr = pVTab
	var pCur uintptr
	pCur = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(closure_cursor{})))
	if pCur == uintptr(0) {
		return 7
	}
	crt.Xmemset(tls, pCur, 0, uint64(unsafe.Sizeof(closure_cursor{})))
	(*closure_cursor)(unsafe.Pointer(pCur)).FpVtab = p
	*(*uintptr)(unsafe.Pointer(ppCursor)) = (pCur /* &.base */)
	(*closure_vtab)(unsafe.Pointer(p)).FnCursor++
	return 0
}

// Free up all the memory allocated by a cursor.  Set it rLimit to 0
// to indicate that it is at EOF.
func closureClearCursor(tls *crt.TLS, pCur uintptr) { /* closure.c:595:13: */
	closureAvlDestroy(tls, (*closure_cursor)(unsafe.Pointer(pCur)).FpClosure, *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, uintptr) }{sqlite3.Xsqlite3_free})))
	sqlite3.Xsqlite3_free(tls, (*closure_cursor)(unsafe.Pointer(pCur)).FzTableName)
	sqlite3.Xsqlite3_free(tls, (*closure_cursor)(unsafe.Pointer(pCur)).FzIdColumn)
	sqlite3.Xsqlite3_free(tls, (*closure_cursor)(unsafe.Pointer(pCur)).FzParentColumn)
	(*closure_cursor)(unsafe.Pointer(pCur)).FzTableName = uintptr(0)
	(*closure_cursor)(unsafe.Pointer(pCur)).FzIdColumn = uintptr(0)
	(*closure_cursor)(unsafe.Pointer(pCur)).FzParentColumn = uintptr(0)
	(*closure_cursor)(unsafe.Pointer(pCur)).FpCurrent = uintptr(0)
	(*closure_cursor)(unsafe.Pointer(pCur)).FpClosure = uintptr(0)
}

// Close a closure cursor.
func closureClose(tls *crt.TLS, cur uintptr) int32 { /* closure.c:610:12: */
	var pCur uintptr = cur
	closureClearCursor(tls, pCur)
	(*closure_vtab)(unsafe.Pointer((*closure_cursor)(unsafe.Pointer(pCur)).FpVtab)).FnCursor--
	sqlite3.Xsqlite3_free(tls, pCur)
	return 0
}

// Advance a cursor to its next row of output
func closureNext(tls *crt.TLS, cur uintptr) int32 { /* closure.c:621:12: */
	var pCur uintptr = cur
	(*closure_cursor)(unsafe.Pointer(pCur)).FpCurrent = closureAvlNext(tls, (*closure_cursor)(unsafe.Pointer(pCur)).FpCurrent)
	return 0
}

// Allocate and insert a node
func closureInsertNode(tls *crt.TLS, pQueue uintptr, pCur uintptr, id sqlite3_int64, iGeneration int32) int32 { /* closure.c:630:12: */
	var pNew uintptr = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(closure_avl{})))
	if pNew == uintptr(0) {
		return 7
	}
	crt.Xmemset(tls, pNew, 0, uint64(unsafe.Sizeof(closure_avl{})))
	(*closure_avl)(unsafe.Pointer(pNew)).Fid = id
	(*closure_avl)(unsafe.Pointer(pNew)).FiGeneration = iGeneration
	closureAvlInsert(tls, (pCur + 48 /* &.pClosure */), pNew)
	queuePush(tls, pQueue, pNew)
	return 0
}

// Called to "rewind" a cursor back to the beginning so that
// it starts its output over again.  Always called at least once
// prior to any closureColumn, closureRowid, or closureEof call.
//
// This routine actually computes the closure.
//
// See the comment at the beginning of closureBestIndex() for a
// description of the meaning of idxNum.  The idxStr parameter is
// not used.
func closureFilter(tls *crt.TLS, pVtabCursor uintptr, idxNum int32, idxStr uintptr, argc int32, argv uintptr) int32 { /* closure.c:657:12: */
	bp := tls.Alloc(96)
	defer tls.Free(96)

	var pCur uintptr = pVtabCursor
	var pVtab uintptr = (*closure_cursor)(unsafe.Pointer(pCur)).FpVtab
	var iRoot sqlite3_int64
	var mxGen int32 = 999999999
	var zSql uintptr
	// var pStmt uintptr at bp+88, 8

	var pAvl uintptr
	var rc int32 = 0
	var zTableName uintptr = (*closure_vtab)(unsafe.Pointer(pVtab)).FzTableName
	var zIdColumn uintptr = (*closure_vtab)(unsafe.Pointer(pVtab)).FzIdColumn
	var zParentColumn uintptr = (*closure_vtab)(unsafe.Pointer(pVtab)).FzParentColumn
	// var sQueue closure_queue at bp+72, 16

	_ = idxStr // Unused parameter
	_ = argc   // Unused parameter
	closureClearCursor(tls, pCur)
	crt.Xmemset(tls, bp+72 /* &sQueue */, 0, uint64(unsafe.Sizeof(closure_queue{})))
	if (idxNum & 1) == 0 {
		// No root=$root in the WHERE clause.  Return an empty set
		return 0
	}
	iRoot = sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)))
	if (idxNum & 0x000f0) != 0 {
		mxGen = sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(((idxNum>>4)&0x0f))*8)))
		if (idxNum & 0x00002) != 0 {
			mxGen--
		}
	}
	if (idxNum & 0x00f00) != 0 {
		zTableName = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(((idxNum>>8)&0x0f))*8)))
		(*closure_cursor)(unsafe.Pointer(pCur)).FzTableName = sqlite3.Xsqlite3_mprintf(tls, ts+130 /* "%s" */, crt.VaList(bp, zTableName))
	}
	if (idxNum & 0x0f000) != 0 {
		zIdColumn = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(((idxNum>>12)&0x0f))*8)))
		(*closure_cursor)(unsafe.Pointer(pCur)).FzIdColumn = sqlite3.Xsqlite3_mprintf(tls, ts+130 /* "%s" */, crt.VaList(bp+8, zIdColumn))
	}
	if (idxNum & 0x0f0000) != 0 {
		zParentColumn = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(((idxNum>>16)&0x0f))*8)))
		(*closure_cursor)(unsafe.Pointer(pCur)).FzParentColumn = sqlite3.Xsqlite3_mprintf(tls, ts+130 /* "%s" */, crt.VaList(bp+16, zParentColumn))
	}

	zSql = sqlite3.Xsqlite3_mprintf(tls,
		ts+3691, /* "SELECT \"%w\".\"%w\"..." */
		crt.VaList(bp+24, zTableName, zIdColumn, zTableName, zTableName, zParentColumn))
	if zSql == uintptr(0) {
		return 7
	} else {
		rc = sqlite3.Xsqlite3_prepare_v2(tls, (*closure_vtab)(unsafe.Pointer(pVtab)).Fdb, zSql, -1, bp+88 /* &pStmt */, uintptr(0))
		sqlite3.Xsqlite3_free(tls, zSql)
		if rc != 0 {
			sqlite3.Xsqlite3_free(tls, (*closure_vtab)(unsafe.Pointer(pVtab)).Fbase.FzErrMsg)
			(*closure_vtab)(unsafe.Pointer(pVtab)).Fbase.FzErrMsg = sqlite3.Xsqlite3_mprintf(tls, ts+130 /* "%s" */, crt.VaList(bp+64, sqlite3.Xsqlite3_errmsg(tls, (*closure_vtab)(unsafe.Pointer(pVtab)).Fdb)))
			return rc
		}
	}
	if rc == 0 {
		rc = closureInsertNode(tls, bp+72 /* &sQueue */, pCur, iRoot, 0)
	}
	for (crt.AssignUintptr(&pAvl, queuePull(tls, bp+72 /* &sQueue */))) != uintptr(0) {
		if (*closure_avl)(unsafe.Pointer(pAvl)).FiGeneration >= mxGen {
			continue
		}
		sqlite3.Xsqlite3_bind_int64(tls, *(*uintptr)(unsafe.Pointer(bp + 88 /* pStmt */)), 1, (*closure_avl)(unsafe.Pointer(pAvl)).Fid)
		for (rc == 0) && (sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 88 /* pStmt */))) == 100) {
			if sqlite3.Xsqlite3_column_type(tls, *(*uintptr)(unsafe.Pointer(bp + 88 /* pStmt */)), 0) == 1 {
				var iNew sqlite3_int64 = sqlite3.Xsqlite3_column_int64(tls, *(*uintptr)(unsafe.Pointer(bp + 88 /* pStmt */)), 0)
				if closureAvlSearch(tls, (*closure_cursor)(unsafe.Pointer(pCur)).FpClosure, iNew) == uintptr(0) {
					rc = closureInsertNode(tls, bp+72 /* &sQueue */, pCur, iNew, ((*closure_avl)(unsafe.Pointer(pAvl)).FiGeneration + 1))
				}
			}
		}
		sqlite3.Xsqlite3_reset(tls, *(*uintptr)(unsafe.Pointer(bp + 88 /* pStmt */)))
	}
	sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 88 /* pStmt */)))
	if rc == 0 {
		(*closure_cursor)(unsafe.Pointer(pCur)).FpCurrent = closureAvlFirst(tls, (*closure_cursor)(unsafe.Pointer(pCur)).FpClosure)
	}

	return rc
}

// Only the word and distance columns have values.  All other columns
// return NULL
func closureColumn(tls *crt.TLS, cur uintptr, ctx uintptr, i int32) int32 { /* closure.c:743:12: */
	var pCur uintptr = cur
	switch i {
	case 0:
		{
			sqlite3.Xsqlite3_result_int64(tls, ctx, (*closure_avl)(unsafe.Pointer((*closure_cursor)(unsafe.Pointer(pCur)).FpCurrent)).Fid)
			break
		}
	case 1:
		{
			sqlite3.Xsqlite3_result_int(tls, ctx, (*closure_avl)(unsafe.Pointer((*closure_cursor)(unsafe.Pointer(pCur)).FpCurrent)).FiGeneration)
			break
		}
	case 2:
		{
			sqlite3.Xsqlite3_result_null(tls, ctx)
			break
		}
	case 3:
		{
			sqlite3.Xsqlite3_result_text(tls, ctx,
				func() uintptr {
					if (*closure_cursor)(unsafe.Pointer(pCur)).FzTableName != 0 {
						return (*closure_cursor)(unsafe.Pointer(pCur)).FzTableName
					}
					return (*closure_vtab)(unsafe.Pointer((*closure_cursor)(unsafe.Pointer(pCur)).FpVtab)).FzTableName
				}(),
				-1, crt.UintptrFromInt32(-1))
			break
		}
	case 4:
		{
			sqlite3.Xsqlite3_result_text(tls, ctx,
				func() uintptr {
					if (*closure_cursor)(unsafe.Pointer(pCur)).FzIdColumn != 0 {
						return (*closure_cursor)(unsafe.Pointer(pCur)).FzIdColumn
					}
					return (*closure_vtab)(unsafe.Pointer((*closure_cursor)(unsafe.Pointer(pCur)).FpVtab)).FzIdColumn
				}(),
				-1, crt.UintptrFromInt32(-1))
			break
		}
	case 5:
		{
			sqlite3.Xsqlite3_result_text(tls, ctx,
				func() uintptr {
					if (*closure_cursor)(unsafe.Pointer(pCur)).FzParentColumn != 0 {
						return (*closure_cursor)(unsafe.Pointer(pCur)).FzParentColumn
					}
					return (*closure_vtab)(unsafe.Pointer((*closure_cursor)(unsafe.Pointer(pCur)).FpVtab)).FzParentColumn
				}(),
				-1, crt.UintptrFromInt32(-1))
			break
		}
	}
	return 0
}

// The rowid.  For the closure table, this is the same as the "id" column.
func closureRowid(tls *crt.TLS, cur uintptr, pRowid uintptr) int32 { /* closure.c:783:12: */
	var pCur uintptr = cur
	*(*sqlite_int64)(unsafe.Pointer(pRowid)) = (*closure_avl)(unsafe.Pointer((*closure_cursor)(unsafe.Pointer(pCur)).FpCurrent)).Fid
	return 0
}

// EOF indicator
func closureEof(tls *crt.TLS, cur uintptr) int32 { /* closure.c:792:12: */
	var pCur uintptr = cur
	return (crt.Bool32((*closure_cursor)(unsafe.Pointer(pCur)).FpCurrent == uintptr(0)))
}

// Search for terms of these forms:
//
//   (A)    root = $root
//   (B1)   depth < $depth
//   (B2)   depth <= $depth
//   (B3)   depth = $depth
//   (C)    tablename = $tablename
//   (D)    idcolumn = $idcolumn
//   (E)    parentcolumn = $parentcolumn
//
//
//
//   idxNum       meaning
//   ----------   ------------------------------------------------------
//   0x00000001   Term of the form (A) found
//   0x00000002   The term of bit-2 is like (B1)
//   0x000000f0   Index in filter.argv[] of $depth.  0 if not used.
//   0x00000f00   Index in filter.argv[] of $tablename.  0 if not used.
//   0x0000f000   Index in filter.argv[] of $idcolumn.  0 if not used
//   0x000f0000   Index in filter.argv[] of $parentcolumn.  0 if not used.
//
// There must be a term of type (A).  If there is not, then the index type
// is 0 and the query will return an empty set.
func closureBestIndex(tls *crt.TLS, pTab uintptr, pIdxInfo uintptr) int32 { /* closure.c:822:12: */
	var iPlan int32 = 0
	var i int32
	var idx int32 = 1
	var pConstraint uintptr
	var pVtab uintptr = pTab
	var rCost float64 = 10000000.0

	pConstraint = (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraint
	i = 0
__1:
	if !(i < (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnConstraint) {
		goto __3
	}
	{
		if int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fusable) == 0 {
			goto __2
		}
		if (((iPlan & 1) == 0) &&
			((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).FiColumn == 2)) &&
			(int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == 2) {
			iPlan = iPlan | (1)
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(i)*8)).FargvIndex = 1
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(i)*8)).Fomit = uint8(1)
			rCost = rCost / (100.0)
		}
		if (((iPlan & 0x0000f0) == 0) &&
			((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).FiColumn == 1)) &&
			(((int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == 16) ||
				(int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == 8)) ||
				(int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == 2)) {
			iPlan = iPlan | (idx << 4)
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(i)*8)).FargvIndex = crt.PreIncInt32(&idx, 1)
			if int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == 16 {
				iPlan = iPlan | (0x000002)
			}
			rCost = rCost / (5.0)
		}
		if (((iPlan & 0x000f00) == 0) &&
			((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).FiColumn == 3)) &&
			(int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == 2) {
			iPlan = iPlan | (idx << 8)
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(i)*8)).FargvIndex = crt.PreIncInt32(&idx, 1)
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(i)*8)).Fomit = uint8(1)
			rCost = rCost / (5.0)
		}
		if (((iPlan & 0x00f000) == 0) &&
			((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).FiColumn == 4)) &&
			(int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == 2) {
			iPlan = iPlan | (idx << 12)
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(i)*8)).FargvIndex = crt.PreIncInt32(&idx, 1)
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(i)*8)).Fomit = uint8(1)
		}
		if (((iPlan & 0x0f0000) == 0) &&
			((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).FiColumn == 5)) &&
			(int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == 2) {
			iPlan = iPlan | (idx << 16)
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(i)*8)).FargvIndex = crt.PreIncInt32(&idx, 1)
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(i)*8)).Fomit = uint8(1)
		}
	}
	goto __2
__2:
	i++
	pConstraint += 12
	goto __1
	goto __3
__3:
	;
	if ((((*closure_vtab)(unsafe.Pointer(pVtab)).FzTableName == uintptr(0)) && ((iPlan & 0x000f00) == 0)) ||
		(((*closure_vtab)(unsafe.Pointer(pVtab)).FzIdColumn == uintptr(0)) && ((iPlan & 0x00f000) == 0))) ||
		(((*closure_vtab)(unsafe.Pointer(pVtab)).FzParentColumn == uintptr(0)) && ((iPlan & 0x0f0000) == 0)) {
		// All of tablename, idcolumn, and parentcolumn must be specified
		// in either the CREATE VIRTUAL TABLE or in the WHERE clause constraints
		// or else the result is an empty set.
		iPlan = 0
	}
	if (iPlan & 1) == 0 {
		// If there is no usable "root=?" term, then set the index-type to 0.
		// Also clear any argvIndex variables already set. This is necessary
		// to prevent the core from throwing an "xBestIndex malfunction error"
		// error (because the argvIndex values are not contiguously assigned
		// starting from 1).
		rCost = rCost * (1e30)
		i = 0
	__4:
		if !(i < (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnConstraint) {
			goto __6
		}
		{
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(i)*8)).FargvIndex = 0
		}
		goto __5
	__5:
		i++
		pConstraint += 12
		goto __4
		goto __6
	__6:
		;
		iPlan = 0
	}
	(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxNum = iPlan
	if (((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnOrderBy == 1) &&
		((*sqlite3_index_orderby)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaOrderBy+uintptr(0)*8)).FiColumn == 0)) &&
		(int32((*sqlite3_index_orderby)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaOrderBy+uintptr(0)*8)).Fdesc) == 0) {
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).ForderByConsumed = 1
	}
	(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = rCost

	return 0
}

// A virtual table module that implements the "transitive_closure".
var closureModule = sqlite3_module{FiVersion: 0, FxCreate: // iVersion
0, FxConnect:// xCreate
0, FxBestIndex:// xConnect
0, FxDisconnect:// xBestIndex
0, FxDestroy:// xDisconnect
0, FxOpen:// xDestroy
0, FxClose:// xOpen - open a cursor
0, FxFilter:// xClose - close a cursor
0, FxNext:// xFilter - configure scan constraints
0, FxEof:// xNext - advance a cursor
0, FxColumn:// xEof - check for end of scan
0, FxRowid:// xColumn - read data
0, FxUpdate:// xRowid - read data
uintptr(0), FxBegin:// xUpdate
uintptr(0), FxSync:// xBegin
uintptr(0), FxCommit:// xSync
uintptr(0), FxRollback:// xCommit
uintptr(0), FxFindFunction:// xRollback
uintptr(0), FxRename:// xFindMethod
uintptr(0), FxSavepoint:// xRename
uintptr(0), FxRelease:// xSavepoint
uintptr(0), FxRollbackTo:// xRelease
uintptr(0), FxShadowName:// xRollbackTo
uintptr(0), // xShadowName
} /* closure.c:918:23 */

// Register the closure virtual table
func sqlite3_closure_init(tls *crt.TLS, db uintptr, pzErrMsg uintptr, pApi uintptr) int32 { /* closure.c:953:5: */
	var rc int32 = 0
	_ = pApi

	_ = pzErrMsg
	rc = sqlite3.Xsqlite3_create_module(tls, db, ts+3737 /* "transitive_closu..." */, uintptr(unsafe.Pointer(&closureModule)), uintptr(0))
	return rc
}

// If we are compiling with optimizing read this file.  It contains
//   several optimizing inline functions and macros.

// A macro to hint to the compiler that a function should not be
// inlined.

// Max size of the error message in a CsvReader

// Size of the CsvReader input buffer

// A context object used when read a CSV file.
type CsvReader1 = struct {
	Fin        uintptr
	Fz         uintptr
	Fn         int32
	FnAlloc    int32
	FnLine     int32
	FbNotFirst int32
	FcTerm     int32
	FiIn       size_t
	FnIn       size_t
	FzIn       uintptr
	FzErr      [200]int8
}

// If we are compiling with optimizing read this file.  It contains
//   several optimizing inline functions and macros.

// A macro to hint to the compiler that a function should not be
// inlined.

// Max size of the error message in a CsvReader

// Size of the CsvReader input buffer

// A context object used when read a CSV file.
type CsvReader = CsvReader1 /* csv.c:73:26 */

// Initialize a CsvReader object
func csv_reader_init(tls *crt.TLS, p uintptr) { /* csv.c:89:13: */
	(*CsvReader)(unsafe.Pointer(p)).Fin = uintptr(0)
	(*CsvReader)(unsafe.Pointer(p)).Fz = uintptr(0)
	(*CsvReader)(unsafe.Pointer(p)).Fn = 0
	(*CsvReader)(unsafe.Pointer(p)).FnAlloc = 0
	(*CsvReader)(unsafe.Pointer(p)).FnLine = 0
	(*CsvReader)(unsafe.Pointer(p)).FbNotFirst = 0
	(*CsvReader)(unsafe.Pointer(p)).FnIn = uint64(0)
	(*CsvReader)(unsafe.Pointer(p)).FzIn = uintptr(0)
	*(*int8)(unsafe.Pointer((p + 64 /* &.zErr */) + uintptr(0))) = int8(0)
}

// Close and reset a CsvReader object
func csv_reader_reset(tls *crt.TLS, p uintptr) { /* csv.c:102:13: */
	if (*CsvReader)(unsafe.Pointer(p)).Fin != 0 {
		crt.Xfclose(tls, (*CsvReader)(unsafe.Pointer(p)).Fin)
		sqlite3.Xsqlite3_free(tls, (*CsvReader)(unsafe.Pointer(p)).FzIn)
	}
	sqlite3.Xsqlite3_free(tls, (*CsvReader)(unsafe.Pointer(p)).Fz)
	csv_reader_init(tls, p)
}

// Report an error on a CsvReader
func csv_errmsg(tls *crt.TLS, p uintptr, zFormat uintptr, va uintptr) { /* csv.c:112:13: */
	var ap va_list
	_ = ap
	ap = va
	sqlite3.Xsqlite3_vsnprintf(tls, 200, p+64 /* &.zErr */, zFormat, ap)
	_ = ap
}

// Open the file associated with a CsvReader
// Return the number of errors.
func csv_reader_open(tls *crt.TLS, p uintptr, zFilename uintptr, zData uintptr) int32 { /* csv.c:122:12: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	if zFilename != 0 {
		(*CsvReader)(unsafe.Pointer(p)).FzIn = sqlite3.Xsqlite3_malloc(tls, 1024)
		if (*CsvReader)(unsafe.Pointer(p)).FzIn == uintptr(0) {
			csv_errmsg(tls, p, ts+2471 /* "out of memory" */, 0)
			return 1
		}
		(*CsvReader)(unsafe.Pointer(p)).Fin = crt.Xfopen(tls, zFilename, ts+3756 /* "rb" */)
		if (*CsvReader)(unsafe.Pointer(p)).Fin == uintptr(0) {
			sqlite3.Xsqlite3_free(tls, (*CsvReader)(unsafe.Pointer(p)).FzIn)
			csv_reader_reset(tls, p)
			csv_errmsg(tls, p, ts+3759 /* "cannot open '%s'..." */, crt.VaList(bp, zFilename))
			return 1
		}
	} else {
		if !((*CsvReader)(unsafe.Pointer(p)).Fin == uintptr(0)) {
			crt.X__assert_fail(tls, ts+3788 /* "p->in==0" */, ts+3797 /* "testdata/sqlite-..." */, uint32(141), uintptr(unsafe.Pointer(&__func__20)))
		}
		(*CsvReader)(unsafe.Pointer(p)).FzIn = zData
		(*CsvReader)(unsafe.Pointer(p)).FnIn = crt.Xstrlen(tls, zData)
	}
	return 0
}

var __func__20 = *(*[16]int8)(unsafe.Pointer(ts + 3840 /* "csv_reader_open" */)) /* csv.c:126:2 */

// The input buffer has overflowed.  Refill the input buffer, then
// return the next character
func csv_getc_refill(tls *crt.TLS, p uintptr) int32 { /* csv.c:151:25: */
	var got size_t

	if !((*CsvReader)(unsafe.Pointer(p)).FiIn >= (*CsvReader)(unsafe.Pointer(p)).FnIn) {
		crt.X__assert_fail(tls, ts+3856 /* "p->iIn>=p->nIn" */, ts+3797 /* "testdata/sqlite-..." */, uint32(154), uintptr(unsafe.Pointer(&__func__21)))
	} // Only called on an empty input buffer
	if !((*CsvReader)(unsafe.Pointer(p)).Fin != uintptr(0)) {
		crt.X__assert_fail(tls, ts+3871 /* "p->in!=0" */, ts+3797 /* "testdata/sqlite-..." */, uint32(155), uintptr(unsafe.Pointer(&__func__21)))
	} // Only called if reading froma file

	got = crt.Xfread(tls, (*CsvReader)(unsafe.Pointer(p)).FzIn, uint64(1), uint64(1024), (*CsvReader)(unsafe.Pointer(p)).Fin)
	if got == uint64(0) {
		return -1
	}
	(*CsvReader)(unsafe.Pointer(p)).FnIn = got
	(*CsvReader)(unsafe.Pointer(p)).FiIn = uint64(1)
	return int32(*(*int8)(unsafe.Pointer((*CsvReader)(unsafe.Pointer(p)).FzIn + uintptr(0))))
}

var __func__21 = *(*[16]int8)(unsafe.Pointer(ts + 3880 /* "csv_getc_refill" */)) /* csv.c:151:54 */

// Return the next character of input.  Return EOF at end of input.
func csv_getc(tls *crt.TLS, p uintptr) int32 { /* csv.c:165:12: */
	if (*CsvReader)(unsafe.Pointer(p)).FiIn >= (*CsvReader)(unsafe.Pointer(p)).FnIn {
		if (*CsvReader)(unsafe.Pointer(p)).Fin != uintptr(0) {
			return csv_getc_refill(tls, p)
		}
		return -1
	}
	return int32(*(*uint8)(unsafe.Pointer(((*CsvReader)(unsafe.Pointer(p)).FzIn) + uintptr(crt.PostIncUint64(&(*CsvReader)(unsafe.Pointer(p)).FiIn, 1)))))
}

// Increase the size of p->z and append character c to the end.
// Return 0 on success and non-zero if there is an OOM error
func csv_resize_and_append(tls *crt.TLS, p uintptr, c int8) int32 { /* csv.c:175:25: */
	var zNew uintptr
	var nNew int32 = (((*CsvReader)(unsafe.Pointer(p)).FnAlloc * 2) + 100)
	zNew = sqlite3.Xsqlite3_realloc64(tls, (*CsvReader)(unsafe.Pointer(p)).Fz, uint64(nNew))
	if zNew != 0 {
		(*CsvReader)(unsafe.Pointer(p)).Fz = zNew
		(*CsvReader)(unsafe.Pointer(p)).FnAlloc = nNew
		*(*int8)(unsafe.Pointer((*CsvReader)(unsafe.Pointer(p)).Fz + uintptr(crt.PostIncInt32(&(*CsvReader)(unsafe.Pointer(p)).Fn, 1)))) = c
		return 0
	} else {
		csv_errmsg(tls, p, ts+2471 /* "out of memory" */, 0)
		return 1
	}
	return int32(0)
}

// Append a single character to the CsvReader.z[] array.
// Return 0 on success and non-zero if there is an OOM error
func csv_append(tls *crt.TLS, p uintptr, c int8) int32 { /* csv.c:192:12: */
	if (*CsvReader)(unsafe.Pointer(p)).Fn >= ((*CsvReader)(unsafe.Pointer(p)).FnAlloc - 1) {
		return csv_resize_and_append(tls, p, c)
	}
	*(*int8)(unsafe.Pointer((*CsvReader)(unsafe.Pointer(p)).Fz + uintptr(crt.PostIncInt32(&(*CsvReader)(unsafe.Pointer(p)).Fn, 1)))) = c
	return 0
}

// Read a single field of CSV text.  Compatible with rfc4180 and extended
// with the option of having a separator other than ",".
//
//   +  Input comes from p->in.
//   +  Store results in p->z of length p->n.  Space to hold p->z comes
//      from sqlite3_malloc64().
//   +  Keep track of the line number in p->nLine.
//   +  Store the character that terminates the field in p->cTerm.  Store
//      EOF on end-of-file.
//
// Return 0 at EOF or on OOM.  On EOF, the p->cTerm character will have
// been set to EOF.
func csv_read_one_field(tls *crt.TLS, p uintptr) uintptr { /* csv.c:211:13: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var c int32
	(*CsvReader)(unsafe.Pointer(p)).Fn = 0
	c = csv_getc(tls, p)
	if c == (-1) {
		(*CsvReader)(unsafe.Pointer(p)).FcTerm = -1
		return uintptr(0)
	}
	if c == '"' {
		var pc int32
		var ppc int32
		var startLine int32 = (*CsvReader)(unsafe.Pointer(p)).FnLine
		pc = crt.AssignInt32(&ppc, 0)
		for 1 != 0 {
			c = csv_getc(tls, p)
			if (c <= '"') || (pc == '"') {
				if c == '\n' {
					(*CsvReader)(unsafe.Pointer(p)).FnLine++
				}
				if c == '"' {
					if pc == '"' {
						pc = 0
						continue
					}
				}
				if ((((c == ',') && (pc == '"')) ||
					((c == '\n') && (pc == '"'))) ||
					(((c == '\n') && (pc == '\r')) && (ppc == '"'))) ||
					((c == (-1)) && (pc == '"')) {
					for ok := true; ok; ok = (int32(*(*int8)(unsafe.Pointer((*CsvReader)(unsafe.Pointer(p)).Fz + uintptr((*CsvReader)(unsafe.Pointer(p)).Fn)))) != '"') {
						(*CsvReader)(unsafe.Pointer(p)).Fn--
					}
					(*CsvReader)(unsafe.Pointer(p)).FcTerm = int32(int8(c))
					break
				}
				if (pc == '"') && (c != '\r') {
					csv_errmsg(tls, p, ts+3896 /* "line %d: unescap..." */, crt.VaList(bp, (*CsvReader)(unsafe.Pointer(p)).FnLine, '"'))
					break
				}
				if c == (-1) {
					csv_errmsg(tls, p, ts+3928, /* "line %d: untermi..." */
						crt.VaList(bp+16, startLine, '"'))
					(*CsvReader)(unsafe.Pointer(p)).FcTerm = int32(int8(c))
					break
				}
			}
			if csv_append(tls, p, int8(c)) != 0 {
				return uintptr(0)
			}
			ppc = pc
			pc = c
		}
	} else {
		// If this is the first field being parsed and it begins with the
		// UTF-8 BOM  (0xEF BB BF) then skip the BOM
		if ((c & 0xff) == 0xef) && ((*CsvReader)(unsafe.Pointer(p)).FbNotFirst == 0) {
			csv_append(tls, p, int8(c))
			c = csv_getc(tls, p)
			if (c & 0xff) == 0xbb {
				csv_append(tls, p, int8(c))
				c = csv_getc(tls, p)
				if (c & 0xff) == 0xbf {
					(*CsvReader)(unsafe.Pointer(p)).FbNotFirst = 1
					(*CsvReader)(unsafe.Pointer(p)).Fn = 0
					return csv_read_one_field(tls, p)
				}
			}
		}
		for (c > ',') || (((c != (-1)) && (c != ',')) && (c != '\n')) {
			if csv_append(tls, p, int8(c)) != 0 {
				return uintptr(0)
			}
			c = csv_getc(tls, p)
		}
		if c == '\n' {
			(*CsvReader)(unsafe.Pointer(p)).FnLine++
			if ((*CsvReader)(unsafe.Pointer(p)).Fn > 0) && (int32(*(*int8)(unsafe.Pointer((*CsvReader)(unsafe.Pointer(p)).Fz + uintptr(((*CsvReader)(unsafe.Pointer(p)).Fn - 1))))) == '\r') {
				(*CsvReader)(unsafe.Pointer(p)).Fn--
			}
		}
		(*CsvReader)(unsafe.Pointer(p)).FcTerm = int32(int8(c))
	}
	if (*CsvReader)(unsafe.Pointer(p)).Fz != 0 {
		*(*int8)(unsafe.Pointer((*CsvReader)(unsafe.Pointer(p)).Fz + uintptr((*CsvReader)(unsafe.Pointer(p)).Fn))) = int8(0)
	}
	(*CsvReader)(unsafe.Pointer(p)).FbNotFirst = 1
	return (*CsvReader)(unsafe.Pointer(p)).Fz
}

// An instance of the CSV virtual table
type CsvTable1 = struct {
	Fbase      sqlite3_vtab
	FzFilename uintptr
	FzData     uintptr
	FiStart    int64
	FnCol      int32
	FtstFlags  uint32
}

// An instance of the CSV virtual table
type CsvTable = CsvTable1 /* csv.c:314:3 */

// Allowed values for tstFlags

// A cursor for the CSV virtual table
type CsvCursor1 = struct {
	Fbase   sqlite3_vtab_cursor
	Frdr    CsvReader
	FazVal  uintptr
	FaLen   uintptr
	FiRowid sqlite3_int64
}

// Allowed values for tstFlags

// A cursor for the CSV virtual table
type CsvCursor = CsvCursor1 /* csv.c:326:3 */

// Transfer error message text from a reader into a CsvTable
func csv_xfer_error(tls *crt.TLS, pTab uintptr, pRdr uintptr) { /* csv.c:329:13: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	sqlite3.Xsqlite3_free(tls, (*CsvTable)(unsafe.Pointer(pTab)).Fbase.FzErrMsg)
	(*CsvTable)(unsafe.Pointer(pTab)).Fbase.FzErrMsg = sqlite3.Xsqlite3_mprintf(tls, ts+130 /* "%s" */, crt.VaList(bp, pRdr+64 /* &.zErr */))
}

// This method is the destructor fo a CsvTable object.
func csvtabDisconnect(tls *crt.TLS, pVtab uintptr) int32 { /* csv.c:337:12: */
	var p uintptr = pVtab
	sqlite3.Xsqlite3_free(tls, (*CsvTable)(unsafe.Pointer(p)).FzFilename)
	sqlite3.Xsqlite3_free(tls, (*CsvTable)(unsafe.Pointer(p)).FzData)
	sqlite3.Xsqlite3_free(tls, p)
	return 0
}

// Skip leading whitespace.  Return a pointer to the first non-whitespace
// character, or to the zero terminator if the string has only whitespace
func csv_skip_whitespace(tls *crt.TLS, z uintptr) uintptr { /* csv.c:347:19: */
	for (int32(*(*uint16)(unsafe.Pointer((*(*uintptr)(unsafe.Pointer(crt.X__ctype_b_loc(tls)))) + uintptr(int32(uint8(*(*int8)(unsafe.Pointer(z + uintptr(0))))))*2))) & int32(uint16(8192))) != 0 {
		z++
	}
	return z
}

// Remove trailing whitespace from the end of string z[]
func csv_trim_whitespace(tls *crt.TLS, z uintptr) { /* csv.c:353:13: */
	var n size_t = crt.Xstrlen(tls, z)
	for (n > uint64(0)) && ((int32(*(*uint16)(unsafe.Pointer((*(*uintptr)(unsafe.Pointer(crt.X__ctype_b_loc(tls)))) + uintptr(int32(uint8(*(*int8)(unsafe.Pointer(z + uintptr(n))))))*2))) & int32(uint16(8192))) != 0) {
		n--
	}
	*(*int8)(unsafe.Pointer(z + uintptr(n))) = int8(0)
}

// Dequote the string
func csv_dequote(tls *crt.TLS, z uintptr) { /* csv.c:360:13: */
	var j int32
	var cQuote int8 = *(*int8)(unsafe.Pointer(z + uintptr(0)))
	var i size_t
	var n size_t

	if (int32(cQuote) != '\'') && (int32(cQuote) != '"') {
		return
	}
	n = crt.Xstrlen(tls, z)
	if (n < uint64(2)) || (int32(*(*int8)(unsafe.Pointer(z + uintptr((n - uint64(1)))))) != int32(*(*int8)(unsafe.Pointer(z + uintptr(0))))) {
		return
	}
	i = uint64(1)
	j = 0
	for ; i < (n - uint64(1)); i++ {
		if (int32(*(*int8)(unsafe.Pointer(z + uintptr(i)))) == int32(cQuote)) && (int32(*(*int8)(unsafe.Pointer(z + uintptr((i + uint64(1)))))) == int32(cQuote)) {
			i++
		}
		*(*int8)(unsafe.Pointer(z + uintptr(crt.PostIncInt32(&j, 1)))) = *(*int8)(unsafe.Pointer(z + uintptr(i)))
	}
	*(*int8)(unsafe.Pointer(z + uintptr(j))) = int8(0)
}

// Check to see if the string is of the form:  "TAG = VALUE" with optional
// whitespace before and around tokens.  If it is, return a pointer to the
// first character of VALUE.  If it is not, return NULL.
func csv_parameter(tls *crt.TLS, zTag uintptr, nTag int32, z uintptr) uintptr { /* csv.c:379:19: */
	z = csv_skip_whitespace(tls, z)
	if crt.Xstrncmp(tls, zTag, z, uint64(nTag)) != 0 {
		return uintptr(0)
	}
	z = csv_skip_whitespace(tls, (z + uintptr(nTag)))
	if int32(*(*int8)(unsafe.Pointer(z + uintptr(0)))) != '=' {
		return uintptr(0)
	}
	return csv_skip_whitespace(tls, (z + uintptr(1)))
}

// Decode a parameter that requires a dequoted string.
//
// Return 1 if the parameter is seen, or 0 if not.  1 is returned
// even if there is an error.  If an error occurs, then an error message
// is left in p->zErr.  If there are no errors, p->zErr[0]==0.
func csv_string_parameter(tls *crt.TLS, p uintptr, zParam uintptr, zArg uintptr, pzVal uintptr) int32 { /* csv.c:393:12: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var zValue uintptr
	zValue = csv_parameter(tls, zParam, int32(crt.Xstrlen(tls, zParam)), zArg)
	if zValue == uintptr(0) {
		return 0
	}
	*(*int8)(unsafe.Pointer((p + 64 /* &.zErr */) + uintptr(0))) = int8(0)
	if *(*uintptr)(unsafe.Pointer(pzVal)) != 0 {
		csv_errmsg(tls, p, ts+3967 /* "more than one '%..." */, crt.VaList(bp, zParam))
		return 1
	}
	*(*uintptr)(unsafe.Pointer(pzVal)) = sqlite3.Xsqlite3_mprintf(tls, ts+130 /* "%s" */, crt.VaList(bp+8, zValue))
	if *(*uintptr)(unsafe.Pointer(pzVal)) == uintptr(0) {
		csv_errmsg(tls, p, ts+2471 /* "out of memory" */, 0)
		return 1
	}
	csv_trim_whitespace(tls, *(*uintptr)(unsafe.Pointer(pzVal)))
	csv_dequote(tls, *(*uintptr)(unsafe.Pointer(pzVal)))
	return 1
}

// Return 0 if the argument is false and 1 if it is true.  Return -1 if
// we cannot really tell.
func csv_boolean(tls *crt.TLS, z uintptr) int32 { /* csv.c:421:12: */
	if (((sqlite3.Xsqlite3_stricmp(tls, ts+3996 /* "yes" */, z) == 0) ||
		(sqlite3.Xsqlite3_stricmp(tls, ts+4000 /* "on" */, z) == 0)) ||
		(sqlite3.Xsqlite3_stricmp(tls, ts+4003 /* "true" */, z) == 0)) ||
		((int32(*(*int8)(unsafe.Pointer(z + uintptr(0)))) == '1') && (int32(*(*int8)(unsafe.Pointer(z + uintptr(1)))) == 0)) {
		return 1
	}
	if (((sqlite3.Xsqlite3_stricmp(tls, ts+4008 /* "no" */, z) == 0) ||
		(sqlite3.Xsqlite3_stricmp(tls, ts+4011 /* "off" */, z) == 0)) ||
		(sqlite3.Xsqlite3_stricmp(tls, ts+4015 /* "false" */, z) == 0)) ||
		((int32(*(*int8)(unsafe.Pointer(z + uintptr(0)))) == '0') && (int32(*(*int8)(unsafe.Pointer(z + uintptr(1)))) == 0)) {
		return 0
	}
	return -1
}

// Check to see if the string is of the form:  "TAG = BOOLEAN" or just "TAG".
// If it is, set *pValue to be the value of the boolean ("true" if there is
// not "= BOOLEAN" component) and return non-zero.  If the input string
// does not begin with TAG, return zero.
func csv_boolean_parameter(tls *crt.TLS, zTag uintptr, nTag int32, z uintptr, pValue uintptr) int32 { /* csv.c:444:12: */
	var b int32
	z = csv_skip_whitespace(tls, z)
	if crt.Xstrncmp(tls, zTag, z, uint64(nTag)) != 0 {
		return 0
	}
	z = csv_skip_whitespace(tls, (z + uintptr(nTag)))
	if int32(*(*int8)(unsafe.Pointer(z + uintptr(0)))) == 0 {
		*(*int32)(unsafe.Pointer(pValue)) = 1
		return 1
	}
	if int32(*(*int8)(unsafe.Pointer(z + uintptr(0)))) != '=' {
		return 0
	}
	z = csv_skip_whitespace(tls, (z + uintptr(1)))
	b = csv_boolean(tls, z)
	if b >= 0 {
		*(*int32)(unsafe.Pointer(pValue)) = b
		return 1
	}
	return 0
}

// Parameters:
//    filename=FILENAME          Name of file containing CSV content
//    data=TEXT                  Direct CSV content.
//    schema=SCHEMA              Alternative CSV schema.
//    header=YES|NO              First row of CSV defines the names of
//                               columns if "yes".  Default "no".
//    columns=N                  Assume the CSV file contains N columns.
//
// Only available if compiled with SQLITE_TEST:
//
//    testflags=N                Bitmask of test flags.  Optional
//
// If schema= is omitted, then the columns are named "c0", "c1", "c2",
// and so forth.  If columns=N is omitted, then the file is opened and
// the number of columns in the first row is counted to determine the
// column count.  If header=YES, then the first row is skipped.
func csvtabConnect(tls *crt.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVtab uintptr, pzErr uintptr) int32 { /* csv.c:486:12: */
	bp := tls.Alloc(372)
	defer tls.Free(372)

	var pNew uintptr  // The CsvTable object to construct
	var bHeader int32 // header= flags.  -1 means not seen yet
	var rc int32      // Result code from this routine
	var i int32
	var j int32        // Loop counters
	var tstFlags int32 // Value for testflags=N parameter
	// var b int32 at bp+368, 4
	// Value of a boolean parameter
	var nCol int32 // Value of the columns= parameter
	// var sRdr CsvReader at bp+80, 264

	// var azPValue [3]uintptr at bp+344, 24

	var z uintptr
	var zValue uintptr
	var z1 uintptr
	var pStr uintptr
	var zSep uintptr
	var iCol int32
	pNew = uintptr(0)
	bHeader = -1
	rc = 0
	tstFlags = 0
	nCol = -99 // Parameter values

	if !(uint64(unsafe.Sizeof([3]uintptr{})) == uint64(unsafe.Sizeof(azParam))) {
		crt.X__assert_fail(tls, ts+4021 /* "sizeof(azPValue)..." */, ts+3797 /* "testdata/sqlite-..." */, uint32(513), uintptr(unsafe.Pointer(&__func__22)))
	}
	crt.Xmemset(tls, bp+80 /* &sRdr */, 0, uint64(unsafe.Sizeof(CsvReader{})))
	crt.Xmemset(tls, bp+344 /* &azPValue[0] */, 0, uint64(unsafe.Sizeof([3]uintptr{})))
	i = 3
__1:
	if !(i < argc) {
		goto __3
	}
	z = *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8))
	j = 0
__4:
	if !(uint64(j) < (uint64(unsafe.Sizeof(azParam)) / uint64(unsafe.Sizeof(uintptr(0))))) {
		goto __6
	}
	if !(csv_string_parameter(tls, bp+80 /* &sRdr */, azParam[j], z, (bp+344 /* &azPValue */ +uintptr(j)*8)) != 0) {
		goto __7
	}
	goto __6
__7:
	;
	goto __5
__5:
	j++
	goto __4
	goto __6
__6:
	;
	if !(uint64(j) < (uint64(unsafe.Sizeof(azParam)) / uint64(unsafe.Sizeof(uintptr(0))))) {
		goto __8
	}
	if !(*(*int8)(unsafe.Pointer((bp + 80 /* &sRdr */ + 64 /* &.zErr */) + uintptr(0))) != 0) {
		goto __10
	}
	goto csvtab_connect_error
__10:
	;
	goto __9
__8:
	if !(csv_boolean_parameter(tls, ts+4055 /* "header" */, 6, z, bp+368 /* &b */) != 0) {
		goto __11
	}
	if !(bHeader >= 0) {
		goto __13
	}
	csv_errmsg(tls, bp+80 /* &sRdr */, ts+4062 /* "more than one 'h..." */, 0)
	goto csvtab_connect_error
__13:
	;
	bHeader = *(*int32)(unsafe.Pointer(bp + 368 /* b */))
	goto __12
__11:
	if !((crt.AssignUintptr(&zValue, csv_parameter(tls, ts+4095 /* "testflags" */, 9, z))) != uintptr(0)) {
		goto __14
	}
	tstFlags = int32(uint32(crt.Xatoi(tls, zValue)))
	goto __15
__14:
	if !((crt.AssignUintptr(&zValue, csv_parameter(tls, ts+4105 /* "columns" */, 7, z))) != uintptr(0)) {
		goto __16
	}
	if !(nCol > 0) {
		goto __18
	}
	csv_errmsg(tls, bp+80 /* &sRdr */, ts+4113 /* "more than one 'c..." */, 0)
	goto csvtab_connect_error
__18:
	;
	nCol = crt.Xatoi(tls, zValue)
	if !(nCol <= 0) {
		goto __19
	}
	csv_errmsg(tls, bp+80 /* &sRdr */, ts+4147 /* "column= value mu..." */, 0)
	goto csvtab_connect_error
__19:
	;
	goto __17
__16:

	csv_errmsg(tls, bp+80 /* &sRdr */, ts+4178 /* "bad parameter: '..." */, crt.VaList(bp, z))
	goto csvtab_connect_error
__17:
	;
__15:
	;
__12:
	;
__9:
	;
	goto __2
__2:
	i++
	goto __1
	goto __3
__3:
	;
	if !((crt.Bool32((*(*uintptr)(unsafe.Pointer(bp + 344 /* &azPValue[0] */ + uintptr(0)*8))) == uintptr(0))) == (crt.Bool32((*(*uintptr)(unsafe.Pointer(bp + 344 /* &azPValue[0] */ + uintptr(1)*8))) == uintptr(0)))) {
		goto __20
	}
	csv_errmsg(tls, bp+80 /* &sRdr */, ts+4198 /* "must specify eit..." */, 0)
	goto csvtab_connect_error
__20:
	;

	if !(((nCol <= 0) || (bHeader == 1)) &&
		(csv_reader_open(tls, bp+80 /* &sRdr */, *(*uintptr)(unsafe.Pointer(bp + 344 /* &azPValue[0] */ + uintptr(0)*8)), *(*uintptr)(unsafe.Pointer(bp + 344 /* &azPValue[0] */ + uintptr(1)*8))) != 0)) {
		goto __21
	}
	goto csvtab_connect_error
__21:
	;
	pNew = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(CsvTable{})))
	*(*uintptr)(unsafe.Pointer(ppVtab)) = pNew
	if !(pNew == uintptr(0)) {
		goto __22
	}
	goto csvtab_connect_oom
__22:
	;
	crt.Xmemset(tls, pNew, 0, uint64(unsafe.Sizeof(CsvTable{})))
	if !((*(*uintptr)(unsafe.Pointer(bp + 344 /* &azPValue[0] */ + uintptr(2)*8))) == uintptr(0)) {
		goto __23
	}
	pStr = sqlite3.Xsqlite3_str_new(tls, uintptr(0))
	zSep = ts + 792 /* "" */
	iCol = 0
	sqlite3.Xsqlite3_str_appendf(tls, pStr, ts+1223 /* "CREATE TABLE x(" */, 0)
	if !((nCol < 0) && (bHeader < 1)) {
		goto __25
	}
	nCol = 0
__26:
	csv_read_one_field(tls, bp+80 /* &sRdr */)
	nCol++
	goto __27
__27:
	if (*CsvReader)(unsafe.Pointer(bp+80 /* &sRdr */)).FcTerm == ',' {
		goto __26
	}
	goto __28
__28:
	;
__25:
	;
	if !((nCol > 0) && (bHeader < 1)) {
		goto __29
	}
	iCol = 0
__31:
	if !(iCol < nCol) {
		goto __33
	}
	sqlite3.Xsqlite3_str_appendf(tls, pStr, ts+4250 /* "%sc%d TEXT" */, crt.VaList(bp+8, zSep, iCol))
	zSep = ts + 4261 /* "," */
	goto __32
__32:
	iCol++
	goto __31
	goto __33
__33:
	;
	goto __30
__29:
__34:
	z1 = csv_read_one_field(tls, bp+80 /* &sRdr */)
	if !(((nCol > 0) && (iCol < nCol)) || ((nCol < 0) && (bHeader != 0))) {
		goto __37
	}
	sqlite3.Xsqlite3_str_appendf(tls, pStr, ts+4263 /* "%s\"%w\" TEXT" */, crt.VaList(bp+24, zSep, z1))
	zSep = ts + 4261 /* "," */
	iCol++
__37:
	;
	goto __35
__35:
	if (*CsvReader)(unsafe.Pointer(bp+80 /* &sRdr */)).FcTerm == ',' {
		goto __34
	}
	goto __36
__36:
	;
	if !(nCol < 0) {
		goto __38
	}
	nCol = iCol
	goto __39
__38:
__40:
	if !(iCol < nCol) {
		goto __41
	}
	sqlite3.Xsqlite3_str_appendf(tls, pStr, ts+4250 /* "%sc%d TEXT" */, crt.VaList(bp+40, zSep, crt.PreIncInt32(&iCol, 1)))
	zSep = ts + 4261 /* "," */
	goto __40
__41:
	;
__39:
	;
__30:
	;
	(*CsvTable)(unsafe.Pointer(pNew)).FnCol = nCol
	sqlite3.Xsqlite3_str_appendf(tls, pStr, ts+793 /* ")" */, 0)
	(*(*uintptr)(unsafe.Pointer(bp + 344 /* &azPValue[0] */ + uintptr(2)*8))) = sqlite3.Xsqlite3_str_finish(tls, pStr)
	if !((*(*uintptr)(unsafe.Pointer(bp + 344 /* &azPValue[0] */ + uintptr(2)*8))) == uintptr(0)) {
		goto __42
	}
	goto csvtab_connect_oom
__42:
	;
	goto __24
__23:
	if !(nCol < 0) {
		goto __43
	}
__45:
	csv_read_one_field(tls, bp+80 /* &sRdr */)
	(*CsvTable)(unsafe.Pointer(pNew)).FnCol++
	goto __46
__46:
	if (*CsvReader)(unsafe.Pointer(bp+80 /* &sRdr */)).FcTerm == ',' {
		goto __45
	}
	goto __47
__47:
	;
	goto __44
__43:
	(*CsvTable)(unsafe.Pointer(pNew)).FnCol = nCol
__44:
	;
__24:
	;
	(*CsvTable)(unsafe.Pointer(pNew)).FzFilename = *(*uintptr)(unsafe.Pointer(bp + 344 /* &azPValue[0] */ + uintptr(0)*8))
	(*(*uintptr)(unsafe.Pointer(bp + 344 /* &azPValue[0] */ + uintptr(0)*8))) = uintptr(0)
	(*CsvTable)(unsafe.Pointer(pNew)).FzData = *(*uintptr)(unsafe.Pointer(bp + 344 /* &azPValue[0] */ + uintptr(1)*8))
	(*(*uintptr)(unsafe.Pointer(bp + 344 /* &azPValue[0] */ + uintptr(1)*8))) = uintptr(0)
	(*CsvTable)(unsafe.Pointer(pNew)).FtstFlags = uint32(tstFlags)
	if !(bHeader != 1) {
		goto __48
	}
	(*CsvTable)(unsafe.Pointer(pNew)).FiStart = int64(0)
	goto __49
__48:
	if !((*CsvTable)(unsafe.Pointer(pNew)).FzData != 0) {
		goto __50
	}
	(*CsvTable)(unsafe.Pointer(pNew)).FiStart = int64(int32((*CsvReader)(unsafe.Pointer(bp + 80 /* &sRdr */)).FiIn))
	goto __51
__50:
	(*CsvTable)(unsafe.Pointer(pNew)).FiStart = int64((int32((size_t(crt.Xftell(tls, (*CsvReader)(unsafe.Pointer(bp+80 /* &sRdr */)).Fin)) - (*CsvReader)(unsafe.Pointer(bp+80 /* &sRdr */)).FnIn) + (*CsvReader)(unsafe.Pointer(bp+80 /* &sRdr */)).FiIn)))
__51:
	;
__49:
	;
	csv_reader_reset(tls, bp+80 /* &sRdr */)
	rc = sqlite3.Xsqlite3_declare_vtab(tls, db, *(*uintptr)(unsafe.Pointer(bp + 344 /* &azPValue[0] */ + uintptr(2)*8)))
	if !(rc != 0) {
		goto __52
	}
	csv_errmsg(tls, bp+80 /* &sRdr */, ts+4275 /* "bad schema: '%s'..." */, crt.VaList(bp+56, *(*uintptr)(unsafe.Pointer(bp + 344 /* &azPValue[0] */ + uintptr(2)*8)), sqlite3.Xsqlite3_errmsg(tls, db)))
	goto csvtab_connect_error
__52:
	;
	i = 0
__53:
	if !(uint64(i) < (uint64(unsafe.Sizeof([3]uintptr{})) / uint64(unsafe.Sizeof(uintptr(0))))) {
		goto __55
	}
	sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(bp + 344 /* &azPValue[0] */ + uintptr(i)*8)))
	goto __54
__54:
	i++
	goto __53
	goto __55
__55:
	;
	// Rationale for DIRECTONLY:
	// An attacker who controls a database schema could use this vtab
	// to exfiltrate sensitive data from other files in the filesystem.
	// And, recommended practice is to put all CSV virtual tables in the
	// TEMP namespace, so they should still be usable from within TEMP
	// views, so there shouldn't be a serious loss of functionality by
	// prohibiting the use of this vtab from persistent triggers and views.
	sqlite3.Xsqlite3_vtab_config(tls, db, 3, 0)
	return 0

csvtab_connect_oom:
	rc = 7
	csv_errmsg(tls, bp+80 /* &sRdr */, ts+2471 /* "out of memory" */, 0)

csvtab_connect_error:
	if !(pNew != 0) {
		goto __56
	}
	csvtabDisconnect(tls, (pNew /* &.base */))
__56:
	;
	i = 0
__57:
	if !(uint64(i) < (uint64(unsafe.Sizeof([3]uintptr{})) / uint64(unsafe.Sizeof(uintptr(0))))) {
		goto __59
	}
	sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(bp + 344 /* &azPValue[0] */ + uintptr(i)*8)))
	goto __58
__58:
	i++
	goto __57
	goto __59
__59:
	;
	if !(*(*int8)(unsafe.Pointer((bp + 80 /* &sRdr */ + 64 /* &.zErr */) + uintptr(0))) != 0) {
		goto __60
	}
	sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(pzErr)))
	*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+130 /* "%s" */, crt.VaList(bp+72, bp+80 /* &sRdr */ +64 /* &.zErr */))
__60:
	;
	csv_reader_reset(tls, bp+80 /* &sRdr */)
	if !(rc == 0) {
		goto __61
	}
	rc = 1
__61:
	;
	return rc
}

var __func__22 = *(*[14]int8)(unsafe.Pointer(ts + 4297 /* "csvtabConnect" */)) /* csv.c:492:2 */
var azParam = [3]uintptr{
	ts + 4311 /* "filename" */, ts + 4320 /* "data" */, ts + 4325, /* "schema" */
} /* csv.c:504:21 */

// Reset the current row content held by a CsvCursor.
func csvtabCursorRowReset(tls *crt.TLS, pCur uintptr) { /* csv.c:667:13: */
	var pTab uintptr = (*CsvCursor)(unsafe.Pointer(pCur)).Fbase.FpVtab
	var i int32
	for i = 0; i < (*CsvTable)(unsafe.Pointer(pTab)).FnCol; i++ {
		sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer((*CsvCursor)(unsafe.Pointer(pCur)).FazVal + uintptr(i)*8)))
		*(*uintptr)(unsafe.Pointer((*CsvCursor)(unsafe.Pointer(pCur)).FazVal + uintptr(i)*8)) = uintptr(0)
		*(*int32)(unsafe.Pointer((*CsvCursor)(unsafe.Pointer(pCur)).FaLen + uintptr(i)*4)) = 0
	}
}

// The xConnect and xCreate methods do the same thing, but they must be
// different so that the virtual table is not an eponymous virtual table.
func csvtabCreate(tls *crt.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVtab uintptr, pzErr uintptr) int32 { /* csv.c:681:12: */
	return csvtabConnect(tls, db, pAux, argc, argv, ppVtab, pzErr)
}

// Destructor for a CsvCursor.
func csvtabClose(tls *crt.TLS, cur uintptr) int32 { /* csv.c:694:12: */
	var pCur uintptr = cur
	csvtabCursorRowReset(tls, pCur)
	csv_reader_reset(tls, (pCur + 8 /* &.rdr */))
	sqlite3.Xsqlite3_free(tls, cur)
	return 0
}

// Constructor for a new CsvTable cursor object.
func csvtabOpen(tls *crt.TLS, p uintptr, ppCursor uintptr) int32 { /* csv.c:705:12: */
	var pTab uintptr = p
	var pCur uintptr
	var nByte size_t
	nByte = (uint64(unsafe.Sizeof(CsvCursor{})) + ((uint64(unsafe.Sizeof(uintptr(0))) + uint64(unsafe.Sizeof(int32(0)))) * uint64((*CsvTable)(unsafe.Pointer(pTab)).FnCol)))
	pCur = sqlite3.Xsqlite3_malloc64(tls, uint64(nByte))
	if pCur == uintptr(0) {
		return 7
	}
	crt.Xmemset(tls, pCur, 0, nByte)
	(*CsvCursor)(unsafe.Pointer(pCur)).FazVal = (pCur + uintptr(1)*296)
	(*CsvCursor)(unsafe.Pointer(pCur)).FaLen = ((*CsvCursor)(unsafe.Pointer(pCur)).FazVal + uintptr((*CsvTable)(unsafe.Pointer(pTab)).FnCol)*8)
	*(*uintptr)(unsafe.Pointer(ppCursor)) = (pCur /* &.base */)
	if csv_reader_open(tls, (pCur+8 /* &.rdr */), (*CsvTable)(unsafe.Pointer(pTab)).FzFilename, (*CsvTable)(unsafe.Pointer(pTab)).FzData) != 0 {
		csv_xfer_error(tls, pTab, (pCur + 8 /* &.rdr */))
		return 1
	}
	return 0
}

// Advance a CsvCursor to its next row of input.
// Set the EOF marker if we reach the end of input.
func csvtabNext(tls *crt.TLS, cur uintptr) int32 { /* csv.c:728:12: */
	var pCur uintptr = cur
	var pTab uintptr = (*sqlite3_vtab_cursor)(unsafe.Pointer(cur)).FpVtab
	var i int32 = 0
	var z uintptr
	for ok := true; ok; ok = ((*CsvCursor)(unsafe.Pointer(pCur)).Frdr.FcTerm == ',') {
		z = csv_read_one_field(tls, (pCur + 8 /* &.rdr */))
		if z == uintptr(0) {
			break
		}
		if i < (*CsvTable)(unsafe.Pointer(pTab)).FnCol {
			if *(*int32)(unsafe.Pointer((*CsvCursor)(unsafe.Pointer(pCur)).FaLen + uintptr(i)*4)) < ((*CsvCursor)(unsafe.Pointer(pCur)).Frdr.Fn + 1) {
				var zNew uintptr = sqlite3.Xsqlite3_realloc64(tls, *(*uintptr)(unsafe.Pointer((*CsvCursor)(unsafe.Pointer(pCur)).FazVal + uintptr(i)*8)), (uint64((*CsvCursor)(unsafe.Pointer(pCur)).Frdr.Fn + 1)))
				if zNew == uintptr(0) {
					csv_errmsg(tls, (pCur + 8 /* &.rdr */), ts+2471 /* "out of memory" */, 0)
					csv_xfer_error(tls, pTab, (pCur + 8 /* &.rdr */))
					break
				}
				*(*uintptr)(unsafe.Pointer((*CsvCursor)(unsafe.Pointer(pCur)).FazVal + uintptr(i)*8)) = zNew
				*(*int32)(unsafe.Pointer((*CsvCursor)(unsafe.Pointer(pCur)).FaLen + uintptr(i)*4)) = ((*CsvCursor)(unsafe.Pointer(pCur)).Frdr.Fn + 1)
			}
			crt.Xmemcpy(tls, *(*uintptr)(unsafe.Pointer((*CsvCursor)(unsafe.Pointer(pCur)).FazVal + uintptr(i)*8)), z, (uint64((*CsvCursor)(unsafe.Pointer(pCur)).Frdr.Fn + 1)))
			i++
		}
	}
	if (z == uintptr(0)) || (((*CsvCursor)(unsafe.Pointer(pCur)).Frdr.FcTerm == (-1)) && (i < (*CsvTable)(unsafe.Pointer(pTab)).FnCol)) {
		(*CsvCursor)(unsafe.Pointer(pCur)).FiRowid = int64(-1)
	} else {
		(*CsvCursor)(unsafe.Pointer(pCur)).FiRowid++
		for i < (*CsvTable)(unsafe.Pointer(pTab)).FnCol {
			sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer((*CsvCursor)(unsafe.Pointer(pCur)).FazVal + uintptr(i)*8)))
			*(*uintptr)(unsafe.Pointer((*CsvCursor)(unsafe.Pointer(pCur)).FazVal + uintptr(i)*8)) = uintptr(0)
			*(*int32)(unsafe.Pointer((*CsvCursor)(unsafe.Pointer(pCur)).FaLen + uintptr(i)*4)) = 0
			i++
		}
	}
	return 0
}

// Return values of columns for the row at which the CsvCursor
// is currently pointing.
func csvtabColumn(tls *crt.TLS, cur uintptr, ctx uintptr, i int32) int32 { /* csv.c:771:12: */
	var pCur uintptr = cur
	var pTab uintptr = (*sqlite3_vtab_cursor)(unsafe.Pointer(cur)).FpVtab
	if ((i >= 0) && (i < (*CsvTable)(unsafe.Pointer(pTab)).FnCol)) && (*(*uintptr)(unsafe.Pointer((*CsvCursor)(unsafe.Pointer(pCur)).FazVal + uintptr(i)*8)) != uintptr(0)) {
		sqlite3.Xsqlite3_result_text(tls, ctx, *(*uintptr)(unsafe.Pointer((*CsvCursor)(unsafe.Pointer(pCur)).FazVal + uintptr(i)*8)), -1, uintptr(0))
	}
	return 0
}

// Return the rowid for the current row.
func csvtabRowid(tls *crt.TLS, cur uintptr, pRowid uintptr) int32 { /* csv.c:787:12: */
	var pCur uintptr = cur
	*(*sqlite_int64)(unsafe.Pointer(pRowid)) = (*CsvCursor)(unsafe.Pointer(pCur)).FiRowid
	return 0
}

// Return TRUE if the cursor has been moved off of the last
// row of output.
func csvtabEof(tls *crt.TLS, cur uintptr) int32 { /* csv.c:797:12: */
	var pCur uintptr = cur
	return (crt.Bool32((*CsvCursor)(unsafe.Pointer(pCur)).FiRowid < int64(0)))
}

// Only a full table scan is supported.  So xFilter simply rewinds to
// the beginning.
func csvtabFilter(tls *crt.TLS, pVtabCursor uintptr, idxNum int32, idxStr uintptr, argc int32, argv uintptr) int32 { /* csv.c:806:12: */
	var pCur uintptr = pVtabCursor
	var pTab uintptr = (*sqlite3_vtab_cursor)(unsafe.Pointer(pVtabCursor)).FpVtab
	(*CsvCursor)(unsafe.Pointer(pCur)).FiRowid = int64(0)
	if (*CsvCursor)(unsafe.Pointer(pCur)).Frdr.Fin == uintptr(0) {
		if !((*CsvCursor)(unsafe.Pointer(pCur)).Frdr.FzIn == (*CsvTable)(unsafe.Pointer(pTab)).FzData) {
			crt.X__assert_fail(tls, ts+4332 /* "pCur->rdr.zIn==p..." */, ts+3797 /* "testdata/sqlite-..." */, uint32(815), uintptr(unsafe.Pointer(&__func__23)))
		}
		if !((*CsvTable)(unsafe.Pointer(pTab)).FiStart >= int64(0)) {
			crt.X__assert_fail(tls, ts+4359 /* "pTab->iStart>=0" */, ts+3797 /* "testdata/sqlite-..." */, uint32(816), uintptr(unsafe.Pointer(&__func__23)))
		}
		if !(size_t((*CsvTable)(unsafe.Pointer(pTab)).FiStart) <= (*CsvCursor)(unsafe.Pointer(pCur)).Frdr.FnIn) {
			crt.X__assert_fail(tls, ts+4375 /* "(size_t)pTab->iS..." */, ts+3797 /* "testdata/sqlite-..." */, uint32(817), uintptr(unsafe.Pointer(&__func__23)))
		}
		(*CsvCursor)(unsafe.Pointer(pCur)).Frdr.FiIn = size_t((*CsvTable)(unsafe.Pointer(pTab)).FiStart)
	} else {
		crt.Xfseek(tls, (*CsvCursor)(unsafe.Pointer(pCur)).Frdr.Fin, (*CsvTable)(unsafe.Pointer(pTab)).FiStart, 0)
		(*CsvCursor)(unsafe.Pointer(pCur)).Frdr.FiIn = uint64(0)
		(*CsvCursor)(unsafe.Pointer(pCur)).Frdr.FnIn = uint64(0)
	}
	return csvtabNext(tls, pVtabCursor)
}

var __func__23 = *(*[13]int8)(unsafe.Pointer(ts + 4411 /* "csvtabFilter" */)) /* csv.c:810:2 */

// Only a forward full table scan is supported.  xBestIndex is mostly
// a no-op.  If CSVTEST_FIDX is set, then the presence of equality
// constraints lowers the estimated cost, which is fiction, but is useful
// for testing certain kinds of virtual table behavior.
func csvtabBestIndex(tls *crt.TLS, tab uintptr, pIdxInfo uintptr) int32 { /* csv.c:833:12: */
	(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = float64(1000000)
	if ((*CsvTable)(unsafe.Pointer((tab))).FtstFlags & uint32(0x0001)) != uint32(0) {
		// The usual (and sensible) case is to always do a full table scan.
		// The code in this branch only runs when testflags=1.  This code
		// generates an artifical and unrealistic plan which is useful
		// for testing virtual table logic but is not helpful to real applications.
		//
		// Any ==, LIKE, or GLOB constraint is marked as usable by the virtual
		// table (even though it is not) and the cost of running the virtual table
		// is reduced from 1 million to just 10.  The constraints are *not* marked
		// as omittable, however, so the query planner should still generate a
		// plan that gives a correct answer, even if they plan is not optimal.
		var i int32
		var nConst int32 = 0
		for i = 0; i < (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnConstraint; i++ {
			var op uint8
			if int32((*sqlite3_index_constraint)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraint+uintptr(i)*12)).Fusable) == 0 {
				continue
			}
			op = (*sqlite3_index_constraint)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraint + uintptr(i)*12)).Fop
			if ((int32(op) == 2) ||
				(int32(op) == 65)) ||
				(int32(op) == 66) {
				(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = float64(10)
				(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(nConst)*8)).FargvIndex = (nConst + 1)
				nConst++
			}
		}
	}
	return 0
}

var CsvModule = sqlite3_module{FiVersion: 0, FxCreate: // iVersion
0, FxConnect:// xCreate
0, FxBestIndex:// xConnect
0, FxDisconnect:// xBestIndex
0, FxDestroy:// xDisconnect
0, FxOpen:// xDestroy
0, FxClose:// xOpen - open a cursor
0, FxFilter:// xClose - close a cursor
0, FxNext:// xFilter - configure scan constraints
0, FxEof:// xNext - advance a cursor
0, FxColumn:// xEof - check for end of scan
0, FxRowid:// xColumn - read data
0, FxUpdate:// xRowid - read data
uintptr(0), FxBegin:// xUpdate
uintptr(0), FxSync:// xBegin
uintptr(0), FxCommit:// xSync
uintptr(0), FxRollback:// xCommit
uintptr(0), FxFindFunction:// xRollback
uintptr(0), FxRename:// xFindMethod
uintptr(0), // xRename
} /* csv.c:872:23 */

// For virtual table testing, make a version of the CSV virtual table
// available that has an xUpdate function.  But the xUpdate always returns
// SQLITE_READONLY since the CSV file is not really writable.
func csvtabUpdate(tls *crt.TLS, p uintptr, n int32, v uintptr, x uintptr) int32 { /* csv.c:901:12: */
	return 8
}

var CsvModuleFauxWrite = sqlite3_module{FiVersion: 0, FxCreate: // iVersion
0, FxConnect:// xCreate
0, FxBestIndex:// xConnect
0, FxDisconnect:// xBestIndex
0, FxDestroy:// xDisconnect
0, FxOpen:// xDestroy
0, FxClose:// xOpen - open a cursor
0, FxFilter:// xClose - close a cursor
0, FxNext:// xFilter - configure scan constraints
0, FxEof:// xNext - advance a cursor
0, FxColumn:// xEof - check for end of scan
0, FxRowid:// xColumn - read data
0, FxUpdate:// xRowid - read data
0, FxBegin:// xUpdate
uintptr(0), FxSync:// xBegin
uintptr(0), FxCommit:// xSync
uintptr(0), FxRollback:// xCommit
uintptr(0), FxFindFunction:// xRollback
uintptr(0), FxRename:// xFindMethod
uintptr(0), // xRename
} /* csv.c:904:23 */

// This routine is called when the extension is loaded.  The new
// CSV virtual table module is registered with the calling database
// connection.
func sqlite3_csv_init(tls *crt.TLS, db uintptr, pzErrMsg uintptr, pApi uintptr) int32 { /* csv.c:939:5: */
	var rc int32
	_ = pApi

	rc = sqlite3.Xsqlite3_create_module(tls, db, ts+4424 /* "csv" */, uintptr(unsafe.Pointer(&CsvModule)), uintptr(0))
	if rc == 0 {
		rc = sqlite3.Xsqlite3_create_module(tls, db, ts+4428 /* "csv_wr" */, uintptr(unsafe.Pointer(&CsvModuleFauxWrite)), uintptr(0))
	}
	return rc
}

// Structure used to accumulate the output
type EvalResult = struct {
	Fz      uintptr
	FzSep   uintptr
	FszSep  int32
	FnAlloc sqlite3_int64
	FnUsed  sqlite3_int64
}

// Callback from sqlite_exec() for the eval() function.
func callback(tls *crt.TLS, pCtx uintptr, argc int32, argv uintptr, colnames uintptr) int32 { /* eval.c:34:12: */
	var p uintptr = pCtx
	var i int32
	if argv == uintptr(0) {
		return 0
	}
	for i = 0; i < argc; i++ {
		var z uintptr
		if *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8)) != 0 {
			z = *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8))
		} else {
			z = ts + 792 /* "" */
		}
		var sz size_t = crt.Xstrlen(tls, z)
		if (((sqlite3_int64(sz) + (*EvalResult)(unsafe.Pointer(p)).FnUsed) + sqlite3_int64((*EvalResult)(unsafe.Pointer(p)).FszSep)) + int64(1)) > (*EvalResult)(unsafe.Pointer(p)).FnAlloc {
			var zNew uintptr
			(*EvalResult)(unsafe.Pointer(p)).FnAlloc = (sqlite3_int64((((uint64((*EvalResult)(unsafe.Pointer(p)).FnAlloc * int64(2))) + uint64(sz)) + uint64((*EvalResult)(unsafe.Pointer(p)).FszSep)) + uint64(1)))
			// Using sqlite3_realloc64() would be better, but it is a recent
			// addition and will cause a segfault if loaded by an older version
			// of SQLite.
			if (*EvalResult)(unsafe.Pointer(p)).FnAlloc <= int64(0x7fffffff) {
				zNew = sqlite3.Xsqlite3_realloc64(tls, (*EvalResult)(unsafe.Pointer(p)).Fz, uint64((*EvalResult)(unsafe.Pointer(p)).FnAlloc))
			} else {
				zNew = uintptr(0)
			}
			if zNew == uintptr(0) {
				sqlite3.Xsqlite3_free(tls, (*EvalResult)(unsafe.Pointer(p)).Fz)
				crt.Xmemset(tls, p, 0, uint64(unsafe.Sizeof(EvalResult{})))
				return 1
			}
			(*EvalResult)(unsafe.Pointer(p)).Fz = zNew
		}
		if (*EvalResult)(unsafe.Pointer(p)).FnUsed > int64(0) {
			crt.Xmemcpy(tls, ((*EvalResult)(unsafe.Pointer(p)).Fz + uintptr((*EvalResult)(unsafe.Pointer(p)).FnUsed)), (*EvalResult)(unsafe.Pointer(p)).FzSep, uint64((*EvalResult)(unsafe.Pointer(p)).FszSep))
			*(*sqlite3_int64)(unsafe.Pointer(p + 32 /* &.nUsed */)) += (sqlite3_int64((*EvalResult)(unsafe.Pointer(p)).FszSep))
		}
		crt.Xmemcpy(tls, ((*EvalResult)(unsafe.Pointer(p)).Fz + uintptr((*EvalResult)(unsafe.Pointer(p)).FnUsed)), z, sz)
		*(*sqlite3_int64)(unsafe.Pointer(p + 32 /* &.nUsed */)) += sqlite3_int64((uint64(sz)))
	}
	return 0
}

// Implementation of the eval(X) and eval(X,Y) SQL functions.
//
// Evaluate the SQL text in X.  Return the results, using string
// Y as the separator.  If Y is omitted, use a single space character.
func sqlEvalFunc(tls *crt.TLS, context uintptr, argc int32, argv uintptr) { /* eval.c:71:13: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var zSql uintptr
	var db uintptr
	*(*uintptr)(unsafe.Pointer(bp + 40 /* zErr */)) = uintptr(0)
	var rc int32
	// var x EvalResult at bp, 40

	crt.Xmemset(tls, bp /* &x */, 0, uint64(unsafe.Sizeof(EvalResult{})))
	(*EvalResult)(unsafe.Pointer(bp /* &x */)).FzSep = ts + 4435 /* " " */
	zSql = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)))
	if zSql == uintptr(0) {
		return
	}
	if argc > 1 {
		(*EvalResult)(unsafe.Pointer(bp /* &x */)).FzSep = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)))
		if (*EvalResult)(unsafe.Pointer(bp /* &x */)).FzSep == uintptr(0) {
			return
		}
	}
	(*EvalResult)(unsafe.Pointer(bp /* &x */)).FszSep = int32(crt.Xstrlen(tls, (*EvalResult)(unsafe.Pointer(bp /* &x */)).FzSep))
	db = sqlite3.Xsqlite3_context_db_handle(tls, context)
	rc = sqlite3.Xsqlite3_exec(tls, db, zSql, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, int32, uintptr, uintptr) int32
	}{callback})), bp /* &x */, bp+40 /* &zErr */)
	if rc != 0 {
		sqlite3.Xsqlite3_result_error(tls, context, *(*uintptr)(unsafe.Pointer(bp + 40 /* zErr */)), -1)
		sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(bp + 40 /* zErr */)))
	} else if (*EvalResult)(unsafe.Pointer(bp /* &x */)).FzSep == uintptr(0) {
		sqlite3.Xsqlite3_result_error_nomem(tls, context)
		sqlite3.Xsqlite3_free(tls, (*EvalResult)(unsafe.Pointer(bp /* &x */)).Fz)
	} else {
		sqlite3.Xsqlite3_result_text(tls, context, (*EvalResult)(unsafe.Pointer(bp /* &x */)).Fz, int32((*EvalResult)(unsafe.Pointer(bp /* &x */)).FnUsed), *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, uintptr) }{sqlite3.Xsqlite3_free})))
	}
}

func sqlite3_eval_init(tls *crt.TLS, db uintptr, pzErrMsg uintptr, pApi uintptr) int32 { /* eval.c:108:5: */
	var rc int32 = 0
	_ = pApi

	_ = pzErrMsg // Unused parameter
	rc = sqlite3.Xsqlite3_create_function(tls, db, ts+4437 /* "eval" */, 1,
		(1 | 0x000080000), uintptr(0),
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*crt.TLS, uintptr, int32, uintptr)
		}{sqlEvalFunc})), uintptr(0), uintptr(0))
	if rc == 0 {
		rc = sqlite3.Xsqlite3_create_function(tls, db, ts+4437 /* "eval" */, 2,
			(1 | 0x000080000), uintptr(0),
			*(*uintptr)(unsafe.Pointer(&struct {
				f func(*crt.TLS, uintptr, int32, uintptr)
			}{sqlEvalFunc})), uintptr(0), uintptr(0))
	}
	return rc
}

// explain_vtab is a subclass of sqlite3_vtab which will
// serve as the underlying representation of a explain virtual table
type explain_vtab1 = struct {
	Fbase sqlite3_vtab
	Fdb   uintptr
}

// explain_vtab is a subclass of sqlite3_vtab which will
// serve as the underlying representation of a explain virtual table
type explain_vtab = explain_vtab1 /* explain.c:38:29 */

// explain_cursor is a subclass of sqlite3_vtab_cursor which will
// serve as the underlying representation of a cursor that scans
// over rows of the result from an EXPLAIN operation.
type explain_cursor1 = struct {
	Fbase     sqlite3_vtab_cursor
	Fdb       uintptr
	FzSql     uintptr
	FpExplain uintptr
	Frc       int32
	_         [4]byte
}

// explain_cursor is a subclass of sqlite3_vtab_cursor which will
// serve as the underlying representation of a cursor that scans
// over rows of the result from an EXPLAIN operation.
type explain_cursor = explain_cursor1 /* explain.c:48:31 */

// The explainConnect() method is invoked to create a new
// explain_vtab that describes the explain virtual table.
//
// Think of this routine as the constructor for explain_vtab objects.
//
// All this routine needs to do is:
//
//    (1) Allocate the explain_vtab object and initialize all fields.
//
//    (2) Tell SQLite (via the sqlite3_declare_vtab() interface) what the
//        result set of queries against explain will look like.
func explainConnect(tls *crt.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVtab uintptr, pzErr uintptr) int32 { /* explain.c:70:12: */
	var pNew uintptr
	var rc int32

	// Column numbers

	rc = sqlite3.Xsqlite3_declare_vtab(tls, db,
		ts+4442 /* "CREATE TABLE x(a..." */)
	if rc == 0 {
		pNew = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(explain_vtab{})))
		*(*uintptr)(unsafe.Pointer(ppVtab)) = pNew
		if pNew == uintptr(0) {
			return 7
		}
		crt.Xmemset(tls, pNew, 0, uint64(unsafe.Sizeof(explain_vtab{})))
		(*explain_vtab)(unsafe.Pointer(pNew)).Fdb = db
	}
	return rc
}

// This method is the destructor for explain_cursor objects.
func explainDisconnect(tls *crt.TLS, pVtab uintptr) int32 { /* explain.c:107:12: */
	sqlite3.Xsqlite3_free(tls, pVtab)
	return 0
}

// Constructor for a new explain_cursor object.
func explainOpen(tls *crt.TLS, p uintptr, ppCursor uintptr) int32 { /* explain.c:115:12: */
	var pCur uintptr
	pCur = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(explain_cursor{})))
	if pCur == uintptr(0) {
		return 7
	}
	crt.Xmemset(tls, pCur, 0, uint64(unsafe.Sizeof(explain_cursor{})))
	(*explain_cursor)(unsafe.Pointer(pCur)).Fdb = (*explain_vtab)(unsafe.Pointer(p)).Fdb
	*(*uintptr)(unsafe.Pointer(ppCursor)) = (pCur /* &.base */)
	return 0
}

// Destructor for a explain_cursor.
func explainClose(tls *crt.TLS, cur uintptr) int32 { /* explain.c:128:12: */
	var pCur uintptr = cur
	sqlite3.Xsqlite3_finalize(tls, (*explain_cursor)(unsafe.Pointer(pCur)).FpExplain)
	sqlite3.Xsqlite3_free(tls, (*explain_cursor)(unsafe.Pointer(pCur)).FzSql)
	sqlite3.Xsqlite3_free(tls, pCur)
	return 0
}

// Advance a explain_cursor to its next row of output.
func explainNext(tls *crt.TLS, cur uintptr) int32 { /* explain.c:140:12: */
	var pCur uintptr = cur
	(*explain_cursor)(unsafe.Pointer(pCur)).Frc = sqlite3.Xsqlite3_step(tls, (*explain_cursor)(unsafe.Pointer(pCur)).FpExplain)
	if ((*explain_cursor)(unsafe.Pointer(pCur)).Frc != 101) && ((*explain_cursor)(unsafe.Pointer(pCur)).Frc != 100) {
		return (*explain_cursor)(unsafe.Pointer(pCur)).Frc
	}
	return 0
}

// Return values of columns for the row at which the explain_cursor
// is currently pointing.
func explainColumn(tls *crt.TLS, cur uintptr, ctx uintptr, i int32) int32 { /* explain.c:151:12: */
	var pCur uintptr = cur
	if i == 8 {
		sqlite3.Xsqlite3_result_text(tls, ctx, (*explain_cursor)(unsafe.Pointer(pCur)).FzSql, -1, crt.UintptrFromInt32(-1))
	} else {
		sqlite3.Xsqlite3_result_value(tls, ctx, sqlite3.Xsqlite3_column_value(tls, (*explain_cursor)(unsafe.Pointer(pCur)).FpExplain, i))
	}
	return 0
}

// Return the rowid for the current row.  In this implementation, the
// rowid is the same as the output value.
func explainRowid(tls *crt.TLS, cur uintptr, pRowid uintptr) int32 { /* explain.c:169:12: */
	var pCur uintptr = cur
	*(*sqlite_int64)(unsafe.Pointer(pRowid)) = sqlite3.Xsqlite3_column_int64(tls, (*explain_cursor)(unsafe.Pointer(pCur)).FpExplain, 0)
	return 0
}

// Return TRUE if the cursor has been moved off of the last
// row of output.
func explainEof(tls *crt.TLS, cur uintptr) int32 { /* explain.c:179:12: */
	var pCur uintptr = cur
	return (crt.Bool32((*explain_cursor)(unsafe.Pointer(pCur)).Frc != 100))
}

// This method is called to "rewind" the explain_cursor object back
// to the first row of output.  This method is always called at least
// once prior to any call to explainColumn() or explainRowid() or
// explainEof().
//
// The argv[0] is the SQL statement that is to be explained.
func explainFilter(tls *crt.TLS, pVtabCursor uintptr, idxNum int32, idxStr uintptr, argc int32, argv uintptr) int32 { /* explain.c:192:12: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var pCur uintptr = pVtabCursor
	var zSql uintptr = uintptr(0)
	var rc int32
	sqlite3.Xsqlite3_finalize(tls, (*explain_cursor)(unsafe.Pointer(pCur)).FpExplain)
	(*explain_cursor)(unsafe.Pointer(pCur)).FpExplain = uintptr(0)
	if sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8))) != 3 {
		(*explain_cursor)(unsafe.Pointer(pCur)).Frc = 101
		return 0
	}
	sqlite3.Xsqlite3_free(tls, (*explain_cursor)(unsafe.Pointer(pCur)).FzSql)
	(*explain_cursor)(unsafe.Pointer(pCur)).FzSql = sqlite3.Xsqlite3_mprintf(tls, ts+130 /* "%s" */, crt.VaList(bp, sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)))))
	if (*explain_cursor)(unsafe.Pointer(pCur)).FzSql != 0 {
		zSql = sqlite3.Xsqlite3_mprintf(tls, ts+4504 /* "EXPLAIN %s" */, crt.VaList(bp+8, (*explain_cursor)(unsafe.Pointer(pCur)).FzSql))
	}
	if zSql == uintptr(0) {
		rc = 7
	} else {
		rc = sqlite3.Xsqlite3_prepare_v2(tls, (*explain_cursor)(unsafe.Pointer(pCur)).Fdb, zSql, -1, (pCur + 24 /* &.pExplain */), uintptr(0))
		sqlite3.Xsqlite3_free(tls, zSql)
	}
	if rc != 0 {
		sqlite3.Xsqlite3_finalize(tls, (*explain_cursor)(unsafe.Pointer(pCur)).FpExplain)
		(*explain_cursor)(unsafe.Pointer(pCur)).FpExplain = uintptr(0)
		sqlite3.Xsqlite3_free(tls, (*explain_cursor)(unsafe.Pointer(pCur)).FzSql)
		(*explain_cursor)(unsafe.Pointer(pCur)).FzSql = uintptr(0)
	} else {
		(*explain_cursor)(unsafe.Pointer(pCur)).Frc = sqlite3.Xsqlite3_step(tls, (*explain_cursor)(unsafe.Pointer(pCur)).FpExplain)
		if ((*explain_cursor)(unsafe.Pointer(pCur)).Frc == 101) || ((*explain_cursor)(unsafe.Pointer(pCur)).Frc == 100) {
			rc = 0
		} else {
			rc = (*explain_cursor)(unsafe.Pointer(pCur)).Frc
		}
	}
	return rc
}

// SQLite will invoke this method one or more times while planning a query
// that uses the explain virtual table.  This routine needs to create
// a query plan for each invocation and compute an estimated cost for that
// plan.
func explainBestIndex(tls *crt.TLS, tab uintptr, pIdxInfo uintptr) int32 { /* explain.c:235:12: */
	var i int32            // Loop counter
	var idx int32 = -1     // Index of a usable == constraint against SQL
	var unusable int32 = 0 // True if there are unusable constraints on SQL

	(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedRows = int64(500)
	for i = 0; i < (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnConstraint; i++ {
		var p uintptr = ((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraint + uintptr(i)*12)
		if (*sqlite3_index_constraint)(unsafe.Pointer(p)).FiColumn != 8 {
			continue
		}
		if !(int32((*sqlite3_index_constraint)(unsafe.Pointer(p)).Fusable) != 0) {
			unusable = 1
		} else if int32((*sqlite3_index_constraint)(unsafe.Pointer(p)).Fop) == 2 {
			idx = i
		}
	}
	if idx >= 0 {
		// There exists a usable == constraint against the SQL column
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = 10.0
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxNum = 1
		(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(idx)*8)).FargvIndex = 1
		(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(idx)*8)).Fomit = uint8(1)
	} else if unusable != 0 {
		// There are unusable constraints against the SQL column.  Do not allow
		// this plan to continue forward.
		return 19
	}
	return 0
}

// This following structure defines all the methods for the
// explain virtual table.
var explainModule = sqlite3_module{FiVersion: 0, FxCreate: // iVersion
uintptr(0), FxConnect:// xCreate
0, FxBestIndex:// xConnect
0, FxDisconnect:// xBestIndex
0, FxDestroy:// xDisconnect
uintptr(0), FxOpen:// xDestroy
0, FxClose:// xOpen - open a cursor
0, FxFilter:// xClose - close a cursor
0, FxNext:// xFilter - configure scan constraints
0, FxEof:// xNext - advance a cursor
0, FxColumn:// xEof - check for end of scan
0, FxRowid:// xColumn - read data
0, FxUpdate:// xRowid - read data
uintptr(0), FxBegin:// xUpdate
uintptr(0), FxSync:// xBegin
uintptr(0), FxCommit:// xSync
uintptr(0), FxRollback:// xCommit
uintptr(0), FxFindFunction:// xRollback
uintptr(0), FxRename:// xFindMethod
uintptr(0), FxSavepoint:// xRename
uintptr(0), FxRelease:// xSavepoint
uintptr(0), FxRollbackTo:// xRelease
uintptr(0), FxShadowName:// xRollbackTo
uintptr(0), // xShadowName
} /* explain.c:271:23 */

func sqlite3ExplainVtabInit(tls *crt.TLS, db uintptr) int32 { /* explain.c:300:5: */
	var rc int32 = 0
	rc = sqlite3.Xsqlite3_create_module(tls, db, ts+4515 /* "explain" */, uintptr(unsafe.Pointer(&explainModule)), uintptr(0))
	return rc
}

func sqlite3_explain_init(tls *crt.TLS, db uintptr, pzErrMsg uintptr, pApi uintptr) int32 { /* explain.c:311:5: */
	var rc int32 = 0
	_ = pApi

	rc = sqlite3ExplainVtabInit(tls, db)
	return rc
}

// Define some inlines helping to catch common problems.

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

//	POSIX Standard: 2.10 Symbolic Constants		<unistd.h>

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// These may be used to determine what facilities are present at compile time.
//   Their values can be obtained at run time from `sysconf'.

// POSIX Standard approved as ISO/IEC 9945-1 as of September 2008.

// These are not #ifdef __USE_POSIX2 because they are
//   in the theoretically application-owned namespace.

// The utilities on GNU systems also correspond to this version.

// The utilities on GNU systems also correspond to this version.

// This symbol was required until the 2001 edition of POSIX.

// If defined, the implementation supports the
//   C Language Bindings Option.

// If defined, the implementation supports the
//   C Language Development Utilities Option.

// If defined, the implementation supports the
//   Software Development Utilities Option.

// If defined, the implementation supports the
//   creation of locales with the localedef utility.

// X/Open version number to which the library conforms.  It is selectable.

// Commands and utilities from XPG4 are available.

// We are compatible with the old published standards as well.

// The X/Open Unix extensions are available.

// The enhanced internationalization capabilities according to XPG4.2
//   are present.

// The legacy interfaces are also available.

// Get values of POSIX options:
//
//   If these symbols are defined, the corresponding features are
//   always available.  If not, they may be available sometimes.
//   The current values can be obtained with `sysconf'.
//
//   _POSIX_JOB_CONTROL		Job control is supported.
//   _POSIX_SAVED_IDS		Processes have a saved set-user-ID
//				and a saved set-group-ID.
//   _POSIX_REALTIME_SIGNALS	Real-time, queued signals are supported.
//   _POSIX_PRIORITY_SCHEDULING	Priority scheduling is supported.
//   _POSIX_TIMERS		POSIX.4 clocks and timers are supported.
//   _POSIX_ASYNCHRONOUS_IO	Asynchronous I/O is supported.
//   _POSIX_PRIORITIZED_IO	Prioritized asynchronous I/O is supported.
//   _POSIX_SYNCHRONIZED_IO	Synchronizing file data is supported.
//   _POSIX_FSYNC			The fsync function is present.
//   _POSIX_MAPPED_FILES		Mapping of files to memory is supported.
//   _POSIX_MEMLOCK		Locking of all memory is supported.
//   _POSIX_MEMLOCK_RANGE		Locking of ranges of memory is supported.
//   _POSIX_MEMORY_PROTECTION	Setting of memory protections is supported.
//   _POSIX_MESSAGE_PASSING	POSIX.4 message queues are supported.
//   _POSIX_SEMAPHORES		POSIX.4 counting semaphores are supported.
//   _POSIX_SHARED_MEMORY_OBJECTS	POSIX.4 shared memory objects are supported.
//   _POSIX_THREADS		POSIX.1c pthreads are supported.
//   _POSIX_THREAD_ATTR_STACKADDR	Thread stack address attribute option supported.
//   _POSIX_THREAD_ATTR_STACKSIZE	Thread stack size attribute option supported.
//   _POSIX_THREAD_SAFE_FUNCTIONS	Thread-safe functions are supported.
//   _POSIX_THREAD_PRIORITY_SCHEDULING
//				POSIX.1c thread execution scheduling supported.
//   _POSIX_THREAD_PRIO_INHERIT	Thread priority inheritance option supported.
//   _POSIX_THREAD_PRIO_PROTECT	Thread priority protection option supported.
//   _POSIX_THREAD_PROCESS_SHARED	Process-shared synchronization supported.
//   _POSIX_PII			Protocol-independent interfaces are supported.
//   _POSIX_PII_XTI		XTI protocol-indep. interfaces are supported.
//   _POSIX_PII_SOCKET		Socket protocol-indep. interfaces are supported.
//   _POSIX_PII_INTERNET		Internet family of protocols supported.
//   _POSIX_PII_INTERNET_STREAM	Connection-mode Internet protocol supported.
//   _POSIX_PII_INTERNET_DGRAM	Connectionless Internet protocol supported.
//   _POSIX_PII_OSI		ISO/OSI family of protocols supported.
//   _POSIX_PII_OSI_COTS		Connection-mode ISO/OSI service supported.
//   _POSIX_PII_OSI_CLTS		Connectionless ISO/OSI service supported.
//   _POSIX_POLL			Implementation supports `poll' function.
//   _POSIX_SELECT		Implementation supports `select' and `pselect'.
//
//   _XOPEN_REALTIME		X/Open realtime support is available.
//   _XOPEN_REALTIME_THREADS	X/Open realtime thread support is available.
//   _XOPEN_SHM			Shared memory interface according to XPG4.2.
//
//   _XBS5_ILP32_OFF32		Implementation provides environment with 32-bit
//				int, long, pointer, and off_t types.
//   _XBS5_ILP32_OFFBIG		Implementation provides environment with 32-bit
//				int, long, and pointer and off_t with at least
//				64 bits.
//   _XBS5_LP64_OFF64		Implementation provides environment with 32-bit
//				int, and 64-bit long, pointer, and off_t types.
//   _XBS5_LPBIG_OFFBIG		Implementation provides environment with at
//				least 32 bits int and long, pointer, and off_t
//				with at least 64 bits.
//
//   If any of these symbols is defined as -1, the corresponding option is not
//   true for any file.  If any is defined as other than -1, the corresponding
//   option is true for all files.  If a symbol is not defined at all, the value
//   for a specific file can be obtained from `pathconf' and `fpathconf'.
//
//   _POSIX_CHOWN_RESTRICTED	Only the super user can use `chown' to change
//				the owner of a file.  `chown' can only be used
//				to change the group ID of a file to a group of
//				which the calling process is a member.
//   _POSIX_NO_TRUNC		Pathname components longer than
//				NAME_MAX generate an error.
//   _POSIX_VDISABLE		If defined, if the value of an element of the
//				`c_cc' member of `struct termios' is
//				_POSIX_VDISABLE, no character will have the
//				effect associated with that element.
//   _POSIX_SYNC_IO		Synchronous I/O may be performed.
//   _POSIX_ASYNC_IO		Asynchronous I/O may be performed.
//   _POSIX_PRIO_IO		Prioritized Asynchronous I/O may be performed.
//
//   Support for the Large File Support interface is not generally available.
//   If it is available the following constants are defined to one.
//   _LFS64_LARGEFILE		Low-level I/O supports large files.
//   _LFS64_STDIO			Standard I/O supports large files.
//

// Define POSIX options for Linux.
//   Copyright (C) 1996-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public License as
//   published by the Free Software Foundation; either version 2.1 of the
//   License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; see the file COPYING.LIB.  If
//   not, see <http://www.gnu.org/licenses/>.

// Job control is supported.

// Processes have a saved set-user-ID and a saved set-group-ID.

// Priority scheduling is supported.

// Synchronizing file data is supported.

// The fsync function is present.

// Mapping of files to memory is supported.

// Locking of all memory is supported.

// Locking of ranges of memory is supported.

// Setting of memory protections is supported.

// Some filesystems allow all users to change file ownership.

// `c_cc' member of 'struct termios' structure can be disabled by
//   using the value _POSIX_VDISABLE.

// Filenames are not silently truncated.

// X/Open realtime support is available.

// X/Open thread realtime support is available.

// XPG4.2 shared memory is supported.

// Tell we have POSIX threads.

// We have the reentrant functions described in POSIX.

// We provide priority scheduling for threads.

// We support user-defined stack sizes.

// We support user-defined stacks.

// We support priority inheritence.

// We support priority protection, though only for non-robust
//   mutexes.

// We support priority inheritence for robust mutexes.

// We do not support priority protection for robust mutexes.

// We support POSIX.1b semaphores.

// Real-time signals are supported.

// We support asynchronous I/O.
// Alternative name for Unix98.
// Support for prioritization is also available.

// The LFS support in asynchronous I/O is also available.

// The rest of the LFS is also available.

// POSIX shared memory objects are implemented.

// CPU-time clocks support needs to be checked at runtime.

// Clock support in threads must be also checked at runtime.

// GNU libc provides regular expression handling.

// Reader/Writer locks are available.

// We have a POSIX shell.

// We support the Timeouts option.

// We support spinlocks.

// The `spawn' function family is supported.

// We have POSIX timers.

// The barrier functions are available.

// POSIX message queues are available.

// Thread process-shared synchronization is supported.

// The monotonic clock might be available.

// The clock selection interfaces are available.

// Advisory information interfaces are available.

// IPv6 support is available.

// Raw socket support is available.

// We have at least one terminal.

// Neither process nor thread sporadic server interfaces is available.

// trace.h is not available.

// Typed memory objects are not available.

// Get the environment definitions from Unix98.
// Copyright (C) 1999-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// Determine the wordsize from the preprocessor defines.

// Both x86-64 and x32 use the 64-bit system call interface.

// This header should define the following symbols under the described
//   situations.  A value `1' means that the model is always supported,
//   `-1' means it is never supported.  Undefined means it cannot be
//   statically decided.
//
//   _POSIX_V7_ILP32_OFF32   32bit int, long, pointers, and off_t type
//   _POSIX_V7_ILP32_OFFBIG  32bit int, long, and pointers and larger off_t type
//
//   _POSIX_V7_LP64_OFF32	   64bit long and pointers and 32bit off_t type
//   _POSIX_V7_LPBIG_OFFBIG  64bit long and pointers and large off_t type
//
//   The macros _POSIX_V6_ILP32_OFF32, _POSIX_V6_ILP32_OFFBIG,
//   _POSIX_V6_LP64_OFF32, _POSIX_V6_LPBIG_OFFBIG, _XBS5_ILP32_OFF32,
//   _XBS5_ILP32_OFFBIG, _XBS5_LP64_OFF32, and _XBS5_LPBIG_OFFBIG were
//   used in previous versions of the Unix standard and are available
//   only for compatibility.

// Environments with 32-bit wide pointers are optionally provided.
//   Therefore following macros aren't defined:
//   # undef _POSIX_V7_ILP32_OFF32
//   # undef _POSIX_V7_ILP32_OFFBIG
//   # undef _POSIX_V6_ILP32_OFF32
//   # undef _POSIX_V6_ILP32_OFFBIG
//   # undef _XBS5_ILP32_OFF32
//   # undef _XBS5_ILP32_OFFBIG
//   and users need to check at runtime.

// We also have no use (for now) for an environment with bigger pointers
//   and offsets.

// By default we have 64-bit wide `long int', pointers and `off_t'.

// Standard file descriptors.

// All functions that are not declared anywhere else.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//   Copyright (C) 2002-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Copyright (C) 1989-2018 Free Software Foundation, Inc.
//
//This file is part of GCC.
//
//GCC is free software; you can redistribute it and/or modify
//it under the terms of the GNU General Public License as published by
//the Free Software Foundation; either version 3, or (at your option)
//any later version.
//
//GCC is distributed in the hope that it will be useful,
//but WITHOUT ANY WARRANTY; without even the implied warranty of
//MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//GNU General Public License for more details.
//
//Under Section 7 of GPL version 3, you are granted additional
//permissions described in the GCC Runtime Library Exception, version
//3.1, as published by the Free Software Foundation.
//
//You should have received a copy of the GNU General Public License and
//a copy of the GCC Runtime Library Exception along with this program;
//see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
//<http://www.gnu.org/licenses/>.

// ISO C Standard:  7.17  Common definitions  <stddef.h>

// Any one of these symbols __need_* means that GNU libc
//   wants us just to define one data type.  So don't define
//   the symbols that indicate this file's entire job has been done.

// This avoids lossage on SunOS but only if stdtypes.h comes first.
//   There's no way to win with the other order!  Sun lossage.

// On 4.3bsd-net2, make sure ansi.h is included, so we have
//   one less case to deal with in the following.
// On FreeBSD 5, machine/ansi.h does not exist anymore...

// In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
//   defined if the corresponding type is *not* defined.
//   FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_.
//   NetBSD defines _I386_ANSI_H_ and _X86_64_ANSI_H_ instead of _ANSI_H_

// Sequent's header files use _PTRDIFF_T_ in some conflicting way.
//   Just ignore it.

// On VxWorks, <type/vxTypesBase.h> may have defined macros like
//   _TYPE_size_t which will typedef size_t.  fixincludes patched the
//   vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
//   not defined, and so that defining this macro defines _GCC_SIZE_T.
//   If we find that the macros are still defined at this point, we must
//   invoke them so that the type is defined as expected.

// In case nobody has defined these types, but we aren't running under
//   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
//   __WCHAR_TYPE__ have reasonable values.  This can happen if the
//   parts of GCC is compiled by an older compiler, that actually
//   include gstddef.h, such as collect2.

// Signed type of difference of two pointers.

// Define this type if we are doing the whole job,
//   or if we want this type in particular.

// Unsigned type of `sizeof' something.

// Define this type if we are doing the whole job,
//   or if we want this type in particular.

// Wide character type.
//   Locale-writers should change this as necessary to
//   be big enough to hold unique values not between 0 and 127,
//   and not (wchar_t) -1, for each defined multibyte character.

// Define this type if we are doing the whole job,
//   or if we want this type in particular.

//  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
//    are already defined.
//  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.
//  NetBSD 5 requires the I386_ANSI_H and X86_64_ANSI_H checks here.

// A null pointer constant.

// The Single Unix specification says that some more types are
//   available here.

type useconds_t = uint32 /* unistd.h:255:22 */

type intptr_t = int64 /* unistd.h:267:20 */

type socklen_t = uint32 /* unistd.h:274:21 */

// Define some macros helping to catch buffer overflows.

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

//	POSIX Standard: 5.1.2 Directory Operations	<dirent.h>

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//   Copyright (C) 2002-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// This file defines `struct dirent'.
//
//   It defines the macro `_DIRENT_HAVE_D_NAMLEN' iff there is a `d_namlen'
//   member that gives the length of `d_name'.
//
//   It defines the macro `_DIRENT_HAVE_D_RECLEN' iff there is a `d_reclen'
//   member that gives the size of the entire directory entry.
//
//   It defines the macro `_DIRENT_HAVE_D_OFF' iff there is a `d_off'
//   member that gives the file offset of the next directory entry.
//
//   It defines the macro `_DIRENT_HAVE_D_TYPE' iff there is a `d_type'
//   member that gives the type of the file.
//

// Copyright (C) 1996-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

type dirent = struct {
	Fd_ino    uint64
	Fd_off    int64
	Fd_reclen uint16
	Fd_type   uint8
	Fd_name   [256]int8
	_         [5]byte
}

type sigevent = struct {
	Fsigev_value struct {
		_          [0]uint64
		Fsival_int int32
		_          [4]byte
	}
	Fsigev_signo  int32
	Fsigev_notify int32
	F_sigev_un    struct {
		_     [0]uint64
		F_pad [12]int32
	}
}

// Structure of the fsdir() table-valued function
//    0    1    2     3    4           5

// Set the result stored by context ctx to a blob containing the
// contents of file zName.  Or, leave the result unchanged (NULL)
// if the file does not exist or is unreadable.
//
// If the file exceeds the SQLite blob size limit, through an
// SQLITE_TOOBIG error.
//
// Throw an SQLITE_IOERR if there are difficulties pulling the file
// off of disk.
func readFileContents(tls *crt.TLS, ctx uintptr, zName uintptr) { /* fileio.c:133:13: */
	var in uintptr
	var nIn sqlite3_int64
	var pBuf uintptr
	var db uintptr
	var mxBlob int32

	in = crt.Xfopen(tls, zName, ts+3756 /* "rb" */)
	if in == uintptr(0) {
		// File does not exist or is unreadable. Leave the result set to NULL.
		return
	}
	crt.Xfseek(tls, in, int64(0), 2)
	nIn = sqlite3_int64(crt.Xftell(tls, in))
	crt.Xrewind(tls, in)
	db = sqlite3.Xsqlite3_context_db_handle(tls, ctx)
	mxBlob = sqlite3.Xsqlite3_limit(tls, db, 0, -1)
	if nIn > sqlite3_int64(mxBlob) {
		sqlite3.Xsqlite3_result_error_code(tls, ctx, 18)
		crt.Xfclose(tls, in)
		return
	}
	pBuf = sqlite3.Xsqlite3_malloc64(tls, func() uint64 {
		if nIn != 0 {
			return uint64(nIn)
		}
		return uint64(1)
	}())
	if pBuf == uintptr(0) {
		sqlite3.Xsqlite3_result_error_nomem(tls, ctx)
		crt.Xfclose(tls, in)
		return
	}
	if nIn == sqlite3_int64(crt.Xfread(tls, pBuf, uint64(1), size_t(nIn), in)) {
		sqlite3.Xsqlite3_result_blob64(tls, ctx, pBuf, uint64(nIn), *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, uintptr) }{sqlite3.Xsqlite3_free})))
	} else {
		sqlite3.Xsqlite3_result_error_code(tls, ctx, 10)
		sqlite3.Xsqlite3_free(tls, pBuf)
	}
	crt.Xfclose(tls, in)
}

// Implementation of the "readfile(X)" SQL function.  The entire content
// of the file named X is read and returned as a BLOB.  NULL is returned
// if the file does not exist or is unreadable.
func readfileFunc(tls *crt.TLS, context uintptr, argc int32, argv uintptr) { /* fileio.c:175:13: */
	var zName uintptr
	_ = argc // Unused parameter
	zName = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)))
	if zName == uintptr(0) {
		return
	}
	readFileContents(tls, context, zName)
}

// Set the error message contained in context ctx to the results of
// vprintf(zFmt, ...).
func ctxErrorMsg(tls *crt.TLS, ctx uintptr, zFmt uintptr, va uintptr) { /* fileio.c:191:13: */
	var zMsg uintptr = uintptr(0)
	var ap va_list
	_ = ap
	ap = va
	zMsg = sqlite3.Xsqlite3_vmprintf(tls, zFmt, ap)
	sqlite3.Xsqlite3_result_error(tls, ctx, zMsg, -1)
	sqlite3.Xsqlite3_free(tls, zMsg)
	_ = ap
}

// This function is used in place of stat().  On Windows, special handling
// is required in order for the included time to be returned as UTC.  On all
// other systems, this function simply calls stat().
func fileStat(tls *crt.TLS, zPath uintptr, pStatBuf uintptr) int32 { /* fileio.c:261:12: */
	return crt.Xstat(tls, zPath, pStatBuf)
}

// This function is used in place of lstat().  On Windows, special handling
// is required in order for the included time to be returned as UTC.  On all
// other systems, this function simply calls lstat().
func fileLinkStat(tls *crt.TLS, zPath uintptr, pStatBuf uintptr) int32 { /* fileio.c:279:12: */
	return crt.Xlstat(tls, zPath, pStatBuf)
}

// Argument zFile is the name of a file that will be created and/or written
// by SQL function writefile(). This function ensures that the directory
// zFile will be written to exists, creating it if required. The permissions
// for any path components created by this function are set in accordance
// with the current umask.
//
// If an OOM condition is encountered, SQLITE_NOMEM is returned. Otherwise,
// SQLITE_OK is returned if the directory is successfully created, or
// SQLITE_ERROR otherwise.
func makeDirectory(tls *crt.TLS, zFile uintptr) int32 { /* fileio.c:303:12: */
	bp := tls.Alloc(152)
	defer tls.Free(152)

	var zCopy uintptr = sqlite3.Xsqlite3_mprintf(tls, ts+130 /* "%s" */, crt.VaList(bp, zFile))
	var rc int32 = 0

	if zCopy == uintptr(0) {
		rc = 7
	} else {
		var nCopy int32 = int32(crt.Xstrlen(tls, zCopy))
		var i int32 = 1

		for rc == 0 {
			// var sStat struct {Fst_dev uint64;Fst_ino uint64;Fst_nlink uint64;Fst_mode uint32;Fst_uid uint32;Fst_gid uint32;F__pad0 int32;Fst_rdev uint64;Fst_size int64;Fst_blksize int64;Fst_blocks int64;Fst_atim timespec;Fst_mtim timespec;Fst_ctim timespec;F__glibc_reserved [3]int64;} at bp+8, 144

			var rc2 int32

			for ; (int32(*(*int8)(unsafe.Pointer(zCopy + uintptr(i)))) != '/') && (i < nCopy); i++ {
			}
			if i == nCopy {
				break
			}
			*(*int8)(unsafe.Pointer(zCopy + uintptr(i))) = int8(0)

			rc2 = fileStat(tls, zCopy, bp+8 /* &sStat */)
			if rc2 != 0 {
				if crt.Xmkdir(tls, zCopy, uint32(0777)) != 0 {
					rc = 1
				}
			} else {
				if !((((*struct {
					Fst_dev           uint64
					Fst_ino           uint64
					Fst_nlink         uint64
					Fst_mode          uint32
					Fst_uid           uint32
					Fst_gid           uint32
					F__pad0           int32
					Fst_rdev          uint64
					Fst_size          int64
					Fst_blksize       int64
					Fst_blocks        int64
					Fst_atim          timespec
					Fst_mtim          timespec
					Fst_ctim          timespec
					F__glibc_reserved [3]int64
				})(unsafe.Pointer(bp + 8 /* &sStat */)).Fst_mode) & uint32(0170000)) == (uint32(0040000))) {
					rc = 1
				}
			}
			*(*int8)(unsafe.Pointer(zCopy + uintptr(i))) = int8('/')
			i++
		}

		sqlite3.Xsqlite3_free(tls, zCopy)
	}

	return rc
}

// This function does the work for the writefile() UDF. Refer to
// header comments at the top of this file for details.
func writeFile(tls *crt.TLS, pCtx uintptr, zFile uintptr, pData uintptr, mode mode_t, mtime sqlite3_int64) int32 { /* fileio.c:343:12: */
	bp := tls.Alloc(176)
	defer tls.Free(176)

	if ((mode) & mode_t(0170000)) == (mode_t(0120000)) {
		var zTo uintptr = sqlite3.Xsqlite3_value_text(tls, pData)
		if crt.Xsymlink(tls, zTo, zFile) < 0 {
			return 1
		}
	} else {
		if ((mode) & mode_t(0170000)) == (mode_t(0040000)) {
			if crt.Xmkdir(tls, zFile, mode) != 0 {
				// The mkdir() call to create the directory failed. This might not
				// be an error though - if there is already a directory at the same
				// path and either the permissions already match or can be changed
				// to do so using chmod(), it is not an error.
				// var sStat struct {Fst_dev uint64;Fst_ino uint64;Fst_nlink uint64;Fst_mode uint32;Fst_uid uint32;Fst_gid uint32;F__pad0 int32;Fst_rdev uint64;Fst_size int64;Fst_blksize int64;Fst_blocks int64;Fst_atim timespec;Fst_mtim timespec;Fst_ctim timespec;F__glibc_reserved [3]int64;} at bp, 144

				if ((((*(*int32)(unsafe.Pointer(crt.X__errno_location(tls)))) != 17) ||
					(0 != fileStat(tls, zFile, bp /* &sStat */))) ||
					!((((*struct {
						Fst_dev           uint64
						Fst_ino           uint64
						Fst_nlink         uint64
						Fst_mode          uint32
						Fst_uid           uint32
						Fst_gid           uint32
						F__pad0           int32
						Fst_rdev          uint64
						Fst_size          int64
						Fst_blksize       int64
						Fst_blocks        int64
						Fst_atim          timespec
						Fst_mtim          timespec
						Fst_ctim          timespec
						F__glibc_reserved [3]int64
					})(unsafe.Pointer(bp /* &sStat */)).Fst_mode) & uint32(0170000)) == (uint32(0040000)))) ||
					((((*struct {
						Fst_dev           uint64
						Fst_ino           uint64
						Fst_nlink         uint64
						Fst_mode          uint32
						Fst_uid           uint32
						Fst_gid           uint32
						F__pad0           int32
						Fst_rdev          uint64
						Fst_size          int64
						Fst_blksize       int64
						Fst_blocks        int64
						Fst_atim          timespec
						Fst_mtim          timespec
						Fst_ctim          timespec
						F__glibc_reserved [3]int64
					})(unsafe.Pointer(bp /* &sStat */)).Fst_mode & uint32(0777)) != (mode & mode_t(0777))) && (0 != crt.Xchmod(tls, zFile, (mode&mode_t(0777))))) {
					return 1
				}
			}
		} else {
			var nWrite sqlite3_int64 = int64(0)
			var z uintptr
			var rc int32 = 0
			var out uintptr = crt.Xfopen(tls, zFile, ts+4523 /* "wb" */)
			if out == uintptr(0) {
				return 1
			}
			z = sqlite3.Xsqlite3_value_blob(tls, pData)
			if z != 0 {
				var n sqlite3_int64 = sqlite3_int64(crt.Xfwrite(tls, z, uint64(1), uint64(sqlite3.Xsqlite3_value_bytes(tls, pData)), out))
				nWrite = sqlite3_int64(sqlite3.Xsqlite3_value_bytes(tls, pData))
				if nWrite != n {
					rc = 1
				}
			}
			crt.Xfclose(tls, out)
			if ((rc == 0) && (mode != 0)) && (crt.Xchmod(tls, zFile, (mode&mode_t(0777))) != 0) {
				rc = 1
			}
			if rc != 0 {
				return 2
			}
			sqlite3.Xsqlite3_result_int64(tls, pCtx, nWrite)
		}
	}

	if mtime >= int64(0) {
		// Legacy unix
		// var times [2]timeval at bp+144, 32

		(*timeval)(unsafe.Pointer(bp + 144 /* &times */ + uintptr(0)*16)).Ftv_usec = crt.AssignPtrInt64(bp+144 /* &times */ +uintptr(1)*16+8 /* &.tv_usec */, int64(0))
		(*timeval)(unsafe.Pointer(bp + 144 /* &times */ + uintptr(0)*16)).Ftv_sec = crt.Xtime(tls, uintptr(0))
		(*timeval)(unsafe.Pointer(bp + 144 /* &times */ + uintptr(1)*16)).Ftv_sec = int64(mtime)
		if crt.Xutimes(tls, zFile, bp+144 /* &times[0] */) != 0 {
			return 1
		}
	}

	return 0
}

// Implementation of the "writefile(W,X[,Y[,Z]]])" SQL function.
// Refer to header comments at the top of this file for details.
func writefileFunc(tls *crt.TLS, context uintptr, argc int32, argv uintptr) { /* fileio.c:457:13: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	var zFile uintptr
	var mode mode_t = mode_t(0)
	var res int32
	var mtime sqlite3_int64 = int64(-1)

	if (argc < 2) || (argc > 4) {
		sqlite3.Xsqlite3_result_error(tls, context,
			ts+4526 /* "wrong number of ..." */, -1)
		return
	}

	zFile = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)))
	if zFile == uintptr(0) {
		return
	}
	if argc >= 3 {
		mode = mode_t(sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8))))
	}
	if argc == 4 {
		mtime = sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(3)*8)))
	}

	res = writeFile(tls, context, zFile, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), mode, mtime)
	if (res == 1) && ((*(*int32)(unsafe.Pointer(crt.X__errno_location(tls)))) == 2) {
		if makeDirectory(tls, zFile) == 0 {
			res = writeFile(tls, context, zFile, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), mode, mtime)
		}
	}

	if (argc > 2) && (res != 0) {
		if ((mode) & mode_t(0170000)) == (mode_t(0120000)) {
			ctxErrorMsg(tls, context, ts+4576 /* "failed to create..." */, crt.VaList(bp, zFile))
		} else if ((mode) & mode_t(0170000)) == (mode_t(0040000)) {
			ctxErrorMsg(tls, context, ts+4605 /* "failed to create..." */, crt.VaList(bp+8, zFile))
		} else {
			ctxErrorMsg(tls, context, ts+4636 /* "failed to write ..." */, crt.VaList(bp+16, zFile))
		}
	}
}

// SQL function:   lsmode(MODE)
//
// Given a numberic st_mode from stat(), convert it into a human-readable
// text string in the style of "ls -l".
func lsModeFunc(tls *crt.TLS, context uintptr, argc int32, argv uintptr) { /* fileio.c:507:13: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var i int32
	var iMode int32 = sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)))
	// var z [16]int8 at bp, 16

	_ = argc
	if ((iMode) & 0170000) == (0120000) {
		*(*int8)(unsafe.Pointer(bp /* &z[0] */ + uintptr(0))) = int8('l')
	} else if ((iMode) & 0170000) == (0100000) {
		*(*int8)(unsafe.Pointer(bp /* &z[0] */ + uintptr(0))) = int8('-')
	} else if ((iMode) & 0170000) == (0040000) {
		*(*int8)(unsafe.Pointer(bp /* &z[0] */ + uintptr(0))) = int8('d')
	} else {
		*(*int8)(unsafe.Pointer(bp /* &z[0] */ + uintptr(0))) = int8('?')
	}
	for i = 0; i < 3; i++ {
		var m int32 = (iMode >> ((2 - i) * 3))
		var a uintptr = (bp /* &z */ + uintptr((1 + (i * 3))))
		*(*int8)(unsafe.Pointer(a + uintptr(0))) = func() int8 {
			if (m & 0x4) != 0 {
				return int8('r')
			}
			return int8('-')
		}()
		*(*int8)(unsafe.Pointer(a + uintptr(1))) = func() int8 {
			if (m & 0x2) != 0 {
				return int8('w')
			}
			return int8('-')
		}()
		*(*int8)(unsafe.Pointer(a + uintptr(2))) = func() int8 {
			if (m & 0x1) != 0 {
				return int8('x')
			}
			return int8('-')
		}()
	}
	*(*int8)(unsafe.Pointer(bp /* &z[0] */ + uintptr(10))) = int8(0)
	sqlite3.Xsqlite3_result_text(tls, context, bp /* &z[0] */, -1, crt.UintptrFromInt32(-1))
}

// Cursor type for recursively iterating through a directory structure.
type fsdir_cursor1 = struct {
	Fbase  sqlite3_vtab_cursor
	FnLvl  int32
	FiLvl  int32
	FaLvl  uintptr
	FzBase uintptr
	FnBase int32
	FsStat struct {
		Fst_dev     uint64
		Fst_ino     uint64
		Fst_nlink   uint64
		Fst_mode    uint32
		Fst_uid     uint32
		Fst_gid     uint32
		F__pad0     int32
		Fst_rdev    uint64
		Fst_size    int64
		Fst_blksize int64
		Fst_blocks  int64
		Fst_atim    struct {
			Ftv_sec  int64
			Ftv_nsec int64
		}
		Fst_mtim struct {
			Ftv_sec  int64
			Ftv_nsec int64
		}
		Fst_ctim struct {
			Ftv_sec  int64
			Ftv_nsec int64
		}
		F__glibc_reserved [3]int64
	}
	FzPath  uintptr
	FiRowid sqlite3_int64
}

// Cursor type for recursively iterating through a directory structure.
type fsdir_cursor = fsdir_cursor1 /* fileio.c:541:29 */
type FsdirLevel1 = struct {
	FpDir uintptr
	FzDir uintptr
}

type FsdirLevel = FsdirLevel1 /* fileio.c:542:27 */

type fsdir_tab1 = struct{ Fbase sqlite3_vtab }

type fsdir_tab = fsdir_tab1 /* fileio.c:564:26 */

// Construct a new fsdir virtual table object.
func fsdirConnect(tls *crt.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVtab uintptr, pzErr uintptr) int32 { /* fileio.c:572:12: */
	var pNew uintptr = uintptr(0)
	var rc int32
	_ = pAux
	_ = argc
	_ = argv
	_ = pzErr
	rc = sqlite3.Xsqlite3_declare_vtab(tls, db, ts+4661 /* "CREATE TABLE x(n..." */)
	if rc == 0 {
		pNew = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(fsdir_tab{})))
		if pNew == uintptr(0) {
			return 7
		}
		crt.Xmemset(tls, pNew, 0, uint64(unsafe.Sizeof(fsdir_tab{})))
		sqlite3.Xsqlite3_vtab_config(tls, db, 3, 0)
	}
	*(*uintptr)(unsafe.Pointer(ppVtab)) = pNew
	return rc
}

// This method is the destructor for fsdir vtab objects.
func fsdirDisconnect(tls *crt.TLS, pVtab uintptr) int32 { /* fileio.c:599:12: */
	sqlite3.Xsqlite3_free(tls, pVtab)
	return 0
}

// Constructor for a new fsdir_cursor object.
func fsdirOpen(tls *crt.TLS, p uintptr, ppCursor uintptr) int32 { /* fileio.c:607:12: */
	var pCur uintptr
	_ = p
	pCur = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(fsdir_cursor{})))
	if pCur == uintptr(0) {
		return 7
	}
	crt.Xmemset(tls, pCur, 0, uint64(unsafe.Sizeof(fsdir_cursor{})))
	(*fsdir_cursor)(unsafe.Pointer(pCur)).FiLvl = -1
	*(*uintptr)(unsafe.Pointer(ppCursor)) = (pCur /* &.base */)
	return 0
}

// Reset a cursor back to the state it was in when first returned
// by fsdirOpen().
func fsdirResetCursor(tls *crt.TLS, pCur uintptr) { /* fileio.c:622:13: */
	var i int32
	for i = 0; i <= (*fsdir_cursor)(unsafe.Pointer(pCur)).FiLvl; i++ {
		var pLvl uintptr = ((*fsdir_cursor)(unsafe.Pointer(pCur)).FaLvl + uintptr(i)*16)
		if (*FsdirLevel)(unsafe.Pointer(pLvl)).FpDir != 0 {
			crt.Xclosedir(tls, (*FsdirLevel)(unsafe.Pointer(pLvl)).FpDir)
		}
		sqlite3.Xsqlite3_free(tls, (*FsdirLevel)(unsafe.Pointer(pLvl)).FzDir)
	}
	sqlite3.Xsqlite3_free(tls, (*fsdir_cursor)(unsafe.Pointer(pCur)).FzPath)
	sqlite3.Xsqlite3_free(tls, (*fsdir_cursor)(unsafe.Pointer(pCur)).FaLvl)
	(*fsdir_cursor)(unsafe.Pointer(pCur)).FaLvl = uintptr(0)
	(*fsdir_cursor)(unsafe.Pointer(pCur)).FzPath = uintptr(0)
	(*fsdir_cursor)(unsafe.Pointer(pCur)).FzBase = uintptr(0)
	(*fsdir_cursor)(unsafe.Pointer(pCur)).FnBase = 0
	(*fsdir_cursor)(unsafe.Pointer(pCur)).FnLvl = 0
	(*fsdir_cursor)(unsafe.Pointer(pCur)).FiLvl = -1
	(*fsdir_cursor)(unsafe.Pointer(pCur)).FiRowid = int64(1)
}

// Destructor for an fsdir_cursor.
func fsdirClose(tls *crt.TLS, cur uintptr) int32 { /* fileio.c:643:12: */
	var pCur uintptr = cur

	fsdirResetCursor(tls, pCur)
	sqlite3.Xsqlite3_free(tls, pCur)
	return 0
}

// Set the error message for the virtual table associated with cursor
// pCur to the results of vprintf(zFmt, ...).
func fsdirSetErrmsg(tls *crt.TLS, pCur uintptr, zFmt uintptr, va uintptr) { /* fileio.c:655:13: */
	var ap va_list
	_ = ap
	ap = va
	(*sqlite3_vtab)(unsafe.Pointer((*fsdir_cursor)(unsafe.Pointer(pCur)).Fbase.FpVtab)).FzErrMsg = sqlite3.Xsqlite3_vmprintf(tls, zFmt, ap)
	_ = ap
}

// Advance an fsdir_cursor to its next row of output.
func fsdirNext(tls *crt.TLS, cur uintptr) int32 { /* fileio.c:666:12: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var pCur uintptr = cur
	var m mode_t = (*fsdir_cursor)(unsafe.Pointer(pCur)).FsStat.Fst_mode

	(*fsdir_cursor)(unsafe.Pointer(pCur)).FiRowid++
	if ((m) & mode_t(0170000)) == (mode_t(0040000)) {
		// Descend into this directory
		var iNew int32 = ((*fsdir_cursor)(unsafe.Pointer(pCur)).FiLvl + 1)
		var pLvl uintptr
		if iNew >= (*fsdir_cursor)(unsafe.Pointer(pCur)).FnLvl {
			var nNew int32 = (iNew + 1)
			var nByte sqlite3_int64 = (sqlite3_int64(uint64(nNew) * uint64(unsafe.Sizeof(FsdirLevel{}))))
			var aNew uintptr = sqlite3.Xsqlite3_realloc64(tls, (*fsdir_cursor)(unsafe.Pointer(pCur)).FaLvl, uint64(nByte))
			if aNew == uintptr(0) {
				return 7
			}
			crt.Xmemset(tls, (aNew + uintptr((*fsdir_cursor)(unsafe.Pointer(pCur)).FnLvl)*16), 0, (uint64(unsafe.Sizeof(FsdirLevel{})) * (uint64(nNew - (*fsdir_cursor)(unsafe.Pointer(pCur)).FnLvl))))
			(*fsdir_cursor)(unsafe.Pointer(pCur)).FaLvl = aNew
			(*fsdir_cursor)(unsafe.Pointer(pCur)).FnLvl = nNew
		}
		(*fsdir_cursor)(unsafe.Pointer(pCur)).FiLvl = iNew
		pLvl = ((*fsdir_cursor)(unsafe.Pointer(pCur)).FaLvl + uintptr(iNew)*16)

		(*FsdirLevel)(unsafe.Pointer(pLvl)).FzDir = (*fsdir_cursor)(unsafe.Pointer(pCur)).FzPath
		(*fsdir_cursor)(unsafe.Pointer(pCur)).FzPath = uintptr(0)
		(*FsdirLevel)(unsafe.Pointer(pLvl)).FpDir = crt.Xopendir(tls, (*FsdirLevel)(unsafe.Pointer(pLvl)).FzDir)
		if (*FsdirLevel)(unsafe.Pointer(pLvl)).FpDir == uintptr(0) {
			fsdirSetErrmsg(tls, pCur, ts+4721 /* "cannot read dire..." */, crt.VaList(bp, (*fsdir_cursor)(unsafe.Pointer(pCur)).FzPath))
			return 1
		}
	}

	for (*fsdir_cursor)(unsafe.Pointer(pCur)).FiLvl >= 0 {
		var pLvl uintptr = ((*fsdir_cursor)(unsafe.Pointer(pCur)).FaLvl + uintptr((*fsdir_cursor)(unsafe.Pointer(pCur)).FiLvl)*16)
		var pEntry uintptr = crt.Xreaddir(tls, (*FsdirLevel)(unsafe.Pointer(pLvl)).FpDir)
		if pEntry != 0 {
			if int32(*(*int8)(unsafe.Pointer((pEntry + 19 /* &.d_name */) + uintptr(0)))) == '.' {
				if (int32(*(*int8)(unsafe.Pointer((pEntry + 19 /* &.d_name */) + uintptr(1)))) == '.') && (int32(*(*int8)(unsafe.Pointer((pEntry + 19 /* &.d_name */) + uintptr(2)))) == 0) {
					continue
				}
				if int32(*(*int8)(unsafe.Pointer((pEntry + 19 /* &.d_name */) + uintptr(1)))) == 0 {
					continue
				}
			}
			sqlite3.Xsqlite3_free(tls, (*fsdir_cursor)(unsafe.Pointer(pCur)).FzPath)
			(*fsdir_cursor)(unsafe.Pointer(pCur)).FzPath = sqlite3.Xsqlite3_mprintf(tls, ts+4747 /* "%s/%s" */, crt.VaList(bp+8, (*FsdirLevel)(unsafe.Pointer(pLvl)).FzDir, pEntry+19 /* &.d_name */))
			if (*fsdir_cursor)(unsafe.Pointer(pCur)).FzPath == uintptr(0) {
				return 7
			}
			if fileLinkStat(tls, (*fsdir_cursor)(unsafe.Pointer(pCur)).FzPath, (pCur+40 /* &.sStat */)) != 0 {
				fsdirSetErrmsg(tls, pCur, ts+4753 /* "cannot stat file..." */, crt.VaList(bp+24, (*fsdir_cursor)(unsafe.Pointer(pCur)).FzPath))
				return 1
			}
			return 0
		}
		crt.Xclosedir(tls, (*FsdirLevel)(unsafe.Pointer(pLvl)).FpDir)
		sqlite3.Xsqlite3_free(tls, (*FsdirLevel)(unsafe.Pointer(pLvl)).FzDir)
		(*FsdirLevel)(unsafe.Pointer(pLvl)).FpDir = uintptr(0)
		(*FsdirLevel)(unsafe.Pointer(pLvl)).FzDir = uintptr(0)
		(*fsdir_cursor)(unsafe.Pointer(pCur)).FiLvl--
	}

	// EOF
	sqlite3.Xsqlite3_free(tls, (*fsdir_cursor)(unsafe.Pointer(pCur)).FzPath)
	(*fsdir_cursor)(unsafe.Pointer(pCur)).FzPath = uintptr(0)
	return 0
}

// Return values of columns for the row at which the series_cursor
// is currently pointing.
func fsdirColumn(tls *crt.TLS, cur uintptr, ctx uintptr, i int32) int32 { /* fileio.c:730:12: */
	bp := tls.Alloc(64)
	defer tls.Free(64)

	var pCur uintptr = cur
	switch i {
	case 0:
		{
			sqlite3.Xsqlite3_result_text(tls, ctx, ((*fsdir_cursor)(unsafe.Pointer(pCur)).FzPath + uintptr((*fsdir_cursor)(unsafe.Pointer(pCur)).FnBase)), -1, crt.UintptrFromInt32(-1))
			break
		}

	case 1:
		sqlite3.Xsqlite3_result_int64(tls, ctx, int64((*fsdir_cursor)(unsafe.Pointer(pCur)).FsStat.Fst_mode))
		break

	case 2:
		sqlite3.Xsqlite3_result_int64(tls, ctx, int64((*fsdir_cursor)(unsafe.Pointer(pCur)).FsStat.Fst_mtim.Ftv_sec))
		break

	case 3:
		{
			var m mode_t = (*fsdir_cursor)(unsafe.Pointer(pCur)).FsStat.Fst_mode
			if ((m) & mode_t(0170000)) == (mode_t(0040000)) {
				sqlite3.Xsqlite3_result_null(tls, ctx)
			} else if ((m) & mode_t(0170000)) == (mode_t(0120000)) {
				// var aStatic [64]int8 at bp, 64

				var aBuf uintptr = bp /* aStatic */
				var nBuf sqlite3_int64 = int64(64)
				var n int32

				for 1 != 0 {
					n = int32(crt.Xreadlink(tls, (*fsdir_cursor)(unsafe.Pointer(pCur)).FzPath, aBuf, uint64(nBuf)))
					if sqlite3_int64(n) < nBuf {
						break
					}
					if aBuf != bp /* aStatic */ {
						sqlite3.Xsqlite3_free(tls, aBuf)
					}
					nBuf = (nBuf * int64(2))
					aBuf = sqlite3.Xsqlite3_malloc64(tls, uint64(nBuf))
					if aBuf == uintptr(0) {
						sqlite3.Xsqlite3_result_error_nomem(tls, ctx)
						return 7
					}
				}

				sqlite3.Xsqlite3_result_text(tls, ctx, aBuf, n, crt.UintptrFromInt32(-1))
				if aBuf != bp /* aStatic */ {
					sqlite3.Xsqlite3_free(tls, aBuf)
				}
			} else {
				readFileContents(tls, ctx, (*fsdir_cursor)(unsafe.Pointer(pCur)).FzPath)
			}
		}
		fallthrough
	case 4:
		fallthrough
	default:
		{
			// The FSDIR_COLUMN_PATH and FSDIR_COLUMN_DIR are input parameters.
			// always return their values as NULL
			break
		}
	}
	return 0
}

// Return the rowid for the current row. In this implementation, the
// first row returned is assigned rowid value 1, and each subsequent
// row a value 1 more than that of the previous.
func fsdirRowid(tls *crt.TLS, cur uintptr, pRowid uintptr) int32 { /* fileio.c:795:12: */
	var pCur uintptr = cur
	*(*sqlite_int64)(unsafe.Pointer(pRowid)) = (*fsdir_cursor)(unsafe.Pointer(pCur)).FiRowid
	return 0
}

// Return TRUE if the cursor has been moved off of the last
// row of output.
func fsdirEof(tls *crt.TLS, cur uintptr) int32 { /* fileio.c:805:12: */
	var pCur uintptr = cur
	return (crt.Bool32((*fsdir_cursor)(unsafe.Pointer(pCur)).FzPath == uintptr(0)))
}

// xFilter callback.
//
// idxNum==1   PATH parameter only
// idxNum==2   Both PATH and DIR supplied
func fsdirFilter(tls *crt.TLS, cur uintptr, idxNum int32, idxStr uintptr, argc int32, argv uintptr) int32 { /* fileio.c:816:12: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var zDir uintptr = uintptr(0)
	var pCur uintptr = cur
	_ = idxStr
	fsdirResetCursor(tls, pCur)

	if idxNum == 0 {
		fsdirSetErrmsg(tls, pCur, ts+4774 /* "table function f..." */, 0)
		return 1
	}

	if !((argc == idxNum) && ((argc == 1) || (argc == 2))) {
		crt.X__assert_fail(tls, ts+4816 /* "argc==idxNum && ..." */, ts+4853 /* "testdata/sqlite-..." */, uint32(831), uintptr(unsafe.Pointer(&__func__24)))
	}
	zDir = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)))
	if zDir == uintptr(0) {
		fsdirSetErrmsg(tls, pCur, ts+4899 /* "table function f..." */, 0)
		return 1
	}
	if argc == 2 {
		(*fsdir_cursor)(unsafe.Pointer(pCur)).FzBase = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)))
	}
	if (*fsdir_cursor)(unsafe.Pointer(pCur)).FzBase != 0 {
		(*fsdir_cursor)(unsafe.Pointer(pCur)).FnBase = (int32(crt.Xstrlen(tls, (*fsdir_cursor)(unsafe.Pointer(pCur)).FzBase)) + 1)
		(*fsdir_cursor)(unsafe.Pointer(pCur)).FzPath = sqlite3.Xsqlite3_mprintf(tls, ts+4747 /* "%s/%s" */, crt.VaList(bp, (*fsdir_cursor)(unsafe.Pointer(pCur)).FzBase, zDir))
	} else {
		(*fsdir_cursor)(unsafe.Pointer(pCur)).FzPath = sqlite3.Xsqlite3_mprintf(tls, ts+130 /* "%s" */, crt.VaList(bp+16, zDir))
	}

	if (*fsdir_cursor)(unsafe.Pointer(pCur)).FzPath == uintptr(0) {
		return 7
	}
	if fileLinkStat(tls, (*fsdir_cursor)(unsafe.Pointer(pCur)).FzPath, (pCur+40 /* &.sStat */)) != 0 {
		fsdirSetErrmsg(tls, pCur, ts+4753 /* "cannot stat file..." */, crt.VaList(bp+24, (*fsdir_cursor)(unsafe.Pointer(pCur)).FzPath))
		return 1
	}

	return 0
}

var __func__24 = *(*[12]int8)(unsafe.Pointer(ts + 4949 /* "fsdirFilter" */)) /* fileio.c:820:2 */

// SQLite will invoke this method one or more times while planning a query
// that uses the generate_series virtual table.  This routine needs to create
// a query plan for each invocation and compute an estimated cost for that
// plan.
//
// In this implementation idxNum is used to represent the
// query plan.  idxStr is unused.
//
// The query plan is represented by values of idxNum:
//
//  (1)  The path value is supplied by argv[0]
//  (2)  Path is in argv[0] and dir is in argv[1]
func fsdirBestIndex(tls *crt.TLS, tab uintptr, pIdxInfo uintptr) int32 { /* fileio.c:872:12: */
	var i int32            // Loop over constraints
	var idxPath int32 = -1 // Index in pIdxInfo->aConstraint of PATH=
	var idxDir int32 = -1  // Index in pIdxInfo->aConstraint of DIR=
	var seenPath int32 = 0 // True if an unusable PATH= constraint is seen
	var seenDir int32 = 0  // True if an unusable DIR= constraint is seen
	var pConstraint uintptr

	_ = tab
	pConstraint = (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraint
	i = 0
__1:
	if !(i < (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnConstraint) {
		goto __3
	}
	{
		if int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) != 2 {
			goto __2
		}
		switch (*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).FiColumn {
		case 4:
			{
				if (*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fusable != 0 {
					idxPath = i
					seenPath = 0
				} else if idxPath < 0 {
					seenPath = 1
				}
				break
			}
		case 5:
			{
				if (*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fusable != 0 {
					idxDir = i
					seenDir = 0
				} else if idxDir < 0 {
					seenDir = 1
				}
				break
			}
		}
	}
	goto __2
__2:
	i++
	pConstraint += 12
	goto __1
	goto __3
__3:
	;
	if (seenPath != 0) || (seenDir != 0) {
		// If input parameters are unusable, disallow this plan
		return 19
	}

	if idxPath < 0 {
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxNum = 0
		// The pIdxInfo->estimatedCost should have been initialized to a huge
		// number.  Leave it unchanged.
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedRows = int64(0x7fffffff)
	} else {
		(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(idxPath)*8)).Fomit = uint8(1)
		(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(idxPath)*8)).FargvIndex = 1
		if idxDir >= 0 {
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(idxDir)*8)).Fomit = uint8(1)
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(idxDir)*8)).FargvIndex = 2
			(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxNum = 2
			(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = 10.0
		} else {
			(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxNum = 1
			(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = 100.0
		}
	}

	return 0
}

// Register the "fsdir" virtual table.
func fsdirRegister(tls *crt.TLS, db uintptr) int32 { /* fileio.c:938:12: */

	var rc int32 = sqlite3.Xsqlite3_create_module(tls, db, ts+4961 /* "fsdir" */, uintptr(unsafe.Pointer(&fsdirModule1)), uintptr(0))
	return rc
}

var fsdirModule1 = sqlite3_module{FiVersion: 0, FxCreate: // iVersion
uintptr(0), FxConnect:// xCreate
0, FxBestIndex:// xConnect
0, FxDisconnect:// xBestIndex
0, FxDestroy:// xDisconnect
uintptr(0), FxOpen:// xDestroy
0, FxClose:// xOpen - open a cursor
0, FxFilter:// xClose - close a cursor
0, FxNext:// xFilter - configure scan constraints
0, FxEof:// xNext - advance a cursor
0, FxColumn:// xEof - check for end of scan
0, FxRowid:// xColumn - read data
0, FxUpdate:// xRowid - read data
uintptr(0), FxBegin:// xUpdate
uintptr(0), FxSync:// xBegin
uintptr(0), FxCommit:// xSync
uintptr(0), FxRollback:// xCommit
uintptr(0), FxFindFunction:// xRollback
uintptr(0), FxRename:// xFindMethod
uintptr(0), FxSavepoint:// xRename
uintptr(0), FxRelease:// xSavepoint
uintptr(0), FxRollbackTo:// xRelease
uintptr(0), FxShadowName:// xRollbackTo
uintptr(0), // xShadowName
} /* fileio.c:939:25 */

func sqlite3_fileio_init(tls *crt.TLS, db uintptr, pzErrMsg uintptr, pApi uintptr) int32 { /* fileio.c:976:5: */
	var rc int32 = 0
	_ = pApi

	_ = pzErrMsg // Unused parameter
	rc = sqlite3.Xsqlite3_create_function(tls, db, ts+4967 /* "readfile" */, 1,
		(1 | 0x000080000), uintptr(0),
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*crt.TLS, uintptr, int32, uintptr)
		}{readfileFunc})), uintptr(0), uintptr(0))
	if rc == 0 {
		rc = sqlite3.Xsqlite3_create_function(tls, db, ts+4976 /* "writefile" */, -1,
			(1 | 0x000080000), uintptr(0),
			*(*uintptr)(unsafe.Pointer(&struct {
				f func(*crt.TLS, uintptr, int32, uintptr)
			}{writefileFunc})), uintptr(0), uintptr(0))
	}
	if rc == 0 {
		rc = sqlite3.Xsqlite3_create_function(tls, db, ts+4986 /* "lsmode" */, 1, 1, uintptr(0),
			*(*uintptr)(unsafe.Pointer(&struct {
				f func(*crt.TLS, uintptr, int32, uintptr)
			}{lsModeFunc})), uintptr(0), uintptr(0))
	}
	if rc == 0 {
		rc = fsdirRegister(tls, db)
	}
	return rc
}

// If we are compiling with optimizing read this file.  It contains
//   several optimizing inline functions and macros.

// Forward declaration of objects used by this implementation
type fuzzer_vtab1 = struct {
	Fbase       sqlite3_vtab
	FzClassName uintptr
	FpRule      uintptr
	FnCursor    int32
	_           [4]byte
}

// If we are compiling with optimizing read this file.  It contains
//   several optimizing inline functions and macros.

// Forward declaration of objects used by this implementation
type fuzzer_vtab = fuzzer_vtab1 /* fuzzer.c:162:28 */
type fuzzer_cursor1 = struct {
	Fbase     sqlite3_vtab_cursor
	FiRowid   sqlite3_int64
	FpVtab    uintptr
	FrLimit   fuzzer_cost
	FpStem    uintptr
	FpDone    uintptr
	FaQueue   [20]uintptr
	FmxQueue  int32
	FzBuf     uintptr
	FnBuf     int32
	FnStem    int32
	FiRuleset int32
	FnullRule fuzzer_rule
	FapHash   [4001]uintptr
}

type fuzzer_cursor = fuzzer_cursor1 /* fuzzer.c:163:30 */
type fuzzer_rule1 = struct {
	FpNext    uintptr
	FzFrom    uintptr
	FrCost    fuzzer_cost
	FnFrom    fuzzer_len
	FnTo      fuzzer_len
	FiRuleset fuzzer_ruleid
	FzTo      [4]int8
}

type fuzzer_rule = fuzzer_rule1 /* fuzzer.c:164:28 */
type fuzzer_stem1 = struct {
	FzBasis    uintptr
	FpRule     uintptr
	FpNext     uintptr
	FpHash     uintptr
	FrBaseCost fuzzer_cost
	FrCostX    fuzzer_cost
	FnBasis    fuzzer_len
	Fn         fuzzer_len
	_          [6]byte
}

type fuzzer_stem = fuzzer_stem1 /* fuzzer.c:166:28 */

// Various types.
//
// fuzzer_cost is the "cost" of an edit operation.
//
// fuzzer_len is the length of a matching string.
//
// fuzzer_ruleid is an ruleset identifier.
type fuzzer_cost = int32   /* fuzzer.c:177:13 */
type fuzzer_len = int8     /* fuzzer.c:178:21 */
type fuzzer_ruleid = int32 /* fuzzer.c:179:13 */

// The two input rule lists are both sorted in order of increasing
// cost.  Merge them together into a single list, sorted by cost, and
// return a pointer to the head of that list.
func fuzzerMergeRules(tls *crt.TLS, pA uintptr, pB uintptr) uintptr { /* fuzzer.c:261:20: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	// var head fuzzer_rule at bp, 32

	var pTail uintptr

	pTail = bp /* &head */
	for (pA != 0) && (pB != 0) {
		if (*fuzzer_rule)(unsafe.Pointer(pA)).FrCost <= (*fuzzer_rule)(unsafe.Pointer(pB)).FrCost {
			(*fuzzer_rule)(unsafe.Pointer(pTail)).FpNext = pA
			pTail = pA
			pA = (*fuzzer_rule)(unsafe.Pointer(pA)).FpNext
		} else {
			(*fuzzer_rule)(unsafe.Pointer(pTail)).FpNext = pB
			pTail = pB
			pB = (*fuzzer_rule)(unsafe.Pointer(pB)).FpNext
		}
	}
	if pA == uintptr(0) {
		(*fuzzer_rule)(unsafe.Pointer(pTail)).FpNext = pB
	} else {
		(*fuzzer_rule)(unsafe.Pointer(pTail)).FpNext = pA
	}
	return (*fuzzer_rule)(unsafe.Pointer(bp /* &head */)).FpNext
}

// Statement pStmt currently points to a row in the fuzzer data table. This
// function allocates and populates a fuzzer_rule structure according to
// the content of the row.
//
// If successful, *ppRule is set to point to the new object and SQLITE_OK
// is returned. Otherwise, *ppRule is zeroed, *pzErr may be set to point
// to an error message and an SQLite error code returned.
func fuzzerLoadOneRule(tls *crt.TLS, p uintptr, pStmt uintptr, ppRule uintptr, pzErr uintptr) int32 { /* fuzzer.c:294:12: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var iRuleset sqlite3_int64 = sqlite3.Xsqlite3_column_int64(tls, pStmt, 0)
	var zFrom uintptr = sqlite3.Xsqlite3_column_text(tls, pStmt, 1)
	var zTo uintptr = sqlite3.Xsqlite3_column_text(tls, pStmt, 2)
	var nCost int32 = sqlite3.Xsqlite3_column_int(tls, pStmt, 3)

	var rc int32 = 0               // Return code
	var nFrom int32                // Size of string zFrom, in bytes
	var nTo int32                  // Size of string zTo, in bytes
	var pRule uintptr = uintptr(0) // New rule object to return

	if zFrom == uintptr(0) {
		zFrom = ts + 792 /* "" */
	}
	if zTo == uintptr(0) {
		zTo = ts + 792 /* "" */
	}
	nFrom = int32(crt.Xstrlen(tls, zFrom))
	nTo = int32(crt.Xstrlen(tls, zTo))

	// Silently ignore null transformations
	if crt.Xstrcmp(tls, zFrom, zTo) == 0 {
		*(*uintptr)(unsafe.Pointer(ppRule)) = uintptr(0)
		return 0
	}

	if (nCost <= 0) || (nCost > 1000) {
		*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+2581, /* "%s: cost must be..." */
			crt.VaList(bp, (*fuzzer_vtab)(unsafe.Pointer(p)).FzClassName, 1000))
		rc = 1
	} else if (nFrom > 50) || (nTo > 50) {
		*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+2615, /* "%s: maximum stri..." */
			crt.VaList(bp+16, (*fuzzer_vtab)(unsafe.Pointer(p)).FzClassName, 50))
		rc = 1
	} else if (iRuleset < int64(0)) || (iRuleset > int64(2147483647)) {
		*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+4993, /* "%s: ruleset must..." */
			crt.VaList(bp+32, (*fuzzer_vtab)(unsafe.Pointer(p)).FzClassName, 2147483647))
		rc = 1
	} else {

		pRule = sqlite3.Xsqlite3_malloc64(tls, (uint64((uint64(unsafe.Sizeof(fuzzer_rule{})) + uint64(nFrom)) + uint64(nTo))))
		if pRule == uintptr(0) {
			rc = 7
		} else {
			crt.Xmemset(tls, pRule, 0, uint64(unsafe.Sizeof(fuzzer_rule{})))
			(*fuzzer_rule)(unsafe.Pointer(pRule)).FzFrom = pRule + 28 /* &.zTo */
			*(*uintptr)(unsafe.Pointer(pRule + 8 /* &.zFrom */)) += (uintptr(nTo + 1))
			(*fuzzer_rule)(unsafe.Pointer(pRule)).FnFrom = fuzzer_len(nFrom)
			crt.Xmemcpy(tls, (*fuzzer_rule)(unsafe.Pointer(pRule)).FzFrom, zFrom, (uint64(nFrom + 1)))
			crt.Xmemcpy(tls, pRule+28 /* &.zTo */, zTo, (uint64(nTo + 1)))
			(*fuzzer_rule)(unsafe.Pointer(pRule)).FnTo = fuzzer_len(nTo)
			(*fuzzer_rule)(unsafe.Pointer(pRule)).FrCost = nCost
			(*fuzzer_rule)(unsafe.Pointer(pRule)).FiRuleset = int32(iRuleset)
		}
	}

	*(*uintptr)(unsafe.Pointer(ppRule)) = pRule
	return rc
}

// Load the content of the fuzzer data table into memory.
func fuzzerLoadRules(tls *crt.TLS, db uintptr, p uintptr, zDb uintptr, zData uintptr, pzErr uintptr) int32 { /* fuzzer.c:363:12: */
	bp := tls.Alloc(192)
	defer tls.Free(192)

	var rc int32 = 0 // Return code
	var zSql uintptr // SELECT used to read from rules table
	var pHead uintptr = uintptr(0)

	zSql = sqlite3.Xsqlite3_mprintf(tls, ts+2684 /* "SELECT * FROM %Q..." */, crt.VaList(bp, zDb, zData))
	if zSql == uintptr(0) {
		rc = 7
	} else {
		var rc2 int32 // finalize() return code
		*(*uintptr)(unsafe.Pointer(bp + 56 /* pStmt */)) = uintptr(0)
		rc = sqlite3.Xsqlite3_prepare_v2(tls, db, zSql, -1, bp+56 /* &pStmt */, uintptr(0))
		if rc != 0 {
			*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+2704 /* "%s: %s" */, crt.VaList(bp+16, (*fuzzer_vtab)(unsafe.Pointer(p)).FzClassName, sqlite3.Xsqlite3_errmsg(tls, db)))
		} else if sqlite3.Xsqlite3_column_count(tls, *(*uintptr)(unsafe.Pointer(bp + 56 /* pStmt */))) != 4 {
			*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+2711, /* "%s: %s has %d co..." */
				crt.VaList(bp+32, (*fuzzer_vtab)(unsafe.Pointer(p)).FzClassName, zData, sqlite3.Xsqlite3_column_count(tls, *(*uintptr)(unsafe.Pointer(bp + 56 /* pStmt */)))))
			rc = 1
		} else {
			for (rc == 0) && (100 == sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 56 /* pStmt */)))) {
				*(*uintptr)(unsafe.Pointer(bp + 64 /* pRule */)) = uintptr(0)
				rc = fuzzerLoadOneRule(tls, p, *(*uintptr)(unsafe.Pointer(bp + 56 /* pStmt */)), bp+64 /* &pRule */, pzErr)
				if *(*uintptr)(unsafe.Pointer(bp + 64 /* pRule */)) != 0 {
					(*fuzzer_rule)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 64 /* pRule */)))).FpNext = pHead
					pHead = *(*uintptr)(unsafe.Pointer(bp + 64 /* pRule */))
				}
			}
		}
		rc2 = sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 56 /* pStmt */)))
		if rc == 0 {
			rc = rc2
		}
	}
	sqlite3.Xsqlite3_free(tls, zSql)

	// All rules are now in a singly linked list starting at pHead. This
	// block sorts them by cost and then sets fuzzer_vtab.pRule to point to
	// point to the head of the sorted list.
	if rc == 0 {
		var i uint32
		var pX uintptr
		// var a [15]uintptr at bp+72, 120

		for i = uint32(0); uint64(i) < (uint64(unsafe.Sizeof([15]uintptr{})) / uint64(unsafe.Sizeof(uintptr(0)))); i++ {
			*(*uintptr)(unsafe.Pointer(bp + 72 /* &a[0] */ + uintptr(i)*8)) = uintptr(0)
		}
		for (crt.AssignUintptr(&pX, pHead)) != uintptr(0) {
			pHead = (*fuzzer_rule)(unsafe.Pointer(pX)).FpNext
			(*fuzzer_rule)(unsafe.Pointer(pX)).FpNext = uintptr(0)
			for i = uint32(0); (*(*uintptr)(unsafe.Pointer(bp + 72 /* &a[0] */ + uintptr(i)*8)) != 0) && (uint64(i) < ((uint64(unsafe.Sizeof([15]uintptr{})) / uint64(unsafe.Sizeof(uintptr(0)))) - uint64(1))); i++ {
				pX = fuzzerMergeRules(tls, *(*uintptr)(unsafe.Pointer(bp + 72 /* &a[0] */ + uintptr(i)*8)), pX)
				*(*uintptr)(unsafe.Pointer(bp + 72 /* &a[0] */ + uintptr(i)*8)) = uintptr(0)
			}
			*(*uintptr)(unsafe.Pointer(bp + 72 /* &a[0] */ + uintptr(i)*8)) = fuzzerMergeRules(tls, *(*uintptr)(unsafe.Pointer(bp + 72 /* &a[0] */ + uintptr(i)*8)), pX)
		}
		pX = *(*uintptr)(unsafe.Pointer(bp + 72 /* &a[0] */ + uintptr(0)*8))
		i = uint32(1)
		for ; uint64(i) < (uint64(unsafe.Sizeof([15]uintptr{})) / uint64(unsafe.Sizeof(uintptr(0)))); i++ {
			pX = fuzzerMergeRules(tls, *(*uintptr)(unsafe.Pointer(bp + 72 /* &a[0] */ + uintptr(i)*8)), pX)
		}
		(*fuzzer_vtab)(unsafe.Pointer(p)).FpRule = fuzzerMergeRules(tls, (*fuzzer_vtab)(unsafe.Pointer(p)).FpRule, pX)
	} else {
		// An error has occurred. Setting p->pRule to point to the head of the
		// allocated list ensures that the list will be cleaned up in this case.

		(*fuzzer_vtab)(unsafe.Pointer(p)).FpRule = pHead
	}

	return rc
}

// This function converts an SQL quoted string into an unquoted string
// and returns a pointer to a buffer allocated using sqlite3_malloc()
// containing the result. The caller should eventually free this buffer
// using sqlite3_free.
//
// Examples:
//
//     "abc"   becomes   abc
//     'xyz'   becomes   xyz
//     [pqr]   becomes   pqr
//     `mno`   becomes   mno
func fuzzerDequote(tls *crt.TLS, zIn uintptr) uintptr { /* fuzzer.c:449:13: */
	var nIn sqlite3_int64 // Size of input string, in bytes
	var zOut uintptr      // Output (dequoted) string

	nIn = sqlite3_int64(crt.Xstrlen(tls, zIn))
	zOut = sqlite3.Xsqlite3_malloc64(tls, (uint64(nIn + int64(1))))
	if zOut != 0 {
		var q int8 = *(*int8)(unsafe.Pointer(zIn + uintptr(0))) // Quote character (if any )

		if (((int32(q) != '[') && (int32(q) != '\'')) && (int32(q) != '"')) && (int32(q) != '`') {
			crt.Xmemcpy(tls, zOut, zIn, (size_t(nIn + int64(1))))
		} else {
			var iOut int32 = 0 // Index of next byte to write to output
			var iIn int32      // Index of next byte to read from input

			if int32(q) == '[' {
				q = int8(']')
			}
			for iIn = 1; sqlite3_int64(iIn) < nIn; iIn++ {
				if int32(*(*int8)(unsafe.Pointer(zIn + uintptr(iIn)))) == int32(q) {
					iIn++
				}
				*(*int8)(unsafe.Pointer(zOut + uintptr(crt.PostIncInt32(&iOut, 1)))) = *(*int8)(unsafe.Pointer(zIn + uintptr(iIn)))
			}
		}
	}
	return zOut
}

// xDisconnect/xDestroy method for the fuzzer module.
func fuzzerDisconnect(tls *crt.TLS, pVtab uintptr) int32 { /* fuzzer.c:478:12: */
	var p uintptr = pVtab

	for (*fuzzer_vtab)(unsafe.Pointer(p)).FpRule != 0 {
		var pRule uintptr = (*fuzzer_vtab)(unsafe.Pointer(p)).FpRule
		(*fuzzer_vtab)(unsafe.Pointer(p)).FpRule = (*fuzzer_rule)(unsafe.Pointer(pRule)).FpNext
		sqlite3.Xsqlite3_free(tls, pRule)
	}
	sqlite3.Xsqlite3_free(tls, p)
	return 0
}

// xConnect/xCreate method for the fuzzer module. Arguments are:
//
//   argv[0]   -> module name  ("fuzzer")
//   argv[1]   -> database name
//   argv[2]   -> table name
//   argv[3]   -> fuzzer rule table name
func fuzzerConnect(tls *crt.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVtab uintptr, pzErr uintptr) int32 { /* fuzzer.c:498:12: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var rc int32 = 0              // Return code
	var pNew uintptr = uintptr(0) // New virtual table
	var zModule uintptr = *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8))
	var zDb uintptr = *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8))

	if argc != 4 {
		*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls,
			ts+5030 /* "%s: wrong number..." */, crt.VaList(bp, zModule))
		rc = 1
	} else {
		var nModule sqlite3_int64 // Length of zModule, in bytes

		nModule = sqlite3_int64(crt.Xstrlen(tls, zModule))
		pNew = sqlite3.Xsqlite3_malloc64(tls, ((uint64(unsafe.Sizeof(fuzzer_vtab{})) + uint64(nModule)) + uint64(1)))
		if pNew == uintptr(0) {
			rc = 7
		} else {
			var zTab uintptr // Dequoted name of fuzzer data table

			crt.Xmemset(tls, pNew, 0, uint64(unsafe.Sizeof(fuzzer_vtab{})))
			(*fuzzer_vtab)(unsafe.Pointer(pNew)).FzClassName = (pNew + uintptr(1)*48)
			crt.Xmemcpy(tls, (*fuzzer_vtab)(unsafe.Pointer(pNew)).FzClassName, zModule, (size_t(nModule + int64(1))))

			zTab = fuzzerDequote(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(3)*8)))
			if zTab == uintptr(0) {
				rc = 7
			} else {
				rc = fuzzerLoadRules(tls, db, pNew, zDb, zTab, pzErr)
				sqlite3.Xsqlite3_free(tls, zTab)
			}

			if rc == 0 {
				rc = sqlite3.Xsqlite3_declare_vtab(tls, db, ts+5081 /* "CREATE TABLE x(w..." */)
			}
			if rc != 0 {
				fuzzerDisconnect(tls, pNew)
				pNew = uintptr(0)
			} else {
				sqlite3.Xsqlite3_vtab_config(tls, db, 2, 0)
			}
		}
	}

	*(*uintptr)(unsafe.Pointer(ppVtab)) = pNew
	return rc
}

// Open a new fuzzer cursor.
func fuzzerOpen(tls *crt.TLS, pVTab uintptr, ppCursor uintptr) int32 { /* fuzzer.c:556:12: */
	var p uintptr = pVTab
	var pCur uintptr
	pCur = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(fuzzer_cursor{})))
	if pCur == uintptr(0) {
		return 7
	}
	crt.Xmemset(tls, pCur, 0, uint64(unsafe.Sizeof(fuzzer_cursor{})))
	(*fuzzer_cursor)(unsafe.Pointer(pCur)).FpVtab = p
	*(*uintptr)(unsafe.Pointer(ppCursor)) = (pCur /* &.base */)
	(*fuzzer_vtab)(unsafe.Pointer(p)).FnCursor++
	return 0
}

// Free all stems in a list.
func fuzzerClearStemList(tls *crt.TLS, pStem uintptr) { /* fuzzer.c:571:13: */
	for pStem != 0 {
		var pNext uintptr = (*fuzzer_stem)(unsafe.Pointer(pStem)).FpNext
		sqlite3.Xsqlite3_free(tls, pStem)
		pStem = pNext
	}
}

// Free up all the memory allocated by a cursor.  Set it rLimit to 0
// to indicate that it is at EOF.
func fuzzerClearCursor(tls *crt.TLS, pCur uintptr, clearHash int32) { /* fuzzer.c:583:13: */
	var i int32
	fuzzerClearStemList(tls, (*fuzzer_cursor)(unsafe.Pointer(pCur)).FpStem)
	fuzzerClearStemList(tls, (*fuzzer_cursor)(unsafe.Pointer(pCur)).FpDone)
	for i = 0; i < 20; i++ {
		fuzzerClearStemList(tls, *(*uintptr)(unsafe.Pointer((pCur + 48 /* &.aQueue */) + uintptr(i)*8)))
	}
	(*fuzzer_cursor)(unsafe.Pointer(pCur)).FrLimit = 0
	if (clearHash != 0) && ((*fuzzer_cursor)(unsafe.Pointer(pCur)).FnStem != 0) {
		(*fuzzer_cursor)(unsafe.Pointer(pCur)).FmxQueue = 0
		(*fuzzer_cursor)(unsafe.Pointer(pCur)).FpStem = uintptr(0)
		(*fuzzer_cursor)(unsafe.Pointer(pCur)).FpDone = uintptr(0)
		crt.Xmemset(tls, pCur+48 /* &.aQueue */, 0, uint64(unsafe.Sizeof([20]uintptr{})))
		crt.Xmemset(tls, pCur+272 /* &.apHash */, 0, uint64(unsafe.Sizeof([4001]uintptr{})))
	}
	(*fuzzer_cursor)(unsafe.Pointer(pCur)).FnStem = 0
}

// Close a fuzzer cursor.
func fuzzerClose(tls *crt.TLS, cur uintptr) int32 { /* fuzzer.c:602:12: */
	var pCur uintptr = cur
	fuzzerClearCursor(tls, pCur, 0)
	sqlite3.Xsqlite3_free(tls, (*fuzzer_cursor)(unsafe.Pointer(pCur)).FzBuf)
	(*fuzzer_vtab)(unsafe.Pointer((*fuzzer_cursor)(unsafe.Pointer(pCur)).FpVtab)).FnCursor--
	sqlite3.Xsqlite3_free(tls, pCur)
	return 0
}

// Compute the current output term for a fuzzer_stem.
func fuzzerRender(tls *crt.TLS, pStem uintptr, pzBuf uintptr, pnBuf uintptr) int32 { /* fuzzer.c:614:12: */
	var pRule uintptr = (*fuzzer_stem)(unsafe.Pointer(pStem)).FpRule
	var n int32   // Size of output term without nul-term
	var z uintptr // Buffer to assemble output term in

	n = ((int32((*fuzzer_stem)(unsafe.Pointer(pStem)).FnBasis) + int32((*fuzzer_rule)(unsafe.Pointer(pRule)).FnTo)) - int32((*fuzzer_rule)(unsafe.Pointer(pRule)).FnFrom))
	if (*(*int32)(unsafe.Pointer(pnBuf))) < (n + 1) {
		(*(*uintptr)(unsafe.Pointer(pzBuf))) = sqlite3.Xsqlite3_realloc(tls, *(*uintptr)(unsafe.Pointer(pzBuf)), (n + 100))
		if (*(*uintptr)(unsafe.Pointer(pzBuf))) == uintptr(0) {
			return 7
		}
		(*(*int32)(unsafe.Pointer(pnBuf))) = (n + 100)
	}
	n = int32((*fuzzer_stem)(unsafe.Pointer(pStem)).Fn)
	z = *(*uintptr)(unsafe.Pointer(pzBuf))
	if n < 0 {
		crt.Xmemcpy(tls, z, (*fuzzer_stem)(unsafe.Pointer(pStem)).FzBasis, (uint64(int32((*fuzzer_stem)(unsafe.Pointer(pStem)).FnBasis) + 1)))
	} else {
		crt.Xmemcpy(tls, z, (*fuzzer_stem)(unsafe.Pointer(pStem)).FzBasis, uint64(n))
		crt.Xmemcpy(tls, (z + uintptr(n)), pRule+28 /* &.zTo */, uint64((*fuzzer_rule)(unsafe.Pointer(pRule)).FnTo))
		crt.Xmemcpy(tls, (z + uintptr((n + int32((*fuzzer_rule)(unsafe.Pointer(pRule)).FnTo)))), ((*fuzzer_stem)(unsafe.Pointer(pStem)).FzBasis + uintptr((n + int32((*fuzzer_rule)(unsafe.Pointer(pRule)).FnFrom)))),
			(uint64(((int32((*fuzzer_stem)(unsafe.Pointer(pStem)).FnBasis) - n) - int32((*fuzzer_rule)(unsafe.Pointer(pRule)).FnFrom)) + 1)))
	}

	return 0
}

// Compute a hash on zBasis.
func fuzzerHash(tls *crt.TLS, z uintptr) uint32 { /* fuzzer.c:647:21: */
	var h uint32 = uint32(0)
	for *(*int8)(unsafe.Pointer(z)) != 0 {
		h = (((h << 3) ^ (h >> 29)) ^ uint32(*(*int8)(unsafe.Pointer(crt.PostIncUintptr(&z, 1)))))
	}
	return (h % uint32(4001))
}

// Current cost of a stem
func fuzzerCost(tls *crt.TLS, pStem uintptr) fuzzer_cost { /* fuzzer.c:656:20: */
	return crt.AssignPtrInt32(pStem+36 /* &.rCostX */, ((*fuzzer_stem)(unsafe.Pointer(pStem)).FrBaseCost + (*fuzzer_rule)(unsafe.Pointer((*fuzzer_stem)(unsafe.Pointer(pStem)).FpRule)).FrCost))
}

// Return 1 if the string to which the cursor is point has already
// been emitted.  Return 0 if not.  Return -1 on a memory allocation
// failures.
func fuzzerSeen(tls *crt.TLS, pCur uintptr, pStem uintptr) int32 { /* fuzzer.c:694:12: */
	var h uint32
	var pLookup uintptr

	if fuzzerRender(tls, pStem, (pCur+216 /* &.zBuf */), (pCur+224 /* &.nBuf */)) == 7 {
		return -1
	}
	h = fuzzerHash(tls, (*fuzzer_cursor)(unsafe.Pointer(pCur)).FzBuf)
	pLookup = *(*uintptr)(unsafe.Pointer((pCur + 272 /* &.apHash */) + uintptr(h)*8))
	for (pLookup != 0) && (crt.Xstrcmp(tls, (*fuzzer_stem)(unsafe.Pointer(pLookup)).FzBasis, (*fuzzer_cursor)(unsafe.Pointer(pCur)).FzBuf) != 0) {
		pLookup = (*fuzzer_stem)(unsafe.Pointer(pLookup)).FpHash
	}
	return (crt.Bool32(pLookup != uintptr(0)))
}

// If argument pRule is NULL, this function returns false.
//
// Otherwise, it returns true if rule pRule should be skipped. A rule
// should be skipped if it does not belong to rule-set iRuleset, or if
// applying it to stem pStem would create a string longer than
// FUZZER_MX_OUTPUT_LENGTH bytes.
func fuzzerSkipRule(tls *crt.TLS, pRule uintptr, pStem uintptr, iRuleset int32) int32 { /* fuzzer.c:717:12: */
	return (crt.Bool32((pRule != 0) && (((*fuzzer_rule)(unsafe.Pointer(pRule)).FiRuleset != iRuleset) ||
		(((int32((*fuzzer_stem)(unsafe.Pointer(pStem)).FnBasis) + int32((*fuzzer_rule)(unsafe.Pointer(pRule)).FnTo)) - int32((*fuzzer_rule)(unsafe.Pointer(pRule)).FnFrom)) > 100))))
}

// Advance a fuzzer_stem to its next value.   Return 0 if there are
// no more values that can be generated by this fuzzer_stem.  Return
// -1 on a memory allocation failure.
func fuzzerAdvance(tls *crt.TLS, pCur uintptr, pStem uintptr) int32 { /* fuzzer.c:733:12: */
	var pRule uintptr
	for (crt.AssignUintptr(&pRule, (*fuzzer_stem)(unsafe.Pointer(pStem)).FpRule)) != uintptr(0) {

		for int32((*fuzzer_stem)(unsafe.Pointer(pStem)).Fn) < (int32((*fuzzer_stem)(unsafe.Pointer(pStem)).FnBasis) - int32((*fuzzer_rule)(unsafe.Pointer(pRule)).FnFrom)) {
			(*fuzzer_stem)(unsafe.Pointer(pStem)).Fn++
			if (int32((*fuzzer_rule)(unsafe.Pointer(pRule)).FnFrom) == 0) ||
				(crt.Xmemcmp(tls, ((*fuzzer_stem)(unsafe.Pointer(pStem)).FzBasis+uintptr((*fuzzer_stem)(unsafe.Pointer(pStem)).Fn)), (*fuzzer_rule)(unsafe.Pointer(pRule)).FzFrom, uint64((*fuzzer_rule)(unsafe.Pointer(pRule)).FnFrom)) == 0) {
				// Found a rewrite case.  Make sure it is not a duplicate
				var rc int32 = fuzzerSeen(tls, pCur, pStem)
				if rc < 0 {
					return -1
				}
				if rc == 0 {
					fuzzerCost(tls, pStem)
					return 1
				}
			}
		}
		(*fuzzer_stem)(unsafe.Pointer(pStem)).Fn = int8(-1)
		for ok := true; ok; ok = fuzzerSkipRule(tls, pRule, pStem, (*fuzzer_cursor)(unsafe.Pointer(pCur)).FiRuleset) != 0 {
			pRule = (*fuzzer_rule)(unsafe.Pointer(pRule)).FpNext
		}
		(*fuzzer_stem)(unsafe.Pointer(pStem)).FpRule = pRule
		if (pRule != 0) && (fuzzerCost(tls, pStem) > (*fuzzer_cursor)(unsafe.Pointer(pCur)).FrLimit) {
			(*fuzzer_stem)(unsafe.Pointer(pStem)).FpRule = uintptr(0)
		}
	}
	return 0
}

// The two input stem lists are both sorted in order of increasing
// rCostX.  Merge them together into a single list, sorted by rCostX, and
// return a pointer to the head of that new list.
func fuzzerMergeStems(tls *crt.TLS, pA uintptr, pB uintptr) uintptr { /* fuzzer.c:766:20: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	// var head fuzzer_stem at bp, 48

	var pTail uintptr

	pTail = bp /* &head */
	for (pA != 0) && (pB != 0) {
		if (*fuzzer_stem)(unsafe.Pointer(pA)).FrCostX <= (*fuzzer_stem)(unsafe.Pointer(pB)).FrCostX {
			(*fuzzer_stem)(unsafe.Pointer(pTail)).FpNext = pA
			pTail = pA
			pA = (*fuzzer_stem)(unsafe.Pointer(pA)).FpNext
		} else {
			(*fuzzer_stem)(unsafe.Pointer(pTail)).FpNext = pB
			pTail = pB
			pB = (*fuzzer_stem)(unsafe.Pointer(pB)).FpNext
		}
	}
	if pA == uintptr(0) {
		(*fuzzer_stem)(unsafe.Pointer(pTail)).FpNext = pB
	} else {
		(*fuzzer_stem)(unsafe.Pointer(pTail)).FpNext = pA
	}
	return (*fuzzer_stem)(unsafe.Pointer(bp /* &head */)).FpNext
}

// Load pCur->pStem with the lowest-cost stem.  Return a pointer
// to the lowest-cost stem.
func fuzzerLowestCostStem(tls *crt.TLS, pCur uintptr) uintptr { /* fuzzer.c:794:20: */
	var pBest uintptr
	var pX uintptr
	var iBest int32
	var i int32

	if (*fuzzer_cursor)(unsafe.Pointer(pCur)).FpStem == uintptr(0) {
		iBest = -1
		pBest = uintptr(0)
		for i = 0; i <= (*fuzzer_cursor)(unsafe.Pointer(pCur)).FmxQueue; i++ {
			pX = *(*uintptr)(unsafe.Pointer((pCur + 48 /* &.aQueue */) + uintptr(i)*8))
			if pX == uintptr(0) {
				continue
			}
			if (pBest == uintptr(0)) || ((*fuzzer_stem)(unsafe.Pointer(pBest)).FrCostX > (*fuzzer_stem)(unsafe.Pointer(pX)).FrCostX) {
				pBest = pX
				iBest = i
			}
		}
		if pBest != 0 {
			*(*uintptr)(unsafe.Pointer((pCur + 48 /* &.aQueue */) + uintptr(iBest)*8)) = (*fuzzer_stem)(unsafe.Pointer(pBest)).FpNext
			(*fuzzer_stem)(unsafe.Pointer(pBest)).FpNext = uintptr(0)
			(*fuzzer_cursor)(unsafe.Pointer(pCur)).FpStem = pBest
		}
	}
	return (*fuzzer_cursor)(unsafe.Pointer(pCur)).FpStem
}

// Insert pNew into queue of pending stems.  Then find the stem
// with the lowest rCostX and move it into pCur->pStem.
// list.  The insert is done such the pNew is in the correct order
// according to fuzzer_stem.zBaseCost+fuzzer_stem.pRule->rCost.
func fuzzerInsert(tls *crt.TLS, pCur uintptr, pNew uintptr) uintptr { /* fuzzer.c:825:20: */
	var pX uintptr
	var i int32

	// If pCur->pStem exists and is greater than pNew, then make pNew
	// the new pCur->pStem and insert the old pCur->pStem instead.
	if ((crt.AssignUintptr(&pX, (*fuzzer_cursor)(unsafe.Pointer(pCur)).FpStem)) != uintptr(0)) && ((*fuzzer_stem)(unsafe.Pointer(pX)).FrCostX > (*fuzzer_stem)(unsafe.Pointer(pNew)).FrCostX) {
		(*fuzzer_stem)(unsafe.Pointer(pNew)).FpNext = uintptr(0)
		(*fuzzer_cursor)(unsafe.Pointer(pCur)).FpStem = pNew
		pNew = pX
	}

	// Insert the new value
	(*fuzzer_stem)(unsafe.Pointer(pNew)).FpNext = uintptr(0)
	pX = pNew
	for i = 0; i <= (*fuzzer_cursor)(unsafe.Pointer(pCur)).FmxQueue; i++ {
		if *(*uintptr)(unsafe.Pointer((pCur + 48 /* &.aQueue */) + uintptr(i)*8)) != 0 {
			pX = fuzzerMergeStems(tls, pX, *(*uintptr)(unsafe.Pointer((pCur + 48 /* &.aQueue */) + uintptr(i)*8)))
			*(*uintptr)(unsafe.Pointer((pCur + 48 /* &.aQueue */) + uintptr(i)*8)) = uintptr(0)
		} else {
			*(*uintptr)(unsafe.Pointer((pCur + 48 /* &.aQueue */) + uintptr(i)*8)) = pX
			break
		}
	}
	if i > (*fuzzer_cursor)(unsafe.Pointer(pCur)).FmxQueue {
		if i < 20 {
			(*fuzzer_cursor)(unsafe.Pointer(pCur)).FmxQueue = i
			*(*uintptr)(unsafe.Pointer((pCur + 48 /* &.aQueue */) + uintptr(i)*8)) = pX
		} else {

			pX = fuzzerMergeStems(tls, pX, *(*uintptr)(unsafe.Pointer((pCur + 48 /* &.aQueue */) + uintptr((20-1))*8)))
			*(*uintptr)(unsafe.Pointer((pCur + 48 /* &.aQueue */) + uintptr((20-1))*8)) = pX
		}
	}

	return fuzzerLowestCostStem(tls, pCur)
}

// Allocate a new fuzzer_stem.  Add it to the hash table but do not
// link it into either the pCur->pStem or pCur->pDone lists.
func fuzzerNewStem(tls *crt.TLS, pCur uintptr, zWord uintptr, rBaseCost fuzzer_cost) uintptr { /* fuzzer.c:868:20: */
	var pNew uintptr
	var pRule uintptr
	var h uint32

	pNew = sqlite3.Xsqlite3_malloc64(tls, (uint64((uint64(unsafe.Sizeof(fuzzer_stem{})) + crt.Xstrlen(tls, zWord)) + uint64(1))))
	if pNew == uintptr(0) {
		return uintptr(0)
	}
	crt.Xmemset(tls, pNew, 0, uint64(unsafe.Sizeof(fuzzer_stem{})))
	(*fuzzer_stem)(unsafe.Pointer(pNew)).FzBasis = (pNew + uintptr(1)*48)
	(*fuzzer_stem)(unsafe.Pointer(pNew)).FnBasis = fuzzer_len(crt.Xstrlen(tls, zWord))
	crt.Xmemcpy(tls, (*fuzzer_stem)(unsafe.Pointer(pNew)).FzBasis, zWord, (uint64(int32((*fuzzer_stem)(unsafe.Pointer(pNew)).FnBasis) + 1)))
	pRule = (*fuzzer_vtab)(unsafe.Pointer((*fuzzer_cursor)(unsafe.Pointer(pCur)).FpVtab)).FpRule
	for fuzzerSkipRule(tls, pRule, pNew, (*fuzzer_cursor)(unsafe.Pointer(pCur)).FiRuleset) != 0 {
		pRule = (*fuzzer_rule)(unsafe.Pointer(pRule)).FpNext
	}
	(*fuzzer_stem)(unsafe.Pointer(pNew)).FpRule = pRule
	(*fuzzer_stem)(unsafe.Pointer(pNew)).Fn = int8(-1)
	(*fuzzer_stem)(unsafe.Pointer(pNew)).FrBaseCost = crt.AssignPtrInt32(pNew+36 /* &.rCostX */, rBaseCost)
	h = fuzzerHash(tls, (*fuzzer_stem)(unsafe.Pointer(pNew)).FzBasis)
	(*fuzzer_stem)(unsafe.Pointer(pNew)).FpHash = *(*uintptr)(unsafe.Pointer((pCur + 272 /* &.apHash */) + uintptr(h)*8))
	*(*uintptr)(unsafe.Pointer((pCur + 272 /* &.apHash */) + uintptr(h)*8)) = pNew
	(*fuzzer_cursor)(unsafe.Pointer(pCur)).FnStem++
	return pNew
}

// Advance a cursor to its next row of output
func fuzzerNext(tls *crt.TLS, cur uintptr) int32 { /* fuzzer.c:901:12: */
	var pCur uintptr = cur
	var rc int32
	var pStem uintptr
	var pNew uintptr

	(*fuzzer_cursor)(unsafe.Pointer(pCur)).FiRowid++

	// Use the element the cursor is currently point to to create
	// a new stem and insert the new stem into the priority queue.
	pStem = (*fuzzer_cursor)(unsafe.Pointer(pCur)).FpStem
	if (*fuzzer_stem)(unsafe.Pointer(pStem)).FrCostX > 0 {
		rc = fuzzerRender(tls, pStem, (pCur + 216 /* &.zBuf */), (pCur + 224 /* &.nBuf */))
		if rc == 7 {
			return 7
		}
		pNew = fuzzerNewStem(tls, pCur, (*fuzzer_cursor)(unsafe.Pointer(pCur)).FzBuf, (*fuzzer_stem)(unsafe.Pointer(pStem)).FrCostX)
		if pNew != 0 {
			if fuzzerAdvance(tls, pCur, pNew) == 0 {
				(*fuzzer_stem)(unsafe.Pointer(pNew)).FpNext = (*fuzzer_cursor)(unsafe.Pointer(pCur)).FpDone
				(*fuzzer_cursor)(unsafe.Pointer(pCur)).FpDone = pNew
			} else {
				if fuzzerInsert(tls, pCur, pNew) == pNew {
					return 0
				}
			}
		} else {
			return 7
		}
	}

	// Adjust the priority queue so that the first element of the
	// stem list is the next lowest cost word.
	for (crt.AssignUintptr(&pStem, (*fuzzer_cursor)(unsafe.Pointer(pCur)).FpStem)) != uintptr(0) {
		var res int32 = fuzzerAdvance(tls, pCur, pStem)
		if res < 0 {
			return 7
		} else if res > 0 {
			(*fuzzer_cursor)(unsafe.Pointer(pCur)).FpStem = uintptr(0)
			pStem = fuzzerInsert(tls, pCur, pStem)
			if (crt.AssignInt32(&rc, fuzzerSeen(tls, pCur, pStem))) != 0 {
				if rc < 0 {
					return 7
				}
				continue
			}
			return 0
		}
		(*fuzzer_cursor)(unsafe.Pointer(pCur)).FpStem = uintptr(0)
		(*fuzzer_stem)(unsafe.Pointer(pStem)).FpNext = (*fuzzer_cursor)(unsafe.Pointer(pCur)).FpDone
		(*fuzzer_cursor)(unsafe.Pointer(pCur)).FpDone = pStem
		if fuzzerLowestCostStem(tls, pCur) != 0 {
			rc = fuzzerSeen(tls, pCur, (*fuzzer_cursor)(unsafe.Pointer(pCur)).FpStem)
			if rc < 0 {
				return 7
			}
			if rc == 0 {
				return 0
			}
		}
	}

	// Reach this point only if queue has been exhausted and there is
	// nothing left to be output.
	(*fuzzer_cursor)(unsafe.Pointer(pCur)).FrLimit = 0
	return 0
}

// Called to "rewind" a cursor back to the beginning so that
// it starts its output over again.  Always called at least once
// prior to any fuzzerColumn, fuzzerRowid, or fuzzerEof call.
func fuzzerFilter(tls *crt.TLS, pVtabCursor uintptr, idxNum int32, idxStr uintptr, argc int32, argv uintptr) int32 { /* fuzzer.c:969:12: */
	var pCur uintptr = pVtabCursor
	var zWord uintptr = ts + 792 /* "" */
	var pStem uintptr
	var idx int32

	fuzzerClearCursor(tls, pCur, 1)
	(*fuzzer_cursor)(unsafe.Pointer(pCur)).FrLimit = 2147483647
	idx = 0
	if (idxNum & 1) != 0 {
		zWord = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)))
		idx++
	}
	if (idxNum & 2) != 0 {
		(*fuzzer_cursor)(unsafe.Pointer(pCur)).FrLimit = sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(idx)*8)))
		idx++
	}
	if (idxNum & 4) != 0 {
		(*fuzzer_cursor)(unsafe.Pointer(pCur)).FiRuleset = sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(idx)*8)))
		idx++
	}
	(*fuzzer_cursor)(unsafe.Pointer(pCur)).FnullRule.FpNext = (*fuzzer_vtab)(unsafe.Pointer((*fuzzer_cursor)(unsafe.Pointer(pCur)).FpVtab)).FpRule
	(*fuzzer_cursor)(unsafe.Pointer(pCur)).FnullRule.FrCost = 0
	(*fuzzer_cursor)(unsafe.Pointer(pCur)).FnullRule.FnFrom = int8(0)
	(*fuzzer_cursor)(unsafe.Pointer(pCur)).FnullRule.FnTo = int8(0)
	(*fuzzer_cursor)(unsafe.Pointer(pCur)).FnullRule.FzFrom = ts + 792 /* "" */
	(*fuzzer_cursor)(unsafe.Pointer(pCur)).FiRowid = int64(1)

	// If the query term is longer than FUZZER_MX_OUTPUT_LENGTH bytes, this
	// query will return zero rows.
	if int32(crt.Xstrlen(tls, zWord)) < 100 {
		(*fuzzer_cursor)(unsafe.Pointer(pCur)).FpStem = crt.AssignUintptr(&pStem, fuzzerNewStem(tls, pCur, zWord, 0))
		if pStem == uintptr(0) {
			return 7
		}
		(*fuzzer_stem)(unsafe.Pointer(pStem)).FpRule = (pCur + 240 /* &.nullRule */)
		(*fuzzer_stem)(unsafe.Pointer(pStem)).Fn = (*fuzzer_stem)(unsafe.Pointer(pStem)).FnBasis
	} else {
		(*fuzzer_cursor)(unsafe.Pointer(pCur)).FrLimit = 0
	}

	return 0
}

// Only the word and distance columns have values.  All other columns
// return NULL
func fuzzerColumn(tls *crt.TLS, cur uintptr, ctx uintptr, i int32) int32 { /* fuzzer.c:1020:12: */
	var pCur uintptr = cur
	if i == 0 {
		// the "word" column
		if fuzzerRender(tls, (*fuzzer_cursor)(unsafe.Pointer(pCur)).FpStem, (pCur+216 /* &.zBuf */), (pCur+224 /* &.nBuf */)) == 7 {
			return 7
		}
		sqlite3.Xsqlite3_result_text(tls, ctx, (*fuzzer_cursor)(unsafe.Pointer(pCur)).FzBuf, -1, crt.UintptrFromInt32(-1))
	} else if i == 1 {
		// the "distance" column
		sqlite3.Xsqlite3_result_int(tls, ctx, (*fuzzer_stem)(unsafe.Pointer((*fuzzer_cursor)(unsafe.Pointer(pCur)).FpStem)).FrCostX)
	} else {
		// All other columns are NULL
		sqlite3.Xsqlite3_result_null(tls, ctx)
	}
	return 0
}

// The rowid.
func fuzzerRowid(tls *crt.TLS, cur uintptr, pRowid uintptr) int32 { /* fuzzer.c:1041:12: */
	var pCur uintptr = cur
	*(*sqlite_int64)(unsafe.Pointer(pRowid)) = (*fuzzer_cursor)(unsafe.Pointer(pCur)).FiRowid
	return 0
}

// When the fuzzer_cursor.rLimit value is 0 or less, that is a signal
// that the cursor has nothing more to output.
func fuzzerEof(tls *crt.TLS, cur uintptr) int32 { /* fuzzer.c:1051:12: */
	var pCur uintptr = cur
	return (crt.Bool32((*fuzzer_cursor)(unsafe.Pointer(pCur)).FrLimit <= 0))
}

// Search for terms of these forms:
//
//   (A)    word MATCH $str
//   (B1)   distance < $value
//   (B2)   distance <= $value
//   (C)    ruleid == $ruleid
//
// The distance< and distance<= are both treated as distance<=.
// The query plan number is a bit vector:
//
//   bit 1:   Term of the form (A) found
//   bit 2:   Term like (B1) or (B2) found
//   bit 3:   Term like (C) found
//
// If bit-1 is set, $str is always in filter.argv[0].  If bit-2 is set
// then $value is in filter.argv[0] if bit-1 is clear and is in
// filter.argv[1] if bit-1 is set.  If bit-3 is set, then $ruleid is
// in filter.argv[0] if bit-1 and bit-2 are both zero, is in
// filter.argv[1] if exactly one of bit-1 and bit-2 are set, and is in
// filter.argv[2] if both bit-1 and bit-2 are set.
func fuzzerBestIndex(tls *crt.TLS, tab uintptr, pIdxInfo uintptr) int32 { /* fuzzer.c:1078:12: */
	var iPlan int32 = 0
	var iDistTerm int32 = -1
	var iRulesetTerm int32 = -1
	var i int32
	var seenMatch int32 = 0
	var pConstraint uintptr
	var rCost float64 = 1e12

	pConstraint = (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraint
	i = 0
__1:
	if !(i < (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnConstraint) {
		goto __3
	}
	{
		if ((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).FiColumn == 0) &&
			(int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == 64) {
			seenMatch = 1
		}
		if int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fusable) == 0 {
			goto __2
		}
		if (((iPlan & 1) == 0) &&
			((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).FiColumn == 0)) &&
			(int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == 64) {
			iPlan = iPlan | (1)
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(i)*8)).FargvIndex = 1
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(i)*8)).Fomit = uint8(1)
			rCost = rCost / (1e6)
		}
		if (((iPlan & 2) == 0) &&
			((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).FiColumn == 1)) &&
			((int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == 16) ||
				(int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == 8)) {
			iPlan = iPlan | (2)
			iDistTerm = i
			rCost = rCost / (10.0)
		}
		if (((iPlan & 4) == 0) &&
			((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).FiColumn == 2)) &&
			(int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == 2) {
			iPlan = iPlan | (4)
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(i)*8)).Fomit = uint8(1)
			iRulesetTerm = i
			rCost = rCost / (10.0)
		}
	}
	goto __2
__2:
	i++
	pConstraint += 12
	goto __1
	goto __3
__3:
	;
	if (iPlan & 2) != 0 {
		(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(iDistTerm)*8)).FargvIndex = (1 + (crt.Bool32((iPlan & 1) != 0)))
	}
	if (iPlan & 4) != 0 {
		var idx int32 = 1
		if (iPlan & 1) != 0 {
			idx++
		}
		if (iPlan & 2) != 0 {
			idx++
		}
		(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(iRulesetTerm)*8)).FargvIndex = idx
	}
	(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxNum = iPlan
	if (((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnOrderBy == 1) &&
		((*sqlite3_index_orderby)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaOrderBy+uintptr(0)*8)).FiColumn == 1)) &&
		(int32((*sqlite3_index_orderby)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaOrderBy+uintptr(0)*8)).Fdesc) == 0) {
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).ForderByConsumed = 1
	}
	if (seenMatch != 0) && ((iPlan & 1) == 0) {
		rCost = 1e99
	}
	(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = rCost

	return 0
}

// A virtual table module that implements the "fuzzer".
var fuzzerModule = sqlite3_module{FiVersion: 0, FxCreate: // iVersion
0, FxConnect:                                             0, FxBestIndex: 0, FxDisconnect: 0, FxDestroy: 0, FxOpen: 0, FxClose: // xOpen - open a cursor
0, FxFilter:// xClose - close a cursor
0, FxNext:// xFilter - configure scan constraints
0, FxEof:// xNext - advance a cursor
0, FxColumn:// xEof - check for end of scan
0, FxRowid:// xColumn - read data
0, FxUpdate:// xRowid - read data
uintptr(0), FxBegin:// xUpdate
uintptr(0), FxSync:// xBegin
uintptr(0), FxCommit:// xSync
uintptr(0), FxRollback:// xCommit
uintptr(0), FxFindFunction:// xRollback
uintptr(0), FxRename:// xFindMethod
uintptr(0), // xRename
} /* fuzzer.c:1147:23 */

func sqlite3_fuzzer_init(tls *crt.TLS, db uintptr, pzErrMsg uintptr, pApi uintptr) int32 { /* fuzzer.c:1176:5: */
	var rc int32 = 0
	_ = pApi

	rc = sqlite3.Xsqlite3_create_module(tls, db, ts+5119 /* "fuzzer" */, uintptr(unsafe.Pointer(&fuzzerModule)), uintptr(0))
	return rc
}

// Implementation of the ieee754() function
func ieee754func(tls *crt.TLS, context uintptr, argc int32, argv uintptr) { /* ieee754.c:42:13: */
	bp := tls.Alloc(152)
	defer tls.Free(152)

	if argc == 1 {
		var m sqlite3_int64
		// var a sqlite3_int64 at bp+16, 8

		// var r float64 at bp+24, 8

		var e int32
		var isNeg int32
		// var zResult [100]int8 at bp+32, 100

		if !(uint64(unsafe.Sizeof(m)) == uint64(unsafe.Sizeof(float64(0)))) {
			crt.X__assert_fail(tls, ts+5126 /* "sizeof(m)==sizeo..." */, ts+5147 /* "testdata/sqlite-..." */, uint32(53), uintptr(unsafe.Pointer(&__func__25)))
		}
		if sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8))) != 2 {
			return
		}
		*(*float64)(unsafe.Pointer(bp + 24 /* r */)) = sqlite3.Xsqlite3_value_double(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)))
		if *(*float64)(unsafe.Pointer(bp + 24 /* r */)) < 0.0 {
			isNeg = 1
			*(*float64)(unsafe.Pointer(bp + 24 /* r */)) = -*(*float64)(unsafe.Pointer(bp + 24 /* r */))
		} else {
			isNeg = 0
		}
		crt.Xmemcpy(tls, bp+16 /* &a */, bp+24 /* &r */, uint64(unsafe.Sizeof(sqlite3_int64(0))))
		if *(*sqlite3_int64)(unsafe.Pointer(bp + 16 /* a */)) == int64(0) {
			e = 0
			m = int64(0)
		} else {
			e = (int32(*(*sqlite3_int64)(unsafe.Pointer(bp + 16 /* a */)) >> 52))
			m = (*(*sqlite3_int64)(unsafe.Pointer(bp + 16 /* a */)) & ((sqlite3_int64((int64(1))) << 52) - int64(1)))
			m = m | (sqlite3_int64((int64(1))) << 52)
			for ((e < 1075) && (m > int64(0))) && ((m & int64(1)) == int64(0)) {
				m >>= 1
				e++
			}
			if isNeg != 0 {
				m = -m
			}
		}
		sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([100]int8{})), bp+32 /* &zResult[0] */, ts+5194, /* "ieee754(%lld,%d)" */
			crt.VaList(bp, m, (e-1075)))
		sqlite3.Xsqlite3_result_text(tls, context, bp+32 /* &zResult[0] */, -1, crt.UintptrFromInt32(-1))
	} else if argc == 2 {
		var m sqlite3_int64
		var e sqlite3_int64
		// var a sqlite3_int64 at bp+144, 8

		// var r float64 at bp+136, 8

		var isNeg int32 = 0
		m = sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)))
		e = sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)))
		if m < int64(0) {
			isNeg = 1
			m = -m
			if m < int64(0) {
				return
			}
		} else if ((m == int64(0)) && (e > int64(1000))) && (e < int64(1000)) {
			sqlite3.Xsqlite3_result_double(tls, context, 0.0)
			return
		}
		for ((m >> 32) & int64(0xffe00000)) != 0 {
			m >>= 1
			e++
		}
		for (m != int64(0)) && (((m >> 32) & int64(0xfff00000)) == int64(0)) {
			m <<= 1
			e--
		}
		e = e + (int64(1075))
		if e < int64(0) {
			e = crt.AssignInt64(&m, int64(0))
		}
		if e > int64(0x7ff) {
			e = int64(0x7ff)
		}
		*(*sqlite3_int64)(unsafe.Pointer(bp + 144 /* a */)) = (m & ((sqlite3_int64((int64(1))) << 52) - int64(1)))
		*(*sqlite3_int64)(unsafe.Pointer(bp + 144 /* a */)) |= (e << 52)
		if isNeg != 0 {
			*(*sqlite3_int64)(unsafe.Pointer(bp + 144 /* a */)) |= crt.Int64FromUint64((sqlite3_uint64((uint64(1))) << 63))
		}
		crt.Xmemcpy(tls, bp+136 /* &r */, bp+144 /* &a */, uint64(unsafe.Sizeof(float64(0))))
		sqlite3.Xsqlite3_result_double(tls, context, *(*float64)(unsafe.Pointer(bp + 136 /* r */)))
	}
}

var __func__25 = *(*[12]int8)(unsafe.Pointer(ts + 5211 /* "ieee754func" */)) /* ieee754.c:46:2 */

func sqlite3_ieee_init(tls *crt.TLS, db uintptr, pzErrMsg uintptr, pApi uintptr) int32 { /* ieee754.c:116:5: */
	var rc int32 = 0
	_ = pApi

	_ = pzErrMsg // Unused parameter
	rc = sqlite3.Xsqlite3_create_function(tls, db, ts+5223 /* "ieee754" */, 1,
		(1 | 0x000200000), uintptr(0),
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*crt.TLS, uintptr, int32, uintptr)
		}{ieee754func})), uintptr(0), uintptr(0))
	if rc == 0 {
		rc = sqlite3.Xsqlite3_create_function(tls, db, ts+5223 /* "ieee754" */, 2,
			(1 | 0x000200000), uintptr(0),
			*(*uintptr)(unsafe.Pointer(&struct {
				f func(*crt.TLS, uintptr, int32, uintptr)
			}{ieee754func})), uintptr(0), uintptr(0))
	}
	return rc
}

//
// END OF REGISTRATION API
//

//******* End of fts5.h ********

// This function is used to touch each page of a mapping of a memory
// mapped SQLite database. Assuming that the system has sufficient free
// memory and supports sufficiently large mappings, this causes the OS
// to cache the entire database in main memory, making subsequent
// database accesses faster.
//
// If the second parameter to this function is not NULL, it is the name of
// the specific database to operate on (i.e. "main" or the name of an
// attached database).
//
// SQLITE_OK is returned if successful, or an SQLite error code otherwise.
// It is not considered an error if the file is not memory-mapped, or if
// the mapping does not span the entire file. If an error does occur, a
// transaction may be left open on the database file.
//
// It is illegal to call this function when the database handle has an
// open transaction. SQLITE_MISUSE is returned in this case.
func sqlite3_mmap_warm(tls *crt.TLS, db uintptr, zDb uintptr) int32 { /* mmapwarm.c:37:5: */
	bp := tls.Alloc(88)
	defer tls.Free(88)

	var rc int32 = 0
	var zSql uintptr = uintptr(0)
	var pgsz int32 = 0
	var nTotal int32 = 0

	if 0 == sqlite3.Xsqlite3_get_autocommit(tls, db) {
		return 21
	}

	// Open a read-only transaction on the file in question
	zSql = sqlite3.Xsqlite3_mprintf(tls, ts+5231, /* "BEGIN; SELECT * ..." */
		crt.VaList(bp, func() uintptr {
			if zDb != 0 {
				return ts + 5272 /* "'" */
			}
			return ts + 792 /* "" */
		}(), func() uintptr {
			if zDb != 0 {
				return zDb
			}
			return ts + 792 /* "" */
		}(), func() uintptr {
			if zDb != 0 {
				return ts + 5274 /* "'." */
			}
			return ts + 792 /* "" */
		}()))
	if zSql == uintptr(0) {
		return 7
	}
	rc = sqlite3.Xsqlite3_exec(tls, db, zSql, uintptr(0), uintptr(0), uintptr(0))
	sqlite3.Xsqlite3_free(tls, zSql)

	// Find the SQLite page size of the file
	if rc == 0 {
		zSql = sqlite3.Xsqlite3_mprintf(tls, ts+5277, /* "PRAGMA %s%q%spag..." */
			crt.VaList(bp+24, func() uintptr {
				if zDb != 0 {
					return ts + 5272 /* "'" */
				}
				return ts + 792 /* "" */
			}(), func() uintptr {
				if zDb != 0 {
					return zDb
				}
				return ts + 792 /* "" */
			}(), func() uintptr {
				if zDb != 0 {
					return ts + 5274 /* "'." */
				}
				return ts + 792 /* "" */
			}()))
		if zSql == uintptr(0) {
			rc = 7
		} else {
			*(*uintptr)(unsafe.Pointer(bp + 64 /* pPgsz */)) = uintptr(0)
			rc = sqlite3.Xsqlite3_prepare_v2(tls, db, zSql, -1, bp+64 /* &pPgsz */, uintptr(0))
			sqlite3.Xsqlite3_free(tls, zSql)
			if rc == 0 {
				if sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 64 /* pPgsz */))) == 100 {
					pgsz = sqlite3.Xsqlite3_column_int(tls, *(*uintptr)(unsafe.Pointer(bp + 64 /* pPgsz */)), 0)
				}
				rc = sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 64 /* pPgsz */)))
			}
			if (rc == 0) && (pgsz == 0) {
				rc = 1
			}
		}
	}

	// Touch each mmap'd page of the file
	if rc == 0 {
		var rc2 int32
		*(*uintptr)(unsafe.Pointer(bp + 72 /* pFd */)) = uintptr(0)
		rc = sqlite3.Xsqlite3_file_control(tls, db, zDb, 7, bp+72 /* &pFd */)
		if (rc == 0) && ((*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 72 /* pFd */)))).FpMethods)).FiVersion >= 3) {
			var iPg sqlite3_int64 = int64(1)
			var p uintptr = (*sqlite3_file)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 72 /* pFd */)))).FpMethods
			for 1 != 0 {
				// var pMap uintptr at bp+80, 8

				rc = (*(*func(*crt.TLS, uintptr, sqlite3_int64, int32, uintptr) int32)(unsafe.Pointer((p + 136 /* &.xFetch */))))(tls, *(*uintptr)(unsafe.Pointer(bp + 72 /* pFd */)), (sqlite3_int64(pgsz) * iPg), pgsz, bp+80 /* &pMap */)
				if (rc != 0) || (*(*uintptr)(unsafe.Pointer(bp + 80 /* pMap */)) == uintptr(0)) {
					break
				}

				nTotal = nTotal + (int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 80 /* pMap */)) + uintptr(0)))))
				nTotal = nTotal + (int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 80 /* pMap */)) + uintptr((pgsz - 1))))))

				rc = (*(*func(*crt.TLS, uintptr, sqlite3_int64, uintptr) int32)(unsafe.Pointer((p + 144 /* &.xUnfetch */))))(tls, *(*uintptr)(unsafe.Pointer(bp + 72 /* pFd */)), (sqlite3_int64(pgsz) * iPg), *(*uintptr)(unsafe.Pointer(bp + 80 /* pMap */)))
				if rc != 0 {
					break
				}
				iPg++
			}
			sqlite3.Xsqlite3_log(tls, 0,
				ts+5300 /* "sqlite3_mmap_war..." */, crt.VaList(bp+48, func() int64 {
					if iPg == int64(1) {
						return int64(0)
					}
					return iPg
				}(),
					sqlite3.Xsqlite3_db_filename(tls, db, zDb)))
		}

		rc2 = sqlite3.Xsqlite3_exec(tls, db, ts+5350 /* "END" */, uintptr(0), uintptr(0), uintptr(0))
		if rc == 0 {
			rc = rc2
		}
	}

	return rc
}

// A structure to hold context of the next_char() computation across
// nested function calls.
type nextCharContext1 = struct {
	Fdb           uintptr
	FpStmt        uintptr
	FzPrefix      uintptr
	FnPrefix      int32
	FnAlloc       int32
	FnUsed        int32
	FaResult      uintptr
	FmallocFailed int32
	FotherError   int32
}

// A structure to hold context of the next_char() computation across
// nested function calls.
type nextCharContext = nextCharContext1 /* nextchar.c:63:32 */

// Append a result character if the character is not already in the
// result.
func nextCharAppend(tls *crt.TLS, p uintptr, c uint32) { /* nextchar.c:80:13: */
	var i int32
	for i = 0; i < (*nextCharContext)(unsafe.Pointer(p)).FnUsed; i++ {
		if *(*uint32)(unsafe.Pointer((*nextCharContext)(unsafe.Pointer(p)).FaResult + uintptr(i)*4)) == c {
			return
		}
	}
	if ((*nextCharContext)(unsafe.Pointer(p)).FnUsed + 1) > (*nextCharContext)(unsafe.Pointer(p)).FnAlloc {
		var aNew uintptr
		var n int32 = (((*nextCharContext)(unsafe.Pointer(p)).FnAlloc * 2) + 30)
		aNew = sqlite3.Xsqlite3_realloc64(tls, (*nextCharContext)(unsafe.Pointer(p)).FaResult, (uint64(uint64(n) * uint64(unsafe.Sizeof(uint32(0))))))
		if aNew == uintptr(0) {
			(*nextCharContext)(unsafe.Pointer(p)).FmallocFailed = 1
			return
		} else {
			(*nextCharContext)(unsafe.Pointer(p)).FaResult = aNew
			(*nextCharContext)(unsafe.Pointer(p)).FnAlloc = n
		}
	}
	*(*uint32)(unsafe.Pointer((*nextCharContext)(unsafe.Pointer(p)).FaResult + uintptr(crt.PostIncInt32(&(*nextCharContext)(unsafe.Pointer(p)).FnUsed, 1))*4)) = c
}

// Write a character into z[] as UTF8.  Return the number of bytes needed
// to hold the character
func writeUtf8(tls *crt.TLS, z uintptr, c uint32) int32 { /* nextchar.c:104:12: */
	if c < uint32(0x00080) {
		*(*uint8)(unsafe.Pointer(z + uintptr(0))) = (uint8(c & uint32(0xff)))
		return 1
	}
	if c < uint32(0x00800) {
		*(*uint8)(unsafe.Pointer(z + uintptr(0))) = (uint8(0xC0 + int32((uint8((c >> 6) & uint32(0x1F))))))
		*(*uint8)(unsafe.Pointer(z + uintptr(1))) = (uint8(0x80 + int32((uint8(c & uint32(0x3F))))))
		return 2
	}
	if c < uint32(0x10000) {
		*(*uint8)(unsafe.Pointer(z + uintptr(0))) = (uint8(0xE0 + int32((uint8((c >> 12) & uint32(0x0F))))))
		*(*uint8)(unsafe.Pointer(z + uintptr(1))) = (uint8(0x80 + int32((uint8((c >> 6) & uint32(0x3F))))))
		*(*uint8)(unsafe.Pointer(z + uintptr(2))) = (uint8(0x80 + int32((uint8(c & uint32(0x3F))))))
		return 3
	}
	*(*uint8)(unsafe.Pointer(z + uintptr(0))) = (uint8(0xF0 + int32((uint8((c >> 18) & uint32(0x07))))))
	*(*uint8)(unsafe.Pointer(z + uintptr(1))) = (uint8(0x80 + int32((uint8((c >> 12) & uint32(0x3F))))))
	*(*uint8)(unsafe.Pointer(z + uintptr(2))) = (uint8(0x80 + int32((uint8((c >> 6) & uint32(0x3F))))))
	*(*uint8)(unsafe.Pointer(z + uintptr(3))) = (uint8(0x80 + int32((uint8(c & uint32(0x3F))))))
	return 4
}

// Read a UTF8 character out of z[] and write it into *pOut.  Return
// the number of bytes in z[] that were used to construct the character.
func readUtf8(tls *crt.TLS, z uintptr, pOut uintptr) int32 { /* nextchar.c:131:12: */
	var c uint32 = uint32(*(*uint8)(unsafe.Pointer(z + uintptr(0))))
	if c < uint32(0xc0) {
		*(*uint32)(unsafe.Pointer(pOut)) = c
		return 1
	} else {
		var n int32 = 1
		c = uint32(validBits[(c - uint32(0xc0))])
		for (int32(*(*uint8)(unsafe.Pointer(z + uintptr(n)))) & 0xc0) == 0x80 {
			c = ((c << 6) + (uint32(0x3f & int32(*(*uint8)(unsafe.Pointer(z + uintptr(crt.PostIncInt32(&n, 1))))))))
		}
		if ((c < uint32(0x80)) || ((c & 0xFFFFF800) == uint32(0xD800))) || ((c & 0xFFFFFFFE) == uint32(0xFFFE)) {
			c = uint32(0xFFFD)
		}
		*(*uint32)(unsafe.Pointer(pOut)) = c
		return n
	}
	return int32(0)
}

var validBits = [64]uint8{
	uint8(0x00), uint8(0x01), uint8(0x02), uint8(0x03), uint8(0x04), uint8(0x05), uint8(0x06), uint8(0x07),
	uint8(0x08), uint8(0x09), uint8(0x0a), uint8(0x0b), uint8(0x0c), uint8(0x0d), uint8(0x0e), uint8(0x0f),
	uint8(0x10), uint8(0x11), uint8(0x12), uint8(0x13), uint8(0x14), uint8(0x15), uint8(0x16), uint8(0x17),
	uint8(0x18), uint8(0x19), uint8(0x1a), uint8(0x1b), uint8(0x1c), uint8(0x1d), uint8(0x1e), uint8(0x1f),
	uint8(0x00), uint8(0x01), uint8(0x02), uint8(0x03), uint8(0x04), uint8(0x05), uint8(0x06), uint8(0x07),
	uint8(0x08), uint8(0x09), uint8(0x0a), uint8(0x0b), uint8(0x0c), uint8(0x0d), uint8(0x0e), uint8(0x0f),
	uint8(0x00), uint8(0x01), uint8(0x02), uint8(0x03), uint8(0x04), uint8(0x05), uint8(0x06), uint8(0x07),
	uint8(0x00), uint8(0x01), uint8(0x02), uint8(0x03), uint8(0x00), uint8(0x01), uint8(0x00), uint8(0x00),
} /* nextchar.c:132:30 */

// The nextCharContext structure has been set up.  Add all "next" characters
// to the result set.
func findNextChars(tls *crt.TLS, p uintptr) { /* nextchar.c:164:13: */
	bp := tls.Alloc(12)
	defer tls.Free(12)

	var cPrev uint32 = uint32(0)
	// var zPrev [8]uint8 at bp, 8

	var n int32
	var rc int32

	for {
		sqlite3.Xsqlite3_bind_text(tls, (*nextCharContext)(unsafe.Pointer(p)).FpStmt, 1, (*nextCharContext)(unsafe.Pointer(p)).FzPrefix, (*nextCharContext)(unsafe.Pointer(p)).FnPrefix,
			uintptr(0))
		n = writeUtf8(tls, bp /* &zPrev[0] */, (cPrev + uint32(1)))
		sqlite3.Xsqlite3_bind_text(tls, (*nextCharContext)(unsafe.Pointer(p)).FpStmt, 2, bp /* zPrev */, n, uintptr(0))
		rc = sqlite3.Xsqlite3_step(tls, (*nextCharContext)(unsafe.Pointer(p)).FpStmt)
		if rc == 101 {
			sqlite3.Xsqlite3_reset(tls, (*nextCharContext)(unsafe.Pointer(p)).FpStmt)
			return
		} else if rc != 100 {
			(*nextCharContext)(unsafe.Pointer(p)).FotherError = rc
			return
		} else {
			var zOut uintptr = sqlite3.Xsqlite3_column_text(tls, (*nextCharContext)(unsafe.Pointer(p)).FpStmt, 0)
			// var cNext uint32 at bp+8, 4

			n = readUtf8(tls, (zOut + uintptr((*nextCharContext)(unsafe.Pointer(p)).FnPrefix)), bp+8 /* &cNext */)
			sqlite3.Xsqlite3_reset(tls, (*nextCharContext)(unsafe.Pointer(p)).FpStmt)
			nextCharAppend(tls, p, *(*uint32)(unsafe.Pointer(bp + 8 /* cNext */)))
			cPrev = *(*uint32)(unsafe.Pointer(bp + 8 /* cNext */))
			if (*nextCharContext)(unsafe.Pointer(p)).FmallocFailed != 0 {
				return
			}
		}
	}
}

// next_character(A,T,F,W)
//
// Return a string composted of all next possible characters after
// A for elements of T.F.  If W is supplied, then it is an SQL expression
// that limits the elements in T.F that are considered.
func nextCharFunc(tls *crt.TLS, context uintptr, argc int32, argv uintptr) { /* nextchar.c:201:13: */
	bp := tls.Alloc(136)
	defer tls.Free(136)

	// var c nextCharContext at bp+80, 56

	var zTable uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)))
	var zField uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8)))
	var zWhere uintptr
	var zCollName uintptr
	var zWhereClause uintptr = uintptr(0)
	var zColl uintptr = uintptr(0)
	var zSql uintptr
	var rc int32

	crt.Xmemset(tls, bp+80 /* &c */, 0, uint64(unsafe.Sizeof(nextCharContext{})))
	(*nextCharContext)(unsafe.Pointer(bp + 80 /* &c */)).Fdb = sqlite3.Xsqlite3_context_db_handle(tls, context)
	(*nextCharContext)(unsafe.Pointer(bp + 80 /* &c */)).FzPrefix = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)))
	(*nextCharContext)(unsafe.Pointer(bp + 80 /* &c */)).FnPrefix = sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)))
	if ((zTable == uintptr(0)) || (zField == uintptr(0))) || ((*nextCharContext)(unsafe.Pointer(bp+80 /* &c */)).FzPrefix == uintptr(0)) {
		return
	}
	if ((argc >= 4) &&
		((crt.AssignUintptr(&zWhere, sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(3)*8))))) != uintptr(0))) &&
		(int32(*(*uint8)(unsafe.Pointer(zWhere + uintptr(0)))) != 0) {
		zWhereClause = sqlite3.Xsqlite3_mprintf(tls, ts+5354 /* "AND (%s)" */, crt.VaList(bp, zWhere))
		if zWhereClause == uintptr(0) {
			sqlite3.Xsqlite3_result_error_nomem(tls, context)
			return
		}
	} else {
		zWhereClause = ts + 792 /* "" */
	}
	if ((argc >= 5) &&
		((crt.AssignUintptr(&zCollName, sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(4)*8))))) != uintptr(0))) &&
		(int32(*(*uint8)(unsafe.Pointer(zCollName + uintptr(0)))) != 0) {
		zColl = sqlite3.Xsqlite3_mprintf(tls, ts+5363 /* "collate \"%w\"" */, crt.VaList(bp+8, zCollName))
		if zColl == uintptr(0) {
			sqlite3.Xsqlite3_result_error_nomem(tls, context)
			if *(*int8)(unsafe.Pointer(zWhereClause + uintptr(0))) != 0 {
				sqlite3.Xsqlite3_free(tls, zWhereClause)
			}
			return
		}
	} else {
		zColl = ts + 792 /* "" */
	}
	zSql = sqlite3.Xsqlite3_mprintf(tls,

		// 1114111 == 0x10ffff

		ts+5376, /* "SELECT %s FROM %..." */
		crt.VaList(bp+16, zField, zTable, zField, zColl, zField, zColl, zWhereClause, zColl))
	if *(*int8)(unsafe.Pointer(zWhereClause + uintptr(0))) != 0 {
		sqlite3.Xsqlite3_free(tls, zWhereClause)
	}
	if *(*int8)(unsafe.Pointer(zColl + uintptr(0))) != 0 {
		sqlite3.Xsqlite3_free(tls, zColl)
	}
	if zSql == uintptr(0) {
		sqlite3.Xsqlite3_result_error_nomem(tls, context)
		return
	}

	rc = sqlite3.Xsqlite3_prepare_v2(tls, (*nextCharContext)(unsafe.Pointer(bp+80 /* &c */)).Fdb, zSql, -1, (bp + 80 /* &c */ + 8 /* &.pStmt */), uintptr(0))
	sqlite3.Xsqlite3_free(tls, zSql)
	if rc != 0 {
		sqlite3.Xsqlite3_result_error(tls, context, sqlite3.Xsqlite3_errmsg(tls, (*nextCharContext)(unsafe.Pointer(bp+80 /* &c */)).Fdb), -1)
		return
	}
	findNextChars(tls, bp+80 /* &c */)
	if (*nextCharContext)(unsafe.Pointer(bp+80 /* &c */)).FmallocFailed != 0 {
		sqlite3.Xsqlite3_result_error_nomem(tls, context)
	} else {
		var pRes uintptr
		pRes = sqlite3.Xsqlite3_malloc64(tls, (uint64(((*nextCharContext)(unsafe.Pointer(bp+80 /* &c */)).FnUsed * 4) + 1)))
		if pRes == uintptr(0) {
			sqlite3.Xsqlite3_result_error_nomem(tls, context)
		} else {
			var i int32
			var n int32 = 0
			for i = 0; i < (*nextCharContext)(unsafe.Pointer(bp+80 /* &c */)).FnUsed; i++ {
				n = n + (writeUtf8(tls, (pRes + uintptr(n)), *(*uint32)(unsafe.Pointer((*nextCharContext)(unsafe.Pointer(bp+80 /* &c */)).FaResult + uintptr(i)*4))))
			}
			*(*uint8)(unsafe.Pointer(pRes + uintptr(n))) = uint8(0)
			sqlite3.Xsqlite3_result_text(tls, context, pRes, n, *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, uintptr) }{sqlite3.Xsqlite3_free})))
		}
	}
	sqlite3.Xsqlite3_finalize(tls, (*nextCharContext)(unsafe.Pointer(bp+80 /* &c */)).FpStmt)
	sqlite3.Xsqlite3_free(tls, (*nextCharContext)(unsafe.Pointer(bp+80 /* &c */)).FaResult)
}

func sqlite3_nextchar_init(tls *crt.TLS, db uintptr, pzErrMsg uintptr, pApi uintptr) int32 { /* nextchar.c:292:5: */
	var rc int32 = 0
	_ = pApi

	_ = pzErrMsg // Unused parameter
	rc = sqlite3.Xsqlite3_create_function(tls, db, ts+5484 /* "next_char" */, 3,
		(1 | 0x000200000), uintptr(0),
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*crt.TLS, uintptr, int32, uintptr)
		}{nextCharFunc})), uintptr(0), uintptr(0))
	if rc == 0 {
		rc = sqlite3.Xsqlite3_create_function(tls, db, ts+5484 /* "next_char" */, 4,
			(1 | 0x000200000), uintptr(0),
			*(*uintptr)(unsafe.Pointer(&struct {
				f func(*crt.TLS, uintptr, int32, uintptr)
			}{nextCharFunc})), uintptr(0), uintptr(0))
	}
	if rc == 0 {
		rc = sqlite3.Xsqlite3_create_function(tls, db, ts+5484 /* "next_char" */, 5,
			(1 | 0x000200000), uintptr(0),
			*(*uintptr)(unsafe.Pointer(&struct {
				f func(*crt.TLS, uintptr, int32, uintptr)
			}{nextCharFunc})), uintptr(0), uintptr(0))
	}
	return rc
}

// Implementation note:
//
// Much of the tokenizer logic is copied out of the tokenize.c source file
// of SQLite.  That logic could be simplified for this particular application,
// but that would impose a risk of introducing subtle errors.  It is best to
// keep the code as close to the original as possible.
//
// The tokenize code is in sync with the SQLite core as of 2018-01-08.
// Any future changes to the core tokenizer might require corresponding
// adjustments to the tokenizer logic in this module.

// Character classes for tokenizing
//
// In the sqlite3GetToken() function, a switch() on aiClass[c] is implemented
// using a lookup table, whereas a switch() directly on c uses a binary search.
// The lookup table is much faster.  To maximize speed, and to ensure that
// a lookup table is used, all of the classes need to be small integers and
// all of them need to be used within the switch.

var aiClass = [256]uint8{
	//         x0  x1  x2  x3  x4  x5  x6  x7  x8  x9  xa  xb  xc  xd  xe  xf
	/* 0x */ uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(7), uint8(7), uint8(27), uint8(7), uint8(7), uint8(27), uint8(27),
	/* 1x */ uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27),
	/* 2x */ uint8(7), uint8(15), uint8(8), uint8(5), uint8(4), uint8(22), uint8(24), uint8(8), uint8(17), uint8(18), uint8(21), uint8(20), uint8(23), uint8(11), uint8(26), uint8(16),
	/* 3x */ uint8(3), uint8(3), uint8(3), uint8(3), uint8(3), uint8(3), uint8(3), uint8(3), uint8(3), uint8(3), uint8(5), uint8(19), uint8(12), uint8(14), uint8(13), uint8(6),
	/* 4x */ uint8(5), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1),
	/* 5x */ uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(0), uint8(1), uint8(1), uint8(9), uint8(27), uint8(27), uint8(27), uint8(1),
	/* 6x */ uint8(8), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1),
	/* 7x */ uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(0), uint8(1), uint8(1), uint8(27), uint8(10), uint8(27), uint8(25), uint8(27),
	/* 8x */ uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2),
	/* 9x */ uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2),
	/* Ax */ uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2),
	/* Bx */ uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2),
	/* Cx */ uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2),
	/* Dx */ uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2),
	/* Ex */ uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2),
	/* Fx */ uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2),
} /* normalize.c:106:28 */

// An array to map all upper-case characters into their corresponding
// lower-case character.
//
// SQLite only considers US-ASCII (or EBCDIC) characters.  We do not
// handle case conversions for the UTF character set since the tables
// involved are nearly as big or bigger than SQLite itself.
var sqlite3UpperToLower = [256]uint8{
	uint8(0), uint8(1), uint8(2), uint8(3), uint8(4), uint8(5), uint8(6), uint8(7), uint8(8), uint8(9), uint8(10), uint8(11), uint8(12), uint8(13), uint8(14), uint8(15), uint8(16), uint8(17),
	uint8(18), uint8(19), uint8(20), uint8(21), uint8(22), uint8(23), uint8(24), uint8(25), uint8(26), uint8(27), uint8(28), uint8(29), uint8(30), uint8(31), uint8(32), uint8(33), uint8(34), uint8(35),
	uint8(36), uint8(37), uint8(38), uint8(39), uint8(40), uint8(41), uint8(42), uint8(43), uint8(44), uint8(45), uint8(46), uint8(47), uint8(48), uint8(49), uint8(50), uint8(51), uint8(52), uint8(53),
	uint8(54), uint8(55), uint8(56), uint8(57), uint8(58), uint8(59), uint8(60), uint8(61), uint8(62), uint8(63), uint8(64), uint8(97), uint8(98), uint8(99), uint8(100), uint8(101), uint8(102), uint8(103),
	uint8(104), uint8(105), uint8(106), uint8(107), uint8(108), uint8(109), uint8(110), uint8(111), uint8(112), uint8(113), uint8(114), uint8(115), uint8(116), uint8(117), uint8(118), uint8(119), uint8(120), uint8(121),
	uint8(122), uint8(91), uint8(92), uint8(93), uint8(94), uint8(95), uint8(96), uint8(97), uint8(98), uint8(99), uint8(100), uint8(101), uint8(102), uint8(103), uint8(104), uint8(105), uint8(106), uint8(107),
	uint8(108), uint8(109), uint8(110), uint8(111), uint8(112), uint8(113), uint8(114), uint8(115), uint8(116), uint8(117), uint8(118), uint8(119), uint8(120), uint8(121), uint8(122), uint8(123), uint8(124), uint8(125),
	uint8(126), uint8(127), uint8(128), uint8(129), uint8(130), uint8(131), uint8(132), uint8(133), uint8(134), uint8(135), uint8(136), uint8(137), uint8(138), uint8(139), uint8(140), uint8(141), uint8(142), uint8(143),
	uint8(144), uint8(145), uint8(146), uint8(147), uint8(148), uint8(149), uint8(150), uint8(151), uint8(152), uint8(153), uint8(154), uint8(155), uint8(156), uint8(157), uint8(158), uint8(159), uint8(160), uint8(161),
	uint8(162), uint8(163), uint8(164), uint8(165), uint8(166), uint8(167), uint8(168), uint8(169), uint8(170), uint8(171), uint8(172), uint8(173), uint8(174), uint8(175), uint8(176), uint8(177), uint8(178), uint8(179),
	uint8(180), uint8(181), uint8(182), uint8(183), uint8(184), uint8(185), uint8(186), uint8(187), uint8(188), uint8(189), uint8(190), uint8(191), uint8(192), uint8(193), uint8(194), uint8(195), uint8(196), uint8(197),
	uint8(198), uint8(199), uint8(200), uint8(201), uint8(202), uint8(203), uint8(204), uint8(205), uint8(206), uint8(207), uint8(208), uint8(209), uint8(210), uint8(211), uint8(212), uint8(213), uint8(214), uint8(215),
	uint8(216), uint8(217), uint8(218), uint8(219), uint8(220), uint8(221), uint8(222), uint8(223), uint8(224), uint8(225), uint8(226), uint8(227), uint8(228), uint8(229), uint8(230), uint8(231), uint8(232), uint8(233),
	uint8(234), uint8(235), uint8(236), uint8(237), uint8(238), uint8(239), uint8(240), uint8(241), uint8(242), uint8(243), uint8(244), uint8(245), uint8(246), uint8(247), uint8(248), uint8(249), uint8(250), uint8(251),
	uint8(252), uint8(253), uint8(254), uint8(255),
} /* normalize.c:133:28 */

// The following 256 byte lookup table is used to support SQLites built-in
// equivalents to the following standard library functions:
//
//   isspace()                        0x01
//   isalpha()                        0x02
//   isdigit()                        0x04
//   isalnum()                        0x06
//   isxdigit()                       0x08
//   toupper()                        0x20
//   SQLite identifier character      0x40
//   Quote character                  0x80
//
// Bit 0x20 is set if the mapped character requires translation to upper
// case. i.e. if the character is a lower-case ASCII character.
// If x is a lower-case ASCII character, then its upper-case equivalent
// is (x - 0x20). Therefore toupper() can be implemented as:
//
//   (x & ~(map[x]&0x20))
//
// The equivalent of tolower() is implemented using the sqlite3UpperToLower[]
// array. tolower() is used more often than toupper() by SQLite.
//
// Bit 0x40 is set if the character is non-alphanumeric and can be used in an
// SQLite identifier.  Identifiers are alphanumerics, "_", "$", and any
// non-ASCII UTF character. Hence the test for whether or not a character is
// part of an identifier is 0x46.
var sqlite3CtypeMap = [256]uint8{
	uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), // 00..07    ........
	uint8(0x00), uint8(0x01), uint8(0x01), uint8(0x01), uint8(0x01), uint8(0x01), uint8(0x00), uint8(0x00), // 08..0f    ........
	uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), // 10..17    ........
	uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), // 18..1f    ........
	uint8(0x01), uint8(0x00), uint8(0x80), uint8(0x00), uint8(0x40), uint8(0x00), uint8(0x00), uint8(0x80), // 20..27     !"#$%&'
	uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), // 28..2f    ()*+,-./
	uint8(0x0c), uint8(0x0c), uint8(0x0c), uint8(0x0c), uint8(0x0c), uint8(0x0c), uint8(0x0c), uint8(0x0c), // 30..37    01234567
	uint8(0x0c), uint8(0x0c), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), // 38..3f    89:;<=>?

	uint8(0x00), uint8(0x0a), uint8(0x0a), uint8(0x0a), uint8(0x0a), uint8(0x0a), uint8(0x0a), uint8(0x02), // 40..47    @ABCDEFG
	uint8(0x02), uint8(0x02), uint8(0x02), uint8(0x02), uint8(0x02), uint8(0x02), uint8(0x02), uint8(0x02), // 48..4f    HIJKLMNO
	uint8(0x02), uint8(0x02), uint8(0x02), uint8(0x02), uint8(0x02), uint8(0x02), uint8(0x02), uint8(0x02), // 50..57    PQRSTUVW
	uint8(0x02), uint8(0x02), uint8(0x02), uint8(0x80), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x40), // 58..5f    XYZ[\]^_
	uint8(0x80), uint8(0x2a), uint8(0x2a), uint8(0x2a), uint8(0x2a), uint8(0x2a), uint8(0x2a), uint8(0x22), // 60..67    `abcdefg
	uint8(0x22), uint8(0x22), uint8(0x22), uint8(0x22), uint8(0x22), uint8(0x22), uint8(0x22), uint8(0x22), // 68..6f    hijklmno
	uint8(0x22), uint8(0x22), uint8(0x22), uint8(0x22), uint8(0x22), uint8(0x22), uint8(0x22), uint8(0x22), // 70..77    pqrstuvw
	uint8(0x22), uint8(0x22), uint8(0x22), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), // 78..7f    xyz{|}~.

	uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), // 80..87    ........
	uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), // 88..8f    ........
	uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), // 90..97    ........
	uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), // 98..9f    ........
	uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), // a0..a7    ........
	uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), // a8..af    ........
	uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), // b0..b7    ........
	uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), // b8..bf    ........

	uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), // c0..c7    ........
	uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), // c8..cf    ........
	uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), // d0..d7    ........
	uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), // d8..df    ........
	uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), // e0..e7    ........
	uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), // e8..ef    ........
	uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), // f0..f7    ........
	uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), // f8..ff    ........
} /* normalize.c:179:28 */

// If X is a character that can be used in an identifier then
// IdChar(X) will be true.  Otherwise it is false.
//
// For ASCII, any character with the high-order bit set is
// allowed in an identifier.  For 7-bit characters,
// sqlite3IsIdChar[X] must be 1.
//
// For EBCDIC, the rules are more complex but have the same
// end result.
//
// Ticket #1066.  the SQL standard does not allow '$' in the
// middle of identifiers.  But many SQL implementations do.
// SQLite will allow '$' in identifiers for compatibility.
// But the feature is undocumented.

// Ignore testcase() macros

// Token values

// Return the length (in bytes) of the token that begins at z[0].
// Store the token type in *tokenType before returning.
func sqlite3GetToken(tls *crt.TLS, z uintptr, tokenType uintptr) int32 { /* normalize.c:293:12: */
	var i int32
	var c int32
	switch int32(aiClass[*(*uint8)(unsafe.Pointer(z))]) { // Switch on the character-class of the first byte
	// of the token. See the comment on the CC_ defines
	// above.
	case 7:
		{
			for i = 1; (int32(sqlite3CtypeMap[*(*uint8)(unsafe.Pointer(z + uintptr(i)))]) & 0x01) != 0; i++ {
			}
			*(*int32)(unsafe.Pointer(tokenType)) = 0
			return i
		}
	case 11:
		{
			if int32(*(*uint8)(unsafe.Pointer(z + uintptr(1)))) == '-' {
				for i = 2; ((crt.AssignInt32(&c, int32(*(*uint8)(unsafe.Pointer(z + uintptr(i)))))) != 0) && (c != '\n'); i++ {
				}
				*(*int32)(unsafe.Pointer(tokenType)) = 0
				return i
			}
			*(*int32)(unsafe.Pointer(tokenType)) = 3
			return 1
		}
	case 17:
		{
			*(*int32)(unsafe.Pointer(tokenType)) = 3
			return 1
		}
	case 18:
		{
			*(*int32)(unsafe.Pointer(tokenType)) = 3
			return 1
		}
	case 19:
		{
			*(*int32)(unsafe.Pointer(tokenType)) = 3
			return 1
		}
	case 20:
		{
			*(*int32)(unsafe.Pointer(tokenType)) = 3
			return 1
		}
	case 21:
		{
			*(*int32)(unsafe.Pointer(tokenType)) = 3
			return 1
		}
	case 16:
		{
			if (int32(*(*uint8)(unsafe.Pointer(z + uintptr(1)))) != '*') || (int32(*(*uint8)(unsafe.Pointer(z + uintptr(2)))) == 0) {
				*(*int32)(unsafe.Pointer(tokenType)) = 3
				return 1
			}
			i = 3
			c = int32(*(*uint8)(unsafe.Pointer(z + uintptr(2))))
			for ; ((c != '*') || (int32(*(*uint8)(unsafe.Pointer(z + uintptr(i)))) != '/')) && ((crt.AssignInt32(&c, int32(*(*uint8)(unsafe.Pointer(z + uintptr(i)))))) != 0); i++ {
			}
			if c != 0 {
				i++
			}
			*(*int32)(unsafe.Pointer(tokenType)) = 0
			return i
		}
	case 22:
		{
			*(*int32)(unsafe.Pointer(tokenType)) = 3
			return 1
		}
	case 14:
		{
			*(*int32)(unsafe.Pointer(tokenType)) = 3
			return (1 + (crt.Bool32(int32(*(*uint8)(unsafe.Pointer(z + uintptr(1)))) == '=')))
		}
	case 12:
		{
			if (crt.AssignInt32(&c, int32(*(*uint8)(unsafe.Pointer(z + uintptr(1)))))) == '=' {
				*(*int32)(unsafe.Pointer(tokenType)) = 3
				return 2
			} else if c == '>' {
				*(*int32)(unsafe.Pointer(tokenType)) = 3
				return 2
			} else if c == '<' {
				*(*int32)(unsafe.Pointer(tokenType)) = 3
				return 2
			} else {
				*(*int32)(unsafe.Pointer(tokenType)) = 3
				return 1
			}
		}
		fallthrough
	case 13:
		{
			if (crt.AssignInt32(&c, int32(*(*uint8)(unsafe.Pointer(z + uintptr(1)))))) == '=' {
				*(*int32)(unsafe.Pointer(tokenType)) = 3
				return 2
			} else if c == '>' {
				*(*int32)(unsafe.Pointer(tokenType)) = 3
				return 2
			} else {
				*(*int32)(unsafe.Pointer(tokenType)) = 3
				return 1
			}
		}
		fallthrough
	case 15:
		{
			if int32(*(*uint8)(unsafe.Pointer(z + uintptr(1)))) != '=' {
				*(*int32)(unsafe.Pointer(tokenType)) = 4
				return 1
			} else {
				*(*int32)(unsafe.Pointer(tokenType)) = 3
				return 2
			}
		}
		fallthrough
	case 10:
		{
			if int32(*(*uint8)(unsafe.Pointer(z + uintptr(1)))) != '|' {
				*(*int32)(unsafe.Pointer(tokenType)) = 3
				return 1
			} else {
				*(*int32)(unsafe.Pointer(tokenType)) = 3
				return 2
			}
		}
		fallthrough
	case 23:
		{
			*(*int32)(unsafe.Pointer(tokenType)) = 3
			return 1
		}
	case 24:
		{
			*(*int32)(unsafe.Pointer(tokenType)) = 3
			return 1
		}
	case 25:
		{
			*(*int32)(unsafe.Pointer(tokenType)) = 3
			return 1
		}
	case 8:
		{
			var delim int32 = int32(*(*uint8)(unsafe.Pointer(z + uintptr(0))))

			for i = 1; (crt.AssignInt32(&c, int32(*(*uint8)(unsafe.Pointer(z + uintptr(i)))))) != 0; i++ {
				if c == delim {
					if int32(*(*uint8)(unsafe.Pointer(z + uintptr((i + 1))))) == delim {
						i++
					} else {
						break
					}
				}
			}
			if c == '\'' {
				*(*int32)(unsafe.Pointer(tokenType)) = 2
				return (i + 1)
			} else if c != 0 {
				*(*int32)(unsafe.Pointer(tokenType)) = 1
				return (i + 1)
			} else {
				*(*int32)(unsafe.Pointer(tokenType)) = 4
				return i
			}
		}
		fallthrough
	case 26:
		{
			if !((int32(sqlite3CtypeMap[*(*uint8)(unsafe.Pointer(z + uintptr(1)))]) & 0x04) != 0) {
				*(*int32)(unsafe.Pointer(tokenType)) = 3
				return 1
			}
			// If the next character is a digit, this is a floating point
			// number that begins with ".".  Fall thru into the next case
		}
		fallthrough
	case 3:
		{
			*(*int32)(unsafe.Pointer(tokenType)) = 2
			if ((int32(*(*uint8)(unsafe.Pointer(z + uintptr(0)))) == '0') && ((int32(*(*uint8)(unsafe.Pointer(z + uintptr(1)))) == 'x') || (int32(*(*uint8)(unsafe.Pointer(z + uintptr(1)))) == 'X'))) && ((int32(sqlite3CtypeMap[*(*uint8)(unsafe.Pointer(z + uintptr(2)))]) & 0x08) != 0) {
				for i = 3; (int32(sqlite3CtypeMap[*(*uint8)(unsafe.Pointer(z + uintptr(i)))]) & 0x08) != 0; i++ {
				}
				return i
			}
			for i = 0; (int32(sqlite3CtypeMap[*(*uint8)(unsafe.Pointer(z + uintptr(i)))]) & 0x04) != 0; i++ {
			}
			if int32(*(*uint8)(unsafe.Pointer(z + uintptr(i)))) == '.' {
				i++
				for (int32(sqlite3CtypeMap[*(*uint8)(unsafe.Pointer(z + uintptr(i)))]) & 0x04) != 0 {
					i++
				}
				*(*int32)(unsafe.Pointer(tokenType)) = 2
			}
			if ((int32(*(*uint8)(unsafe.Pointer(z + uintptr(i)))) == 'e') || (int32(*(*uint8)(unsafe.Pointer(z + uintptr(i)))) == 'E')) && (((int32(sqlite3CtypeMap[*(*uint8)(unsafe.Pointer(z + uintptr((i + 1))))]) & 0x04) != 0) ||
				(((int32(*(*uint8)(unsafe.Pointer(z + uintptr((i + 1))))) == '+') || (int32(*(*uint8)(unsafe.Pointer(z + uintptr((i + 1))))) == '-')) && ((int32(sqlite3CtypeMap[*(*uint8)(unsafe.Pointer(z + uintptr((i + 2))))]) & 0x04) != 0))) {
				i = i + (2)
				for (int32(sqlite3CtypeMap[*(*uint8)(unsafe.Pointer(z + uintptr(i)))]) & 0x04) != 0 {
					i++
				}
				*(*int32)(unsafe.Pointer(tokenType)) = 2
			}
			for (int32(sqlite3CtypeMap[*(*uint8)(unsafe.Pointer(z + uintptr(i)))]) & 0x46) != 0 {
				*(*int32)(unsafe.Pointer(tokenType)) = 4
				i++
			}
			return i
		}
	case 9:
		{
			i = 1
			c = int32(*(*uint8)(unsafe.Pointer(z + uintptr(0))))
			for ; (c != ']') && ((crt.AssignInt32(&c, int32(*(*uint8)(unsafe.Pointer(z + uintptr(i)))))) != 0); i++ {
			}
			*(*int32)(unsafe.Pointer(tokenType)) = func() int32 {
				if c == ']' {
					return 1
				}
				return 4
			}()
			return i
		}
	case 6:
		{
			*(*int32)(unsafe.Pointer(tokenType)) = 2
			for i = 1; (int32(sqlite3CtypeMap[*(*uint8)(unsafe.Pointer(z + uintptr(i)))]) & 0x04) != 0; i++ {
			}
			return i
		}
	case 4:
		fallthrough
	case 5:
		{
			var n int32 = 0

			*(*int32)(unsafe.Pointer(tokenType)) = 2
			for i = 1; (crt.AssignInt32(&c, int32(*(*uint8)(unsafe.Pointer(z + uintptr(i)))))) != 0; i++ {
				if (int32(sqlite3CtypeMap[uint8(c)]) & 0x46) != 0 {
					n++
				} else if (c == '(') && (n > 0) {
					for ok := true; ok; ok = ((((crt.AssignInt32(&c, int32(*(*uint8)(unsafe.Pointer(z + uintptr(i)))))) != 0) && !((int32(sqlite3CtypeMap[uint8(c)]) & 0x01) != 0)) && (c != ')')) {
						i++
					}
					if c == ')' {
						i++
					} else {
						*(*int32)(unsafe.Pointer(tokenType)) = 4
					}
					break
				} else if (c == ':') && (int32(*(*uint8)(unsafe.Pointer(z + uintptr((i + 1))))) == ':') {
					i++
				} else {
					break
				}
			}
			if n == 0 {
				*(*int32)(unsafe.Pointer(tokenType)) = 4
			}
			return i
		}
	case 1:
		{
			for i = 1; int32(aiClass[*(*uint8)(unsafe.Pointer(z + uintptr(i)))]) <= 1; i++ {
			}
			if (int32(sqlite3CtypeMap[*(*uint8)(unsafe.Pointer(z + uintptr(i)))]) & 0x46) != 0 {
				// This token started out using characters that can appear in keywords,
				// but z[i] is a character not allowed within keywords, so this must
				// be an identifier instead
				i++
				break
			}
			*(*int32)(unsafe.Pointer(tokenType)) = 1
			return i
		}
	case 0:
		{

			if int32(*(*uint8)(unsafe.Pointer(z + uintptr(1)))) == '\'' {
				*(*int32)(unsafe.Pointer(tokenType)) = 2
				for i = 2; (int32(sqlite3CtypeMap[*(*uint8)(unsafe.Pointer(z + uintptr(i)))]) & 0x08) != 0; i++ {
				}
				if (int32(*(*uint8)(unsafe.Pointer(z + uintptr(i)))) != '\'') || ((i % 2) != 0) {
					*(*int32)(unsafe.Pointer(tokenType)) = 4
					for (*(*uint8)(unsafe.Pointer(z + uintptr(i))) != 0) && (int32(*(*uint8)(unsafe.Pointer(z + uintptr(i)))) != '\'') {
						i++
					}
				}
				if *(*uint8)(unsafe.Pointer(z + uintptr(i))) != 0 {
					i++
				}
				return i
			}
			// If it is not a BLOB literal, then it must be an ID, since no
			// SQL keywords start with the letter 'x'.  Fall through
		}
		fallthrough
	case 2:
		{
			i = 1
			break
		}
	default:
		{
			*(*int32)(unsafe.Pointer(tokenType)) = 4
			return 1
		}
	}
	for (int32(sqlite3CtypeMap[*(*uint8)(unsafe.Pointer(z + uintptr(i)))]) & 0x46) != 0 {
		i++
	}
	*(*int32)(unsafe.Pointer(tokenType)) = 1
	return i
}

func sqlite3_normalize(tls *crt.TLS, zSql uintptr) uintptr { /* normalize.c:546:6: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var z uintptr          // The output string
	var nZ sqlite3_int64   // Size of the output string in bytes
	var nSql sqlite3_int64 // Size of the input string in bytes
	var i int32            // Next character to read from zSql[]
	var j int32            // Next slot to fill in on z[]
	// var tokenType int32 at bp, 4
	// Type of the next token
	var n int32 // Size of the next token
	var k int32 // Loop counter

	nSql = sqlite3_int64(crt.Xstrlen(tls, zSql))
	nZ = nSql
	z = sqlite3.Xsqlite3_malloc64(tls, (uint64(nZ + int64(2))))
	if z == uintptr(0) {
		return uintptr(0)
	}
	for i = crt.AssignInt32(&j, 0); *(*int8)(unsafe.Pointer(zSql + uintptr(i))) != 0; i = i + (n) {
		n = sqlite3GetToken(tls, (zSql + uintptr(i)), bp /* &tokenType */)
		switch *(*int32)(unsafe.Pointer(bp /* tokenType */)) {
		case 0:
			{
				break
			}
		case 4:
			{
				sqlite3.Xsqlite3_free(tls, z)
				return uintptr(0)
			}
		case 2:
			{
				*(*int8)(unsafe.Pointer(z + uintptr(crt.PostIncInt32(&j, 1)))) = int8('?')
				break
			}
		case 3:
			fallthrough
		case 1:
			{
				if (n == 4) && (sqlite3.Xsqlite3_strnicmp(tls, (zSql+uintptr(i)), ts+5494 /* "NULL" */, 4) == 0) {
					if (((j >= 3) && (crt.Xstrncmp(tls, ((z+uintptr(j))-uintptr(2)), ts+5499 /* "is" */, uint64(2)) == 0)) && !((int32(sqlite3CtypeMap[uint8(*(*int8)(unsafe.Pointer(z + uintptr((j - 3)))))]) & 0x46) != 0)) ||
						(((j >= 4) && (crt.Xstrncmp(tls, ((z+uintptr(j))-uintptr(3)), ts+5502 /* "not" */, uint64(3)) == 0)) && !((int32(sqlite3CtypeMap[uint8(*(*int8)(unsafe.Pointer(z + uintptr((j - 4)))))]) & 0x46) != 0)) {
					} else {
						// Here the NULL is a literal value
						*(*int8)(unsafe.Pointer(z + uintptr(crt.PostIncInt32(&j, 1)))) = int8('?')
						break
					}
				}
				if ((j > 0) && ((int32(sqlite3CtypeMap[uint8(*(*int8)(unsafe.Pointer(z + uintptr((j - 1)))))]) & 0x46) != 0)) && ((int32(sqlite3CtypeMap[uint8(*(*int8)(unsafe.Pointer(zSql + uintptr(i))))]) & 0x46) != 0) {
					*(*int8)(unsafe.Pointer(z + uintptr(crt.PostIncInt32(&j, 1)))) = int8(' ')
				}
				for k = 0; k < n; k++ {
					*(*int8)(unsafe.Pointer(z + uintptr(crt.PostIncInt32(&j, 1)))) = int8(sqlite3UpperToLower[uint8(*(*int8)(unsafe.Pointer(zSql + uintptr((i + k)))))])
				}
				break
			}
		}
	}
	for (j > 0) && (int32(*(*int8)(unsafe.Pointer(z + uintptr((j - 1))))) == ' ') {
		j--
	}
	if (j > 0) && (int32(*(*int8)(unsafe.Pointer(z + uintptr((j - 1))))) != ';') {
		*(*int8)(unsafe.Pointer(z + uintptr(crt.PostIncInt32(&j, 1)))) = int8(';')
	}
	*(*int8)(unsafe.Pointer(z + uintptr(j))) = int8(0)

	// Make a second pass converting "in(...)" where the "..." is not a
	// SELECT statement into "in(?,?,?)"
	for i = 0; i < j; i = n {
		var zIn uintptr = crt.Xstrstr(tls, (z + uintptr(i)), ts+5506 /* "in(" */)
		var nParen int32
		if zIn == uintptr(0) {
			break
		}
		n = ((int32((int64(zIn) - int64(z)) / 1)) + 3) // Index of first char past "in("
		if (n != 0) && ((int32(sqlite3CtypeMap[uint8(*(*int8)(unsafe.Pointer(zIn + crt.UintptrFromInt32(-1))))]) & 0x46) != 0) {
			continue
		}
		if (crt.Xstrncmp(tls, zIn, ts+5510 /* "in(select" */, uint64(9)) == 0) && !((int32(sqlite3CtypeMap[uint8(*(*int8)(unsafe.Pointer(zIn + uintptr(9))))]) & 0x46) != 0) {
			continue
		}
		if (crt.Xstrncmp(tls, zIn, ts+5520 /* "in(with" */, uint64(7)) == 0) && !((int32(sqlite3CtypeMap[uint8(*(*int8)(unsafe.Pointer(zIn + uintptr(7))))]) & 0x46) != 0) {
			continue
		}
		nParen = 1
		k = 0
		for ; *(*int8)(unsafe.Pointer(z + uintptr((n + k)))) != 0; k++ {
			if int32(*(*int8)(unsafe.Pointer(z + uintptr((n + k))))) == '(' {
				nParen++
			}
			if int32(*(*int8)(unsafe.Pointer(z + uintptr((n + k))))) == ')' {
				nParen--
				if nParen == 0 {
					break
				}
			}
		}
		// k is the number of bytes in the "..." within "in(...)"
		if k < 5 {
			z = sqlite3.Xsqlite3_realloc64(tls, z, (uint64((j + (5 - k)) + 1)))
			if z == uintptr(0) {
				return uintptr(0)
			}
			crt.Xmemmove(tls, ((z + uintptr(n)) + uintptr(5)), ((z + uintptr(n)) + uintptr(k)), (uint64(j - (n + k))))
		} else if k > 5 {
			crt.Xmemmove(tls, ((z + uintptr(n)) + uintptr(5)), ((z + uintptr(n)) + uintptr(k)), (uint64(j - (n + k))))
		}
		j = ((j - k) + 5)
		*(*int8)(unsafe.Pointer(z + uintptr(j))) = int8(0)
		crt.Xmemcpy(tls, (z + uintptr(n)), ts+5528 /* "?,?,?" */, uint64(5))
	}
	return z
}

// For testing purposes, or to build a stand-alone SQL normalizer program,
// compile this one source file with the -DSQLITE_NORMALIZE_CLI and link
// it against any SQLite library.  The resulting command-line program will
// run sqlite3_normalize() over the text of all files named on the command-
// line and show the result on standard output.

// Floating-point inline functions for stdlib.h.
//   Copyright (C) 2012-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// Define some macros helping to catch buffer overflows.

// The following object is the session context for a single percentile()
// function.  We have to remember all input Y values until the very end.
// Those values are accumulated in the Percentile.a[] array.
type Percentile1 = struct {
	FnAlloc uint32
	FnUsed  uint32
	FrPct   float64
	Fa      uintptr
}

// Floating-point inline functions for stdlib.h.
//   Copyright (C) 2012-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// Define some macros helping to catch buffer overflows.

// The following object is the session context for a single percentile()
// function.  We have to remember all input Y values until the very end.
// Those values are accumulated in the Percentile.a[] array.
type Percentile = Percentile1 /* percentile.c:71:27 */

// Return TRUE if the input floating-point number is an infinity.
func isInfinity(tls *crt.TLS, r float64) int32 { /* percentile.c:82:12: */
	bp := tls.Alloc(16)
	defer tls.Free(16)
	*(*float64)(unsafe.Pointer(bp + 8)) = r

	// var u sqlite3_uint64 at bp, 8

	if !(uint64(unsafe.Sizeof(sqlite3_uint64(0))) == uint64(unsafe.Sizeof(float64(0)))) {
		crt.X__assert_fail(tls, ts+5534 /* "sizeof(u)==sizeo..." */, ts+5555 /* "testdata/sqlite-..." */, uint32(84), uintptr(unsafe.Pointer(&__func__26)))
	}
	crt.Xmemcpy(tls, bp /* &u */, bp+8 /* &r */, uint64(unsafe.Sizeof(sqlite3_uint64(0))))
	return (crt.Bool32(((*(*sqlite3_uint64)(unsafe.Pointer(bp /* u */)) >> 52) & uint64(0x7ff)) == uint64(0x7ff)))
}

var __func__26 = *(*[11]int8)(unsafe.Pointer(ts + 5605 /* "isInfinity" */)) /* percentile.c:82:32 */

// Return TRUE if two doubles differ by 0.001 or less
func sameValue(tls *crt.TLS, a float64, b float64) int32 { /* percentile.c:92:12: */
	a = a - (b)
	return (crt.Bool32((a >= -0.001) && (a <= 0.001)))
}

// The "step" function for percentile(Y,P) is called once for each
// input row.
func percentStep(tls *crt.TLS, pCtx uintptr, argc int32, argv uintptr) { /* percentile.c:101:13: */
	var p uintptr
	var rPct float64
	var eType int32
	var y float64
	if !(argc == 2) {
		crt.X__assert_fail(tls, ts+1318 /* "argc==2" */, ts+5555 /* "testdata/sqlite-..." */, uint32(106), uintptr(unsafe.Pointer(&__func__27)))
	}

	// Requirement 3:  P must be a number between 0 and 100
	eType = sqlite3.Xsqlite3_value_numeric_type(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)))
	rPct = sqlite3.Xsqlite3_value_double(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)))
	if (((eType != 1) && (eType != 2)) ||
		(rPct < 0.0)) || (rPct > 100.0) {
		sqlite3.Xsqlite3_result_error(tls, pCtx,
			ts+5616 /* "2nd argument to ..." */, -1)
		return
	}

	// Allocate the session context.
	p = sqlite3.Xsqlite3_aggregate_context(tls, pCtx, int32(unsafe.Sizeof(Percentile{})))
	if p == uintptr(0) {
		return
	}

	// Remember the P value.  Throw an error if the P value is different
	// from any prior row, per Requirement (2).
	if (*Percentile)(unsafe.Pointer(p)).FrPct == 0.0 {
		(*Percentile)(unsafe.Pointer(p)).FrPct = (rPct + 1.0)
	} else if !(sameValue(tls, (*Percentile)(unsafe.Pointer(p)).FrPct, (rPct+1.0)) != 0) {
		sqlite3.Xsqlite3_result_error(tls, pCtx,
			ts+5683 /* "2nd argument to ..." */, -1)
		return
	}

	// Ignore rows for which Y is NULL
	eType = sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)))
	if eType == 5 {
		return
	}

	// If not NULL, then Y must be numeric.  Otherwise throw an error.
	// Requirement 4
	if (eType != 1) && (eType != 2) {
		sqlite3.Xsqlite3_result_error(tls, pCtx,
			ts+5747 /* "1st argument to ..." */, -1)
		return
	}

	// Throw an error if the Y value is infinity or NaN
	y = sqlite3.Xsqlite3_value_double(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)))
	if isInfinity(tls, y) != 0 {
		sqlite3.Xsqlite3_result_error(tls, pCtx, ts+5791 /* "Inf input to per..." */, -1)
		return
	}

	// Allocate and store the Y
	if (*Percentile)(unsafe.Pointer(p)).FnUsed >= (*Percentile)(unsafe.Pointer(p)).FnAlloc {
		var n uint32 = (((*Percentile)(unsafe.Pointer(p)).FnAlloc * uint32(2)) + uint32(250))
		var a uintptr = sqlite3.Xsqlite3_realloc64(tls, (*Percentile)(unsafe.Pointer(p)).Fa, (uint64(uint64(unsafe.Sizeof(float64(0))) * uint64(n))))
		if a == uintptr(0) {
			sqlite3.Xsqlite3_free(tls, (*Percentile)(unsafe.Pointer(p)).Fa)
			crt.Xmemset(tls, p, 0, uint64(unsafe.Sizeof(Percentile{})))
			sqlite3.Xsqlite3_result_error_nomem(tls, pCtx)
			return
		}
		(*Percentile)(unsafe.Pointer(p)).FnAlloc = n
		(*Percentile)(unsafe.Pointer(p)).Fa = a
	}
	*(*float64)(unsafe.Pointer((*Percentile)(unsafe.Pointer(p)).Fa + uintptr(crt.PostIncUint32(&(*Percentile)(unsafe.Pointer(p)).FnUsed, 1))*8)) = y
}

var __func__27 = *(*[12]int8)(unsafe.Pointer(ts + 5817 /* "percentStep" */)) /* percentile.c:101:79 */

// Compare to doubles for sorting using qsort()
func doubleCmp(tls *crt.TLS, pA uintptr, pB uintptr) int32 { /* percentile.c:170:25: */
	var a float64 = *(*float64)(unsafe.Pointer(pA))
	var b float64 = *(*float64)(unsafe.Pointer(pB))
	if a == b {
		return 0
	}
	if a < b {
		return -1
	}
	return +1
}

// Called to compute the final output of percentile() and to clean
// up all allocated memory.
func percentFinal(tls *crt.TLS, pCtx uintptr) { /* percentile.c:182:13: */
	var p uintptr
	var i1 uint32
	var i2 uint32
	var v1 float64
	var v2 float64
	var ix float64
	var vx float64
	p = sqlite3.Xsqlite3_aggregate_context(tls, pCtx, 0)
	if p == uintptr(0) {
		return
	}
	if (*Percentile)(unsafe.Pointer(p)).Fa == uintptr(0) {
		return
	}
	if (*Percentile)(unsafe.Pointer(p)).FnUsed != 0 {
		crt.Xqsort(tls, (*Percentile)(unsafe.Pointer(p)).Fa, uint64((*Percentile)(unsafe.Pointer(p)).FnUsed), uint64(unsafe.Sizeof(float64(0))), *(*uintptr)(unsafe.Pointer(&struct {
			f func(*crt.TLS, uintptr, uintptr) int32
		}{doubleCmp})))
		ix = ((((*Percentile)(unsafe.Pointer(p)).FrPct - 1.0) * (float64((*Percentile)(unsafe.Pointer(p)).FnUsed - uint32(1)))) * 0.01)
		i1 = uint32(ix)
		if (ix == float64(i1)) || (i1 == ((*Percentile)(unsafe.Pointer(p)).FnUsed - uint32(1))) {
			i2 = i1
		} else {
			i2 = (i1 + uint32(1))
		}
		v1 = *(*float64)(unsafe.Pointer((*Percentile)(unsafe.Pointer(p)).Fa + uintptr(i1)*8))
		v2 = *(*float64)(unsafe.Pointer((*Percentile)(unsafe.Pointer(p)).Fa + uintptr(i2)*8))
		vx = (v1 + ((v2 - v1) * (ix - float64(i1))))
		sqlite3.Xsqlite3_result_double(tls, pCtx, vx)
	}
	sqlite3.Xsqlite3_free(tls, (*Percentile)(unsafe.Pointer(p)).Fa)
	crt.Xmemset(tls, p, 0, uint64(unsafe.Sizeof(Percentile{})))
}

func sqlite3_percentile_init(tls *crt.TLS, db uintptr, pzErrMsg uintptr, pApi uintptr) int32 { /* percentile.c:208:5: */
	var rc int32 = 0
	_ = pApi

	_ = pzErrMsg // Unused parameter
	rc = sqlite3.Xsqlite3_create_function(tls, db, ts+5829 /* "percentile" */, 2,
		(1 | 0x000200000), uintptr(0),
		uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
			f func(*crt.TLS, uintptr, int32, uintptr)
		}{percentStep})), *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, uintptr) }{percentFinal})))
	return rc
}

// When possible, define assert so that it does not add extra
//   parentheses around EXPR.  Otherwise, those added parentheses would
//   suppress warnings we'd expect to be detected by gcc's -Wparentheses.

// Version 2.4 and later of GCC define a magical variable `__PRETTY_FUNCTION__'
//   which contains the name of the function currently being defined.
//   This is broken in G++ before version 2.6.
//   C9x has a similar variable called __func__, but prefer the GCC one since
//   it demangles C++ function names.

// prefixes_vtab is a subclass of sqlite3_vtab which is
// underlying representation of the virtual table
type prefixes_vtab1 = struct{ Fbase sqlite3_vtab }

// When possible, define assert so that it does not add extra
//   parentheses around EXPR.  Otherwise, those added parentheses would
//   suppress warnings we'd expect to be detected by gcc's -Wparentheses.

// Version 2.4 and later of GCC define a magical variable `__PRETTY_FUNCTION__'
//   which contains the name of the function currently being defined.
//   This is broken in G++ before version 2.6.
//   C9x has a similar variable called __func__, but prefer the GCC one since
//   it demangles C++ function names.

// prefixes_vtab is a subclass of sqlite3_vtab which is
// underlying representation of the virtual table
type prefixes_vtab = prefixes_vtab1 /* prefixes.c:33:30 */

// prefixes_cursor is a subclass of sqlite3_vtab_cursor which will
// serve as the underlying representation of a cursor that scans
// over rows of the result
type prefixes_cursor1 = struct {
	Fbase   sqlite3_vtab_cursor
	FiRowid sqlite3_int64
	FzStr   uintptr
	FnStr   int32
	_       [4]byte
}

// prefixes_cursor is a subclass of sqlite3_vtab_cursor which will
// serve as the underlying representation of a cursor that scans
// over rows of the result
type prefixes_cursor = prefixes_cursor1 /* prefixes.c:43:32 */

// The prefixesConnect() method is invoked to create a new
// template virtual table.
//
// Think of this routine as the constructor for prefixes_vtab objects.
//
// All this routine needs to do is:
//
//    (1) Allocate the prefixes_vtab object and initialize all fields.
//
//    (2) Tell SQLite (via the sqlite3_declare_vtab() interface) what the
//        result set of queries against the virtual table will look like.
func prefixesConnect(tls *crt.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVtab uintptr, pzErr uintptr) int32 { /* prefixes.c:64:12: */
	var pNew uintptr
	var rc int32

	rc = sqlite3.Xsqlite3_declare_vtab(tls, db,
		ts+5840 /* "CREATE TABLE pre..." */)
	if rc == 0 {
		pNew = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(prefixes_vtab{})))
		*(*uintptr)(unsafe.Pointer(ppVtab)) = pNew
		if pNew == uintptr(0) {
			return 7
		}
		crt.Xmemset(tls, pNew, 0, uint64(unsafe.Sizeof(prefixes_vtab{})))
		sqlite3.Xsqlite3_vtab_config(tls, db, 2, 0)
	}
	return rc
}

// This method is the destructor for prefixes_vtab objects.
func prefixesDisconnect(tls *crt.TLS, pVtab uintptr) int32 { /* prefixes.c:90:12: */
	var p uintptr = pVtab
	sqlite3.Xsqlite3_free(tls, p)
	return 0
}

// Constructor for a new prefixes_cursor object.
func prefixesOpen(tls *crt.TLS, p uintptr, ppCursor uintptr) int32 { /* prefixes.c:99:12: */
	var pCur uintptr
	pCur = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(prefixes_cursor{})))
	if pCur == uintptr(0) {
		return 7
	}
	crt.Xmemset(tls, pCur, 0, uint64(unsafe.Sizeof(prefixes_cursor{})))
	*(*uintptr)(unsafe.Pointer(ppCursor)) = (pCur /* &.base */)
	return 0
}

// Destructor for a prefixes_cursor.
func prefixesClose(tls *crt.TLS, cur uintptr) int32 { /* prefixes.c:111:12: */
	var pCur uintptr = cur
	sqlite3.Xsqlite3_free(tls, (*prefixes_cursor)(unsafe.Pointer(pCur)).FzStr)
	sqlite3.Xsqlite3_free(tls, pCur)
	return 0
}

// Advance a prefixes_cursor to its next row of output.
func prefixesNext(tls *crt.TLS, cur uintptr) int32 { /* prefixes.c:122:12: */
	var pCur uintptr = cur
	(*prefixes_cursor)(unsafe.Pointer(pCur)).FiRowid++
	return 0
}

// Return values of columns for the row at which the prefixes_cursor
// is currently pointing.
func prefixesColumn(tls *crt.TLS, cur uintptr, ctx uintptr, i int32) int32 { /* prefixes.c:132:12: */
	var pCur uintptr = cur
	switch i {
	case 0:
		sqlite3.Xsqlite3_result_text(tls, ctx, (*prefixes_cursor)(unsafe.Pointer(pCur)).FzStr, ((*prefixes_cursor)(unsafe.Pointer(pCur)).FnStr - int32((*prefixes_cursor)(unsafe.Pointer(pCur)).FiRowid)),
			uintptr(0))
		break
	default:
		sqlite3.Xsqlite3_result_text(tls, ctx, (*prefixes_cursor)(unsafe.Pointer(pCur)).FzStr, (*prefixes_cursor)(unsafe.Pointer(pCur)).FnStr, uintptr(0))
		break
	}
	return 0
}

// Return the rowid for the current row.  In this implementation, the
// rowid is the same as the output value.
func prefixesRowid(tls *crt.TLS, cur uintptr, pRowid uintptr) int32 { /* prefixes.c:154:12: */
	var pCur uintptr = cur
	*(*sqlite_int64)(unsafe.Pointer(pRowid)) = (*prefixes_cursor)(unsafe.Pointer(pCur)).FiRowid
	return 0
}

// Return TRUE if the cursor has been moved off of the last
// row of output.
func prefixesEof(tls *crt.TLS, cur uintptr) int32 { /* prefixes.c:164:12: */
	var pCur uintptr = cur
	return (crt.Bool32((*prefixes_cursor)(unsafe.Pointer(pCur)).FiRowid > sqlite3_int64((*prefixes_cursor)(unsafe.Pointer(pCur)).FnStr)))
}

// This method is called to "rewind" the prefixes_cursor object back
// to the first row of output.  This method is always called at least
// once prior to any call to prefixesColumn() or prefixesRowid() or
// prefixesEof().
func prefixesFilter(tls *crt.TLS, pVtabCursor uintptr, idxNum int32, idxStr uintptr, argc int32, argv uintptr) int32 { /* prefixes.c:175:12: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var pCur uintptr = pVtabCursor
	sqlite3.Xsqlite3_free(tls, (*prefixes_cursor)(unsafe.Pointer(pCur)).FzStr)
	if argc > 0 {
		(*prefixes_cursor)(unsafe.Pointer(pCur)).FzStr = sqlite3.Xsqlite3_mprintf(tls, ts+130 /* "%s" */, crt.VaList(bp, sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)))))
		(*prefixes_cursor)(unsafe.Pointer(pCur)).FnStr = func() int32 {
			if (*prefixes_cursor)(unsafe.Pointer(pCur)).FzStr != 0 {
				return int32(crt.Xstrlen(tls, (*prefixes_cursor)(unsafe.Pointer(pCur)).FzStr))
			}
			return 0
		}()
	} else {
		(*prefixes_cursor)(unsafe.Pointer(pCur)).FzStr = uintptr(0)
		(*prefixes_cursor)(unsafe.Pointer(pCur)).FnStr = 0
	}
	(*prefixes_cursor)(unsafe.Pointer(pCur)).FiRowid = int64(0)
	return 0
}

// SQLite will invoke this method one or more times while planning a query
// that uses the virtual table.  This routine needs to create
// a query plan for each invocation and compute an estimated cost for that
// plan.
func prefixesBestIndex(tls *crt.TLS, tab uintptr, pIdxInfo uintptr) int32 { /* prefixes.c:199:12: */
	// Search for a usable equality constraint against column 1
	// (original_string) and use it if at all possible
	var i int32
	var p uintptr

	i = 0
	p = (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraint
__1:
	if !(i < (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnConstraint) {
		goto __3
	}
	{
		if (*sqlite3_index_constraint)(unsafe.Pointer(p)).FiColumn != 1 {
			goto __2
		}
		if int32((*sqlite3_index_constraint)(unsafe.Pointer(p)).Fop) != 2 {
			goto __2
		}
		if !(int32((*sqlite3_index_constraint)(unsafe.Pointer(p)).Fusable) != 0) {
			goto __2
		}
		(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(i)*8)).FargvIndex = 1
		(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(i)*8)).Fomit = uint8(1)
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = float64(10)
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedRows = int64(10)
		return 0
	}
	goto __2
__2:
	i++
	p += 12
	goto __1
	goto __3
__3:
	;
	(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = float64(1000000000)
	(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedRows = int64(1000000000)
	return 0
}

// This following structure defines all the methods for the
// virtual table.
var prefixesModule = sqlite3_module{FiVersion:
/* iVersion    */ 0, FxCreate:
/* xCreate     */ uintptr(0), FxConnect:
/* xConnect    */ 0, FxBestIndex:
/* xBestIndex  */ 0, FxDisconnect:
/* xDisconnect */ 0, FxDestroy:
/* xDestroy    */ uintptr(0), FxOpen:
/* xOpen       */ 0, FxClose:
/* xClose      */ 0, FxFilter:
/* xFilter     */ 0, FxNext:
/* xNext       */ 0, FxEof:
/* xEof        */ 0, FxColumn:
/* xColumn     */ 0, FxRowid:
/* xRowid      */ 0, FxUpdate:
/* xUpdate     */ uintptr(0), FxBegin:
/* xBegin      */ uintptr(0), FxSync:
/* xSync       */ uintptr(0), FxCommit:
/* xCommit     */ uintptr(0), FxRollback:
/* xRollback   */ uintptr(0), FxFindFunction:
/* xFindMethod */ uintptr(0), FxRename:
/* xRename     */ uintptr(0), FxSavepoint:
/* xSavepoint  */ uintptr(0), FxRelease:
/* xRelease    */ uintptr(0), FxRollbackTo:
/* xRollbackTo */ uintptr(0), FxShadowName:
/* xShadowName */ uintptr(0),
} /* prefixes.c:227:23 */

// This is a copy of the SQLITE_SKIP_UTF8(zIn) macro in sqliteInt.h.
//
// Assuming zIn points to the first byte of a UTF-8 character,
// advance zIn to point to the first byte of the next UTF-8 character.

// Implementation of function prefix_length(). This function accepts two
// strings as arguments and returns the length in characters (not bytes),
// of the longest prefix shared by the two strings. For example:
//
//   prefix_length('abcdxxx', 'abcyy') == 3
//   prefix_length('abcdxxx', 'bcyyy') == 0
//   prefix_length('abcdxxx', 'ab')    == 2
//   prefix_length('ab',      'abcd')  == 2
//
// This function assumes the input is well-formed utf-8. If it is not,
// it is possible for this function to return -1.
func prefixLengthFunc(tls *crt.TLS, ctx uintptr, nVal int32, apVal uintptr) { /* prefixes.c:279:13: */
	var nByte int32    // Number of bytes to compare
	var nRet int32 = 0 // Return value
	var zL uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(apVal + uintptr(0)*8)))
	var zR uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(apVal + uintptr(1)*8)))
	var nL int32 = sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(apVal + uintptr(0)*8)))
	var nR int32 = sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(apVal + uintptr(1)*8)))
	var i int32

	nByte = func() int32 {
		if nL > nR {
			return nL
		}
		return nR
	}()
	for i = 0; i < nByte; i++ {
		if int32(*(*uint8)(unsafe.Pointer(zL + uintptr(i)))) != int32(*(*uint8)(unsafe.Pointer(zR + uintptr(i)))) {
			break
		}
		if (int32(*(*uint8)(unsafe.Pointer(zL + uintptr(i)))) & 0xC0) != 0x80 {
			nRet++
		}
	}

	if (int32(*(*uint8)(unsafe.Pointer(zL + uintptr(i)))) & 0xC0) == 0x80 {
		nRet--
	}
	sqlite3.Xsqlite3_result_int(tls, ctx, nRet)
}

func sqlite3_prefixes_init(tls *crt.TLS, db uintptr, pzErrMsg uintptr, pApi uintptr) int32 { /* prefixes.c:305:5: */
	var rc int32 = 0
	_ = pApi

	rc = sqlite3.Xsqlite3_create_module(tls, db, ts+5904 /* "prefixes" */, uintptr(unsafe.Pointer(&prefixesModule)), uintptr(0))
	if rc == 0 {
		rc = sqlite3.Xsqlite3_create_function(tls,
			db, ts+5913 /* "prefix_length" */, 2, 1, uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
				f func(*crt.TLS, uintptr, int32, uintptr)
			}{prefixLengthFunc})), uintptr(0), uintptr(0))
	}
	return rc
}

// The following macros redefine the API routines so that they are
// redirected through the global sqlite3_api structure.
//
// This header file is also used by the loadext.c source file
// (part of the main SQLite library - not an extension) so that
// it can get access to the sqlite3_api_routines structure
// definition.  But the main library does not want to redefine
// the API.  So the redefinition macros are only valid if the
// SQLITE_CORE macros is undefined.

// This case when the file is being statically linked into the
// application

// The following #defines change the names of some functions implemented in
// this file to prevent name collisions with C-library functions of the
// same name.

// The end-of-input character

// The NFA is implemented as sequence of opcodes taken from the following
// set.  Each opcode has a single integer argument.

// Each opcode is a "state" in the NFA
type ReStateNumber = uint16 /* regexp.c:98:24 */

// Because this is an NFA and not a DFA, multiple states can be active at
// once.  An instance of the following object records all active states in
// the NFA.  The implementation is optimized for the common case where the
// number of actives states is small.
type ReStateSet1 = struct {
	FnState uint32
	FaState uintptr
}

// Because this is an NFA and not a DFA, multiple states can be active at
// once.  An instance of the following object records all active states in
// the NFA.  The implementation is optimized for the common case where the
// number of actives states is small.
type ReStateSet = ReStateSet1 /* regexp.c:108:3 */

// An input string read one character at a time.
type ReInput1 = struct {
	Fz  uintptr
	Fi  int32
	Fmx int32
}

// An input string read one character at a time.
type ReInput = ReInput1 /* regexp.c:112:24 */

// A compiled NFA (or an NFA that is in the process of being compiled) is
// an instance of the following object.
type ReCompiled1 = struct {
	FsIn       ReInput
	FzErr      uintptr
	FaOp       uintptr
	FaArg      uintptr
	FxNextChar uintptr
	FzInit     [12]uint8
	FnInit     int32
	FnState    uint32
	FnAlloc    uint32
}

// A compiled NFA (or an NFA that is in the process of being compiled) is
// an instance of the following object.
type ReCompiled = ReCompiled1 /* regexp.c:122:27 */

// Add a state to the given state set if it is not already there
func re_add_state(tls *crt.TLS, pSet uintptr, newState int32) { /* regexp.c:136:13: */
	var i uint32
	for i = uint32(0); i < (*ReStateSet)(unsafe.Pointer(pSet)).FnState; i++ {
		if int32(*(*ReStateNumber)(unsafe.Pointer((*ReStateSet)(unsafe.Pointer(pSet)).FaState + uintptr(i)*2))) == newState {
			return
		}
	}
	*(*ReStateNumber)(unsafe.Pointer((*ReStateSet)(unsafe.Pointer(pSet)).FaState + uintptr(crt.PostIncUint32(&(*ReStateSet)(unsafe.Pointer(pSet)).FnState, 1))*2)) = ReStateNumber(newState)
}

// Extract the next unicode character from *pzIn and return it.  Advance
// *pzIn to the first byte past the end of the character returned.  To
// be clear:  this routine converts utf8 to unicode.  This routine is
// optimized for the common case where the next character is a single byte.
func re_next_char(tls *crt.TLS, p uintptr) uint32 { /* regexp.c:147:17: */
	var c uint32
	if (*ReInput)(unsafe.Pointer(p)).Fi >= (*ReInput)(unsafe.Pointer(p)).Fmx {
		return uint32(0)
	}
	c = uint32(*(*uint8)(unsafe.Pointer((*ReInput)(unsafe.Pointer(p)).Fz + uintptr(crt.PostIncInt32(&(*ReInput)(unsafe.Pointer(p)).Fi, 1)))))
	if c >= uint32(0x80) {
		if (((c & uint32(0xe0)) == uint32(0xc0)) && ((*ReInput)(unsafe.Pointer(p)).Fi < (*ReInput)(unsafe.Pointer(p)).Fmx)) && ((int32(*(*uint8)(unsafe.Pointer((*ReInput)(unsafe.Pointer(p)).Fz + uintptr((*ReInput)(unsafe.Pointer(p)).Fi)))) & 0xc0) == 0x80) {
			c = (((c & uint32(0x1f)) << 6) | (uint32(int32(*(*uint8)(unsafe.Pointer((*ReInput)(unsafe.Pointer(p)).Fz + uintptr(crt.PostIncInt32(&(*ReInput)(unsafe.Pointer(p)).Fi, 1))))) & 0x3f)))
			if c < uint32(0x80) {
				c = uint32(0xfffd)
			}
		} else if ((((c & uint32(0xf0)) == uint32(0xe0)) && (((*ReInput)(unsafe.Pointer(p)).Fi + 1) < (*ReInput)(unsafe.Pointer(p)).Fmx)) && ((int32(*(*uint8)(unsafe.Pointer((*ReInput)(unsafe.Pointer(p)).Fz + uintptr((*ReInput)(unsafe.Pointer(p)).Fi)))) & 0xc0) == 0x80)) &&
			((int32(*(*uint8)(unsafe.Pointer((*ReInput)(unsafe.Pointer(p)).Fz + uintptr(((*ReInput)(unsafe.Pointer(p)).Fi + 1))))) & 0xc0) == 0x80) {
			c = ((((c & uint32(0x0f)) << 12) | (uint32((int32(*(*uint8)(unsafe.Pointer((*ReInput)(unsafe.Pointer(p)).Fz + uintptr((*ReInput)(unsafe.Pointer(p)).Fi)))) & 0x3f) << 6))) | (uint32(int32(*(*uint8)(unsafe.Pointer((*ReInput)(unsafe.Pointer(p)).Fz + uintptr(((*ReInput)(unsafe.Pointer(p)).Fi + 1))))) & 0x3f)))
			*(*int32)(unsafe.Pointer(p + 8 /* &.i */)) += (2)
			if (c <= uint32(0x7ff)) || ((c >= uint32(0xd800)) && (c <= uint32(0xdfff))) {
				c = uint32(0xfffd)
			}
		} else if (((((c & uint32(0xf8)) == uint32(0xf0)) && (((*ReInput)(unsafe.Pointer(p)).Fi + 3) < (*ReInput)(unsafe.Pointer(p)).Fmx)) && ((int32(*(*uint8)(unsafe.Pointer((*ReInput)(unsafe.Pointer(p)).Fz + uintptr((*ReInput)(unsafe.Pointer(p)).Fi)))) & 0xc0) == 0x80)) &&
			((int32(*(*uint8)(unsafe.Pointer((*ReInput)(unsafe.Pointer(p)).Fz + uintptr(((*ReInput)(unsafe.Pointer(p)).Fi + 1))))) & 0xc0) == 0x80)) && ((int32(*(*uint8)(unsafe.Pointer((*ReInput)(unsafe.Pointer(p)).Fz + uintptr(((*ReInput)(unsafe.Pointer(p)).Fi + 2))))) & 0xc0) == 0x80) {
			c = (((((c & uint32(0x07)) << 18) | (uint32((int32(*(*uint8)(unsafe.Pointer((*ReInput)(unsafe.Pointer(p)).Fz + uintptr((*ReInput)(unsafe.Pointer(p)).Fi)))) & 0x3f) << 12))) | (uint32((int32(*(*uint8)(unsafe.Pointer((*ReInput)(unsafe.Pointer(p)).Fz + uintptr(((*ReInput)(unsafe.Pointer(p)).Fi + 1))))) & 0x3f) << 6))) |
				(uint32(int32(*(*uint8)(unsafe.Pointer((*ReInput)(unsafe.Pointer(p)).Fz + uintptr(((*ReInput)(unsafe.Pointer(p)).Fi + 2))))) & 0x3f)))
			*(*int32)(unsafe.Pointer(p + 8 /* &.i */)) += (3)
			if (c <= uint32(0xffff)) || (c > uint32(0x10ffff)) {
				c = uint32(0xfffd)
			}
		} else {
			c = uint32(0xfffd)
		}
	}
	return c
}
func re_next_char_nocase(tls *crt.TLS, p uintptr) uint32 { /* regexp.c:172:17: */
	var c uint32 = re_next_char(tls, p)
	if (c >= uint32('A')) && (c <= uint32('Z')) {
		c = c + (uint32('a' - 'A'))
	}
	return c
}

// Return true if c is a perl "word" character:  [A-Za-z0-9_]
func re_word_char(tls *crt.TLS, c int32) int32 { /* regexp.c:179:12: */
	return (crt.Bool32(((((c >= '0') && (c <= '9')) || ((c >= 'a') && (c <= 'z'))) ||
		((c >= 'A') && (c <= 'Z'))) || (c == '_')))
}

// Return true if c is a "digit" character:  [0-9]
func re_digit_char(tls *crt.TLS, c int32) int32 { /* regexp.c:185:12: */
	return (crt.Bool32((c >= '0') && (c <= '9')))
}

// Return true if c is a perl "space" character:  [ \t\r\n\v\f]
func re_space_char(tls *crt.TLS, c int32) int32 { /* regexp.c:190:12: */
	return (crt.Bool32((((((c == ' ') || (c == '\t')) || (c == '\n')) || (c == '\r')) || (c == '\v')) || (c == '\f')))
}

// Run a compiled regular expression on the zero-terminated input
// string zIn[].  Return true on a match and false if there is no match.
func sqlite3re_match(tls *crt.TLS, pRe uintptr, zIn uintptr, nIn int32) int32 { /* regexp.c:197:12: */
	bp := tls.Alloc(248)
	defer tls.Free(248)

	// var aStateSet [2]ReStateSet at bp, 32

	var pThis uintptr
	var pNext uintptr
	// var aSpace [100]ReStateNumber at bp+32, 200

	var pToFree uintptr
	var i uint32
	var iSwap uint32
	var c int32
	var cPrev int32
	var rc int32
	// var in ReInput at bp+232, 16

	var x uint8
	var j int32
	var n int32
	var hit int32
	var x1 int32
	i = uint32(0)
	iSwap = uint32(0)
	c = (0 + 1)
	cPrev = 0
	rc = 0

	(*ReInput)(unsafe.Pointer(bp + 232 /* &in */)).Fz = zIn
	(*ReInput)(unsafe.Pointer(bp + 232 /* &in */)).Fi = 0
	(*ReInput)(unsafe.Pointer(bp + 232 /* &in */)).Fmx = func() int32 {
		if nIn >= 0 {
			return nIn
		}
		return int32(crt.Xstrlen(tls, zIn))
	}()

	// Look for the initial prefix match, if there is one.
	if !((*ReCompiled)(unsafe.Pointer(pRe)).FnInit != 0) {
		goto __1
	}
	x = *(*uint8)(unsafe.Pointer((pRe + 48 /* &.zInit */) + uintptr(0)))
__2:
	if !((((*ReInput)(unsafe.Pointer(bp+232 /* &in */)).Fi + (*ReCompiled)(unsafe.Pointer(pRe)).FnInit) <= (*ReInput)(unsafe.Pointer(bp+232 /* &in */)).Fmx) &&
		((int32(*(*uint8)(unsafe.Pointer(zIn + uintptr((*ReInput)(unsafe.Pointer(bp+232 /* &in */)).Fi)))) != int32(x)) || (crt.Xstrncmp(tls, (zIn+uintptr((*ReInput)(unsafe.Pointer(bp+232 /* &in */)).Fi)), pRe+48 /* &.zInit */, uint64((*ReCompiled)(unsafe.Pointer(pRe)).FnInit)) != 0))) {
		goto __3
	}
	(*ReInput)(unsafe.Pointer(bp+232 /* &in */)).Fi++
	goto __2
__3:
	;
	if !(((*ReInput)(unsafe.Pointer(bp+232 /* &in */)).Fi + (*ReCompiled)(unsafe.Pointer(pRe)).FnInit) > (*ReInput)(unsafe.Pointer(bp+232 /* &in */)).Fmx) {
		goto __4
	}
	return 0
__4:
	;
__1:
	;

	if !(uint64((*ReCompiled)(unsafe.Pointer(pRe)).FnState) <= (uint64(unsafe.Sizeof([100]ReStateNumber{})) / (uint64(unsafe.Sizeof(ReStateNumber(0))) * uint64(2)))) {
		goto __5
	}
	pToFree = uintptr(0)
	(*ReStateSet)(unsafe.Pointer(bp /* &aStateSet */ + uintptr(0)*16)).FaState = bp + 32 /* &aSpace[0] */
	goto __6
__5:
	pToFree = sqlite3.Xsqlite3_malloc64(tls, (uint64((uint64(unsafe.Sizeof(ReStateNumber(0))) * uint64(2)) * uint64((*ReCompiled)(unsafe.Pointer(pRe)).FnState))))
	if !(pToFree == uintptr(0)) {
		goto __7
	}
	return -1
__7:
	;
	(*ReStateSet)(unsafe.Pointer(bp /* &aStateSet */ + uintptr(0)*16)).FaState = pToFree
__6:
	;
	(*ReStateSet)(unsafe.Pointer(bp /* &aStateSet */ + uintptr(1)*16)).FaState = ((*ReStateSet)(unsafe.Pointer(bp /* &aStateSet */ +uintptr(0)*16)).FaState + uintptr((*ReCompiled)(unsafe.Pointer(pRe)).FnState)*2)
	pNext = (bp /* &aStateSet */ + uintptr(1)*16)
	(*ReStateSet)(unsafe.Pointer(pNext)).FnState = uint32(0)
	re_add_state(tls, pNext, 0)
__8:
	if !((c != 0) && ((*ReStateSet)(unsafe.Pointer(pNext)).FnState > uint32(0))) {
		goto __9
	}
	cPrev = c
	c = int32((*(*func(*crt.TLS, uintptr) uint32)(unsafe.Pointer((pRe + 40 /* &.xNextChar */))))(tls, bp+232 /* &in */))
	pThis = pNext
	pNext = (bp /* &aStateSet */ + uintptr(iSwap)*16)
	iSwap = (uint32(1) - iSwap)
	(*ReStateSet)(unsafe.Pointer(pNext)).FnState = uint32(0)
	i = uint32(0)
__10:
	if !(i < (*ReStateSet)(unsafe.Pointer(pThis)).FnState) {
		goto __12
	}
	x1 = int32(*(*ReStateNumber)(unsafe.Pointer((*ReStateSet)(unsafe.Pointer(pThis)).FaState + uintptr(i)*2)))
	switch int32(*(*int8)(unsafe.Pointer((*ReCompiled)(unsafe.Pointer(pRe)).FaOp + uintptr(x1)))) {
	case 1:
		goto __14
	case 2:
		goto __15
	case 11:
		goto __16
	case 12:
		goto __17
	case 13:
		goto __18
	case 14:
		goto __19
	case 15:
		goto __20
	case 16:
		goto __21
	case 17:
		goto __22
	case 3:
		goto __23
	case 4:
		goto __24
	case 5:
		goto __25
	case 6:
		goto __26
	case 7:
		goto __27
	case 8:
		goto __28
	}
	goto __13
__14:
	if !(*(*int32)(unsafe.Pointer((*ReCompiled)(unsafe.Pointer(pRe)).FaArg + uintptr(x1)*4)) == c) {
		goto __29
	}
	re_add_state(tls, pNext, (x1 + 1))
__29:
	;
	goto __13
__15:
	re_add_state(tls, pNext, (x1 + 1))
	goto __13
__16:
	if !(re_word_char(tls, c) != 0) {
		goto __30
	}
	re_add_state(tls, pNext, (x1 + 1))
__30:
	;
	goto __13
__17:
	if !(!(re_word_char(tls, c) != 0)) {
		goto __31
	}
	re_add_state(tls, pNext, (x1 + 1))
__31:
	;
	goto __13
__18:
	if !(re_digit_char(tls, c) != 0) {
		goto __32
	}
	re_add_state(tls, pNext, (x1 + 1))
__32:
	;
	goto __13
__19:
	if !(!(re_digit_char(tls, c) != 0)) {
		goto __33
	}
	re_add_state(tls, pNext, (x1 + 1))
__33:
	;
	goto __13
__20:
	if !(re_space_char(tls, c) != 0) {
		goto __34
	}
	re_add_state(tls, pNext, (x1 + 1))
__34:
	;
	goto __13
__21:
	if !(!(re_space_char(tls, c) != 0)) {
		goto __35
	}
	re_add_state(tls, pNext, (x1 + 1))
__35:
	;
	goto __13
__22:
	if !(re_word_char(tls, c) != re_word_char(tls, cPrev)) {
		goto __36
	}
	re_add_state(tls, pThis, (x1 + 1))
__36:
	;
	goto __13
__23:
	re_add_state(tls, pNext, x1)
	re_add_state(tls, pThis, (x1 + 1))
	goto __13
__24:
	re_add_state(tls, pThis, (x1 + *(*int32)(unsafe.Pointer((*ReCompiled)(unsafe.Pointer(pRe)).FaArg + uintptr(x1)*4))))
	re_add_state(tls, pThis, (x1 + 1))
	goto __13
__25:
	re_add_state(tls, pThis, (x1 + *(*int32)(unsafe.Pointer((*ReCompiled)(unsafe.Pointer(pRe)).FaArg + uintptr(x1)*4))))
	goto __13
__26:
	rc = 1
	goto re_match_end
__27:
__28:
	j = 1
	n = *(*int32)(unsafe.Pointer((*ReCompiled)(unsafe.Pointer(pRe)).FaArg + uintptr(x1)*4))
	hit = 0
	j = 1
__37:
	if !((j > 0) && (j < n)) {
		goto __39
	}
	if !(int32(*(*int8)(unsafe.Pointer((*ReCompiled)(unsafe.Pointer(pRe)).FaOp + uintptr((x1 + j))))) == 9) {
		goto __40
	}
	if !(*(*int32)(unsafe.Pointer((*ReCompiled)(unsafe.Pointer(pRe)).FaArg + uintptr((x1+j))*4)) == c) {
		goto __42
	}
	hit = 1
	j = -1
__42:
	;
	goto __41
__40:
	if !((*(*int32)(unsafe.Pointer((*ReCompiled)(unsafe.Pointer(pRe)).FaArg + uintptr((x1+j))*4)) <= c) && (*(*int32)(unsafe.Pointer((*ReCompiled)(unsafe.Pointer(pRe)).FaArg + uintptr(((x1+j)+1))*4)) >= c)) {
		goto __43
	}
	hit = 1
	j = -1
	goto __44
__43:
	j++
__44:
	;
__41:
	;
	goto __38
__38:
	j++
	goto __37
	goto __39
__39:
	;
	if !(int32(*(*int8)(unsafe.Pointer((*ReCompiled)(unsafe.Pointer(pRe)).FaOp + uintptr(x1)))) == 8) {
		goto __45
	}
	hit = crt.BoolInt32(!(hit != 0))
__45:
	;
	if !(hit != 0) {
		goto __46
	}
	re_add_state(tls, pNext, (x1 + n))
__46:
	;
	goto __13
__13:
	;
	goto __11
__11:
	i++
	goto __10
	goto __12
__12:
	;
	goto __8
__9:
	;
	i = uint32(0)
__47:
	if !(i < (*ReStateSet)(unsafe.Pointer(pNext)).FnState) {
		goto __49
	}
	if !(int32(*(*int8)(unsafe.Pointer((*ReCompiled)(unsafe.Pointer(pRe)).FaOp + uintptr(*(*ReStateNumber)(unsafe.Pointer((*ReStateSet)(unsafe.Pointer(pNext)).FaState + uintptr(i)*2)))))) == 6) {
		goto __50
	}
	rc = 1
	goto __49
__50:
	;
	goto __48
__48:
	i++
	goto __47
	goto __49
__49:
	;
re_match_end:
	sqlite3.Xsqlite3_free(tls, pToFree)
	return rc
}

// Resize the opcode and argument arrays for an RE under construction.
func re_resize(tls *crt.TLS, p uintptr, N int32) int32 { /* regexp.c:337:12: */
	var aOp uintptr
	var aArg uintptr
	aOp = sqlite3.Xsqlite3_realloc64(tls, (*ReCompiled)(unsafe.Pointer(p)).FaOp, (uint64(uint64(N) * uint64(unsafe.Sizeof(int8(0))))))
	if aOp == uintptr(0) {
		return 1
	}
	(*ReCompiled)(unsafe.Pointer(p)).FaOp = aOp
	aArg = sqlite3.Xsqlite3_realloc64(tls, (*ReCompiled)(unsafe.Pointer(p)).FaArg, (uint64(uint64(N) * uint64(unsafe.Sizeof(int32(0))))))
	if aArg == uintptr(0) {
		return 1
	}
	(*ReCompiled)(unsafe.Pointer(p)).FaArg = aArg
	(*ReCompiled)(unsafe.Pointer(p)).FnAlloc = uint32(N)
	return 0
}

// Insert a new opcode and argument into an RE under construction.  The
// insertion point is just prior to existing opcode iBefore.
func re_insert(tls *crt.TLS, p uintptr, iBefore int32, op int32, arg int32) int32 { /* regexp.c:353:12: */
	var i int32
	if ((*ReCompiled)(unsafe.Pointer(p)).FnAlloc <= (*ReCompiled)(unsafe.Pointer(p)).FnState) && (re_resize(tls, p, (int32((*ReCompiled)(unsafe.Pointer(p)).FnAlloc*uint32(2)))) != 0) {
		return 0
	}
	for i = int32((*ReCompiled)(unsafe.Pointer(p)).FnState); i > iBefore; i-- {
		*(*int8)(unsafe.Pointer((*ReCompiled)(unsafe.Pointer(p)).FaOp + uintptr(i))) = *(*int8)(unsafe.Pointer((*ReCompiled)(unsafe.Pointer(p)).FaOp + uintptr((i - 1))))
		*(*int32)(unsafe.Pointer((*ReCompiled)(unsafe.Pointer(p)).FaArg + uintptr(i)*4)) = *(*int32)(unsafe.Pointer((*ReCompiled)(unsafe.Pointer(p)).FaArg + uintptr((i-1))*4))
	}
	(*ReCompiled)(unsafe.Pointer(p)).FnState++
	*(*int8)(unsafe.Pointer((*ReCompiled)(unsafe.Pointer(p)).FaOp + uintptr(iBefore))) = int8(op)
	*(*int32)(unsafe.Pointer((*ReCompiled)(unsafe.Pointer(p)).FaArg + uintptr(iBefore)*4)) = arg
	return iBefore
}

// Append a new opcode and argument to the end of the RE under construction.
func re_append(tls *crt.TLS, p uintptr, op int32, arg int32) int32 { /* regexp.c:368:12: */
	return re_insert(tls, p, int32((*ReCompiled)(unsafe.Pointer(p)).FnState), op, arg)
}

// Make a copy of N opcodes starting at iStart onto the end of the RE
// under construction.
func re_copy(tls *crt.TLS, p uintptr, iStart int32, N int32) { /* regexp.c:375:13: */
	if (((*ReCompiled)(unsafe.Pointer(p)).FnState + uint32(N)) >= (*ReCompiled)(unsafe.Pointer(p)).FnAlloc) && (re_resize(tls, p, (int32(((*ReCompiled)(unsafe.Pointer(p)).FnAlloc*uint32(2))+uint32(N)))) != 0) {
		return
	}
	crt.Xmemcpy(tls, ((*ReCompiled)(unsafe.Pointer(p)).FaOp + uintptr((*ReCompiled)(unsafe.Pointer(p)).FnState)), ((*ReCompiled)(unsafe.Pointer(p)).FaOp + uintptr(iStart)), (uint64(N) * uint64(unsafe.Sizeof(int8(0)))))
	crt.Xmemcpy(tls, ((*ReCompiled)(unsafe.Pointer(p)).FaArg + uintptr((*ReCompiled)(unsafe.Pointer(p)).FnState)*4), ((*ReCompiled)(unsafe.Pointer(p)).FaArg + uintptr(iStart)*4), (uint64(N) * uint64(unsafe.Sizeof(int32(0)))))
	*(*uint32)(unsafe.Pointer(p + 64 /* &.nState */)) += (uint32(N))
}

// Return true if c is a hexadecimal digit character:  [0-9a-fA-F]
// If c is a hex digit, also set *pV = (*pV)*16 + valueof(c).  If
// c is not a hex digit *pV is unchanged.
func re_hex(tls *crt.TLS, c int32, pV uintptr) int32 { /* regexp.c:386:12: */
	if (c >= '0') && (c <= '9') {
		c = c - ('0')
	} else if (c >= 'a') && (c <= 'f') {
		c = c - ('a' - 10)
	} else if (c >= 'A') && (c <= 'F') {
		c = c - ('A' - 10)
	} else {
		return 0
	}
	*(*int32)(unsafe.Pointer(pV)) = (((*(*int32)(unsafe.Pointer(pV))) * 16) + (c & 0xff))
	return 1
}

// A backslash character has been seen, read the next character and
// return its interpretation.
func re_esc_char(tls *crt.TLS, p uintptr) uint32 { /* regexp.c:403:17: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var i int32
	*(*int32)(unsafe.Pointer(bp /* v */)) = 0
	var c int8
	if (*ReCompiled)(unsafe.Pointer(p)).FsIn.Fi >= (*ReCompiled)(unsafe.Pointer(p)).FsIn.Fmx {
		return uint32(0)
	}
	c = int8(*(*uint8)(unsafe.Pointer((*ReCompiled)(unsafe.Pointer(p)).FsIn.Fz + uintptr((*ReCompiled)(unsafe.Pointer(p)).FsIn.Fi))))
	if (int32(c) == 'u') && (((*ReCompiled)(unsafe.Pointer(p)).FsIn.Fi + 4) < (*ReCompiled)(unsafe.Pointer(p)).FsIn.Fmx) {
		var zIn uintptr = ((*ReCompiled)(unsafe.Pointer(p)).FsIn.Fz + uintptr((*ReCompiled)(unsafe.Pointer(p)).FsIn.Fi))
		if (((re_hex(tls, int32(*(*uint8)(unsafe.Pointer(zIn + uintptr(1)))), bp /* &v */) != 0) &&
			(re_hex(tls, int32(*(*uint8)(unsafe.Pointer(zIn + uintptr(2)))), bp /* &v */) != 0)) &&
			(re_hex(tls, int32(*(*uint8)(unsafe.Pointer(zIn + uintptr(3)))), bp /* &v */) != 0)) &&
			(re_hex(tls, int32(*(*uint8)(unsafe.Pointer(zIn + uintptr(4)))), bp /* &v */) != 0) {
			*(*int32)(unsafe.Pointer(p /* &.sIn */ + 8 /* &.i */)) += (5)
			return uint32(*(*int32)(unsafe.Pointer(bp /* v */)))
		}
	}
	if (int32(c) == 'x') && (((*ReCompiled)(unsafe.Pointer(p)).FsIn.Fi + 2) < (*ReCompiled)(unsafe.Pointer(p)).FsIn.Fmx) {
		var zIn uintptr = ((*ReCompiled)(unsafe.Pointer(p)).FsIn.Fz + uintptr((*ReCompiled)(unsafe.Pointer(p)).FsIn.Fi))
		if (re_hex(tls, int32(*(*uint8)(unsafe.Pointer(zIn + uintptr(1)))), bp /* &v */) != 0) &&
			(re_hex(tls, int32(*(*uint8)(unsafe.Pointer(zIn + uintptr(2)))), bp /* &v */) != 0) {
			*(*int32)(unsafe.Pointer(p /* &.sIn */ + 8 /* &.i */)) += (3)
			return uint32(*(*int32)(unsafe.Pointer(bp /* v */)))
		}
	}
	for i = 0; (zEsc[i] != 0) && (int32(zEsc[i]) != int32(c)); i++ {
	}
	if zEsc[i] != 0 {
		if i < 6 {
			c = zTrans[i]
		}
		(*ReCompiled)(unsafe.Pointer(p)).FsIn.Fi++
	} else {
		(*ReCompiled)(unsafe.Pointer(p)).FzErr = ts + 5927 /* "unknown \\ escape" */
	}
	return uint32(c)
}

var zEsc = *(*[21]int8)(unsafe.Pointer(ts + 5944 /* "afnrtv\\()*.+?[$^..." */)) /* regexp.c:404:21 */
var zTrans = *(*[7]int8)(unsafe.Pointer(ts + 5965 /* "\a\f\n\r\t\v" */))        /* regexp.c:405:21 */

// Peek at the next byte of input
func rePeek(tls *crt.TLS, p uintptr) uint8 { /* regexp.c:444:22: */
	if (*ReCompiled)(unsafe.Pointer(p)).FsIn.Fi < (*ReCompiled)(unsafe.Pointer(p)).FsIn.Fmx {
		return *(*uint8)(unsafe.Pointer((*ReCompiled)(unsafe.Pointer(p)).FsIn.Fz + uintptr((*ReCompiled)(unsafe.Pointer(p)).FsIn.Fi)))
	}
	return uint8(0)
}

// Compile RE text into a sequence of opcodes.  Continue up to the
// first unmatched ")" character, then return.  If an error is found,
// return a pointer to the error message string.
func re_subcompile_re(tls *crt.TLS, p uintptr) uintptr { /* regexp.c:452:19: */
	var zErr uintptr
	var iStart int32
	var iEnd int32
	var iGoto int32
	iStart = int32((*ReCompiled)(unsafe.Pointer(p)).FnState)
	zErr = re_subcompile_string(tls, p)
	if zErr != 0 {
		return zErr
	}
	for int32(rePeek(tls, p)) == '|' {
		iEnd = int32((*ReCompiled)(unsafe.Pointer(p)).FnState)
		re_insert(tls, p, iStart, 4, ((iEnd + 2) - iStart))
		iGoto = re_append(tls, p, 5, 0)
		(*ReCompiled)(unsafe.Pointer(p)).FsIn.Fi++
		zErr = re_subcompile_string(tls, p)
		if zErr != 0 {
			return zErr
		}
		*(*int32)(unsafe.Pointer((*ReCompiled)(unsafe.Pointer(p)).FaArg + uintptr(iGoto)*4)) = (int32((*ReCompiled)(unsafe.Pointer(p)).FnState - uint32(iGoto)))
	}
	return uintptr(0)
}

// Compile an element of regular expression text (anything that can be
// an operand to the "|" operator).  Return NULL on success or a pointer
// to the error message if there is a problem.
func re_subcompile_string(tls *crt.TLS, p uintptr) uintptr { /* regexp.c:474:19: */
	var iPrev int32 = -1
	var iStart int32
	var c uint32
	var zErr uintptr
	for (crt.AssignUint32(&c, (*(*func(*crt.TLS, uintptr) uint32)(unsafe.Pointer((p + 40 /* &.xNextChar */))))(tls, (p /* &.sIn */)))) != uint32(0) {
		iStart = int32((*ReCompiled)(unsafe.Pointer(p)).FnState)
		switch c {
		case uint32('|'):
			fallthrough
		case uint32('$'):
			fallthrough
		case uint32(')'):
			{
				(*ReCompiled)(unsafe.Pointer(p)).FsIn.Fi--
				return uintptr(0)
			}
		case uint32('('):
			{
				zErr = re_subcompile_re(tls, p)
				if zErr != 0 {
					return zErr
				}
				if int32(rePeek(tls, p)) != ')' {
					return ts + 5972 /* "unmatched '('" */
				}
				(*ReCompiled)(unsafe.Pointer(p)).FsIn.Fi++
				break
			}
		case uint32('.'):
			{
				if int32(rePeek(tls, p)) == '*' {
					re_append(tls, p, 3, 0)
					(*ReCompiled)(unsafe.Pointer(p)).FsIn.Fi++
				} else {
					re_append(tls, p, 2, 0)
				}
				break
			}
		case uint32('*'):
			{
				if iPrev < 0 {
					return ts + 5986 /* "'*' without oper..." */
				}
				re_insert(tls, p, iPrev, 5, (int32(((*ReCompiled)(unsafe.Pointer(p)).FnState - uint32(iPrev)) + uint32(1))))
				re_append(tls, p, 4, (int32((uint32(iPrev) - (*ReCompiled)(unsafe.Pointer(p)).FnState) + uint32(1))))
				break
			}
		case uint32('+'):
			{
				if iPrev < 0 {
					return ts + 6006 /* "'+' without oper..." */
				}
				re_append(tls, p, 4, (int32(uint32(iPrev) - (*ReCompiled)(unsafe.Pointer(p)).FnState)))
				break
			}
		case uint32('?'):
			{
				if iPrev < 0 {
					return ts + 6026 /* "'?' without oper..." */
				}
				re_insert(tls, p, iPrev, 4, (int32(((*ReCompiled)(unsafe.Pointer(p)).FnState - uint32(iPrev)) + uint32(1))))
				break
			}
		case uint32('{'):
			{
				var m int32 = 0
				var n int32 = 0
				var sz int32
				var j int32
				if iPrev < 0 {
					return ts + 6046 /* "'{m,n}' without ..." */
				}
				for ((crt.AssignUint32(&c, uint32(rePeek(tls, p)))) >= uint32('0')) && (c <= uint32('9')) {
					m = (int32(((uint32(m * 10)) + c) - uint32('0')))
					(*ReCompiled)(unsafe.Pointer(p)).FsIn.Fi++
				}
				n = m
				if c == uint32(',') {
					(*ReCompiled)(unsafe.Pointer(p)).FsIn.Fi++
					n = 0
					for ((crt.AssignUint32(&c, uint32(rePeek(tls, p)))) >= uint32('0')) && (c <= uint32('9')) {
						n = (int32(((uint32(n * 10)) + c) - uint32('0')))
						(*ReCompiled)(unsafe.Pointer(p)).FsIn.Fi++
					}
				}
				if c != uint32('}') {
					return ts + 6070 /* "unmatched '{'" */
				}
				if (n > 0) && (n < m) {
					return ts + 6084 /* "n less than m in..." */
				}
				(*ReCompiled)(unsafe.Pointer(p)).FsIn.Fi++
				sz = (int32((*ReCompiled)(unsafe.Pointer(p)).FnState - uint32(iPrev)))
				if m == 0 {
					if n == 0 {
						return ts + 6109 /* "both m and n are..." */
					}
					re_insert(tls, p, iPrev, 4, (sz + 1))
					n--
				} else {
					for j = 1; j < m; j++ {
						re_copy(tls, p, iPrev, sz)
					}
				}
				for j = m; j < n; j++ {
					re_append(tls, p, 4, (sz + 1))
					re_copy(tls, p, iPrev, sz)
				}
				if (n == 0) && (m > 0) {
					re_append(tls, p, 4, -sz)
				}
				break
			}
		case uint32('['):
			{
				var iFirst int32 = int32((*ReCompiled)(unsafe.Pointer(p)).FnState)
				if int32(rePeek(tls, p)) == '^' {
					re_append(tls, p, 8, 0)
					(*ReCompiled)(unsafe.Pointer(p)).FsIn.Fi++
				} else {
					re_append(tls, p, 7, 0)
				}
				for (crt.AssignUint32(&c, (*(*func(*crt.TLS, uintptr) uint32)(unsafe.Pointer((p + 40 /* &.xNextChar */))))(tls, (p /* &.sIn */)))) != uint32(0) {
					if (c == uint32('[')) && (int32(rePeek(tls, p)) == ':') {
						return ts + 6142 /* "POSIX character ..." */
					}
					if c == uint32('\\') {
						c = re_esc_char(tls, p)
					}
					if int32(rePeek(tls, p)) == '-' {
						re_append(tls, p, 10, int32(c))
						(*ReCompiled)(unsafe.Pointer(p)).FsIn.Fi++
						c = (*(*func(*crt.TLS, uintptr) uint32)(unsafe.Pointer((p + 40 /* &.xNextChar */))))(tls, (p /* &.sIn */))
						if c == uint32('\\') {
							c = re_esc_char(tls, p)
						}
						re_append(tls, p, 10, int32(c))
					} else {
						re_append(tls, p, 9, int32(c))
					}
					if int32(rePeek(tls, p)) == ']' {
						(*ReCompiled)(unsafe.Pointer(p)).FsIn.Fi++
						break
					}
				}
				if c == uint32(0) {
					return ts + 6180 /* "unclosed '['" */
				}
				*(*int32)(unsafe.Pointer((*ReCompiled)(unsafe.Pointer(p)).FaArg + uintptr(iFirst)*4)) = (int32((*ReCompiled)(unsafe.Pointer(p)).FnState - uint32(iFirst)))
				break
			}
		case uint32('\\'):
			{
				var specialOp int32 = 0
				switch int32(rePeek(tls, p)) {
				case 'b':
					specialOp = 17
					break
				case 'd':
					specialOp = 13
					break
				case 'D':
					specialOp = 14
					break
				case 's':
					specialOp = 15
					break
				case 'S':
					specialOp = 16
					break
				case 'w':
					specialOp = 11
					break
				case 'W':
					specialOp = 12
					break
				}
				if specialOp != 0 {
					(*ReCompiled)(unsafe.Pointer(p)).FsIn.Fi++
					re_append(tls, p, specialOp, 0)
				} else {
					c = re_esc_char(tls, p)
					re_append(tls, p, 1, int32(c))
				}
				break
			}
		default:
			{
				re_append(tls, p, 1, int32(c))
				break
			}
		}
		iPrev = iStart
	}
	return uintptr(0)
}

// Free and reclaim all the memory used by a previously compiled
// regular expression.  Applications should invoke this routine once
// for every call to re_compile() to avoid memory leaks.
func sqlite3re_free(tls *crt.TLS, pRe uintptr) { /* regexp.c:613:13: */
	if pRe != 0 {
		sqlite3.Xsqlite3_free(tls, (*ReCompiled)(unsafe.Pointer(pRe)).FaOp)
		sqlite3.Xsqlite3_free(tls, (*ReCompiled)(unsafe.Pointer(pRe)).FaArg)
		sqlite3.Xsqlite3_free(tls, pRe)
	}
}

// Compile a textual regular expression in zIn[] into a compiled regular
// expression suitable for us by re_match() and return a pointer to the
// compiled regular expression in *ppRe.  Return NULL on success or an
// error message if something goes wrong.
func sqlite3re_compile(tls *crt.TLS, ppRe uintptr, zIn uintptr, noCase int32) uintptr { /* regexp.c:627:19: */
	var pRe uintptr
	var zErr uintptr
	var i int32
	var j int32

	*(*uintptr)(unsafe.Pointer(ppRe)) = uintptr(0)
	pRe = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(ReCompiled{})))
	if pRe == uintptr(0) {
		return ts + 2471 /* "out of memory" */
	}
	crt.Xmemset(tls, pRe, 0, uint64(unsafe.Sizeof(ReCompiled{})))
	(*ReCompiled)(unsafe.Pointer(pRe)).FxNextChar = func() uintptr {
		if noCase != 0 {
			return *(*uintptr)(unsafe.Pointer(&struct {
				f func(*crt.TLS, uintptr) uint32
			}{re_next_char_nocase}))
		}
		return *(*uintptr)(unsafe.Pointer(&struct {
			f func(*crt.TLS, uintptr) uint32
		}{re_next_char}))
	}()
	if re_resize(tls, pRe, 30) != 0 {
		sqlite3re_free(tls, pRe)
		return ts + 2471 /* "out of memory" */
	}
	if int32(*(*int8)(unsafe.Pointer(zIn + uintptr(0)))) == '^' {
		zIn++
	} else {
		re_append(tls, pRe, 3, 0)
	}
	(*ReCompiled)(unsafe.Pointer(pRe)).FsIn.Fz = zIn
	(*ReCompiled)(unsafe.Pointer(pRe)).FsIn.Fi = 0
	(*ReCompiled)(unsafe.Pointer(pRe)).FsIn.Fmx = int32(crt.Xstrlen(tls, zIn))
	zErr = re_subcompile_re(tls, pRe)
	if zErr != 0 {
		sqlite3re_free(tls, pRe)
		return zErr
	}
	if (int32(rePeek(tls, pRe)) == '$') && (((*ReCompiled)(unsafe.Pointer(pRe)).FsIn.Fi + 1) >= (*ReCompiled)(unsafe.Pointer(pRe)).FsIn.Fmx) {
		re_append(tls, pRe, 1, 0)
		re_append(tls, pRe, 6, 0)
		*(*uintptr)(unsafe.Pointer(ppRe)) = pRe
	} else if (*ReCompiled)(unsafe.Pointer(pRe)).FsIn.Fi >= (*ReCompiled)(unsafe.Pointer(pRe)).FsIn.Fmx {
		re_append(tls, pRe, 6, 0)
		*(*uintptr)(unsafe.Pointer(ppRe)) = pRe
	} else {
		sqlite3re_free(tls, pRe)
		return ts + 6193 /* "unrecognized cha..." */
	}

	// The following is a performance optimization.  If the regex begins with
	// ".*" (if the input regex lacks an initial "^") and afterwards there are
	// one or more matching characters, enter those matching characters into
	// zInit[].  The re_match() routine can then search ahead in the input
	// string looking for the initial match without having to run the whole
	// regex engine over the string.  Do not worry able trying to match
	// unicode characters beyond plane 0 - those are very rare and this is
	// just an optimization.
	if int32(*(*int8)(unsafe.Pointer((*ReCompiled)(unsafe.Pointer(pRe)).FaOp + uintptr(0)))) == 3 {
		j = 0
		i = 1
		for ; (uint64(j) < (uint64(unsafe.Sizeof([12]uint8{})) - uint64(2))) && (int32(*(*int8)(unsafe.Pointer((*ReCompiled)(unsafe.Pointer(pRe)).FaOp + uintptr(i)))) == 1); i++ {
			var x uint32 = uint32(*(*int32)(unsafe.Pointer((*ReCompiled)(unsafe.Pointer(pRe)).FaArg + uintptr(i)*4)))
			if x <= uint32(127) {
				*(*uint8)(unsafe.Pointer((pRe + 48 /* &.zInit */) + uintptr(crt.PostIncInt32(&j, 1)))) = uint8(x)
			} else if x <= uint32(0xfff) {
				*(*uint8)(unsafe.Pointer((pRe + 48 /* &.zInit */) + uintptr(crt.PostIncInt32(&j, 1)))) = (uint8(uint32(0xc0) | (x >> 6)))
				*(*uint8)(unsafe.Pointer((pRe + 48 /* &.zInit */) + uintptr(crt.PostIncInt32(&j, 1)))) = (uint8(uint32(0x80) | (x & uint32(0x3f))))
			} else if x <= uint32(0xffff) {
				*(*uint8)(unsafe.Pointer((pRe + 48 /* &.zInit */) + uintptr(crt.PostIncInt32(&j, 1)))) = (uint8(uint32(0xd0) | (x >> 12)))
				*(*uint8)(unsafe.Pointer((pRe + 48 /* &.zInit */) + uintptr(crt.PostIncInt32(&j, 1)))) = (uint8(uint32(0x80) | ((x >> 6) & uint32(0x3f))))
				*(*uint8)(unsafe.Pointer((pRe + 48 /* &.zInit */) + uintptr(crt.PostIncInt32(&j, 1)))) = (uint8(uint32(0x80) | (x & uint32(0x3f))))
			} else {
				break
			}
		}
		if (j > 0) && (int32(*(*uint8)(unsafe.Pointer((pRe + 48 /* &.zInit */) + uintptr((j - 1))))) == 0) {
			j--
		}
		(*ReCompiled)(unsafe.Pointer(pRe)).FnInit = j
	}
	return (*ReCompiled)(unsafe.Pointer(pRe)).FzErr
}

// Implementation of the regexp() SQL function.  This function implements
// the build-in REGEXP operator.  The first argument to the function is the
// pattern and the second argument is the string.  So, the SQL statements:
//
//       A REGEXP B
//
// is implemented as regexp(B,A).
func re_sql_func(tls *crt.TLS, context uintptr, argc int32, argv uintptr) { /* regexp.c:707:13: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// var pRe uintptr at bp, 8
	// Compiled regular expression
	var zPattern uintptr // The regular expression
	var zStr uintptr     // String being searched
	var zErr uintptr     // Compile error message
	var setAux int32 = 0 // True to invoke sqlite3_set_auxdata()

	*(*uintptr)(unsafe.Pointer(bp /* pRe */)) = sqlite3.Xsqlite3_get_auxdata(tls, context, 0)
	if *(*uintptr)(unsafe.Pointer(bp /* pRe */)) == uintptr(0) {
		zPattern = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)))
		if zPattern == uintptr(0) {
			return
		}
		zErr = sqlite3re_compile(tls, bp /* &pRe */, zPattern, 0)
		if zErr != 0 {
			sqlite3re_free(tls, *(*uintptr)(unsafe.Pointer(bp /* pRe */)))
			sqlite3.Xsqlite3_result_error(tls, context, zErr, -1)
			return
		}
		if *(*uintptr)(unsafe.Pointer(bp /* pRe */)) == uintptr(0) {
			sqlite3.Xsqlite3_result_error_nomem(tls, context)
			return
		}
		setAux = 1
	}
	zStr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)))
	if zStr != uintptr(0) {
		sqlite3.Xsqlite3_result_int(tls, context, sqlite3re_match(tls, *(*uintptr)(unsafe.Pointer(bp /* pRe */)), zStr, -1))
	}
	if setAux != 0 {
		sqlite3.Xsqlite3_set_auxdata(tls, context, 0, *(*uintptr)(unsafe.Pointer(bp /* pRe */)), *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, uintptr) }{sqlite3re_free})))
	}
}

// Invoke this routine to register the regexp() function with the
// SQLite database connection.
func sqlite3_regexp_init(tls *crt.TLS, db uintptr, pzErrMsg uintptr, pApi uintptr) int32 { /* regexp.c:750:5: */
	var rc int32 = 0
	_ = pApi

	rc = sqlite3.Xsqlite3_create_function(tls, db, ts+6216 /* "regexp" */, 2, (1 | 0x000200000),
		uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
			f func(*crt.TLS, uintptr, int32, uintptr)
		}{re_sql_func})), uintptr(0), uintptr(0))
	return rc
}

// When possible, define assert so that it does not add extra
//   parentheses around EXPR.  Otherwise, those added parentheses would
//   suppress warnings we'd expect to be detected by gcc's -Wparentheses.

// Version 2.4 and later of GCC define a magical variable `__PRETTY_FUNCTION__'
//   which contains the name of the function currently being defined.
//   This is broken in G++ before version 2.6.
//   C9x has a similar variable called __func__, but prefer the GCC one since
//   it demangles C++ function names.

//      remember(V,PTR)
//
// Return the integer value V.  Also save the value of V in a
// C-language variable whose address is PTR.
func rememberFunc(tls *crt.TLS, pCtx uintptr, argc int32, argv uintptr) { /* remember.c:45:13: */
	var v sqlite3_int64
	var ptr uintptr
	if !(argc == 2) {
		crt.X__assert_fail(tls, ts+1318 /* "argc==2" */, ts+6223 /* "testdata/sqlite-..." */, uint32(52), uintptr(unsafe.Pointer(&__func__28)))
	}
	v = sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)))
	ptr = sqlite3.Xsqlite3_value_pointer(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), ts+3452 /* "carray" */)
	if ptr != 0 {
		*(*sqlite3_int64)(unsafe.Pointer(ptr)) = v
	}
	sqlite3.Xsqlite3_result_int64(tls, pCtx, v)
}

var __func__28 = *(*[13]int8)(unsafe.Pointer(ts + 6271 /* "rememberFunc" */)) /* remember.c:49:2 */

func sqlite3_remember_init(tls *crt.TLS, db uintptr, pzErrMsg uintptr, pApi uintptr) int32 { /* remember.c:62:5: */
	var rc int32 = 0
	_ = pApi

	rc = sqlite3.Xsqlite3_create_function(tls, db, ts+6284 /* "remember" */, 2, 1, uintptr(0),
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*crt.TLS, uintptr, int32, uintptr)
		}{rememberFunc})), uintptr(0), uintptr(0))
	return rc
}

// series_cursor is a subclass of sqlite3_vtab_cursor which will
// serve as the underlying representation of a cursor that scans
// over rows of the result
type series_cursor1 = struct {
	Fbase    sqlite3_vtab_cursor
	FisDesc  int32
	FiRowid  sqlite3_int64
	FiValue  sqlite3_int64
	FmnValue sqlite3_int64
	FmxValue sqlite3_int64
	FiStep   sqlite3_int64
}

// series_cursor is a subclass of sqlite3_vtab_cursor which will
// serve as the underlying representation of a cursor that scans
// over rows of the result
type series_cursor = series_cursor1 /* series.c:83:30 */

// The seriesConnect() method is invoked to create a new
// series_vtab that describes the generate_series virtual table.
//
// Think of this routine as the constructor for series_vtab objects.
//
// All this routine needs to do is:
//
//    (1) Allocate the series_vtab object and initialize all fields.
//
//    (2) Tell SQLite (via the sqlite3_declare_vtab() interface) what the
//        result set of queries against generate_series will look like.
func seriesConnect(tls *crt.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVtab uintptr, pzErr uintptr) int32 { /* series.c:107:12: */
	var pNew uintptr
	var rc int32

	// Column numbers

	rc = sqlite3.Xsqlite3_declare_vtab(tls, db,
		ts+6293 /* "CREATE TABLE x(v..." */)
	if rc == 0 {
		pNew = crt.AssignPtrUintptr(ppVtab, sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(sqlite3_vtab{}))))
		if pNew == uintptr(0) {
			return 7
		}
		crt.Xmemset(tls, pNew, 0, uint64(unsafe.Sizeof(sqlite3_vtab{})))
		sqlite3.Xsqlite3_vtab_config(tls, db, 2, 0)
	}
	return rc
}

// This method is the destructor for series_cursor objects.
func seriesDisconnect(tls *crt.TLS, pVtab uintptr) int32 { /* series.c:137:12: */
	sqlite3.Xsqlite3_free(tls, pVtab)
	return 0
}

// Constructor for a new series_cursor object.
func seriesOpen(tls *crt.TLS, p uintptr, ppCursor uintptr) int32 { /* series.c:145:12: */
	var pCur uintptr
	pCur = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(series_cursor{})))
	if pCur == uintptr(0) {
		return 7
	}
	crt.Xmemset(tls, pCur, 0, uint64(unsafe.Sizeof(series_cursor{})))
	*(*uintptr)(unsafe.Pointer(ppCursor)) = (pCur /* &.base */)
	return 0
}

// Destructor for a series_cursor.
func seriesClose(tls *crt.TLS, cur uintptr) int32 { /* series.c:157:12: */
	sqlite3.Xsqlite3_free(tls, cur)
	return 0
}

// Advance a series_cursor to its next row of output.
func seriesNext(tls *crt.TLS, cur uintptr) int32 { /* series.c:166:12: */
	var pCur uintptr = cur
	if (*series_cursor)(unsafe.Pointer(pCur)).FisDesc != 0 {
		*(*sqlite3_int64)(unsafe.Pointer(pCur + 24 /* &.iValue */)) -= ((*series_cursor)(unsafe.Pointer(pCur)).FiStep)
	} else {
		*(*sqlite3_int64)(unsafe.Pointer(pCur + 24 /* &.iValue */)) += ((*series_cursor)(unsafe.Pointer(pCur)).FiStep)
	}
	(*series_cursor)(unsafe.Pointer(pCur)).FiRowid++
	return 0
}

// Return values of columns for the row at which the series_cursor
// is currently pointing.
func seriesColumn(tls *crt.TLS, cur uintptr, ctx uintptr, i int32) int32 { /* series.c:181:12: */
	var pCur uintptr = cur
	var x sqlite3_int64 = int64(0)
	switch i {
	case 1:
		x = (*series_cursor)(unsafe.Pointer(pCur)).FmnValue
		break
	case 2:
		x = (*series_cursor)(unsafe.Pointer(pCur)).FmxValue
		break
	case 3:
		x = (*series_cursor)(unsafe.Pointer(pCur)).FiStep
		break
	default:
		x = (*series_cursor)(unsafe.Pointer(pCur)).FiValue
		break
	}
	sqlite3.Xsqlite3_result_int64(tls, ctx, x)
	return 0
}

// Return the rowid for the current row. In this implementation, the
// first row returned is assigned rowid value 1, and each subsequent
// row a value 1 more than that of the previous.
func seriesRowid(tls *crt.TLS, cur uintptr, pRowid uintptr) int32 { /* series.c:203:12: */
	var pCur uintptr = cur
	*(*sqlite_int64)(unsafe.Pointer(pRowid)) = (*series_cursor)(unsafe.Pointer(pCur)).FiRowid
	return 0
}

// Return TRUE if the cursor has been moved off of the last
// row of output.
func seriesEof(tls *crt.TLS, cur uintptr) int32 { /* series.c:213:12: */
	var pCur uintptr = cur
	if (*series_cursor)(unsafe.Pointer(pCur)).FisDesc != 0 {
		return (crt.Bool32((*series_cursor)(unsafe.Pointer(pCur)).FiValue < (*series_cursor)(unsafe.Pointer(pCur)).FmnValue))
	} else {
		return (crt.Bool32((*series_cursor)(unsafe.Pointer(pCur)).FiValue > (*series_cursor)(unsafe.Pointer(pCur)).FmxValue))
	}
	return int32(0)
}

// True to cause run-time checking of the start=, stop=, and/or step=
// parameters.  The only reason to do this is for testing the
// constraint checking logic for virtual tables in the SQLite core.

// This method is called to "rewind" the series_cursor object back
// to the first row of output.  This method is always called at least
// once prior to any call to seriesColumn() or seriesRowid() or
// seriesEof().
//
// The query plan selected by seriesBestIndex is passed in the idxNum
// parameter.  (idxStr is not used in this implementation.)  idxNum
// is a bitmask showing which constraints are available:
//
//    1:    start=VALUE
//    2:    stop=VALUE
//    4:    step=VALUE
//
// Also, if bit 8 is set, that means that the series should be output
// in descending order rather than in ascending order.
//
// This routine should initialize the cursor and position it so that it
// is pointing at the first row, or pointing off the end of the table
// (so that seriesEof() will return true) if the table is empty.
func seriesFilter(tls *crt.TLS, pVtabCursor uintptr, idxNum int32, idxStr uintptr, argc int32, argv uintptr) int32 { /* series.c:251:12: */
	var pCur uintptr = pVtabCursor
	var i int32 = 0
	if (idxNum & 1) != 0 {
		(*series_cursor)(unsafe.Pointer(pCur)).FmnValue = sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(crt.PostIncInt32(&i, 1))*8)))
	} else {
		(*series_cursor)(unsafe.Pointer(pCur)).FmnValue = int64(0)
	}
	if (idxNum & 2) != 0 {
		(*series_cursor)(unsafe.Pointer(pCur)).FmxValue = sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(crt.PostIncInt32(&i, 1))*8)))
	} else {
		(*series_cursor)(unsafe.Pointer(pCur)).FmxValue = int64(0xffffffff)
	}
	if (idxNum & 4) != 0 {
		(*series_cursor)(unsafe.Pointer(pCur)).FiStep = sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(crt.PostIncInt32(&i, 1))*8)))
		if (*series_cursor)(unsafe.Pointer(pCur)).FiStep < int64(1) {
			(*series_cursor)(unsafe.Pointer(pCur)).FiStep = int64(1)
		}
	} else {
		(*series_cursor)(unsafe.Pointer(pCur)).FiStep = int64(1)
	}
	for i = 0; i < argc; i++ {
		if sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8))) == 5 {
			// If any of the constraints have a NULL value, then return no rows.
			// See ticket https://www.sqlite.org/src/info/fac496b61722daf2
			(*series_cursor)(unsafe.Pointer(pCur)).FmnValue = int64(1)
			(*series_cursor)(unsafe.Pointer(pCur)).FmxValue = int64(0)
			break
		}
	}
	if (idxNum & 8) != 0 {
		(*series_cursor)(unsafe.Pointer(pCur)).FisDesc = 1
		(*series_cursor)(unsafe.Pointer(pCur)).FiValue = (*series_cursor)(unsafe.Pointer(pCur)).FmxValue
		if (*series_cursor)(unsafe.Pointer(pCur)).FiStep > int64(0) {
			*(*sqlite3_int64)(unsafe.Pointer(pCur + 24 /* &.iValue */)) -= (((*series_cursor)(unsafe.Pointer(pCur)).FmxValue - (*series_cursor)(unsafe.Pointer(pCur)).FmnValue) % (*series_cursor)(unsafe.Pointer(pCur)).FiStep)
		}
	} else {
		(*series_cursor)(unsafe.Pointer(pCur)).FisDesc = 0
		(*series_cursor)(unsafe.Pointer(pCur)).FiValue = (*series_cursor)(unsafe.Pointer(pCur)).FmnValue
	}
	(*series_cursor)(unsafe.Pointer(pCur)).FiRowid = int64(1)
	return 0
}

// SQLite will invoke this method one or more times while planning a query
// that uses the generate_series virtual table.  This routine needs to create
// a query plan for each invocation and compute an estimated cost for that
// plan.
//
// In this implementation idxNum is used to represent the
// query plan.  idxStr is unused.
//
// The query plan is represented by bits in idxNum:
//
//  (1)  start = $value  -- constraint exists
//  (2)  stop = $value   -- constraint exists
//  (4)  step = $value   -- constraint exists
//  (8)  output in descending order
func seriesBestIndex(tls *crt.TLS, tab uintptr, pIdxInfo uintptr) int32 { /* series.c:313:12: */
	bp := tls.Alloc(12)
	defer tls.Free(12)

	var i int32
	var j int32                // Loop over constraints
	var idxNum int32 = 0       // The query plan bitmask
	var unusableMask int32 = 0 // Mask of unusable constraints
	var nArg int32 = 0         // Number of arguments that seriesFilter() expects
	// var aIdx [3]int32 at bp, 12
	// Constraints on start, stop, and step
	var pConstraint uintptr

	// This implementation assumes that the start, stop, and step columns
	// are the last three columns in the virtual table.
	if !(2 == (1 + 1)) {
		crt.X__assert_fail(tls, ts+6352 /* "2 == 1+1" */, ts+6361 /* "testdata/sqlite-..." */, uint32(326), uintptr(unsafe.Pointer(&__func__29)))
	}
	if !(3 == (1 + 2)) {
		crt.X__assert_fail(tls, ts+6407 /* "3 == 1+2" */, ts+6361 /* "testdata/sqlite-..." */, uint32(327), uintptr(unsafe.Pointer(&__func__29)))
	}
	*(*int32)(unsafe.Pointer(bp /* &aIdx[0] */ + uintptr(0)*4)) = crt.AssignPtrInt32(bp /* &aIdx */ +uintptr(1)*4, crt.AssignPtrInt32(bp /* &aIdx */ +uintptr(2)*4, -1))
	pConstraint = (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraint
	i = 0
__1:
	if !(i < (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnConstraint) {
		goto __3
	}
	{
		var iCol int32  // 0 for start, 1 for stop, 2 for step
		var iMask int32 // bitmask for those column
		if (*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).FiColumn < 1 {
			goto __2
		}
		iCol = ((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).FiColumn - 1)
		if !((iCol >= 0) && (iCol <= 2)) {
			crt.X__assert_fail(tls, ts+6416 /* "iCol>=0 && iCol<..." */, ts+6361 /* "testdata/sqlite-..." */, uint32(335), uintptr(unsafe.Pointer(&__func__29)))
		}
		iMask = (int32(1) << iCol)
		if int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fusable) == 0 {
			unusableMask = unusableMask | (iMask)
			goto __2
		} else if int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == 2 {
			idxNum = idxNum | (iMask)
			*(*int32)(unsafe.Pointer(bp /* &aIdx[0] */ + uintptr(iCol)*4)) = i
		}
	}
	goto __2
__2:
	i++
	pConstraint += 12
	goto __1
	goto __3
__3:
	;
	for i = 0; i < 3; i++ {
		if (crt.AssignInt32(&j, *(*int32)(unsafe.Pointer(bp /* &aIdx[0] */ + uintptr(i)*4)))) >= 0 {
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(j)*8)).FargvIndex = crt.PreIncInt32(&nArg, 1)
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(j)*8)).Fomit = crt.BoolUint8(!(0 != 0))
		}
	}
	if (unusableMask & ^idxNum) != 0 {
		// The start, stop, and step columns are inputs.  Therefore if there
		// are unusable constraints on any of start, stop, or step then
		// this plan is unusable
		return 19
	}
	if (idxNum & 3) == 3 {
		// Both start= and stop= boundaries are available.  This is the
		// the preferred case
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = (float64(2 - (crt.Bool32((idxNum & 4) != 0))))
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedRows = int64(1000)
		if (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnOrderBy == 1 {
			if (*sqlite3_index_orderby)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaOrderBy+uintptr(0)*8)).Fdesc != 0 {
				idxNum = idxNum | (8)
			}
			(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).ForderByConsumed = 1
		}
	} else {
		// If either boundary is missing, we have to generate a huge span
		// of numbers.  Make this case very expensive so that the query
		// planner will work hard to avoid it.
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedRows = int64(2147483647)
	}
	(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxNum = idxNum
	return 0
}

var __func__29 = *(*[16]int8)(unsafe.Pointer(ts + 6435 /* "seriesBestIndex" */)) /* series.c:316:2 */

// This following structure defines all the methods for the
// generate_series virtual table.
var seriesModule = sqlite3_module{FiVersion: 0, FxCreate: // iVersion
uintptr(0), FxConnect:// xCreate
0, FxBestIndex:// xConnect
0, FxDisconnect:// xBestIndex
0, FxDestroy:// xDisconnect
uintptr(0), FxOpen:// xDestroy
0, FxClose:// xOpen - open a cursor
0, FxFilter:// xClose - close a cursor
0, FxNext:// xFilter - configure scan constraints
0, FxEof:// xNext - advance a cursor
0, FxColumn:// xEof - check for end of scan
0, FxRowid:// xColumn - read data
0, FxUpdate:// xRowid - read data
uintptr(0), FxBegin:// xUpdate
uintptr(0), FxSync:// xBegin
uintptr(0), FxCommit:// xSync
uintptr(0), FxRollback:// xCommit
uintptr(0), FxFindFunction:// xRollback
uintptr(0), FxRename:// xFindMethod
uintptr(0), // xRename
} /* series.c:380:23 */

func sqlite3_series_init(tls *crt.TLS, db uintptr, pzErrMsg uintptr, pApi uintptr) int32 { /* series.c:408:5: */
	var rc int32 = 0
	_ = pApi

	if sqlite3.Xsqlite3_libversion_number(tls) < 3008012 {
		*(*uintptr)(unsafe.Pointer(pzErrMsg)) = sqlite3.Xsqlite3_mprintf(tls,
			ts+6451 /* "generate_series(..." */, 0)
		return 1
	}
	rc = sqlite3.Xsqlite3_create_module(tls, db, ts+6501 /* "generate_series" */, uintptr(unsafe.Pointer(&seriesModule)), uintptr(0))
	return rc
}

// Floating-point inline functions for stdlib.h.
//   Copyright (C) 2012-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// Define some macros helping to catch buffer overflows.

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.2 Diagnostics	<assert.h>

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// void assert (int expression);
//
//   If NDEBUG is defined, do nothing.
//   If not, and EXPRESSION is zero, print an error message and abort.

// void assert_perror (int errnum);
//
//   If NDEBUG is defined, do nothing.  If not, and ERRNUM is not zero, print an
//   error message with the error text for ERRNUM and abort.
//   (This is a GNU extension.)

type u8 = uint8   /* spellfix.c:33:25 */
type u16 = uint16 /* spellfix.c:34:26 */

// Character classes for ASCII characters:
//
//   0   ''        Silent letters:   H W
//   1   'A'       Any vowel:   A E I O U (Y)
//   2   'B'       A bilabeal stop or fricative:  B F P V W
//   3   'C'       Other fricatives or back stops:  C G J K Q S X Z
//   4   'D'       Alveolar stops:  D T
//   5   'H'       Letter H at the beginning of a word
//   6   'L'       Glide:  L
//   7   'R'       Semivowel:  R
//   8   'M'       Nasals:  M N
//   9   'Y'       Letter Y at the beginning of a word.
//   10  '9'       Digits: 0 1 2 3 4 5 6 7 8 9
//   11  ' '       White space
//   12  '?'       Other.

// The following table gives the character class for non-initial ASCII
// characters.
var midClass = [128]uint8{
	/*   */ uint8(12) /*   */, uint8(12) /*   */, uint8(12),
	/*   */ uint8(12) /*   */, uint8(12) /*   */, uint8(12),
	/*   */ uint8(12) /*   */, uint8(12) /*   */, uint8(12),
	/*   */ uint8(11) /*   */, uint8(12) /*   */, uint8(12),
	/*   */ uint8(11) /*   */, uint8(11) /*   */, uint8(12),
	/*   */ uint8(12) /*   */, uint8(12) /*   */, uint8(12),
	/*   */ uint8(12) /*   */, uint8(12) /*   */, uint8(12),
	/*   */ uint8(12) /*   */, uint8(12) /*   */, uint8(12),
	/*   */ uint8(12) /*   */, uint8(12) /*   */, uint8(12),
	/*   */ uint8(12) /*   */, uint8(12) /*   */, uint8(12),
	/*   */ uint8(12) /*   */, uint8(12) /*   */, uint8(11),
	/* ! */ uint8(12) /* " */, uint8(12) /* # */, uint8(12),
	/* $ */ uint8(12) /* % */, uint8(12) /* & */, uint8(12),
	/* ' */ uint8(0) /* ( */, uint8(12) /* ) */, uint8(12),
	/* * */ uint8(12) /* + */, uint8(12) /* , */, uint8(12),
	/* - */ uint8(12) /* . */, uint8(12) /* / */, uint8(12),
	/* 0 */ uint8(10) /* 1 */, uint8(10) /* 2 */, uint8(10),
	/* 3 */ uint8(10) /* 4 */, uint8(10) /* 5 */, uint8(10),
	/* 6 */ uint8(10) /* 7 */, uint8(10) /* 8 */, uint8(10),
	/* 9 */ uint8(10) /* : */, uint8(12) /* ; */, uint8(12),
	/* < */ uint8(12) /* = */, uint8(12) /* > */, uint8(12),
	/* ? */ uint8(12) /* @ */, uint8(12) /* A */, uint8(1),
	/* B */ uint8(2) /* C */, uint8(3) /* D */, uint8(4),
	/* E */ uint8(1) /* F */, uint8(2) /* G */, uint8(3),
	/* H */ uint8(0) /* I */, uint8(1) /* J */, uint8(3),
	/* K */ uint8(3) /* L */, uint8(6) /* M */, uint8(8),
	/* N */ uint8(8) /* O */, uint8(1) /* P */, uint8(2),
	/* Q */ uint8(3) /* R */, uint8(7) /* S */, uint8(3),
	/* T */ uint8(4) /* U */, uint8(1) /* V */, uint8(2),
	/* W */ uint8(2) /* X */, uint8(3) /* Y */, uint8(1),
	/* Z */ uint8(3) /* [ */, uint8(12) /* \ */, uint8(12),
	/* ] */ uint8(12) /* ^ */, uint8(12) /* _ */, uint8(12),
	/* ` */ uint8(12) /* a */, uint8(1) /* b */, uint8(2),
	/* c */ uint8(3) /* d */, uint8(4) /* e */, uint8(1),
	/* f */ uint8(2) /* g */, uint8(3) /* h */, uint8(0),
	/* i */ uint8(1) /* j */, uint8(3) /* k */, uint8(3),
	/* l */ uint8(6) /* m */, uint8(8) /* n */, uint8(8),
	/* o */ uint8(1) /* p */, uint8(2) /* q */, uint8(3),
	/* r */ uint8(7) /* s */, uint8(3) /* t */, uint8(4),
	/* u */ uint8(1) /* v */, uint8(2) /* w */, uint8(2),
	/* x */ uint8(3) /* y */, uint8(1) /* z */, uint8(3),
	/* { */ uint8(12) /* | */, uint8(12) /* } */, uint8(12),
	/* ~ */ uint8(12) /*   */, uint8(12),
} /* spellfix.c:75:28 */
// This tables gives the character class for ASCII characters that form the
// initial character of a word.  The only difference from midClass is with
// the letters H, W, and Y.
var initClass = [128]uint8{
	/*   */ uint8(12) /*   */, uint8(12) /*   */, uint8(12),
	/*   */ uint8(12) /*   */, uint8(12) /*   */, uint8(12),
	/*   */ uint8(12) /*   */, uint8(12) /*   */, uint8(12),
	/*   */ uint8(11) /*   */, uint8(12) /*   */, uint8(12),
	/*   */ uint8(11) /*   */, uint8(11) /*   */, uint8(12),
	/*   */ uint8(12) /*   */, uint8(12) /*   */, uint8(12),
	/*   */ uint8(12) /*   */, uint8(12) /*   */, uint8(12),
	/*   */ uint8(12) /*   */, uint8(12) /*   */, uint8(12),
	/*   */ uint8(12) /*   */, uint8(12) /*   */, uint8(12),
	/*   */ uint8(12) /*   */, uint8(12) /*   */, uint8(12),
	/*   */ uint8(12) /*   */, uint8(12) /*   */, uint8(11),
	/* ! */ uint8(12) /* " */, uint8(12) /* # */, uint8(12),
	/* $ */ uint8(12) /* % */, uint8(12) /* & */, uint8(12),
	/* ' */ uint8(12) /* ( */, uint8(12) /* ) */, uint8(12),
	/* * */ uint8(12) /* + */, uint8(12) /* , */, uint8(12),
	/* - */ uint8(12) /* . */, uint8(12) /* / */, uint8(12),
	/* 0 */ uint8(10) /* 1 */, uint8(10) /* 2 */, uint8(10),
	/* 3 */ uint8(10) /* 4 */, uint8(10) /* 5 */, uint8(10),
	/* 6 */ uint8(10) /* 7 */, uint8(10) /* 8 */, uint8(10),
	/* 9 */ uint8(10) /* : */, uint8(12) /* ; */, uint8(12),
	/* < */ uint8(12) /* = */, uint8(12) /* > */, uint8(12),
	/* ? */ uint8(12) /* @ */, uint8(12) /* A */, uint8(1),
	/* B */ uint8(2) /* C */, uint8(3) /* D */, uint8(4),
	/* E */ uint8(1) /* F */, uint8(2) /* G */, uint8(3),
	/* H */ uint8(0) /* I */, uint8(1) /* J */, uint8(3),
	/* K */ uint8(3) /* L */, uint8(6) /* M */, uint8(8),
	/* N */ uint8(8) /* O */, uint8(1) /* P */, uint8(2),
	/* Q */ uint8(3) /* R */, uint8(7) /* S */, uint8(3),
	/* T */ uint8(4) /* U */, uint8(1) /* V */, uint8(2),
	/* W */ uint8(2) /* X */, uint8(3) /* Y */, uint8(9),
	/* Z */ uint8(3) /* [ */, uint8(12) /* \ */, uint8(12),
	/* ] */ uint8(12) /* ^ */, uint8(12) /* _ */, uint8(12),
	/* ` */ uint8(12) /* a */, uint8(1) /* b */, uint8(2),
	/* c */ uint8(3) /* d */, uint8(4) /* e */, uint8(1),
	/* f */ uint8(2) /* g */, uint8(3) /* h */, uint8(0),
	/* i */ uint8(1) /* j */, uint8(3) /* k */, uint8(3),
	/* l */ uint8(6) /* m */, uint8(8) /* n */, uint8(8),
	/* o */ uint8(1) /* p */, uint8(2) /* q */, uint8(3),
	/* r */ uint8(7) /* s */, uint8(3) /* t */, uint8(4),
	/* u */ uint8(1) /* v */, uint8(2) /* w */, uint8(2),
	/* x */ uint8(3) /* y */, uint8(9) /* z */, uint8(3),
	/* { */ uint8(12) /* | */, uint8(12) /* } */, uint8(12),
	/* ~ */ uint8(12) /*   */, uint8(12),
} /* spellfix.c:125:28 */

// Mapping from the character class number (0-13) to a symbol for each
// character class.  Note that initClass[] can be used to map the class
// symbol back into the class number.
var className = *(*[14]uint8)(unsafe.Pointer(ts + 6517 /* ".ABCDHLRMY9 ?" */)) /* spellfix.c:176:28 */

// Generate a "phonetic hash" from a string of ASCII characters
// in zIn[0..nIn-1].
//
//   * Map characters by character class as defined above.
//   * Omit double-letters
//   * Omit vowels beside R and L
//   * Omit T when followed by CH
//   * Omit W when followed by R
//   * Omit D when followed by J or G
//   * Omit K in KN or G in GN at the beginning of a word
//
// Space to hold the result is obtained from sqlite3_malloc()
//
// Return NULL if memory allocation fails.
func phoneticHash(tls *crt.TLS, zIn uintptr, nIn int32) uintptr { /* spellfix.c:194:22: */
	var zOut uintptr = sqlite3.Xsqlite3_malloc64(tls, (uint64(nIn + 1)))
	var i int32
	var nOut int32 = 0
	var cPrev int8 = int8(0x77)
	var cPrevX int8 = int8(0x77)
	var aClass uintptr = uintptr(unsafe.Pointer(&initClass))

	if zOut == uintptr(0) {
		return uintptr(0)
	}
	if nIn > 2 {
		switch int32(*(*uint8)(unsafe.Pointer(zIn + uintptr(0)))) {
		case 'g':
			fallthrough
		case 'k':
			{
				if int32(*(*uint8)(unsafe.Pointer(zIn + uintptr(1)))) == 'n' {
					zIn++
					nIn--
				}
				break
			}
		}
	}
	for i = 0; i < nIn; i++ {
		var c uint8 = *(*uint8)(unsafe.Pointer(zIn + uintptr(i)))
		if (i + 1) < nIn {
			if (int32(c) == 'w') && (int32(*(*uint8)(unsafe.Pointer(zIn + uintptr((i + 1))))) == 'r') {
				continue
			}
			if (int32(c) == 'd') && ((int32(*(*uint8)(unsafe.Pointer(zIn + uintptr((i + 1))))) == 'j') || (int32(*(*uint8)(unsafe.Pointer(zIn + uintptr((i + 1))))) == 'g')) {
				continue
			}
			if (i + 2) < nIn {
				if ((int32(c) == 't') && (int32(*(*uint8)(unsafe.Pointer(zIn + uintptr((i + 1))))) == 'c')) && (int32(*(*uint8)(unsafe.Pointer(zIn + uintptr((i + 2))))) == 'h') {
					continue
				}
			}
		}
		c = *(*uint8)(unsafe.Pointer(aClass + uintptr((int32(c) & 0x7f))))
		if int32(c) == 11 {
			continue
		}
		if (int32(c) == 12) && (int32(cPrev) != 10) {
			continue
		}
		aClass = uintptr(unsafe.Pointer(&midClass))
		if (int32(c) == 1) && ((int32(cPrevX) == 7) || (int32(cPrevX) == 6)) {
			continue
		}
		if ((int32(c) == 7) || (int32(c) == 6)) && (int32(cPrevX) == 1) {
			nOut--
		}
		cPrev = int8(c)
		if int32(c) == 0 {
			continue
		}
		cPrevX = int8(c)
		c = className[c]

		if (nOut == 0) || (int32(c) != int32(*(*uint8)(unsafe.Pointer(zOut + uintptr((nOut - 1)))))) {
			*(*uint8)(unsafe.Pointer(zOut + uintptr(crt.PostIncInt32(&nOut, 1)))) = c
		}
	}
	*(*uint8)(unsafe.Pointer(zOut + uintptr(nOut))) = uint8(0)
	return zOut
}

// This is an SQL function wrapper around phoneticHash().  See
// the description of phoneticHash() for additional information.
func phoneticHashSqlFunc(tls *crt.TLS, context uintptr, argc int32, argv uintptr) { /* spellfix.c:246:13: */
	var zIn uintptr
	var zOut uintptr

	zIn = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)))
	if zIn == uintptr(0) {
		return
	}
	zOut = phoneticHash(tls, zIn, sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8))))
	if zOut == uintptr(0) {
		sqlite3.Xsqlite3_result_error_nomem(tls, context)
	} else {
		sqlite3.Xsqlite3_result_text(tls, context, zOut, -1, *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, uintptr) }{sqlite3.Xsqlite3_free})))
	}
}

// Return the character class number for a character given its
// context.
func characterClass(tls *crt.TLS, cPrev int8, c int8) int8 { /* spellfix.c:268:13: */
	if int32(cPrev) == 0 {
		return int8(initClass[(int32(c) & 0x7f)])
	}
	return int8(midClass[(int32(c) & 0x7f)])
}

// Return the cost of inserting or deleting character c immediately
// following character cPrev.  If cPrev==0, that means c is the first
// character of the word.
func insertOrDeleteCost(tls *crt.TLS, cPrev int8, c int8, cNext int8) int32 { /* spellfix.c:277:12: */
	var classC int8 = characterClass(tls, cPrev, c)
	var classCprev int8

	if int32(classC) == 0 {
		// Insert or delete "silent" characters such as H or W
		return 1
	}
	if int32(cPrev) == int32(c) {
		// Repeated characters, or miss a repeat
		return 10
	}
	if (int32(classC) == 1) && ((int32(cPrev) == 'r') || (int32(cNext) == 'r')) {
		return 20
	}
	classCprev = characterClass(tls, cPrev, cPrev)
	if int32(classC) == int32(classCprev) {
		if int32(classC) == 1 {
			// Remove or add a new vowel to a vowel cluster
			return 15
		} else {
			// Remove or add a consonant not in the same class
			return 50
		}
	}

	// any other character insertion or deletion
	return 100
}

// Divide the insertion cost by this factor when appending to the
// end of the word.

// Return the cost of substituting cTo in place of cFrom assuming
// the previous character is cPrev.  If cPrev==0 then cTo is the first
// character of the word.
func substituteCost(tls *crt.TLS, cPrev int8, cFrom int8, cTo int8) int32 { /* spellfix.c:318:12: */
	var classFrom int8
	var classTo int8
	if int32(cFrom) == int32(cTo) {
		// Exact match
		return 0
	}
	if (int32(cFrom) == (int32(cTo) ^ 0x20)) && (((int32(cTo) >= 'A') && (int32(cTo) <= 'Z')) || ((int32(cTo) >= 'a') && (int32(cTo) <= 'z'))) {
		// differ only in case
		return 0
	}
	classFrom = characterClass(tls, cPrev, cFrom)
	classTo = characterClass(tls, cPrev, cTo)
	if int32(classFrom) == int32(classTo) {
		// Same character class
		return 40
	}
	if (((int32(classFrom) >= 2) && (int32(classFrom) <= 9)) &&
		(int32(classTo) >= 2)) && (int32(classTo) <= 9) {
		// Convert from one consonant to another, but in a different class
		return 75
	}
	// Any other subsitution
	return 100
}

// Given two strings zA and zB which are pure ASCII, return the cost
// of transforming zA into zB.  If zA ends with '*' assume that it is
// a prefix of zB and give only minimal penalty for extra characters
// on the end of zB.
//
// Smaller numbers mean a closer match.
//
// Negative values indicate an error:
//    -1  One of the inputs is NULL
//    -2  Non-ASCII characters on input
//    -3  Unable to allocate memory
//
// If pnMatch is not NULL, then *pnMatch is set to the number of bytes
// of zB that matched the pattern in zA. If zA does not end with a '*',
// then this value is always the number of bytes in zB (i.e. strlen(zB)).
// If zA does end in a '*', then it is the number of bytes in the prefix
// of zB that was deemed to match zA.
func editdist1(tls *crt.TLS, zA uintptr, zB uintptr, pnMatch uintptr) int32 { /* spellfix.c:362:12: */
	bp := tls.Alloc(300)
	defer tls.Free(300)

	var nA int32
	var nB int32 // Number of characters in zA[] and zB[]
	var xA int32
	var xB int32 // Loop counters for zA[] and zB[]
	var cA int8 = int8(0)
	var cB int8 // Current character of zA and zB
	var cAprev int8
	var cBprev int8 // Previous character of zA and zB
	var cAnext int8
	var cBnext int8                 // Next character in zA and zB
	var d int32                     // North-west cost value
	var dc int32 = 0                // North-west character value
	var res int32                   // Final result
	var m uintptr                   // The cost matrix
	var cx uintptr                  // Corresponding character values
	var toFree uintptr = uintptr(0) // Malloced space
	var nMatch int32 = 0
	// var mStack [75]int32 at bp, 300
	// Stack space to use if not too much is needed

	// Early out if either input is NULL
	if (zA == uintptr(0)) || (zB == uintptr(0)) {
		return -1
	}

	// Skip any common prefix
	for (*(*int8)(unsafe.Pointer(zA + uintptr(0))) != 0) && (int32(*(*int8)(unsafe.Pointer(zA + uintptr(0)))) == int32(*(*int8)(unsafe.Pointer(zB + uintptr(0))))) {
		dc = int32(*(*int8)(unsafe.Pointer(zA + uintptr(0))))
		zA++
		zB++
		nMatch++
	}
	if pnMatch != 0 {
		*(*int32)(unsafe.Pointer(pnMatch)) = nMatch
	}
	if (int32(*(*int8)(unsafe.Pointer(zA + uintptr(0)))) == 0) && (int32(*(*int8)(unsafe.Pointer(zB + uintptr(0)))) == 0) {
		return 0
	}

	// Verify input strings and measure their lengths
	for nA = 0; *(*int8)(unsafe.Pointer(zA + uintptr(nA))) != 0; nA++ {
		if (int32(*(*int8)(unsafe.Pointer(zA + uintptr(nA)))) & 0x80) != 0 {
			return -2
		}
	}
	for nB = 0; *(*int8)(unsafe.Pointer(zB + uintptr(nB))) != 0; nB++ {
		if (int32(*(*int8)(unsafe.Pointer(zB + uintptr(nB)))) & 0x80) != 0 {
			return -2
		}
	}

	// Special processing if either string is empty
	if nA == 0 {
		cBprev = int8(dc)
		for xB = crt.AssignInt32(&res, 0); (int32(crt.AssignInt8(&cB, *(*int8)(unsafe.Pointer(zB + uintptr(xB)))))) != 0; xB++ {
			res = res + (insertOrDeleteCost(tls, cBprev, cB, *(*int8)(unsafe.Pointer(zB + uintptr((xB + 1))))) / 4)
			cBprev = cB
		}
		return res
	}
	if nB == 0 {
		cAprev = int8(dc)
		for xA = crt.AssignInt32(&res, 0); (int32(crt.AssignInt8(&cA, *(*int8)(unsafe.Pointer(zA + uintptr(xA)))))) != 0; xA++ {
			res = res + (insertOrDeleteCost(tls, cAprev, cA, *(*int8)(unsafe.Pointer(zA + uintptr((xA + 1))))))
			cAprev = cA
		}
		return res
	}

	// A is a prefix of B
	if (int32(*(*int8)(unsafe.Pointer(zA + uintptr(0)))) == '*') && (int32(*(*int8)(unsafe.Pointer(zA + uintptr(1)))) == 0) {
		return 0
	}

	// Allocate and initialize the Wagner matrix
	if uint64(nB) < ((uint64(unsafe.Sizeof([75]int32{})) * uint64(4)) / (uint64(unsafe.Sizeof(int32(0))) * uint64(5))) {
		m = bp /* &mStack[0] */
	} else {
		m = crt.AssignUintptr(&toFree, sqlite3.Xsqlite3_malloc64(tls, (uint64(((uint64((nB+1)*5))*uint64(unsafe.Sizeof(int32(0))))/uint64(4)))))
		if m == uintptr(0) {
			return -3
		}
	}
	cx = (m + uintptr((nB+1))*4)

	// Compute the Wagner edit distance
	*(*int32)(unsafe.Pointer(m + uintptr(0)*4)) = 0
	*(*int8)(unsafe.Pointer(cx + uintptr(0))) = int8(dc)
	cBprev = int8(dc)
	for xB = 1; xB <= nB; xB++ {
		cBnext = *(*int8)(unsafe.Pointer(zB + uintptr(xB)))
		cB = *(*int8)(unsafe.Pointer(zB + uintptr((xB - 1))))
		*(*int8)(unsafe.Pointer(cx + uintptr(xB))) = cB
		*(*int32)(unsafe.Pointer(m + uintptr(xB)*4)) = (*(*int32)(unsafe.Pointer(m + uintptr((xB-1))*4)) + insertOrDeleteCost(tls, cBprev, cB, cBnext))
		cBprev = cB
	}
	cAprev = int8(dc)
	for xA = 1; xA <= nA; xA++ {
		var lastA int32 = (crt.Bool32(xA == nA))
		cA = *(*int8)(unsafe.Pointer(zA + uintptr((xA - 1))))
		cAnext = *(*int8)(unsafe.Pointer(zA + uintptr(xA)))
		if (int32(cA) == '*') && (lastA != 0) {
			break
		}
		d = *(*int32)(unsafe.Pointer(m + uintptr(0)*4))
		dc = int32(*(*int8)(unsafe.Pointer(cx + uintptr(0))))
		*(*int32)(unsafe.Pointer(m + uintptr(0)*4)) = (d + insertOrDeleteCost(tls, cAprev, cA, cAnext))
		cBprev = int8(0)
		for xB = 1; xB <= nB; xB++ {
			var totalCost int32
			var insCost int32
			var delCost int32
			var subCost int32
			var ncx int32
			cB = *(*int8)(unsafe.Pointer(zB + uintptr((xB - 1))))
			cBnext = *(*int8)(unsafe.Pointer(zB + uintptr(xB)))

			// Cost to insert cB
			insCost = insertOrDeleteCost(tls, *(*int8)(unsafe.Pointer(cx + uintptr((xB - 1)))), cB, cBnext)
			if lastA != 0 {
				insCost = insCost / (4)
			}

			// Cost to delete cA
			delCost = insertOrDeleteCost(tls, *(*int8)(unsafe.Pointer(cx + uintptr(xB))), cA, cBnext)

			// Cost to substitute cA->cB
			subCost = substituteCost(tls, *(*int8)(unsafe.Pointer(cx + uintptr((xB - 1)))), cA, cB)

			// Best cost
			totalCost = (insCost + *(*int32)(unsafe.Pointer(m + uintptr((xB-1))*4)))
			ncx = int32(cB)
			if (delCost + *(*int32)(unsafe.Pointer(m + uintptr(xB)*4))) < totalCost {
				totalCost = (delCost + *(*int32)(unsafe.Pointer(m + uintptr(xB)*4)))
				ncx = int32(cA)
			}
			if (subCost + d) < totalCost {
				totalCost = (subCost + d)
			}

			// Update the matrix
			d = *(*int32)(unsafe.Pointer(m + uintptr(xB)*4))
			dc = int32(*(*int8)(unsafe.Pointer(cx + uintptr(xB))))
			*(*int32)(unsafe.Pointer(m + uintptr(xB)*4)) = totalCost
			*(*int8)(unsafe.Pointer(cx + uintptr(xB))) = int8(ncx)
			cBprev = cB
		}
		cAprev = cA
	}

	// Free the wagner matrix and return the result
	if int32(cA) == '*' {
		res = *(*int32)(unsafe.Pointer(m + uintptr(1)*4))
		for xB = 1; xB <= nB; xB++ {
			if *(*int32)(unsafe.Pointer(m + uintptr(xB)*4)) < res {
				res = *(*int32)(unsafe.Pointer(m + uintptr(xB)*4))
				if pnMatch != 0 {
					*(*int32)(unsafe.Pointer(pnMatch)) = (xB + nMatch)
				}
			}
		}
	} else {
		res = *(*int32)(unsafe.Pointer(m + uintptr(nB)*4))
		// In the current implementation, pnMatch is always NULL if zA does
		// not end in "*"
	}
	sqlite3.Xsqlite3_free(tls, toFree)
	return res
}

// Function:    editdist(A,B)
//
// Return the cost of transforming string A into string B.  Both strings
// must be pure ASCII text.  If A ends with '*' then it is assumed to be
// a prefix of B and extra characters on the end of B have minimal additional
// cost.
func editdistSqlFunc(tls *crt.TLS, context uintptr, argc int32, argv uintptr) { /* spellfix.c:518:13: */
	var res int32 = editdist1(tls,
		sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8))),
		sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8))),
		uintptr(0))
	if res < 0 {
		if res == (-3) {
			sqlite3.Xsqlite3_result_error_nomem(tls, context)
		} else if res == (-2) {
			sqlite3.Xsqlite3_result_error(tls, context, ts+6531 /* "non-ASCII input ..." */, -1)
		} else {
			sqlite3.Xsqlite3_result_error(tls, context, ts+6561 /* "NULL input to ed..." */, -1)
		}
	} else {
		sqlite3.Xsqlite3_result_int(tls, context, res)
	}
}

// End of the fixed-cost edit distance implementation
//
//
// Begin: Configurable cost unicode edit distance routines
// Forward declaration of structures
type EditDist3Cost1 = struct {
	FpNext uintptr
	FnFrom u8
	FnTo   u8
	FiCost u16
	Fa     [4]int8
}

// End of the fixed-cost edit distance implementation
//
//
// Begin: Configurable cost unicode edit distance routines
// Forward declaration of structures
type EditDist3Cost = EditDist3Cost1 /* spellfix.c:546:30 */
type EditDist3Config1 = struct {
	FnLang int32
	Fa     uintptr
}

type EditDist3Config = EditDist3Config1 /* spellfix.c:547:32 */
type EditDist3From1 = struct {
	FnSubst  int32
	FnDel    int32
	FnByte   int32
	FapSubst uintptr
	FapDel   uintptr
}

type EditDist3From = EditDist3From1 /* spellfix.c:549:30 */
type EditDist3FromString1 = struct {
	Fz        uintptr
	Fn        int32
	FisPrefix int32
	Fa        uintptr
}

type EditDist3FromString = EditDist3FromString1 /* spellfix.c:550:36 */
type EditDist3To1 = struct {
	FnIns  int32
	FnByte int32
	FapIns uintptr
}

type EditDist3To = EditDist3To1 /* spellfix.c:551:28 */
type EditDist3ToString1 = struct {
	Fz uintptr
	Fn int32
	Fa uintptr
}

type EditDist3ToString = EditDist3ToString1 /* spellfix.c:552:34 */
type EditDist3Lang1 = struct {
	FiLang    int32
	FiInsCost int32
	FiDelCost int32
	FiSubCost int32
	FpCost    uintptr
}

type EditDist3Lang = EditDist3Lang1 /* spellfix.c:553:30 */

// The default EditDist3Lang object, with default costs.
var editDist3Lang = EditDist3Lang{FiLang: 0, FiInsCost: 100, FiDelCost: 100, FiSubCost: 150, FpCost: uintptr(0)} /* spellfix.c:583:28 */

// Clear or delete an instance of the object that records all edit-distance
// weights.
func editDist3ConfigClear(tls *crt.TLS, p uintptr) { /* spellfix.c:640:13: */
	var i int32
	if p == uintptr(0) {
		return
	}
	for i = 0; i < (*EditDist3Config)(unsafe.Pointer(p)).FnLang; i++ {
		var pCost uintptr
		var pNext uintptr
		pCost = (*EditDist3Lang)(unsafe.Pointer((*EditDist3Config)(unsafe.Pointer(p)).Fa + uintptr(i)*24)).FpCost
		for pCost != 0 {
			pNext = (*EditDist3Cost)(unsafe.Pointer(pCost)).FpNext
			sqlite3.Xsqlite3_free(tls, pCost)
			pCost = pNext
		}
	}
	sqlite3.Xsqlite3_free(tls, (*EditDist3Config)(unsafe.Pointer(p)).Fa)
	crt.Xmemset(tls, p, 0, uint64(unsafe.Sizeof(EditDist3Config{})))
}
func editDist3ConfigDelete(tls *crt.TLS, pIn uintptr) { /* spellfix.c:655:13: */
	var p uintptr = pIn
	editDist3ConfigClear(tls, p)
	sqlite3.Xsqlite3_free(tls, p)
}

// Compare the FROM values of two EditDist3Cost objects, for sorting.
// Return negative, zero, or positive if the A is less than, equal to,
// or greater than B.
func editDist3CostCompare(tls *crt.TLS, pA uintptr, pB uintptr) int32 { /* spellfix.c:665:12: */
	var n int32 = int32((*EditDist3Cost)(unsafe.Pointer(pA)).FnFrom)
	var rc int32
	if n > int32((*EditDist3Cost)(unsafe.Pointer(pB)).FnFrom) {
		n = int32((*EditDist3Cost)(unsafe.Pointer(pB)).FnFrom)
	}
	rc = crt.Xstrncmp(tls, pA+12 /* &.a */, pB+12 /* &.a */, uint64(n))
	if rc == 0 {
		rc = (int32((*EditDist3Cost)(unsafe.Pointer(pA)).FnFrom) - int32((*EditDist3Cost)(unsafe.Pointer(pB)).FnFrom))
	}
	return rc
}

// Merge together two sorted lists of EditDist3Cost objects, in order
// of increasing FROM.
func editDist3CostMerge(tls *crt.TLS, pA uintptr, pB uintptr) uintptr { /* spellfix.c:678:22: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	*(*uintptr)(unsafe.Pointer(bp /* pHead */)) = uintptr(0)
	var ppTail uintptr = bp /* &pHead */
	var p uintptr
	for (pA != 0) && (pB != 0) {
		if editDist3CostCompare(tls, pA, pB) <= 0 {
			p = pA
			pA = (*EditDist3Cost)(unsafe.Pointer(pA)).FpNext
		} else {
			p = pB
			pB = (*EditDist3Cost)(unsafe.Pointer(pB)).FpNext
		}
		*(*uintptr)(unsafe.Pointer(ppTail)) = p
		ppTail = (p /* &.pNext */)
	}
	if pA != 0 {
		*(*uintptr)(unsafe.Pointer(ppTail)) = pA
	} else {
		*(*uintptr)(unsafe.Pointer(ppTail)) = pB
	}
	return *(*uintptr)(unsafe.Pointer(bp /* pHead */))
}

// Sort a list of EditDist3Cost objects into order of increasing FROM
func editDist3CostSort(tls *crt.TLS, pList uintptr) uintptr { /* spellfix.c:707:22: */
	bp := tls.Alloc(480)
	defer tls.Free(480)

	// var ap [60]uintptr at bp, 480

	var p uintptr
	var i int32
	var mx int32 = 0
	*(*uintptr)(unsafe.Pointer(bp /* &ap[0] */ + uintptr(0)*8)) = uintptr(0)
	*(*uintptr)(unsafe.Pointer(bp /* &ap[0] */ + uintptr(1)*8)) = uintptr(0)
	for pList != 0 {
		p = pList
		pList = (*EditDist3Cost)(unsafe.Pointer(p)).FpNext
		(*EditDist3Cost)(unsafe.Pointer(p)).FpNext = uintptr(0)
		for i = 0; *(*uintptr)(unsafe.Pointer(bp /* &ap[0] */ + uintptr(i)*8)) != 0; i++ {
			p = editDist3CostMerge(tls, *(*uintptr)(unsafe.Pointer(bp /* &ap[0] */ + uintptr(i)*8)), p)
			*(*uintptr)(unsafe.Pointer(bp /* &ap[0] */ + uintptr(i)*8)) = uintptr(0)
		}
		*(*uintptr)(unsafe.Pointer(bp /* &ap[0] */ + uintptr(i)*8)) = p
		if i > mx {
			mx = i
			*(*uintptr)(unsafe.Pointer(bp /* &ap[0] */ + uintptr((i+1))*8)) = uintptr(0)
		}
	}
	p = uintptr(0)
	for i = 0; i <= mx; i++ {
		if *(*uintptr)(unsafe.Pointer(bp /* &ap[0] */ + uintptr(i)*8)) != 0 {
			p = editDist3CostMerge(tls, p, *(*uintptr)(unsafe.Pointer(bp /* &ap[0] */ + uintptr(i)*8)))
		}
	}
	return p
}

// Load all edit-distance weights from a table.
func editDist3ConfigLoad(tls *crt.TLS, p uintptr, db uintptr, zTable uintptr) int32 { /* spellfix.c:737:12: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	// var pStmt uintptr at bp+8, 8

	var rc int32
	var rc2 int32
	var zSql uintptr
	var iLangPrev int32 = -9999
	var pLang uintptr = uintptr(0)

	zSql = sqlite3.Xsqlite3_mprintf(tls,
		ts+6586 /* "SELECT iLang, cF..." */, crt.VaList(bp, zTable))
	if zSql == uintptr(0) {
		return 7
	}
	rc = sqlite3.Xsqlite3_prepare(tls, db, zSql, -1, bp+8 /* &pStmt */, uintptr(0))
	sqlite3.Xsqlite3_free(tls, zSql)
	if rc != 0 {
		return rc
	}
	editDist3ConfigClear(tls, p)
	for sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 8 /* pStmt */))) == 100 {
		var iLang int32 = sqlite3.Xsqlite3_column_int(tls, *(*uintptr)(unsafe.Pointer(bp + 8 /* pStmt */)), 0)
		var zFrom uintptr = sqlite3.Xsqlite3_column_text(tls, *(*uintptr)(unsafe.Pointer(bp + 8 /* pStmt */)), 1)
		var nFrom int32
		if zFrom != 0 {
			nFrom = sqlite3.Xsqlite3_column_bytes(tls, *(*uintptr)(unsafe.Pointer(bp + 8 /* pStmt */)), 1)
		} else {
			nFrom = 0
		}
		var zTo uintptr = sqlite3.Xsqlite3_column_text(tls, *(*uintptr)(unsafe.Pointer(bp + 8 /* pStmt */)), 2)
		var nTo int32
		if zTo != 0 {
			nTo = sqlite3.Xsqlite3_column_bytes(tls, *(*uintptr)(unsafe.Pointer(bp + 8 /* pStmt */)), 2)
		} else {
			nTo = 0
		}
		var iCost int32 = sqlite3.Xsqlite3_column_int(tls, *(*uintptr)(unsafe.Pointer(bp + 8 /* pStmt */)), 3)

		if (nFrom > 100) || (nTo > 100) {
			continue
		}
		if iCost < 0 {
			continue
		}
		if iCost >= 10000 {
			continue
		} // Costs above 10K are considered infinite
		if (pLang == uintptr(0)) || (iLang != iLangPrev) {
			var pNew uintptr
			pNew = sqlite3.Xsqlite3_realloc64(tls, (*EditDist3Config)(unsafe.Pointer(p)).Fa, (uint64((uint64((*EditDist3Config)(unsafe.Pointer(p)).FnLang + 1)) * uint64(unsafe.Sizeof(EditDist3Lang{})))))
			if pNew == uintptr(0) {
				rc = 7
				break
			}
			(*EditDist3Config)(unsafe.Pointer(p)).Fa = pNew
			pLang = ((*EditDist3Config)(unsafe.Pointer(p)).Fa + uintptr((*EditDist3Config)(unsafe.Pointer(p)).FnLang)*24)
			(*EditDist3Config)(unsafe.Pointer(p)).FnLang++
			(*EditDist3Lang)(unsafe.Pointer(pLang)).FiLang = iLang
			(*EditDist3Lang)(unsafe.Pointer(pLang)).FiInsCost = 100
			(*EditDist3Lang)(unsafe.Pointer(pLang)).FiDelCost = 100
			(*EditDist3Lang)(unsafe.Pointer(pLang)).FiSubCost = 150
			(*EditDist3Lang)(unsafe.Pointer(pLang)).FpCost = uintptr(0)
			iLangPrev = iLang
		}
		if ((nFrom == 1) && (int32(*(*int8)(unsafe.Pointer(zFrom + uintptr(0)))) == '?')) && (nTo == 0) {
			(*EditDist3Lang)(unsafe.Pointer(pLang)).FiDelCost = iCost
		} else if ((nFrom == 0) && (nTo == 1)) && (int32(*(*int8)(unsafe.Pointer(zTo + uintptr(0)))) == '?') {
			(*EditDist3Lang)(unsafe.Pointer(pLang)).FiInsCost = iCost
		} else if (((nFrom == 1) && (nTo == 1)) && (int32(*(*int8)(unsafe.Pointer(zFrom + uintptr(0)))) == '?')) && (int32(*(*int8)(unsafe.Pointer(zTo + uintptr(0)))) == '?') {
			(*EditDist3Lang)(unsafe.Pointer(pLang)).FiSubCost = iCost
		} else {
			var pCost uintptr
			var nExtra int32 = ((nFrom + nTo) - 4)
			if nExtra < 0 {
				nExtra = 0
			}
			pCost = sqlite3.Xsqlite3_malloc64(tls, (uint64(uint64(unsafe.Sizeof(EditDist3Cost{})) + uint64(nExtra))))
			if pCost == uintptr(0) {
				rc = 7
				break
			}
			(*EditDist3Cost)(unsafe.Pointer(pCost)).FnFrom = u8(nFrom)
			(*EditDist3Cost)(unsafe.Pointer(pCost)).FnTo = u8(nTo)
			(*EditDist3Cost)(unsafe.Pointer(pCost)).FiCost = u16(iCost)
			crt.Xmemcpy(tls, pCost+12 /* &.a */, zFrom, uint64(nFrom))
			crt.Xmemcpy(tls, ((pCost + 12 /* &.a */) + uintptr(nFrom)), zTo, uint64(nTo))
			(*EditDist3Cost)(unsafe.Pointer(pCost)).FpNext = (*EditDist3Lang)(unsafe.Pointer(pLang)).FpCost
			(*EditDist3Lang)(unsafe.Pointer(pLang)).FpCost = pCost
		}
	}
	rc2 = sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 8 /* pStmt */)))
	if rc == 0 {
		rc = rc2
	}
	if rc == 0 {
		var iLang int32
		for iLang = 0; iLang < (*EditDist3Config)(unsafe.Pointer(p)).FnLang; iLang++ {
			(*EditDist3Lang)(unsafe.Pointer((*EditDist3Config)(unsafe.Pointer(p)).Fa + uintptr(iLang)*24)).FpCost = editDist3CostSort(tls, (*EditDist3Lang)(unsafe.Pointer((*EditDist3Config)(unsafe.Pointer(p)).Fa+uintptr(iLang)*24)).FpCost)
		}
	}
	return rc
}

// Return the length (in bytes) of a utf-8 character.  Or return a maximum
// of N.
func utf8Len(tls *crt.TLS, c uint8, N int32) int32 { /* spellfix.c:818:12: */
	var len int32 = 1
	if int32(c) > 0x7f {
		if (int32(c) & 0xe0) == 0xc0 {
			len = 2
		} else if (int32(c) & 0xf0) == 0xe0 {
			len = 3
		} else {
			len = 4
		}
	}
	if len > N {
		len = N
	}
	return len
}

// Return TRUE (non-zero) if the To side of the given cost matches
// the given string.
func matchTo(tls *crt.TLS, p uintptr, z uintptr, n int32) int32 { /* spellfix.c:837:12: */

	if int32(*(*int8)(unsafe.Pointer((p + 12 /* &.a */) + uintptr((*EditDist3Cost)(unsafe.Pointer(p)).FnFrom)))) != int32(*(*int8)(unsafe.Pointer(z + uintptr(0)))) {
		return 0
	}
	if int32((*EditDist3Cost)(unsafe.Pointer(p)).FnTo) > n {
		return 0
	}
	if crt.Xstrncmp(tls, ((p+12 /* &.a */)+uintptr((*EditDist3Cost)(unsafe.Pointer(p)).FnFrom)), z, uint64((*EditDist3Cost)(unsafe.Pointer(p)).FnTo)) != 0 {
		return 0
	}
	return 1
}

// Return TRUE (non-zero) if the From side of the given cost matches
// the given string.
func matchFrom(tls *crt.TLS, p uintptr, z uintptr, n int32) int32 { /* spellfix.c:849:12: */

	if (*EditDist3Cost)(unsafe.Pointer(p)).FnFrom != 0 {
		if int32(*(*int8)(unsafe.Pointer((p + 12 /* &.a */) + uintptr(0)))) != int32(*(*int8)(unsafe.Pointer(z + uintptr(0)))) {
			return 0
		}
		if crt.Xstrncmp(tls, p+12 /* &.a */, z, uint64((*EditDist3Cost)(unsafe.Pointer(p)).FnFrom)) != 0 {
			return 0
		}
	}
	return 1
}

// Return TRUE (non-zero) of the next FROM character and the next TO
// character are the same.
func matchFromTo(tls *crt.TLS, pStr uintptr, n1 int32, z2 uintptr, n2 int32) int32 { /* spellfix.c:862:12: */
	var b1 int32 = (*EditDist3From)(unsafe.Pointer((*EditDist3FromString)(unsafe.Pointer(pStr)).Fa + uintptr(n1)*32)).FnByte
	if b1 > n2 {
		return 0
	}

	if int32(*(*int8)(unsafe.Pointer((*EditDist3FromString)(unsafe.Pointer(pStr)).Fz + uintptr(n1)))) != int32(*(*int8)(unsafe.Pointer(z2 + uintptr(0)))) {
		return 0
	}
	if crt.Xstrncmp(tls, ((*EditDist3FromString)(unsafe.Pointer(pStr)).Fz+uintptr(n1)), z2, uint64(b1)) != 0 {
		return 0
	}
	return 1
}

// Delete an EditDist3FromString objecct
func editDist3FromStringDelete(tls *crt.TLS, p uintptr) { /* spellfix.c:879:13: */
	var i int32
	if p != 0 {
		for i = 0; i < (*EditDist3FromString)(unsafe.Pointer(p)).Fn; i++ {
			sqlite3.Xsqlite3_free(tls, (*EditDist3From)(unsafe.Pointer((*EditDist3FromString)(unsafe.Pointer(p)).Fa+uintptr(i)*32)).FapDel)
			sqlite3.Xsqlite3_free(tls, (*EditDist3From)(unsafe.Pointer((*EditDist3FromString)(unsafe.Pointer(p)).Fa+uintptr(i)*32)).FapSubst)
		}
		sqlite3.Xsqlite3_free(tls, p)
	}
}

// Create a EditDist3FromString object.
func editDist3FromStringNew(tls *crt.TLS, pLang uintptr, z uintptr, n int32) uintptr { /* spellfix.c:893:28: */
	var pStr uintptr
	var p uintptr
	var i int32

	if z == uintptr(0) {
		return uintptr(0)
	}
	if n < 0 {
		n = int32(crt.Xstrlen(tls, z))
	}
	pStr = sqlite3.Xsqlite3_malloc64(tls, (uint64(((uint64(unsafe.Sizeof(EditDist3FromString{})) + (uint64(unsafe.Sizeof(EditDist3From{})) * uint64(n))) + uint64(n)) + uint64(1))))
	if pStr == uintptr(0) {
		return uintptr(0)
	}
	(*EditDist3FromString)(unsafe.Pointer(pStr)).Fa = (pStr + uintptr(1)*24)
	crt.Xmemset(tls, (*EditDist3FromString)(unsafe.Pointer(pStr)).Fa, 0, (uint64(unsafe.Sizeof(EditDist3From{})) * uint64(n)))
	(*EditDist3FromString)(unsafe.Pointer(pStr)).Fn = n
	(*EditDist3FromString)(unsafe.Pointer(pStr)).Fz = ((*EditDist3FromString)(unsafe.Pointer(pStr)).Fa + uintptr(n)*32)
	crt.Xmemcpy(tls, (*EditDist3FromString)(unsafe.Pointer(pStr)).Fz, z, (uint64(n + 1)))
	if (n != 0) && (int32(*(*int8)(unsafe.Pointer(z + uintptr((n - 1))))) == '*') {
		(*EditDist3FromString)(unsafe.Pointer(pStr)).FisPrefix = 1
		n--
		(*EditDist3FromString)(unsafe.Pointer(pStr)).Fn--
		*(*int8)(unsafe.Pointer((*EditDist3FromString)(unsafe.Pointer(pStr)).Fz + uintptr(n))) = int8(0)
	} else {
		(*EditDist3FromString)(unsafe.Pointer(pStr)).FisPrefix = 0
	}

	for i = 0; i < n; i++ {
		var pFrom uintptr = ((*EditDist3FromString)(unsafe.Pointer(pStr)).Fa + uintptr(i)*32)
		crt.Xmemset(tls, pFrom, 0, uint64(unsafe.Sizeof(EditDist3From{})))
		(*EditDist3From)(unsafe.Pointer(pFrom)).FnByte = utf8Len(tls, uint8(*(*int8)(unsafe.Pointer(z + uintptr(i)))), (n - i))
		for p = (*EditDist3Lang)(unsafe.Pointer(pLang)).FpCost; p != 0; p = (*EditDist3Cost)(unsafe.Pointer(p)).FpNext {
			var apNew uintptr
			if (i + int32((*EditDist3Cost)(unsafe.Pointer(p)).FnFrom)) > n {
				continue
			}
			if matchFrom(tls, p, (z+uintptr(i)), (n-i)) == 0 {
				continue
			}
			if int32((*EditDist3Cost)(unsafe.Pointer(p)).FnTo) == 0 {
				apNew = sqlite3.Xsqlite3_realloc64(tls, (*EditDist3From)(unsafe.Pointer(pFrom)).FapDel,
					(uint64(uint64(unsafe.Sizeof(uintptr(0))) * (uint64((*EditDist3From)(unsafe.Pointer(pFrom)).FnDel + 1)))))
				if apNew == uintptr(0) {
					break
				}
				(*EditDist3From)(unsafe.Pointer(pFrom)).FapDel = apNew
				*(*uintptr)(unsafe.Pointer(apNew + uintptr(crt.PostIncInt32(&(*EditDist3From)(unsafe.Pointer(pFrom)).FnDel, 1))*8)) = p
			} else {
				apNew = sqlite3.Xsqlite3_realloc64(tls, (*EditDist3From)(unsafe.Pointer(pFrom)).FapSubst,
					(uint64(uint64(unsafe.Sizeof(uintptr(0))) * (uint64((*EditDist3From)(unsafe.Pointer(pFrom)).FnSubst + 1)))))
				if apNew == uintptr(0) {
					break
				}
				(*EditDist3From)(unsafe.Pointer(pFrom)).FapSubst = apNew
				*(*uintptr)(unsafe.Pointer(apNew + uintptr(crt.PostIncInt32(&(*EditDist3From)(unsafe.Pointer(pFrom)).FnSubst, 1))*8)) = p
			}
		}
		if p != 0 {
			editDist3FromStringDelete(tls, pStr)
			pStr = uintptr(0)
			break
		}
	}
	return pStr
}

// Update entry m[i] such that it is the minimum of its current value
// and m[j]+iCost.
func updateCost(tls *crt.TLS, m uintptr, i int32, j int32, iCost int32) { /* spellfix.c:955:13: */
	var b uint32

	b = (*(*uint32)(unsafe.Pointer(m + uintptr(j)*4)) + uint32(iCost))
	if b < *(*uint32)(unsafe.Pointer(m + uintptr(i)*4)) {
		*(*uint32)(unsafe.Pointer(m + uintptr(i)*4)) = b
	}
}

// How much stack space (int bytes) to use for Wagner matrix in
// editDist3Core().  If more space than this is required, the entire
// matrix is taken from the heap.  To reduce the load on the memory
// allocator, make this value as large as practical for the
// architecture in use.

// Compute the edit distance between two strings.
//
// If an error occurs, return a negative number which is the error code.
//
// If pnMatch is not NULL, then *pnMatch is set to the number of characters
// (not bytes) in z2 that matched the search pattern in *pFrom. If pFrom does
// not contain the pattern for a prefix-search, then this is always the number
// of characters in z2. If pFrom does contain a prefix search pattern, then
// it is the number of characters in the prefix of z2 that was deemed to
// match pFrom.
func editDist3Core(tls *crt.TLS, pFrom uintptr, z2 uintptr, n2 int32, pLang uintptr, pnMatch uintptr) int32 { /* spellfix.c:990:12: */
	bp := tls.Alloc(1048)
	defer tls.Free(1048)

	var k int32
	var n int32
	var i1 int32
	var b1 int32
	var i2 int32
	var b2 int32
	// var f EditDist3FromString at bp+1024, 24

	var a2 uintptr
	var m uintptr
	var pToFree uintptr
	var szRow int32
	var p uintptr
	var res int32
	var nByte sqlite3_uint64
	// var stackSpace [256]uint32 at bp, 1024

	var apNew uintptr
	var cx int32  // Index of current cell
	var cxp int32 // Index of cell immediately to the left
	var cxd int32 // Index of cell to the left and one row above
	var cxu int32
	var rx int32 // Starting index for current row
	var rxp int32
	var b int32
	var nExtra int32
	*(*EditDist3FromString)(unsafe.Pointer(bp + 1024 /* f */)) = *(*EditDist3FromString)(unsafe.Pointer(pFrom))

	// allocate the Wagner matrix and the aTo[] array for the TO string
	n = (((*EditDist3FromString)(unsafe.Pointer(bp+1024 /* &f */)).Fn + 1) * (n2 + 1))
	n = ((n + 1) & ^int32(crt.Int32FromInt32(1)))
	nByte = (sqlite3_uint64((uint64(n) * uint64(unsafe.Sizeof(uint32(0)))) + (uint64(unsafe.Sizeof(EditDist3To{})) * uint64(n2))))
	if !(nByte <= sqlite3_uint64(unsafe.Sizeof([256]uint32{}))) {
		goto __1
	}
	m = bp /* &stackSpace[0] */
	pToFree = uintptr(0)
	goto __2
__1:
	m = crt.AssignUintptr(&pToFree, sqlite3.Xsqlite3_malloc64(tls, nByte))
	if !(m == uintptr(0)) {
		goto __3
	}
	return -1
__3:
	;
__2:
	;
	a2 = (m + uintptr(n)*4)
	crt.Xmemset(tls, a2, 0, (uint64(unsafe.Sizeof(EditDist3To{})) * uint64(n2)))

	// Fill in the a1[] matrix for all characters of the TO string
	i2 = 0
__4:
	if !(i2 < n2) {
		goto __6
	}
	(*EditDist3To)(unsafe.Pointer(a2 + uintptr(i2)*16)).FnByte = utf8Len(tls, uint8(*(*int8)(unsafe.Pointer(z2 + uintptr(i2)))), (n2 - i2))
	p = (*EditDist3Lang)(unsafe.Pointer(pLang)).FpCost
__7:
	if !(p != 0) {
		goto __9
	}
	if !(int32((*EditDist3Cost)(unsafe.Pointer(p)).FnFrom) > 0) {
		goto __10
	}
	goto __9
__10:
	;
	if !((i2 + int32((*EditDist3Cost)(unsafe.Pointer(p)).FnTo)) > n2) {
		goto __11
	}
	goto __8
__11:
	;
	if !(int32(*(*int8)(unsafe.Pointer((p + 12 /* &.a */) + uintptr(0)))) > int32(*(*int8)(unsafe.Pointer(z2 + uintptr(i2))))) {
		goto __12
	}
	goto __9
__12:
	;
	if !(matchTo(tls, p, (z2+uintptr(i2)), (n2-i2)) == 0) {
		goto __13
	}
	goto __8
__13:
	;
	(*EditDist3To)(unsafe.Pointer(a2+uintptr(i2)*16)).FnIns++
	apNew = sqlite3.Xsqlite3_realloc64(tls, (*EditDist3To)(unsafe.Pointer(a2+uintptr(i2)*16)).FapIns, (uint64(uint64(unsafe.Sizeof(uintptr(0))) * uint64((*EditDist3To)(unsafe.Pointer(a2+uintptr(i2)*16)).FnIns))))
	if !(apNew == uintptr(0)) {
		goto __14
	}
	res = -1 // Out of memory
	goto editDist3Abort
__14:
	;
	(*EditDist3To)(unsafe.Pointer(a2 + uintptr(i2)*16)).FapIns = apNew
	*(*uintptr)(unsafe.Pointer((*EditDist3To)(unsafe.Pointer(a2+uintptr(i2)*16)).FapIns + uintptr(((*EditDist3To)(unsafe.Pointer(a2+uintptr(i2)*16)).FnIns-1))*8)) = p
	goto __8
__8:
	p = (*EditDist3Cost)(unsafe.Pointer(p)).FpNext
	goto __7
	goto __9
__9:
	;
	goto __5
__5:
	i2++
	goto __4
	goto __6
__6:
	;

	// Prepare to compute the minimum edit distance
	szRow = ((*EditDist3FromString)(unsafe.Pointer(bp+1024 /* &f */)).Fn + 1)
	crt.Xmemset(tls, m, 0x01, ((uint64((n2 + 1) * szRow)) * uint64(unsafe.Sizeof(uint32(0)))))
	*(*uint32)(unsafe.Pointer(m + uintptr(0)*4)) = uint32(0)

	// First fill in the top-row of the matrix with FROM deletion costs
	i1 = 0
__15:
	if !(i1 < (*EditDist3FromString)(unsafe.Pointer(bp+1024 /* &f */)).Fn) {
		goto __17
	}
	b1 = (*EditDist3From)(unsafe.Pointer((*EditDist3FromString)(unsafe.Pointer(bp+1024 /* &f */)).Fa + uintptr(i1)*32)).FnByte
	updateCost(tls, m, (i1 + b1), i1, (*EditDist3Lang)(unsafe.Pointer(pLang)).FiDelCost)
	k = 0
__18:
	if !(k < (*EditDist3From)(unsafe.Pointer((*EditDist3FromString)(unsafe.Pointer(bp+1024 /* &f */)).Fa+uintptr(i1)*32)).FnDel) {
		goto __20
	}
	p = *(*uintptr)(unsafe.Pointer((*EditDist3From)(unsafe.Pointer((*EditDist3FromString)(unsafe.Pointer(bp+1024 /* &f */)).Fa+uintptr(i1)*32)).FapDel + uintptr(k)*8))
	updateCost(tls, m, (i1 + int32((*EditDist3Cost)(unsafe.Pointer(p)).FnFrom)), i1, int32((*EditDist3Cost)(unsafe.Pointer(p)).FiCost))
	goto __19
__19:
	k++
	goto __18
	goto __20
__20:
	;
	goto __16
__16:
	i1 = i1 + (b1)
	goto __15
	goto __17
__17:
	;

	// Fill in all subsequent rows, top-to-bottom, left-to-right
	i2 = 0
__21:
	if !(i2 < n2) {
		goto __23
	} // Starting index for previous row
	b2 = (*EditDist3To)(unsafe.Pointer(a2 + uintptr(i2)*16)).FnByte
	rx = (szRow * (i2 + b2))
	rxp = (szRow * i2)
	updateCost(tls, m, rx, rxp, (*EditDist3Lang)(unsafe.Pointer(pLang)).FiInsCost)
	k = 0
__24:
	if !(k < (*EditDist3To)(unsafe.Pointer(a2+uintptr(i2)*16)).FnIns) {
		goto __26
	}
	p = *(*uintptr)(unsafe.Pointer((*EditDist3To)(unsafe.Pointer(a2+uintptr(i2)*16)).FapIns + uintptr(k)*8))
	updateCost(tls, m, (szRow * (i2 + int32((*EditDist3Cost)(unsafe.Pointer(p)).FnTo))), rxp, int32((*EditDist3Cost)(unsafe.Pointer(p)).FiCost))
	goto __25
__25:
	k++
	goto __24
	goto __26
__26:
	;
	i1 = 0
__27:
	if !(i1 < (*EditDist3FromString)(unsafe.Pointer(bp+1024 /* &f */)).Fn) {
		goto __29
	} // Index of cell immediately above
	b1 = (*EditDist3From)(unsafe.Pointer((*EditDist3FromString)(unsafe.Pointer(bp+1024 /* &f */)).Fa + uintptr(i1)*32)).FnByte
	cxp = (rx + i1)
	cx = (cxp + b1)
	cxd = (rxp + i1)
	cxu = (cxd + b1)
	updateCost(tls, m, cx, cxp, (*EditDist3Lang)(unsafe.Pointer(pLang)).FiDelCost)
	k = 0
__30:
	if !(k < (*EditDist3From)(unsafe.Pointer((*EditDist3FromString)(unsafe.Pointer(bp+1024 /* &f */)).Fa+uintptr(i1)*32)).FnDel) {
		goto __32
	}
	p = *(*uintptr)(unsafe.Pointer((*EditDist3From)(unsafe.Pointer((*EditDist3FromString)(unsafe.Pointer(bp+1024 /* &f */)).Fa+uintptr(i1)*32)).FapDel + uintptr(k)*8))
	updateCost(tls, m, (cxp + int32((*EditDist3Cost)(unsafe.Pointer(p)).FnFrom)), cxp, int32((*EditDist3Cost)(unsafe.Pointer(p)).FiCost))
	goto __31
__31:
	k++
	goto __30
	goto __32
__32:
	;
	updateCost(tls, m, cx, cxu, (*EditDist3Lang)(unsafe.Pointer(pLang)).FiInsCost)
	if !(matchFromTo(tls, bp+1024 /* &f */, i1, (z2+uintptr(i2)), (n2-i2)) != 0) {
		goto __33
	}
	updateCost(tls, m, cx, cxd, 0)
__33:
	;
	updateCost(tls, m, cx, cxd, (*EditDist3Lang)(unsafe.Pointer(pLang)).FiSubCost)
	k = 0
__34:
	if !(k < (*EditDist3From)(unsafe.Pointer((*EditDist3FromString)(unsafe.Pointer(bp+1024 /* &f */)).Fa+uintptr(i1)*32)).FnSubst) {
		goto __36
	}
	p = *(*uintptr)(unsafe.Pointer((*EditDist3From)(unsafe.Pointer((*EditDist3FromString)(unsafe.Pointer(bp+1024 /* &f */)).Fa+uintptr(i1)*32)).FapSubst + uintptr(k)*8))
	if !(matchTo(tls, p, (z2+uintptr(i2)), (n2-i2)) != 0) {
		goto __37
	}
	updateCost(tls, m, ((cxd + int32((*EditDist3Cost)(unsafe.Pointer(p)).FnFrom)) + (szRow * int32((*EditDist3Cost)(unsafe.Pointer(p)).FnTo))), cxd, int32((*EditDist3Cost)(unsafe.Pointer(p)).FiCost))
__37:
	;
	goto __35
__35:
	k++
	goto __34
	goto __36
__36:
	;
	goto __28
__28:
	i1 = i1 + (b1)
	goto __27
	goto __29
__29:
	;
	goto __22
__22:
	i2 = i2 + (b2)
	goto __21
	goto __23
__23:
	;

	// Free memory allocations and return the result
	res = int32(*(*uint32)(unsafe.Pointer(m + uintptr(((szRow*(n2+1))-1))*4)))
	n = n2
	if !((*EditDist3FromString)(unsafe.Pointer(bp+1024 /* &f */)).FisPrefix != 0) {
		goto __38
	}
	i2 = 1
__39:
	if !(i2 <= n2) {
		goto __41
	}
	b = int32(*(*uint32)(unsafe.Pointer(m + uintptr(((szRow*i2)-1))*4)))
	if !(b <= res) {
		goto __42
	}
	res = b
	n = (i2 - 1)
__42:
	;
	goto __40
__40:
	i2++
	goto __39
	goto __41
__41:
	;
__38:
	;
	if !(pnMatch != 0) {
		goto __43
	}
	nExtra = 0
	k = 0
__44:
	if !(k < n) {
		goto __46
	}
	if !((int32(*(*int8)(unsafe.Pointer(z2 + uintptr(k)))) & 0xc0) == 0x80) {
		goto __47
	}
	nExtra++
__47:
	;
	goto __45
__45:
	k++
	goto __44
	goto __46
__46:
	;
	*(*int32)(unsafe.Pointer(pnMatch)) = (n - nExtra)
__43:
	;

editDist3Abort:
	i2 = 0
__48:
	if !(i2 < n2) {
		goto __50
	}
	sqlite3.Xsqlite3_free(tls, (*EditDist3To)(unsafe.Pointer(a2+uintptr(i2)*16)).FapIns)
	goto __49
__49:
	i2++
	goto __48
	goto __50
__50:
	;
	sqlite3.Xsqlite3_free(tls, pToFree)
	return res
}

// Get an appropriate EditDist3Lang object.
func editDist3FindLang(tls *crt.TLS, pConfig uintptr, iLang int32) uintptr { /* spellfix.c:1150:28: */
	var i int32
	for i = 0; i < (*EditDist3Config)(unsafe.Pointer(pConfig)).FnLang; i++ {
		if (*EditDist3Lang)(unsafe.Pointer((*EditDist3Config)(unsafe.Pointer(pConfig)).Fa+uintptr(i)*24)).FiLang == iLang {
			return ((*EditDist3Config)(unsafe.Pointer(pConfig)).Fa + uintptr(i)*24)
		}
	}
	return uintptr(unsafe.Pointer(&editDist3Lang))
}

// Function:    editdist3(A,B,iLang)
//              editdist3(tablename)
//
// Return the cost of transforming string A into string B using edit
// weights for iLang.
//
// The second form loads edit weights into memory from a table.
func editDist3SqlFunc(tls *crt.TLS, context uintptr, argc int32, argv uintptr) { /* spellfix.c:1170:13: */
	var pConfig uintptr = sqlite3.Xsqlite3_user_data(tls, context)
	var db uintptr = sqlite3.Xsqlite3_context_db_handle(tls, context)
	var rc int32
	if argc == 1 {
		var zTable uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)))
		rc = editDist3ConfigLoad(tls, pConfig, db, zTable)
		if rc != 0 {
			sqlite3.Xsqlite3_result_error_code(tls, context, rc)
		}
	} else {
		var zA uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)))
		var zB uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)))
		var nA int32 = sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)))
		var nB int32 = sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)))
		var iLang int32
		if argc == 3 {
			iLang = sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8)))
		} else {
			iLang = 0
		}
		var pLang uintptr = editDist3FindLang(tls, pConfig, iLang)
		var pFrom uintptr
		var dist int32

		pFrom = editDist3FromStringNew(tls, pLang, zA, nA)
		if pFrom == uintptr(0) {
			sqlite3.Xsqlite3_result_error_nomem(tls, context)
			return
		}
		dist = editDist3Core(tls, pFrom, zB, nB, pLang, uintptr(0))
		editDist3FromStringDelete(tls, pFrom)
		if dist == (-1) {
			sqlite3.Xsqlite3_result_error_nomem(tls, context)
		} else {
			sqlite3.Xsqlite3_result_int(tls, context, dist)
		}
	}
}

// Register the editDist3 function with SQLite
func editDist3Install(tls *crt.TLS, db uintptr) int32 { /* spellfix.c:1210:12: */
	var rc int32
	var pConfig uintptr = sqlite3.Xsqlite3_malloc64(tls, uint64(unsafe.Sizeof(EditDist3Config{})))
	if pConfig == uintptr(0) {
		return 7
	}
	crt.Xmemset(tls, pConfig, 0, uint64(unsafe.Sizeof(EditDist3Config{})))
	rc = sqlite3.Xsqlite3_create_function_v2(tls, db, ts+6658, /* "editdist3" */
		2, (1 | 0x000000800), pConfig,
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*crt.TLS, uintptr, int32, uintptr)
		}{editDist3SqlFunc})), uintptr(0), uintptr(0), uintptr(0))
	if rc == 0 {
		rc = sqlite3.Xsqlite3_create_function_v2(tls, db, ts+6658, /* "editdist3" */
			3, (1 | 0x000000800), pConfig,
			*(*uintptr)(unsafe.Pointer(&struct {
				f func(*crt.TLS, uintptr, int32, uintptr)
			}{editDist3SqlFunc})), uintptr(0), uintptr(0), uintptr(0))
	}
	if rc == 0 {
		rc = sqlite3.Xsqlite3_create_function_v2(tls, db, ts+6658, /* "editdist3" */
			1, (1 | 0x000000800), pConfig,
			*(*uintptr)(unsafe.Pointer(&struct {
				f func(*crt.TLS, uintptr, int32, uintptr)
			}{editDist3SqlFunc})), uintptr(0), uintptr(0), *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, uintptr) }{editDist3ConfigDelete})))
	} else {
		sqlite3.Xsqlite3_free(tls, pConfig)
	}
	return rc
}

// End configurable cost unicode edit distance routines
//
//
// Begin transliterate unicode-to-ascii implementation

// This lookup table is used to help decode the first byte of
// a multi-byte UTF8 character.
var sqlite3Utf8Trans1 = [64]uint8{
	uint8(0x00), uint8(0x01), uint8(0x02), uint8(0x03), uint8(0x04), uint8(0x05), uint8(0x06), uint8(0x07),
	uint8(0x08), uint8(0x09), uint8(0x0a), uint8(0x0b), uint8(0x0c), uint8(0x0d), uint8(0x0e), uint8(0x0f),
	uint8(0x10), uint8(0x11), uint8(0x12), uint8(0x13), uint8(0x14), uint8(0x15), uint8(0x16), uint8(0x17),
	uint8(0x18), uint8(0x19), uint8(0x1a), uint8(0x1b), uint8(0x1c), uint8(0x1d), uint8(0x1e), uint8(0x1f),
	uint8(0x00), uint8(0x01), uint8(0x02), uint8(0x03), uint8(0x04), uint8(0x05), uint8(0x06), uint8(0x07),
	uint8(0x08), uint8(0x09), uint8(0x0a), uint8(0x0b), uint8(0x0c), uint8(0x0d), uint8(0x0e), uint8(0x0f),
	uint8(0x00), uint8(0x01), uint8(0x02), uint8(0x03), uint8(0x04), uint8(0x05), uint8(0x06), uint8(0x07),
	uint8(0x00), uint8(0x01), uint8(0x02), uint8(0x03), uint8(0x00), uint8(0x01), uint8(0x00), uint8(0x00),
} /* spellfix.c:1243:28 */

// Return the value of the first UTF-8 character in the string.
func utf8Read(tls *crt.TLS, z uintptr, n int32, pSize uintptr) int32 { /* spellfix.c:1258:12: */
	var c int32
	var i int32

	// All callers to this routine (in the current implementation)
	// always have n>0.
	if 0 != 0 {
		c = crt.AssignInt32(&i, 0)
	} else {
		c = int32(*(*uint8)(unsafe.Pointer(z + uintptr(0))))
		i = 1
		if c >= 0xc0 {
			c = int32(sqlite3Utf8Trans1[(c - 0xc0)])
			for (i < n) && ((int32(*(*uint8)(unsafe.Pointer(z + uintptr(i)))) & 0xc0) == 0x80) {
				c = ((c << 6) + (0x3f & int32(*(*uint8)(unsafe.Pointer(z + uintptr(crt.PostIncInt32(&i, 1)))))))
			}
		}
	}
	*(*int32)(unsafe.Pointer(pSize)) = i
	return c
}

// Return the number of characters in the utf-8 string in the nIn byte
// buffer pointed to by zIn.
func utf8Charlen(tls *crt.TLS, zIn uintptr, nIn int32) int32 { /* spellfix.c:1283:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var i int32
	var nChar int32 = 0
	for i = 0; i < nIn; nChar++ {
		// var sz int32 at bp, 4

		utf8Read(tls, (zIn + uintptr(i)), (nIn - i), bp /* &sz */)
		i = i + (*(*int32)(unsafe.Pointer(bp /* sz */)))
	}
	return nChar
}

type Transliteration1 = struct {
	FcFrom uint16
	FcTo0  uint8
	FcTo1  uint8
	FcTo2  uint8
	FcTo3  uint8
}

type Transliteration = Transliteration1 /* spellfix.c:1294:32 */

// Table of translations from unicode characters into ASCII.
var translit = [389]Transliteration{
	{FcFrom: uint16(0x00A0), FcTo0: uint8(0x20), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, //   to
	{FcFrom: uint16(0x00B5), FcTo0: uint8(0x75), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // µ to u
	{FcFrom: uint16(0x00C0), FcTo0: uint8(0x41), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // À to A
	{FcFrom: uint16(0x00C1), FcTo0: uint8(0x41), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Á to A
	{FcFrom: uint16(0x00C2), FcTo0: uint8(0x41), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Â to A
	{FcFrom: uint16(0x00C3), FcTo0: uint8(0x41), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ã to A
	{FcFrom: uint16(0x00C4), FcTo0: uint8(0x41), FcTo1: uint8(0x65), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ä to Ae
	{FcFrom: uint16(0x00C5), FcTo0: uint8(0x41), FcTo1: uint8(0x61), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Å to Aa
	{FcFrom: uint16(0x00C6), FcTo0: uint8(0x41), FcTo1: uint8(0x45), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Æ to AE
	{FcFrom: uint16(0x00C7), FcTo0: uint8(0x43), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ç to C
	{FcFrom: uint16(0x00C8), FcTo0: uint8(0x45), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // È to E
	{FcFrom: uint16(0x00C9), FcTo0: uint8(0x45), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // É to E
	{FcFrom: uint16(0x00CA), FcTo0: uint8(0x45), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ê to E
	{FcFrom: uint16(0x00CB), FcTo0: uint8(0x45), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ë to E
	{FcFrom: uint16(0x00CC), FcTo0: uint8(0x49), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ì to I
	{FcFrom: uint16(0x00CD), FcTo0: uint8(0x49), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Í to I
	{FcFrom: uint16(0x00CE), FcTo0: uint8(0x49), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Î to I
	{FcFrom: uint16(0x00CF), FcTo0: uint8(0x49), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ï to I
	{FcFrom: uint16(0x00D0), FcTo0: uint8(0x44), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ð to D
	{FcFrom: uint16(0x00D1), FcTo0: uint8(0x4E), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ñ to N
	{FcFrom: uint16(0x00D2), FcTo0: uint8(0x4F), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ò to O
	{FcFrom: uint16(0x00D3), FcTo0: uint8(0x4F), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ó to O
	{FcFrom: uint16(0x00D4), FcTo0: uint8(0x4F), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ô to O
	{FcFrom: uint16(0x00D5), FcTo0: uint8(0x4F), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Õ to O
	{FcFrom: uint16(0x00D6), FcTo0: uint8(0x4F), FcTo1: uint8(0x65), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ö to Oe
	{FcFrom: uint16(0x00D7), FcTo0: uint8(0x78), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // × to x
	{FcFrom: uint16(0x00D8), FcTo0: uint8(0x4F), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ø to O
	{FcFrom: uint16(0x00D9), FcTo0: uint8(0x55), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ù to U
	{FcFrom: uint16(0x00DA), FcTo0: uint8(0x55), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ú to U
	{FcFrom: uint16(0x00DB), FcTo0: uint8(0x55), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Û to U
	{FcFrom: uint16(0x00DC), FcTo0: uint8(0x55), FcTo1: uint8(0x65), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ü to Ue
	{FcFrom: uint16(0x00DD), FcTo0: uint8(0x59), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ý to Y
	{FcFrom: uint16(0x00DE), FcTo0: uint8(0x54), FcTo1: uint8(0x68), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Þ to Th
	{FcFrom: uint16(0x00DF), FcTo0: uint8(0x73), FcTo1: uint8(0x73), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ß to ss
	{FcFrom: uint16(0x00E0), FcTo0: uint8(0x61), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // à to a
	{FcFrom: uint16(0x00E1), FcTo0: uint8(0x61), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // á to a
	{FcFrom: uint16(0x00E2), FcTo0: uint8(0x61), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // â to a
	{FcFrom: uint16(0x00E3), FcTo0: uint8(0x61), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ã to a
	{FcFrom: uint16(0x00E4), FcTo0: uint8(0x61), FcTo1: uint8(0x65), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ä to ae
	{FcFrom: uint16(0x00E5), FcTo0: uint8(0x61), FcTo1: uint8(0x61), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // å to aa
	{FcFrom: uint16(0x00E6), FcTo0: uint8(0x61), FcTo1: uint8(0x65), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // æ to ae
	{FcFrom: uint16(0x00E7), FcTo0: uint8(0x63), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ç to c
	{FcFrom: uint16(0x00E8), FcTo0: uint8(0x65), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // è to e
	{FcFrom: uint16(0x00E9), FcTo0: uint8(0x65), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // é to e
	{FcFrom: uint16(0x00EA), FcTo0: uint8(0x65), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ê to e
	{FcFrom: uint16(0x00EB), FcTo0: uint8(0x65), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ë to e
	{FcFrom: uint16(0x00EC), FcTo0: uint8(0x69), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ì to i
	{FcFrom: uint16(0x00ED), FcTo0: uint8(0x69), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // í to i
	{FcFrom: uint16(0x00EE), FcTo0: uint8(0x69), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // î to i
	{FcFrom: uint16(0x00EF), FcTo0: uint8(0x69), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ï to i
	{FcFrom: uint16(0x00F0), FcTo0: uint8(0x64), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ð to d
	{FcFrom: uint16(0x00F1), FcTo0: uint8(0x6E), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ñ to n
	{FcFrom: uint16(0x00F2), FcTo0: uint8(0x6F), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ò to o
	{FcFrom: uint16(0x00F3), FcTo0: uint8(0x6F), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ó to o
	{FcFrom: uint16(0x00F4), FcTo0: uint8(0x6F), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ô to o
	{FcFrom: uint16(0x00F5), FcTo0: uint8(0x6F), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // õ to o
	{FcFrom: uint16(0x00F6), FcTo0: uint8(0x6F), FcTo1: uint8(0x65), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ö to oe
	{FcFrom: uint16(0x00F7), FcTo0: uint8(0x3A), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ÷ to :
	{FcFrom: uint16(0x00F8), FcTo0: uint8(0x6F), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ø to o
	{FcFrom: uint16(0x00F9), FcTo0: uint8(0x75), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ù to u
	{FcFrom: uint16(0x00FA), FcTo0: uint8(0x75), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ú to u
	{FcFrom: uint16(0x00FB), FcTo0: uint8(0x75), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // û to u
	{FcFrom: uint16(0x00FC), FcTo0: uint8(0x75), FcTo1: uint8(0x65), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ü to ue
	{FcFrom: uint16(0x00FD), FcTo0: uint8(0x79), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ý to y
	{FcFrom: uint16(0x00FE), FcTo0: uint8(0x74), FcTo1: uint8(0x68), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // þ to th
	{FcFrom: uint16(0x00FF), FcTo0: uint8(0x79), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ÿ to y
	{FcFrom: uint16(0x0100), FcTo0: uint8(0x41), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ā to A
	{FcFrom: uint16(0x0101), FcTo0: uint8(0x61), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ā to a
	{FcFrom: uint16(0x0102), FcTo0: uint8(0x41), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ă to A
	{FcFrom: uint16(0x0103), FcTo0: uint8(0x61), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ă to a
	{FcFrom: uint16(0x0104), FcTo0: uint8(0x41), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ą to A
	{FcFrom: uint16(0x0105), FcTo0: uint8(0x61), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ą to a
	{FcFrom: uint16(0x0106), FcTo0: uint8(0x43), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ć to C
	{FcFrom: uint16(0x0107), FcTo0: uint8(0x63), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ć to c
	{FcFrom: uint16(0x0108), FcTo0: uint8(0x43), FcTo1: uint8(0x68), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ĉ to Ch
	{FcFrom: uint16(0x0109), FcTo0: uint8(0x63), FcTo1: uint8(0x68), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ĉ to ch
	{FcFrom: uint16(0x010A), FcTo0: uint8(0x43), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ċ to C
	{FcFrom: uint16(0x010B), FcTo0: uint8(0x63), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ċ to c
	{FcFrom: uint16(0x010C), FcTo0: uint8(0x43), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Č to C
	{FcFrom: uint16(0x010D), FcTo0: uint8(0x63), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // č to c
	{FcFrom: uint16(0x010E), FcTo0: uint8(0x44), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ď to D
	{FcFrom: uint16(0x010F), FcTo0: uint8(0x64), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ď to d
	{FcFrom: uint16(0x0110), FcTo0: uint8(0x44), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Đ to D
	{FcFrom: uint16(0x0111), FcTo0: uint8(0x64), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // đ to d
	{FcFrom: uint16(0x0112), FcTo0: uint8(0x45), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ē to E
	{FcFrom: uint16(0x0113), FcTo0: uint8(0x65), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ē to e
	{FcFrom: uint16(0x0114), FcTo0: uint8(0x45), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ĕ to E
	{FcFrom: uint16(0x0115), FcTo0: uint8(0x65), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ĕ to e
	{FcFrom: uint16(0x0116), FcTo0: uint8(0x45), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ė to E
	{FcFrom: uint16(0x0117), FcTo0: uint8(0x65), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ė to e
	{FcFrom: uint16(0x0118), FcTo0: uint8(0x45), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ę to E
	{FcFrom: uint16(0x0119), FcTo0: uint8(0x65), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ę to e
	{FcFrom: uint16(0x011A), FcTo0: uint8(0x45), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ě to E
	{FcFrom: uint16(0x011B), FcTo0: uint8(0x65), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ě to e
	{FcFrom: uint16(0x011C), FcTo0: uint8(0x47), FcTo1: uint8(0x68), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ĝ to Gh
	{FcFrom: uint16(0x011D), FcTo0: uint8(0x67), FcTo1: uint8(0x68), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ĝ to gh
	{FcFrom: uint16(0x011E), FcTo0: uint8(0x47), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ğ to G
	{FcFrom: uint16(0x011F), FcTo0: uint8(0x67), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ğ to g
	{FcFrom: uint16(0x0120), FcTo0: uint8(0x47), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ġ to G
	{FcFrom: uint16(0x0121), FcTo0: uint8(0x67), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ġ to g
	{FcFrom: uint16(0x0122), FcTo0: uint8(0x47), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ģ to G
	{FcFrom: uint16(0x0123), FcTo0: uint8(0x67), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ģ to g
	{FcFrom: uint16(0x0124), FcTo0: uint8(0x48), FcTo1: uint8(0x68), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ĥ to Hh
	{FcFrom: uint16(0x0125), FcTo0: uint8(0x68), FcTo1: uint8(0x68), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ĥ to hh
	{FcFrom: uint16(0x0126), FcTo0: uint8(0x48), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ħ to H
	{FcFrom: uint16(0x0127), FcTo0: uint8(0x68), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ħ to h
	{FcFrom: uint16(0x0128), FcTo0: uint8(0x49), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ĩ to I
	{FcFrom: uint16(0x0129), FcTo0: uint8(0x69), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ĩ to i
	{FcFrom: uint16(0x012A), FcTo0: uint8(0x49), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ī to I
	{FcFrom: uint16(0x012B), FcTo0: uint8(0x69), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ī to i
	{FcFrom: uint16(0x012C), FcTo0: uint8(0x49), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ĭ to I
	{FcFrom: uint16(0x012D), FcTo0: uint8(0x69), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ĭ to i
	{FcFrom: uint16(0x012E), FcTo0: uint8(0x49), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Į to I
	{FcFrom: uint16(0x012F), FcTo0: uint8(0x69), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // į to i
	{FcFrom: uint16(0x0130), FcTo0: uint8(0x49), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // İ to I
	{FcFrom: uint16(0x0131), FcTo0: uint8(0x69), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ı to i
	{FcFrom: uint16(0x0132), FcTo0: uint8(0x49), FcTo1: uint8(0x4A), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ĳ to IJ
	{FcFrom: uint16(0x0133), FcTo0: uint8(0x69), FcTo1: uint8(0x6A), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ĳ to ij
	{FcFrom: uint16(0x0134), FcTo0: uint8(0x4A), FcTo1: uint8(0x68), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ĵ to Jh
	{FcFrom: uint16(0x0135), FcTo0: uint8(0x6A), FcTo1: uint8(0x68), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ĵ to jh
	{FcFrom: uint16(0x0136), FcTo0: uint8(0x4B), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ķ to K
	{FcFrom: uint16(0x0137), FcTo0: uint8(0x6B), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ķ to k
	{FcFrom: uint16(0x0138), FcTo0: uint8(0x6B), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ĸ to k
	{FcFrom: uint16(0x0139), FcTo0: uint8(0x4C), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ĺ to L
	{FcFrom: uint16(0x013A), FcTo0: uint8(0x6C), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ĺ to l
	{FcFrom: uint16(0x013B), FcTo0: uint8(0x4C), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ļ to L
	{FcFrom: uint16(0x013C), FcTo0: uint8(0x6C), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ļ to l
	{FcFrom: uint16(0x013D), FcTo0: uint8(0x4C), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ľ to L
	{FcFrom: uint16(0x013E), FcTo0: uint8(0x6C), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ľ to l
	{FcFrom: uint16(0x013F), FcTo0: uint8(0x4C), FcTo1: uint8(0x2E), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ŀ to L.
	{FcFrom: uint16(0x0140), FcTo0: uint8(0x6C), FcTo1: uint8(0x2E), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ŀ to l.
	{FcFrom: uint16(0x0141), FcTo0: uint8(0x4C), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ł to L
	{FcFrom: uint16(0x0142), FcTo0: uint8(0x6C), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ł to l
	{FcFrom: uint16(0x0143), FcTo0: uint8(0x4E), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ń to N
	{FcFrom: uint16(0x0144), FcTo0: uint8(0x6E), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ń to n
	{FcFrom: uint16(0x0145), FcTo0: uint8(0x4E), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ņ to N
	{FcFrom: uint16(0x0146), FcTo0: uint8(0x6E), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ņ to n
	{FcFrom: uint16(0x0147), FcTo0: uint8(0x4E), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ň to N
	{FcFrom: uint16(0x0148), FcTo0: uint8(0x6E), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ň to n
	{FcFrom: uint16(0x0149), FcTo0: uint8(0x27), FcTo1: uint8(0x6E), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ŉ to 'n
	{FcFrom: uint16(0x014A), FcTo0: uint8(0x4E), FcTo1: uint8(0x47), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ŋ to NG
	{FcFrom: uint16(0x014B), FcTo0: uint8(0x6E), FcTo1: uint8(0x67), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ŋ to ng
	{FcFrom: uint16(0x014C), FcTo0: uint8(0x4F), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ō to O
	{FcFrom: uint16(0x014D), FcTo0: uint8(0x6F), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ō to o
	{FcFrom: uint16(0x014E), FcTo0: uint8(0x4F), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ŏ to O
	{FcFrom: uint16(0x014F), FcTo0: uint8(0x6F), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ŏ to o
	{FcFrom: uint16(0x0150), FcTo0: uint8(0x4F), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ő to O
	{FcFrom: uint16(0x0151), FcTo0: uint8(0x6F), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ő to o
	{FcFrom: uint16(0x0152), FcTo0: uint8(0x4F), FcTo1: uint8(0x45), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Œ to OE
	{FcFrom: uint16(0x0153), FcTo0: uint8(0x6F), FcTo1: uint8(0x65), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // œ to oe
	{FcFrom: uint16(0x0154), FcTo0: uint8(0x52), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ŕ to R
	{FcFrom: uint16(0x0155), FcTo0: uint8(0x72), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ŕ to r
	{FcFrom: uint16(0x0156), FcTo0: uint8(0x52), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ŗ to R
	{FcFrom: uint16(0x0157), FcTo0: uint8(0x72), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ŗ to r
	{FcFrom: uint16(0x0158), FcTo0: uint8(0x52), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ř to R
	{FcFrom: uint16(0x0159), FcTo0: uint8(0x72), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ř to r
	{FcFrom: uint16(0x015A), FcTo0: uint8(0x53), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ś to S
	{FcFrom: uint16(0x015B), FcTo0: uint8(0x73), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ś to s
	{FcFrom: uint16(0x015C), FcTo0: uint8(0x53), FcTo1: uint8(0x68), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ŝ to Sh
	{FcFrom: uint16(0x015D), FcTo0: uint8(0x73), FcTo1: uint8(0x68), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ŝ to sh
	{FcFrom: uint16(0x015E), FcTo0: uint8(0x53), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ş to S
	{FcFrom: uint16(0x015F), FcTo0: uint8(0x73), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ş to s
	{FcFrom: uint16(0x0160), FcTo0: uint8(0x53), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Š to S
	{FcFrom: uint16(0x0161), FcTo0: uint8(0x73), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // š to s
	{FcFrom: uint16(0x0162), FcTo0: uint8(0x54), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ţ to T
	{FcFrom: uint16(0x0163), FcTo0: uint8(0x74), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ţ to t
	{FcFrom: uint16(0x0164), FcTo0: uint8(0x54), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ť to T
	{FcFrom: uint16(0x0165), FcTo0: uint8(0x74), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ť to t
	{FcFrom: uint16(0x0166), FcTo0: uint8(0x54), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ŧ to T
	{FcFrom: uint16(0x0167), FcTo0: uint8(0x74), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ŧ to t
	{FcFrom: uint16(0x0168), FcTo0: uint8(0x55), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ũ to U
	{FcFrom: uint16(0x0169), FcTo0: uint8(0x75), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ũ to u
	{FcFrom: uint16(0x016A), FcTo0: uint8(0x55), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ū to U
	{FcFrom: uint16(0x016B), FcTo0: uint8(0x75), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ū to u
	{FcFrom: uint16(0x016C), FcTo0: uint8(0x55), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ŭ to U
	{FcFrom: uint16(0x016D), FcTo0: uint8(0x75), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ŭ to u
	{FcFrom: uint16(0x016E), FcTo0: uint8(0x55), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ů to U
	{FcFrom: uint16(0x016F), FcTo0: uint8(0x75), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ů to u
	{FcFrom: uint16(0x0170), FcTo0: uint8(0x55), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ű to U
	{FcFrom: uint16(0x0171), FcTo0: uint8(0x75), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ű to u
	{FcFrom: uint16(0x0172), FcTo0: uint8(0x55), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ų to U
	{FcFrom: uint16(0x0173), FcTo0: uint8(0x75), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ų to u
	{FcFrom: uint16(0x0174), FcTo0: uint8(0x57), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ŵ to W
	{FcFrom: uint16(0x0175), FcTo0: uint8(0x77), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ŵ to w
	{FcFrom: uint16(0x0176), FcTo0: uint8(0x59), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ŷ to Y
	{FcFrom: uint16(0x0177), FcTo0: uint8(0x79), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ŷ to y
	{FcFrom: uint16(0x0178), FcTo0: uint8(0x59), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ÿ to Y
	{FcFrom: uint16(0x0179), FcTo0: uint8(0x5A), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ź to Z
	{FcFrom: uint16(0x017A), FcTo0: uint8(0x7A), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ź to z
	{FcFrom: uint16(0x017B), FcTo0: uint8(0x5A), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ż to Z
	{FcFrom: uint16(0x017C), FcTo0: uint8(0x7A), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ż to z
	{FcFrom: uint16(0x017D), FcTo0: uint8(0x5A), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ž to Z
	{FcFrom: uint16(0x017E), FcTo0: uint8(0x7A), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ž to z
	{FcFrom: uint16(0x017F), FcTo0: uint8(0x73), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ſ to s
	{FcFrom: uint16(0x0192), FcTo0: uint8(0x66), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ƒ to f
	{FcFrom: uint16(0x0218), FcTo0: uint8(0x53), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ș to S
	{FcFrom: uint16(0x0219), FcTo0: uint8(0x73), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ș to s
	{FcFrom: uint16(0x021A), FcTo0: uint8(0x54), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ț to T
	{FcFrom: uint16(0x021B), FcTo0: uint8(0x74), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ț to t
	{FcFrom: uint16(0x0386), FcTo0: uint8(0x41), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ά to A
	{FcFrom: uint16(0x0388), FcTo0: uint8(0x45), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Έ to E
	{FcFrom: uint16(0x0389), FcTo0: uint8(0x49), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ή to I
	{FcFrom: uint16(0x038A), FcTo0: uint8(0x49), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ί to I
	{FcFrom: uint16(0x038C), FcTo0: uint8(0x4f), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ό to O
	{FcFrom: uint16(0x038E), FcTo0: uint8(0x59), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ύ to Y
	{FcFrom: uint16(0x038F), FcTo0: uint8(0x4f), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ώ to O
	{FcFrom: uint16(0x0390), FcTo0: uint8(0x69), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ΐ to i
	{FcFrom: uint16(0x0391), FcTo0: uint8(0x41), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Α to A
	{FcFrom: uint16(0x0392), FcTo0: uint8(0x42), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Β to B
	{FcFrom: uint16(0x0393), FcTo0: uint8(0x47), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Γ to G
	{FcFrom: uint16(0x0394), FcTo0: uint8(0x44), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Δ to D
	{FcFrom: uint16(0x0395), FcTo0: uint8(0x45), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ε to E
	{FcFrom: uint16(0x0396), FcTo0: uint8(0x5a), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ζ to Z
	{FcFrom: uint16(0x0397), FcTo0: uint8(0x49), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Η to I
	{FcFrom: uint16(0x0398), FcTo0: uint8(0x54), FcTo1: uint8(0x68), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Θ to Th
	{FcFrom: uint16(0x0399), FcTo0: uint8(0x49), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ι to I
	{FcFrom: uint16(0x039A), FcTo0: uint8(0x4b), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Κ to K
	{FcFrom: uint16(0x039B), FcTo0: uint8(0x4c), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Λ to L
	{FcFrom: uint16(0x039C), FcTo0: uint8(0x4d), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Μ to M
	{FcFrom: uint16(0x039D), FcTo0: uint8(0x4e), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ν to N
	{FcFrom: uint16(0x039E), FcTo0: uint8(0x58), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ξ to X
	{FcFrom: uint16(0x039F), FcTo0: uint8(0x4f), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ο to O
	{FcFrom: uint16(0x03A0), FcTo0: uint8(0x50), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Π to P
	{FcFrom: uint16(0x03A1), FcTo0: uint8(0x52), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ρ to R
	{FcFrom: uint16(0x03A3), FcTo0: uint8(0x53), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Σ to S
	{FcFrom: uint16(0x03A4), FcTo0: uint8(0x54), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Τ to T
	{FcFrom: uint16(0x03A5), FcTo0: uint8(0x59), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Υ to Y
	{FcFrom: uint16(0x03A6), FcTo0: uint8(0x46), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Φ to F
	{FcFrom: uint16(0x03A7), FcTo0: uint8(0x43), FcTo1: uint8(0x68), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Χ to Ch
	{FcFrom: uint16(0x03A8), FcTo0: uint8(0x50), FcTo1: uint8(0x73), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ψ to Ps
	{FcFrom: uint16(0x03A9), FcTo0: uint8(0x4f), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ω to O
	{FcFrom: uint16(0x03AA), FcTo0: uint8(0x49), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ϊ to I
	{FcFrom: uint16(0x03AB), FcTo0: uint8(0x59), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ϋ to Y
	{FcFrom: uint16(0x03AC), FcTo0: uint8(0x61), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ά to a
	{FcFrom: uint16(0x03AD), FcTo0: uint8(0x65), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // έ to e
	{FcFrom: uint16(0x03AE), FcTo0: uint8(0x69), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ή to i
	{FcFrom: uint16(0x03AF), FcTo0: uint8(0x69), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ί to i
	{FcFrom: uint16(0x03B1), FcTo0: uint8(0x61), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // α to a
	{FcFrom: uint16(0x03B2), FcTo0: uint8(0x62), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // β to b
	{FcFrom: uint16(0x03B3), FcTo0: uint8(0x67), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // γ to g
	{FcFrom: uint16(0x03B4), FcTo0: uint8(0x64), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // δ to d
	{FcFrom: uint16(0x03B5), FcTo0: uint8(0x65), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ε to e
	{FcFrom: uint16(0x03B6), FcTo0: uint8(0x7a), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ζ to z
	{FcFrom: uint16(0x03B7), FcTo0: uint8(0x69), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // η to i
	{FcFrom: uint16(0x03B8), FcTo0: uint8(0x74), FcTo1: uint8(0x68), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // θ to th
	{FcFrom: uint16(0x03B9), FcTo0: uint8(0x69), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ι to i
	{FcFrom: uint16(0x03BA), FcTo0: uint8(0x6b), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // κ to k
	{FcFrom: uint16(0x03BB), FcTo0: uint8(0x6c), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // λ to l
	{FcFrom: uint16(0x03BC), FcTo0: uint8(0x6d), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // μ to m
	{FcFrom: uint16(0x03BD), FcTo0: uint8(0x6e), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ν to n
	{FcFrom: uint16(0x03BE), FcTo0: uint8(0x78), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ξ to x
	{FcFrom: uint16(0x03BF), FcTo0: uint8(0x6f), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ο to o
	{FcFrom: uint16(0x03C0), FcTo0: uint8(0x70), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // π to p
	{FcFrom: uint16(0x03C1), FcTo0: uint8(0x72), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ρ to r
	{FcFrom: uint16(0x03C3), FcTo0: uint8(0x73), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // σ to s
	{FcFrom: uint16(0x03C4), FcTo0: uint8(0x74), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // τ to t
	{FcFrom: uint16(0x03C5), FcTo0: uint8(0x79), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // υ to y
	{FcFrom: uint16(0x03C6), FcTo0: uint8(0x66), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // φ to f
	{FcFrom: uint16(0x03C7), FcTo0: uint8(0x63), FcTo1: uint8(0x68), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // χ to ch
	{FcFrom: uint16(0x03C8), FcTo0: uint8(0x70), FcTo1: uint8(0x73), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ψ to ps
	{FcFrom: uint16(0x03C9), FcTo0: uint8(0x6f), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ω to o
	{FcFrom: uint16(0x03CA), FcTo0: uint8(0x69), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ϊ to i
	{FcFrom: uint16(0x03CB), FcTo0: uint8(0x79), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ϋ to y
	{FcFrom: uint16(0x03CC), FcTo0: uint8(0x6f), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ό to o
	{FcFrom: uint16(0x03CD), FcTo0: uint8(0x79), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ύ to y
	{FcFrom: uint16(0x03CE), FcTo0: uint8(0x69), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ώ to i
	{FcFrom: uint16(0x0400), FcTo0: uint8(0x45), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ѐ to E
	{FcFrom: uint16(0x0401), FcTo0: uint8(0x45), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ё to E
	{FcFrom: uint16(0x0402), FcTo0: uint8(0x44), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ђ to D
	{FcFrom: uint16(0x0403), FcTo0: uint8(0x47), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ѓ to G
	{FcFrom: uint16(0x0404), FcTo0: uint8(0x45), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Є to E
	{FcFrom: uint16(0x0405), FcTo0: uint8(0x5a), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ѕ to Z
	{FcFrom: uint16(0x0406), FcTo0: uint8(0x49), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // І to I
	{FcFrom: uint16(0x0407), FcTo0: uint8(0x49), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ї to I
	{FcFrom: uint16(0x0408), FcTo0: uint8(0x4a), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ј to J
	{FcFrom: uint16(0x0409), FcTo0: uint8(0x49), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Љ to I
	{FcFrom: uint16(0x040A), FcTo0: uint8(0x4e), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Њ to N
	{FcFrom: uint16(0x040B), FcTo0: uint8(0x44), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ћ to D
	{FcFrom: uint16(0x040C), FcTo0: uint8(0x4b), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ќ to K
	{FcFrom: uint16(0x040D), FcTo0: uint8(0x49), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ѝ to I
	{FcFrom: uint16(0x040E), FcTo0: uint8(0x55), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ў to U
	{FcFrom: uint16(0x040F), FcTo0: uint8(0x44), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Џ to D
	{FcFrom: uint16(0x0410), FcTo0: uint8(0x41), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // А to A
	{FcFrom: uint16(0x0411), FcTo0: uint8(0x42), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Б to B
	{FcFrom: uint16(0x0412), FcTo0: uint8(0x56), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // В to V
	{FcFrom: uint16(0x0413), FcTo0: uint8(0x47), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Г to G
	{FcFrom: uint16(0x0414), FcTo0: uint8(0x44), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Д to D
	{FcFrom: uint16(0x0415), FcTo0: uint8(0x45), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Е to E
	{FcFrom: uint16(0x0416), FcTo0: uint8(0x5a), FcTo1: uint8(0x68), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ж to Zh
	{FcFrom: uint16(0x0417), FcTo0: uint8(0x5a), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // З to Z
	{FcFrom: uint16(0x0418), FcTo0: uint8(0x49), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // И to I
	{FcFrom: uint16(0x0419), FcTo0: uint8(0x49), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Й to I
	{FcFrom: uint16(0x041A), FcTo0: uint8(0x4b), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // К to K
	{FcFrom: uint16(0x041B), FcTo0: uint8(0x4c), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Л to L
	{FcFrom: uint16(0x041C), FcTo0: uint8(0x4d), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // М to M
	{FcFrom: uint16(0x041D), FcTo0: uint8(0x4e), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Н to N
	{FcFrom: uint16(0x041E), FcTo0: uint8(0x4f), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // О to O
	{FcFrom: uint16(0x041F), FcTo0: uint8(0x50), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // П to P
	{FcFrom: uint16(0x0420), FcTo0: uint8(0x52), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Р to R
	{FcFrom: uint16(0x0421), FcTo0: uint8(0x53), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // С to S
	{FcFrom: uint16(0x0422), FcTo0: uint8(0x54), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Т to T
	{FcFrom: uint16(0x0423), FcTo0: uint8(0x55), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // У to U
	{FcFrom: uint16(0x0424), FcTo0: uint8(0x46), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ф to F
	{FcFrom: uint16(0x0425), FcTo0: uint8(0x4b), FcTo1: uint8(0x68), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Х to Kh
	{FcFrom: uint16(0x0426), FcTo0: uint8(0x54), FcTo1: uint8(0x63), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ц to Tc
	{FcFrom: uint16(0x0427), FcTo0: uint8(0x43), FcTo1: uint8(0x68), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ч to Ch
	{FcFrom: uint16(0x0428), FcTo0: uint8(0x53), FcTo1: uint8(0x68), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ш to Sh
	{FcFrom: uint16(0x0429), FcTo0: uint8(0x53), FcTo1: uint8(0x68), FcTo2: uint8(0x63), FcTo3: uint8(0x68)}, // Щ to Shch
	{FcFrom: uint16(0x042A), FcTo0: uint8(0x61), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, //  to A
	{FcFrom: uint16(0x042B), FcTo0: uint8(0x59), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ы to Y
	{FcFrom: uint16(0x042C), FcTo0: uint8(0x59), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, //  to Y
	{FcFrom: uint16(0x042D), FcTo0: uint8(0x45), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Э to E
	{FcFrom: uint16(0x042E), FcTo0: uint8(0x49), FcTo1: uint8(0x75), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ю to Iu
	{FcFrom: uint16(0x042F), FcTo0: uint8(0x49), FcTo1: uint8(0x61), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Я to Ia
	{FcFrom: uint16(0x0430), FcTo0: uint8(0x61), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // а to a
	{FcFrom: uint16(0x0431), FcTo0: uint8(0x62), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // б to b
	{FcFrom: uint16(0x0432), FcTo0: uint8(0x76), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // в to v
	{FcFrom: uint16(0x0433), FcTo0: uint8(0x67), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // г to g
	{FcFrom: uint16(0x0434), FcTo0: uint8(0x64), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // д to d
	{FcFrom: uint16(0x0435), FcTo0: uint8(0x65), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // е to e
	{FcFrom: uint16(0x0436), FcTo0: uint8(0x7a), FcTo1: uint8(0x68), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ж to zh
	{FcFrom: uint16(0x0437), FcTo0: uint8(0x7a), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // з to z
	{FcFrom: uint16(0x0438), FcTo0: uint8(0x69), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // и to i
	{FcFrom: uint16(0x0439), FcTo0: uint8(0x69), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // й to i
	{FcFrom: uint16(0x043A), FcTo0: uint8(0x6b), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // к to k
	{FcFrom: uint16(0x043B), FcTo0: uint8(0x6c), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // л to l
	{FcFrom: uint16(0x043C), FcTo0: uint8(0x6d), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // м to m
	{FcFrom: uint16(0x043D), FcTo0: uint8(0x6e), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // н to n
	{FcFrom: uint16(0x043E), FcTo0: uint8(0x6f), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // о to o
	{FcFrom: uint16(0x043F), FcTo0: uint8(0x70), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // п to p
	{FcFrom: uint16(0x0440), FcTo0: uint8(0x72), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // р to r
	{FcFrom: uint16(0x0441), FcTo0: uint8(0x73), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // с to s
	{FcFrom: uint16(0x0442), FcTo0: uint8(0x74), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // т to t
	{FcFrom: uint16(0x0443), FcTo0: uint8(0x75), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // у to u
	{FcFrom: uint16(0x0444), FcTo0: uint8(0x66), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ф to f
	{FcFrom: uint16(0x0445), FcTo0: uint8(0x6b), FcTo1: uint8(0x68), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // х to kh
	{FcFrom: uint16(0x0446), FcTo0: uint8(0x74), FcTo1: uint8(0x63), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ц to tc
	{FcFrom: uint16(0x0447), FcTo0: uint8(0x63), FcTo1: uint8(0x68), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ч to ch
	{FcFrom: uint16(0x0448), FcTo0: uint8(0x73), FcTo1: uint8(0x68), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ш to sh
	{FcFrom: uint16(0x0449), FcTo0: uint8(0x73), FcTo1: uint8(0x68), FcTo2: uint8(0x63), FcTo3: uint8(0x68)}, // щ to shch
	{FcFrom: uint16(0x044A), FcTo0: uint8(0x61), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, //  to a
	{FcFrom: uint16(0x044B), FcTo0: uint8(0x79), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ы to y
	{FcFrom: uint16(0x044C), FcTo0: uint8(0x79), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, //  to y
	{FcFrom: uint16(0x044D), FcTo0: uint8(0x65), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // э to e
	{FcFrom: uint16(0x044E), FcTo0: uint8(0x69), FcTo1: uint8(0x75), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ю to iu
	{FcFrom: uint16(0x044F), FcTo0: uint8(0x69), FcTo1: uint8(0x61), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // я to ia
	{FcFrom: uint16(0x0450), FcTo0: uint8(0x65), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ѐ to e
	{FcFrom: uint16(0x0451), FcTo0: uint8(0x65), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ё to e
	{FcFrom: uint16(0x0452), FcTo0: uint8(0x64), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ђ to d
	{FcFrom: uint16(0x0453), FcTo0: uint8(0x67), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ѓ to g
	{FcFrom: uint16(0x0454), FcTo0: uint8(0x65), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // є to e
	{FcFrom: uint16(0x0455), FcTo0: uint8(0x7a), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ѕ to z
	{FcFrom: uint16(0x0456), FcTo0: uint8(0x69), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // і to i
	{FcFrom: uint16(0x0457), FcTo0: uint8(0x69), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ї to i
	{FcFrom: uint16(0x0458), FcTo0: uint8(0x6a), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ј to j
	{FcFrom: uint16(0x0459), FcTo0: uint8(0x69), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // љ to i
	{FcFrom: uint16(0x045A), FcTo0: uint8(0x6e), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // њ to n
	{FcFrom: uint16(0x045B), FcTo0: uint8(0x64), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ћ to d
	{FcFrom: uint16(0x045C), FcTo0: uint8(0x6b), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ќ to k
	{FcFrom: uint16(0x045D), FcTo0: uint8(0x69), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ѝ to i
	{FcFrom: uint16(0x045E), FcTo0: uint8(0x75), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ў to u
	{FcFrom: uint16(0x045F), FcTo0: uint8(0x64), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // џ to d
	{FcFrom: uint16(0x1E02), FcTo0: uint8(0x42), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ḃ to B
	{FcFrom: uint16(0x1E03), FcTo0: uint8(0x62), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ḃ to b
	{FcFrom: uint16(0x1E0A), FcTo0: uint8(0x44), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ḋ to D
	{FcFrom: uint16(0x1E0B), FcTo0: uint8(0x64), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ḋ to d
	{FcFrom: uint16(0x1E1E), FcTo0: uint8(0x46), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ḟ to F
	{FcFrom: uint16(0x1E1F), FcTo0: uint8(0x66), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ḟ to f
	{FcFrom: uint16(0x1E40), FcTo0: uint8(0x4D), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ṁ to M
	{FcFrom: uint16(0x1E41), FcTo0: uint8(0x6D), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ṁ to m
	{FcFrom: uint16(0x1E56), FcTo0: uint8(0x50), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ṗ to P
	{FcFrom: uint16(0x1E57), FcTo0: uint8(0x70), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ṗ to p
	{FcFrom: uint16(0x1E60), FcTo0: uint8(0x53), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ṡ to S
	{FcFrom: uint16(0x1E61), FcTo0: uint8(0x73), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ṡ to s
	{FcFrom: uint16(0x1E6A), FcTo0: uint8(0x54), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ṫ to T
	{FcFrom: uint16(0x1E6B), FcTo0: uint8(0x74), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ṫ to t
	{FcFrom: uint16(0x1E80), FcTo0: uint8(0x57), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ẁ to W
	{FcFrom: uint16(0x1E81), FcTo0: uint8(0x77), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ẁ to w
	{FcFrom: uint16(0x1E82), FcTo0: uint8(0x57), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ẃ to W
	{FcFrom: uint16(0x1E83), FcTo0: uint8(0x77), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ẃ to w
	{FcFrom: uint16(0x1E84), FcTo0: uint8(0x57), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ẅ to W
	{FcFrom: uint16(0x1E85), FcTo0: uint8(0x77), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ẅ to w
	{FcFrom: uint16(0x1EF2), FcTo0: uint8(0x59), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // Ỳ to Y
	{FcFrom: uint16(0x1EF3), FcTo0: uint8(0x79), FcTo1: uint8(0x00), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ỳ to y
	{FcFrom: uint16(0xFB00), FcTo0: uint8(0x66), FcTo1: uint8(0x66), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ﬀ to ff
	{FcFrom: uint16(0xFB01), FcTo0: uint8(0x66), FcTo1: uint8(0x69), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ﬁ to fi
	{FcFrom: uint16(0xFB02), FcTo0: uint8(0x66), FcTo1: uint8(0x6C), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ﬂ to fl
	{FcFrom: uint16(0xFB05), FcTo0: uint8(0x73), FcTo1: uint8(0x74), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ﬅ to st
	{FcFrom: uint16(0xFB06), FcTo0: uint8(0x73), FcTo1: uint8(0x74), FcTo2: uint8(0x00), FcTo3: uint8(0x00)}, // ﬆ to st
} /* spellfix.c:1306:30 */

func spellfixFindTranslit(tls *crt.TLS, c int32, pxTop uintptr) uintptr { /* spellfix.c:1698:30: */
	*(*int32)(unsafe.Pointer(pxTop)) = (int32((uint64(unsafe.Sizeof(translit)) / uint64(unsafe.Sizeof(Transliteration{}))) - uint64(1)))
	return uintptr(unsafe.Pointer(&translit))
}

// Convert the input string from UTF-8 into pure ASCII by converting
// all non-ASCII characters to some combination of characters in the
// ASCII subset.
//
// The returned string might contain more characters than the input.
//
// Space to hold the returned string comes from sqlite3_malloc() and
// should be freed by the caller.
func transliterate(tls *crt.TLS, zIn uintptr, nIn int32) uintptr { /* spellfix.c:1713:22: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var zOut uintptr = sqlite3.Xsqlite3_malloc64(tls, (uint64((nIn * 4) + 1)))
	var c int32
	// var sz int32 at bp, 4

	var nOut int32
	if zOut == uintptr(0) {
		return uintptr(0)
	}
	nOut = 0
	for nIn > 0 {
		c = utf8Read(tls, zIn, nIn, bp /* &sz */)
		zIn += uintptr(*(*int32)(unsafe.Pointer(bp /* sz */)))
		nIn = nIn - (*(*int32)(unsafe.Pointer(bp /* sz */)))
		if c <= 127 {
			*(*uint8)(unsafe.Pointer(zOut + uintptr(crt.PostIncInt32(&nOut, 1)))) = uint8(c)
		} else {
			// var xTop int32 at bp+4, 4

			var xBtm int32
			var x int32
			var tbl uintptr = spellfixFindTranslit(tls, c, bp+4 /* &xTop */)
			xBtm = 0
			for *(*int32)(unsafe.Pointer(bp + 4 /* xTop */)) >= xBtm {
				x = ((*(*int32)(unsafe.Pointer(bp + 4 /* xTop */)) + xBtm) / 2)
				if int32((*Transliteration)(unsafe.Pointer(tbl+uintptr(x)*6)).FcFrom) == c {
					*(*uint8)(unsafe.Pointer(zOut + uintptr(crt.PostIncInt32(&nOut, 1)))) = (*Transliteration)(unsafe.Pointer(tbl + uintptr(x)*6)).FcTo0
					if (*Transliteration)(unsafe.Pointer(tbl+uintptr(x)*6)).FcTo1 != 0 {
						*(*uint8)(unsafe.Pointer(zOut + uintptr(crt.PostIncInt32(&nOut, 1)))) = (*Transliteration)(unsafe.Pointer(tbl + uintptr(x)*6)).FcTo1
						if (*Transliteration)(unsafe.Pointer(tbl+uintptr(x)*6)).FcTo2 != 0 {
							*(*uint8)(unsafe.Pointer(zOut + uintptr(crt.PostIncInt32(&nOut, 1)))) = (*Transliteration)(unsafe.Pointer(tbl + uintptr(x)*6)).FcTo2
							if (*Transliteration)(unsafe.Pointer(tbl+uintptr(x)*6)).FcTo3 != 0 {
								*(*uint8)(unsafe.Pointer(zOut + uintptr(crt.PostIncInt32(&nOut, 1)))) = (*Transliteration)(unsafe.Pointer(tbl + uintptr(x)*6)).FcTo3
							}
						}
					}
					c = 0
					break
				} else if int32((*Transliteration)(unsafe.Pointer(tbl+uintptr(x)*6)).FcFrom) > c {
					*(*int32)(unsafe.Pointer(bp + 4 /* xTop */)) = (x - 1)
				} else {
					xBtm = (x + 1)
				}
			}
			if c != 0 {
				*(*uint8)(unsafe.Pointer(zOut + uintptr(crt.PostIncInt32(&nOut, 1)))) = uint8('?')
			}
		}
	}
	*(*uint8)(unsafe.Pointer(zOut + uintptr(nOut))) = uint8(0)
	return zOut
}

// Return the number of characters in the shortest prefix of the input
// string that transliterates to an ASCII string nTrans bytes or longer.
// Or, if the transliteration of the input string is less than nTrans
// bytes in size, return the number of characters in the input string.
func translen_to_charlen(tls *crt.TLS, zIn uintptr, nIn int32, nTrans int32) int32 { /* spellfix.c:1771:12: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var i int32
	var c int32
	// var sz int32 at bp, 4

	var nOut int32
	var nChar int32

	i = crt.AssignInt32(&nOut, 0)
	for nChar = 0; (i < nIn) && (nOut < nTrans); nChar++ {
		c = utf8Read(tls, (zIn + uintptr(i)), (nIn - i), bp /* &sz */)
		i = i + (*(*int32)(unsafe.Pointer(bp /* sz */)))

		nOut++
		if c >= 128 {
			// var xTop int32 at bp+4, 4

			var xBtm int32
			var x int32
			var tbl uintptr = spellfixFindTranslit(tls, c, bp+4 /* &xTop */)
			xBtm = 0
			for *(*int32)(unsafe.Pointer(bp + 4 /* xTop */)) >= xBtm {
				x = ((*(*int32)(unsafe.Pointer(bp + 4 /* xTop */)) + xBtm) / 2)
				if int32((*Transliteration)(unsafe.Pointer(tbl+uintptr(x)*6)).FcFrom) == c {
					if (*Transliteration)(unsafe.Pointer(tbl+uintptr(x)*6)).FcTo1 != 0 {
						nOut++
						if (*Transliteration)(unsafe.Pointer(tbl+uintptr(x)*6)).FcTo2 != 0 {
							nOut++
							if (*Transliteration)(unsafe.Pointer(tbl+uintptr(x)*6)).FcTo3 != 0 {
								nOut++
							}
						}
					}
					break
				} else if int32((*Transliteration)(unsafe.Pointer(tbl+uintptr(x)*6)).FcFrom) > c {
					*(*int32)(unsafe.Pointer(bp + 4 /* xTop */)) = (x - 1)
				} else {
					xBtm = (x + 1)
				}
			}
		}
	}

	return nChar
}

//    spellfix1_translit(X)
//
// Convert a string that contains non-ASCII Roman characters into
// pure ASCII.
func transliterateSqlFunc(tls *crt.TLS, context uintptr, argc int32, argv uintptr) { /* spellfix.c:1817:13: */
	var zIn uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)))
	var nIn int32 = sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)))
	var zOut uintptr = transliterate(tls, zIn, nIn)
	if zOut == uintptr(0) {
		sqlite3.Xsqlite3_result_error_nomem(tls, context)
	} else {
		sqlite3.Xsqlite3_result_text(tls, context, zOut, -1, *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, uintptr) }{sqlite3.Xsqlite3_free})))
	}
}

//    spellfix1_scriptcode(X)
//
// Try to determine the dominant script used by the word X and return
// its ISO 15924 numeric code.
//
// The current implementation only understands the following scripts:
//
//    215  (Latin)
//    220  (Cyrillic)
//    200  (Greek)
//
// This routine will return 998 if the input X contains characters from
// two or more of the above scripts or 999 if X contains no characters
// from any of the above scripts.
func scriptCodeSqlFunc(tls *crt.TLS, context uintptr, argc int32, argv uintptr) { /* spellfix.c:1848:13: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var zIn uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)))
	var nIn int32 = sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)))
	var c int32
	// var sz int32 at bp, 4

	var scriptMask int32 = 0
	var res int32
	var seenDigit int32 = 0

	for nIn > 0 {
		c = utf8Read(tls, zIn, nIn, bp /* &sz */)
		zIn += uintptr(*(*int32)(unsafe.Pointer(bp /* sz */)))
		nIn = nIn - (*(*int32)(unsafe.Pointer(bp /* sz */)))
		if c < 0x02af {
			if (c >= 0x80) || (int32(midClass[(c&0x7f)]) < 10) {
				scriptMask = scriptMask | (0x0001)
			} else if (c >= '0') && (c <= '9') {
				seenDigit = 1
			}
		} else if (c >= 0x0400) && (c <= 0x04ff) {
			scriptMask = scriptMask | (0x0002)
		} else if (c >= 0x0386) && (c <= 0x03ce) {
			scriptMask = scriptMask | (0x0004)
		} else if (c >= 0x0590) && (c <= 0x05ff) {
			scriptMask = scriptMask | (0x0008)
		} else if (c >= 0x0600) && (c <= 0x06ff) {
			scriptMask = scriptMask | (0x0010)
		}
	}
	if (scriptMask == 0) && (seenDigit != 0) {
		scriptMask = 0x0001
	}
	switch scriptMask {
	case 0:
		res = 999
		break
	case 0x0001:
		res = 215
		break
	case 0x0002:
		res = 220
		break
	case 0x0004:
		res = 200
		break
	case 0x0008:
		res = 125
		break
	case 0x0010:
		res = 160
		break
	default:
		res = 998
		break
	}
	sqlite3.Xsqlite3_result_int(tls, context, res)
}

// End transliterate
//
//
// Begin spellfix1 virtual table.

// Maximum length of a phonehash used for querying the shadow table

// Maximum number of hash strings to examine per query

type spellfix1_vtab1 = struct {
	Fbase       sqlite3_vtab
	Fdb         uintptr
	FzDbName    uintptr
	FzTableName uintptr
	FzCostTable uintptr
	FpConfig3   uintptr
}

// End transliterate
//
//
// Begin spellfix1 virtual table.

// Maximum length of a phonehash used for querying the shadow table

// Maximum number of hash strings to examine per query

type spellfix1_vtab = spellfix1_vtab1 /* spellfix.c:1910:31 */
type spellfix1_cursor1 = struct {
	Fbase      sqlite3_vtab_cursor
	FpVTab     uintptr
	FzPattern  uintptr
	FidxNum    int32
	FnRow      int32
	FnAlloc    int32
	FiRow      int32
	FiLang     int32
	FiTop      int32
	FiScope    int32
	FnSearch   int32
	FpFullScan uintptr
	Fa         uintptr
}

type spellfix1_cursor = spellfix1_cursor1 /* spellfix.c:1911:33 */

// Fuzzy-search cursor object
type spellfix1_row = struct {
	FiRowid    sqlite3_int64
	FzWord     uintptr
	FiRank     int32
	FiDistance int32
	FiScore    int32
	FiMatchlen int32
	FzHash     [32]int8
}

// Construct one or more SQL statements from the format string given
// and then evaluate those statements. The success code is written
// into *pRc.
//
// If *pRc is initially non-zero then this routine is a no-op.
func spellfix1DbExec(tls *crt.TLS, pRc uintptr, db uintptr, zFormat uintptr, va uintptr) { /* spellfix.c:1955:13: */
	var ap va_list
	_ = ap
	var zSql uintptr
	if *(*int32)(unsafe.Pointer(pRc)) != 0 {
		return
	}
	ap = va
	zSql = sqlite3.Xsqlite3_vmprintf(tls, zFormat, ap)
	_ = ap
	if zSql == uintptr(0) {
		*(*int32)(unsafe.Pointer(pRc)) = 7
	} else {
		*(*int32)(unsafe.Pointer(pRc)) = sqlite3.Xsqlite3_exec(tls, db, zSql, uintptr(0), uintptr(0), uintptr(0))
		sqlite3.Xsqlite3_free(tls, zSql)
	}
}

// xDisconnect/xDestroy method for the fuzzy-search module.
func spellfix1Uninit(tls *crt.TLS, isDestroy int32, pVTab uintptr) int32 { /* spellfix.c:1978:12: */
	bp := tls.Alloc(20)
	defer tls.Free(20)

	var p uintptr = pVTab
	*(*int32)(unsafe.Pointer(bp + 16 /* rc */)) = 0
	if isDestroy != 0 {
		var db uintptr = (*spellfix1_vtab)(unsafe.Pointer(p)).Fdb
		spellfix1DbExec(tls, bp+16 /* &rc */, db, ts+6668, /* "DROP TABLE IF EX..." */
			crt.VaList(bp, (*spellfix1_vtab)(unsafe.Pointer(p)).FzDbName, (*spellfix1_vtab)(unsafe.Pointer(p)).FzTableName))
	}
	if *(*int32)(unsafe.Pointer(bp + 16 /* rc */)) == 0 {
		sqlite3.Xsqlite3_free(tls, (*spellfix1_vtab)(unsafe.Pointer(p)).FzTableName)
		editDist3ConfigDelete(tls, (*spellfix1_vtab)(unsafe.Pointer(p)).FpConfig3)
		sqlite3.Xsqlite3_free(tls, (*spellfix1_vtab)(unsafe.Pointer(p)).FzCostTable)
		sqlite3.Xsqlite3_free(tls, p)
	}
	return *(*int32)(unsafe.Pointer(bp + 16 /* rc */))
}
func spellfix1Disconnect(tls *crt.TLS, pVTab uintptr) int32 { /* spellfix.c:1994:12: */
	return spellfix1Uninit(tls, 0, pVTab)
}
func spellfix1Destroy(tls *crt.TLS, pVTab uintptr) int32 { /* spellfix.c:1997:12: */
	return spellfix1Uninit(tls, 1, pVTab)
}

// Make a copy of a string.  Remove leading and trailing whitespace
// and dequote it.
func spellfix1Dequote(tls *crt.TLS, zIn uintptr) uintptr { /* spellfix.c:2005:13: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var zOut uintptr
	var i int32
	var j int32
	var c int8
	for (int32(*(*uint16)(unsafe.Pointer((*(*uintptr)(unsafe.Pointer(crt.X__ctype_b_loc(tls)))) + uintptr(int32(uint8(*(*int8)(unsafe.Pointer(zIn + uintptr(0))))))*2))) & int32(uint16(8192))) != 0 {
		zIn++
	}
	zOut = sqlite3.Xsqlite3_mprintf(tls, ts+130 /* "%s" */, crt.VaList(bp, zIn))
	if zOut == uintptr(0) {
		return uintptr(0)
	}
	i = int32(crt.Xstrlen(tls, zOut))
	*(*int8)(unsafe.Pointer(zOut + uintptr(i))) = int8(0)
	c = *(*int8)(unsafe.Pointer(zOut + uintptr(0)))
	if (int32(c) == '\'') || (int32(c) == '"') {
		i = 1
		j = 0
		for ; 1 != 0; i++ {
			*(*int8)(unsafe.Pointer(zOut + uintptr(crt.PostIncInt32(&j, 1)))) = *(*int8)(unsafe.Pointer(zOut + uintptr(i)))
			if int32(*(*int8)(unsafe.Pointer(zOut + uintptr(i)))) == int32(c) {
				if int32(*(*int8)(unsafe.Pointer(zOut + uintptr((i + 1))))) == int32(c) {
					i++
				} else {
					*(*int8)(unsafe.Pointer(zOut + uintptr((j - 1)))) = int8(0)
					break
				}
			}
		}
	}
	return zOut
}

// xConnect/xCreate method for the spellfix1 module. Arguments are:
//
//   argv[0]   -> module name  ("spellfix1")
//   argv[1]   -> database name
//   argv[2]   -> table name
//   argv[3].. -> optional arguments (i.e. "edit_cost_table" parameter)
func spellfix1Init(tls *crt.TLS, isCreate int32, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVTab uintptr, pzErr uintptr) int32 { /* spellfix.c:2043:12: */
	bp := tls.Alloc(60)
	defer tls.Free(60)

	var pNew uintptr = uintptr(0)
	// const char *zModule = argv[0]; // not used
	var zDbName uintptr = *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8))
	var zTableName uintptr = *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8))
	var nDbName int32
	*(*int32)(unsafe.Pointer(bp + 56 /* rc */)) = 0
	var i int32

	nDbName = int32(crt.Xstrlen(tls, zDbName))
	pNew = sqlite3.Xsqlite3_malloc64(tls, (uint64((uint64(unsafe.Sizeof(spellfix1_vtab{})) + uint64(nDbName)) + uint64(1))))
	if pNew == uintptr(0) {
		*(*int32)(unsafe.Pointer(bp + 56 /* rc */)) = 7
	} else {
		crt.Xmemset(tls, pNew, 0, uint64(unsafe.Sizeof(spellfix1_vtab{})))
		(*spellfix1_vtab)(unsafe.Pointer(pNew)).FzDbName = (pNew + uintptr(1)*64)
		crt.Xmemcpy(tls, (*spellfix1_vtab)(unsafe.Pointer(pNew)).FzDbName, zDbName, (uint64(nDbName + 1)))
		(*spellfix1_vtab)(unsafe.Pointer(pNew)).FzTableName = sqlite3.Xsqlite3_mprintf(tls, ts+130 /* "%s" */, crt.VaList(bp, zTableName))
		(*spellfix1_vtab)(unsafe.Pointer(pNew)).Fdb = db
		if (*spellfix1_vtab)(unsafe.Pointer(pNew)).FzTableName == uintptr(0) {
			*(*int32)(unsafe.Pointer(bp + 56 /* rc */)) = 7
		} else {
			sqlite3.Xsqlite3_vtab_config(tls, db, 2, 0)
			*(*int32)(unsafe.Pointer(bp + 56 /* rc */)) = sqlite3.Xsqlite3_declare_vtab(tls, db,

				ts+6705 /* "CREATE TABLE x(w..." */)
		}
		if (*(*int32)(unsafe.Pointer(bp + 56 /* rc */)) == 0) && (isCreate != 0) {
			spellfix1DbExec(tls, bp+56 /* &rc */, db,

				ts+6859, /* "CREATE TABLE IF ..." */
				crt.VaList(bp+8, zDbName, zTableName))
			spellfix1DbExec(tls, bp+56 /* &rc */, db,

				ts+6993, /* "CREATE INDEX IF ..." */
				crt.VaList(bp+24, zDbName, zTableName, zTableName))
		}
		for i = 3; (*(*int32)(unsafe.Pointer(bp + 56 /* rc */)) == 0) && (i < argc); i++ {
			if (crt.Xstrncmp(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8)), ts+7078 /* "edit_cost_table=" */, uint64(16)) == 0) && ((*spellfix1_vtab)(unsafe.Pointer(pNew)).FzCostTable == uintptr(0)) {
				(*spellfix1_vtab)(unsafe.Pointer(pNew)).FzCostTable = spellfix1Dequote(tls, (*(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8)) + uintptr(16)))
				if (*spellfix1_vtab)(unsafe.Pointer(pNew)).FzCostTable == uintptr(0) {
					*(*int32)(unsafe.Pointer(bp + 56 /* rc */)) = 7
				}
				continue
			}
			*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+7095 /* "bad argument to ..." */, crt.VaList(bp+48, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8))))
			*(*int32)(unsafe.Pointer(bp + 56 /* rc */)) = 1
		}
	}

	if (*(*int32)(unsafe.Pointer(bp + 56 /* rc */)) != 0) && (pNew != 0) {
		*(*uintptr)(unsafe.Pointer(ppVTab)) = uintptr(0)
		spellfix1Uninit(tls, 0, (pNew /* &.base */))
	} else {
		*(*uintptr)(unsafe.Pointer(ppVTab)) = pNew
	}
	return *(*int32)(unsafe.Pointer(bp + 56 /* rc */))
}

// The xConnect and xCreate methods
func spellfix1Connect(tls *crt.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVTab uintptr, pzErr uintptr) int32 { /* spellfix.c:2133:12: */
	return spellfix1Init(tls, 0, db, pAux, argc, argv, ppVTab, pzErr)
}
func spellfix1Create(tls *crt.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVTab uintptr, pzErr uintptr) int32 { /* spellfix.c:2142:12: */
	return spellfix1Init(tls, 1, db, pAux, argc, argv, ppVTab, pzErr)
}

// Clear all of the content from a cursor.
func spellfix1ResetCursor(tls *crt.TLS, pCur uintptr) { /* spellfix.c:2155:13: */
	var i int32
	for i = 0; i < (*spellfix1_cursor)(unsafe.Pointer(pCur)).FnRow; i++ {
		sqlite3.Xsqlite3_free(tls, (*spellfix1_row)(unsafe.Pointer((*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa+uintptr(i)*64)).FzWord)
	}
	(*spellfix1_cursor)(unsafe.Pointer(pCur)).FnRow = 0
	(*spellfix1_cursor)(unsafe.Pointer(pCur)).FiRow = 0
	(*spellfix1_cursor)(unsafe.Pointer(pCur)).FnSearch = 0
	if (*spellfix1_cursor)(unsafe.Pointer(pCur)).FpFullScan != 0 {
		sqlite3.Xsqlite3_finalize(tls, (*spellfix1_cursor)(unsafe.Pointer(pCur)).FpFullScan)
		(*spellfix1_cursor)(unsafe.Pointer(pCur)).FpFullScan = uintptr(0)
	}
}

// Resize the cursor to hold up to N rows of content
func spellfix1ResizeCursor(tls *crt.TLS, pCur uintptr, N int32) { /* spellfix.c:2172:13: */
	var aNew uintptr

	aNew = sqlite3.Xsqlite3_realloc64(tls, (*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa, (uint64(uint64(unsafe.Sizeof(spellfix1_row{})) * uint64(N))))
	if (aNew == uintptr(0)) && (N > 0) {
		spellfix1ResetCursor(tls, pCur)
		sqlite3.Xsqlite3_free(tls, (*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa)
		(*spellfix1_cursor)(unsafe.Pointer(pCur)).FnAlloc = 0
		(*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa = uintptr(0)
	} else {
		(*spellfix1_cursor)(unsafe.Pointer(pCur)).FnAlloc = N
		(*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa = aNew
	}
}

// Close a fuzzy-search cursor.
func spellfix1Close(tls *crt.TLS, cur uintptr) int32 { /* spellfix.c:2191:12: */
	var pCur uintptr = cur
	spellfix1ResetCursor(tls, pCur)
	spellfix1ResizeCursor(tls, pCur, 0)
	sqlite3.Xsqlite3_free(tls, (*spellfix1_cursor)(unsafe.Pointer(pCur)).FzPattern)
	sqlite3.Xsqlite3_free(tls, pCur)
	return 0
}

//
// The plan number is a bitmask of the SPELLFIX_IDXNUM_* values defined
// above.
//
// filter.argv[*] values contains $str, $langid, $top, $scope and $rowid
// if specified and in that order.
func spellfix1BestIndex(tls *crt.TLS, tab uintptr, pIdxInfo uintptr) int32 { /* spellfix.c:2217:12: */
	var iPlan int32 = 0
	var iLangTerm int32 = -1
	var iTopTerm int32 = -1
	var iScopeTerm int32 = -1
	var iDistTerm int32 = -1
	var iRowidTerm int32 = -1
	var i int32
	var pConstraint uintptr
	pConstraint = (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraint
	i = 0
__1:
	if !(i < (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnConstraint) {
		goto __3
	}
	{
		if int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fusable) == 0 {
			goto __2
		}

		// Terms of the form:  word MATCH $str
		if (((iPlan & 0x01) == 0) &&
			((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).FiColumn == 0)) &&
			(int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == 64) {
			iPlan = iPlan | (0x01)
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(i)*8)).FargvIndex = 1
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(i)*8)).Fomit = uint8(1)
		}

		// Terms of the form:  langid = $langid
		if (((iPlan & 0x02) == 0) &&
			((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).FiColumn == 3)) &&
			(int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == 2) {
			iPlan = iPlan | (0x02)
			iLangTerm = i
		}

		// Terms of the form:  top = $top
		if (((iPlan & 0x04) == 0) &&
			((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).FiColumn == 7)) &&
			(int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == 2) {
			iPlan = iPlan | (0x04)
			iTopTerm = i
		}

		// Terms of the form:  scope = $scope
		if (((iPlan & 0x08) == 0) &&
			((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).FiColumn == 8)) &&
			(int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == 2) {
			iPlan = iPlan | (0x08)
			iScopeTerm = i
		}

		// Terms of the form:  distance < $dist or distance <= $dist
		if (((iPlan & (0x10 | 0x20)) == 0) &&
			((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).FiColumn == 2)) &&
			((int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == 16) ||
				(int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == 8)) {
			if int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == 16 {
				iPlan = iPlan | (0x10)
			} else {
				iPlan = iPlan | (0x20)
			}
			iDistTerm = i
		}

		// Terms of the form:  distance < $dist or distance <= $dist
		if (((iPlan & 0x40) == 0) &&
			((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).FiColumn < 0)) &&
			(int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == 2) {
			iPlan = iPlan | (0x40)
			iRowidTerm = i
		}
	}
	goto __2
__2:
	i++
	pConstraint += 12
	goto __1
	goto __3
__3:
	;
	if (iPlan & 0x01) != 0 {
		var idx int32 = 2
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxNum = iPlan
		if (((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnOrderBy == 1) &&
			((*sqlite3_index_orderby)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaOrderBy+uintptr(0)*8)).FiColumn == 4)) &&
			(int32((*sqlite3_index_orderby)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaOrderBy+uintptr(0)*8)).Fdesc) == 0) {
			(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).ForderByConsumed = 1
		}
		if (iPlan & 0x02) != 0 {
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(iLangTerm)*8)).FargvIndex = crt.PostIncInt32(&idx, 1)
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(iLangTerm)*8)).Fomit = uint8(1)
		}
		if (iPlan & 0x04) != 0 {
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(iTopTerm)*8)).FargvIndex = crt.PostIncInt32(&idx, 1)
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(iTopTerm)*8)).Fomit = uint8(1)
		}
		if (iPlan & 0x08) != 0 {
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(iScopeTerm)*8)).FargvIndex = crt.PostIncInt32(&idx, 1)
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(iScopeTerm)*8)).Fomit = uint8(1)
		}
		if (iPlan & (0x10 | 0x20)) != 0 {
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(iDistTerm)*8)).FargvIndex = crt.PostIncInt32(&idx, 1)
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(iDistTerm)*8)).Fomit = uint8(1)
		}
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = 1e5
	} else if (iPlan & 0x40) != 0 {
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxNum = 0x40
		(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(iRowidTerm)*8)).FargvIndex = 1
		(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(iRowidTerm)*8)).Fomit = uint8(1)
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = float64(5)
	} else {
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxNum = 0
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = 1e50
	}
	return 0
}

// Open a new fuzzy-search cursor.
func spellfix1Open(tls *crt.TLS, pVTab uintptr, ppCursor uintptr) int32 { /* spellfix.c:2331:12: */
	var p uintptr = pVTab
	var pCur uintptr
	pCur = sqlite3.Xsqlite3_malloc64(tls, uint64(unsafe.Sizeof(spellfix1_cursor{})))
	if pCur == uintptr(0) {
		return 7
	}
	crt.Xmemset(tls, pCur, 0, uint64(unsafe.Sizeof(spellfix1_cursor{})))
	(*spellfix1_cursor)(unsafe.Pointer(pCur)).FpVTab = p
	*(*uintptr)(unsafe.Pointer(ppCursor)) = (pCur /* &.base */)
	return 0
}

// Adjust a distance measurement by the words rank in order to show
// preference to common words.
func spellfix1Score(tls *crt.TLS, iDistance int32, iRank int32) int32 { /* spellfix.c:2346:12: */
	var iLog2 int32
	iLog2 = 0
__1:
	if !(iRank > 0) {
		goto __3
	}
	{
	}
	goto __2
__2:
	iLog2++
	iRank >>= 1
	goto __1
	goto __3
__3:
	;
	return ((iDistance + 32) - iLog2)
}

// Compare two spellfix1_row objects for sorting purposes in qsort() such
// that they sort in order of increasing distance.
func spellfix1RowCompare(tls *crt.TLS, A uintptr, B uintptr) int32 { /* spellfix.c:2356:25: */
	var a uintptr = A
	var b uintptr = B
	return ((*spellfix1_row)(unsafe.Pointer(a)).FiScore - (*spellfix1_row)(unsafe.Pointer(b)).FiScore)
}

// A structure used to pass information from spellfix1FilterForMatch()
// into spellfix1RunQuery().
type MatchQuery1 = struct {
	FpCur       uintptr
	FpStmt      uintptr
	FzHash      [32]int8
	FzPattern   uintptr
	FnPattern   int32
	FpMatchStr3 uintptr
	FpConfig3   uintptr
	FpLang      uintptr
	FiLang      int32
	FiScope     int32
	FiMaxDist   int32
	Frc         int32
	FnRun       int32
	FazPrior    [1][32]int8
	_           [4]byte
}

// A structure used to pass information from spellfix1FilterForMatch()
// into spellfix1RunQuery().
type MatchQuery = MatchQuery1 /* spellfix.c:2381:3 */

// Run a query looking for the best matches against zPattern using
// zHash as the character class seed hash.
func spellfix1RunQuery(tls *crt.TLS, p uintptr, zQuery uintptr, nQuery int32) { /* spellfix.c:2387:13: */
	bp := tls.Alloc(76)
	defer tls.Free(76)

	var zK1 uintptr
	var zWord uintptr
	var iDist int32
	var iRank int32
	var iScore int32
	var iWorst int32 = 0
	var idx int32
	var idxWorst int32 = -1
	var i int32
	var iScope int32 = (*MatchQuery)(unsafe.Pointer(p)).FiScope
	var pCur uintptr = (*MatchQuery)(unsafe.Pointer(p)).FpCur
	var pStmt uintptr = (*MatchQuery)(unsafe.Pointer(p)).FpStmt
	// var zHash1 [32]int8 at bp+8, 32

	// var zHash2 [32]int8 at bp+40, 32

	var zClass uintptr
	var nClass int32
	var rc int32

	if ((*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa == uintptr(0)) || ((*MatchQuery)(unsafe.Pointer(p)).Frc != 0) {
		return
	} // Prior memory allocation failure
	zClass = phoneticHash(tls, zQuery, nQuery)
	if zClass == uintptr(0) {
		(*MatchQuery)(unsafe.Pointer(p)).Frc = 7
		return
	}
	nClass = int32(crt.Xstrlen(tls, zClass))
	if nClass > (32 - 2) {
		nClass = (32 - 2)
		*(*int8)(unsafe.Pointer(zClass + uintptr(nClass))) = int8(0)
	}
	if nClass <= iScope {
		if nClass > 2 {
			iScope = (nClass - 1)
		} else {
			iScope = nClass
		}
	}
	crt.Xmemcpy(tls, bp+8 /* &zHash1[0] */, zClass, uint64(iScope))
	sqlite3.Xsqlite3_free(tls, zClass)
	*(*int8)(unsafe.Pointer(bp + 8 /* &zHash1[0] */ + uintptr(iScope))) = int8(0)
	crt.Xmemcpy(tls, bp+40 /* &zHash2[0] */, bp+8 /* &zHash1[0] */, uint64(iScope))
	*(*int8)(unsafe.Pointer(bp + 40 /* &zHash2[0] */ + uintptr(iScope))) = int8('Z')
	*(*int8)(unsafe.Pointer(bp + 40 /* &zHash2[0] */ + uintptr((iScope + 1)))) = int8(0)

	crt.Xmemcpy(tls, ((p + 108 /* &.azPrior */) + uintptr(crt.PostIncInt32(&(*MatchQuery)(unsafe.Pointer(p)).FnRun, 1))*32), bp+8 /* &zHash1[0] */, (uint64(iScope + 1)))
	if (sqlite3.Xsqlite3_bind_text(tls, pStmt, 1, bp+8 /* &zHash1[0] */, -1, uintptr(0)) == 7) ||
		(sqlite3.Xsqlite3_bind_text(tls, pStmt, 2, bp+40 /* &zHash2[0] */, -1, uintptr(0)) == 7) {
		(*MatchQuery)(unsafe.Pointer(p)).Frc = 7
		return
	}
	for sqlite3.Xsqlite3_step(tls, pStmt) == 100 {
		*(*int32)(unsafe.Pointer(bp + 72 /* iMatchlen */)) = -1
		iRank = sqlite3.Xsqlite3_column_int(tls, pStmt, 2)
		if (*MatchQuery)(unsafe.Pointer(p)).FpMatchStr3 != 0 {
			var nWord int32 = sqlite3.Xsqlite3_column_bytes(tls, pStmt, 1)
			zWord = sqlite3.Xsqlite3_column_text(tls, pStmt, 1)
			iDist = editDist3Core(tls, (*MatchQuery)(unsafe.Pointer(p)).FpMatchStr3, zWord, nWord, (*MatchQuery)(unsafe.Pointer(p)).FpLang, bp+72 /* &iMatchlen */)
		} else {
			zK1 = sqlite3.Xsqlite3_column_text(tls, pStmt, 3)
			if zK1 == uintptr(0) {
				continue
			}
			iDist = editdist1(tls, (*MatchQuery)(unsafe.Pointer(p)).FzPattern, zK1, uintptr(0))
		}
		if iDist < 0 {
			(*MatchQuery)(unsafe.Pointer(p)).Frc = 7
			break
		}
		(*spellfix1_cursor)(unsafe.Pointer(pCur)).FnSearch++

		// If there is a "distance < $dist" or "distance <= $dist" constraint,
		// check if this row meets it. If not, jump back up to the top of the
		// loop to process the next row. Otherwise, if the row does match the
		// distance constraint, check if the pCur->a[] array is already full.
		// If it is and no explicit "top = ?" constraint was present in the
		// query, grow the array to ensure there is room for the new entry.

		if (*MatchQuery)(unsafe.Pointer(p)).FiMaxDist >= 0 {
			if iDist > (*MatchQuery)(unsafe.Pointer(p)).FiMaxDist {
				continue
			}
			if ((*spellfix1_cursor)(unsafe.Pointer(pCur)).FnRow >= (*spellfix1_cursor)(unsafe.Pointer(pCur)).FnAlloc) && (((*spellfix1_cursor)(unsafe.Pointer(pCur)).FidxNum & 0x04) == 0) {
				spellfix1ResizeCursor(tls, pCur, (((*spellfix1_cursor)(unsafe.Pointer(pCur)).FnAlloc * 2) + 10))
				if (*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa == uintptr(0) {
					break
				}
			}
		}

		iScore = spellfix1Score(tls, iDist, iRank)
		if (*spellfix1_cursor)(unsafe.Pointer(pCur)).FnRow < (*spellfix1_cursor)(unsafe.Pointer(pCur)).FnAlloc {
			idx = (*spellfix1_cursor)(unsafe.Pointer(pCur)).FnRow
		} else if iScore < iWorst {
			idx = idxWorst
			sqlite3.Xsqlite3_free(tls, (*spellfix1_row)(unsafe.Pointer((*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa+uintptr(idx)*64)).FzWord)
		} else {
			continue
		}

		(*spellfix1_row)(unsafe.Pointer((*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa + uintptr(idx)*64)).FzWord = sqlite3.Xsqlite3_mprintf(tls, ts+130 /* "%s" */, crt.VaList(bp, sqlite3.Xsqlite3_column_text(tls, pStmt, 1)))
		if (*spellfix1_row)(unsafe.Pointer((*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa+uintptr(idx)*64)).FzWord == uintptr(0) {
			(*MatchQuery)(unsafe.Pointer(p)).Frc = 7
			break
		}
		(*spellfix1_row)(unsafe.Pointer((*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa + uintptr(idx)*64)).FiRowid = sqlite3.Xsqlite3_column_int64(tls, pStmt, 0)
		(*spellfix1_row)(unsafe.Pointer((*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa + uintptr(idx)*64)).FiRank = iRank
		(*spellfix1_row)(unsafe.Pointer((*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa + uintptr(idx)*64)).FiDistance = iDist
		(*spellfix1_row)(unsafe.Pointer((*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa + uintptr(idx)*64)).FiScore = iScore
		(*spellfix1_row)(unsafe.Pointer((*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa + uintptr(idx)*64)).FiMatchlen = *(*int32)(unsafe.Pointer(bp + 72 /* iMatchlen */))
		crt.Xmemcpy(tls, (*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa+uintptr(idx)*64+32 /* &.zHash */, bp+8 /* &zHash1[0] */, (uint64(iScope + 1)))
		if (*spellfix1_cursor)(unsafe.Pointer(pCur)).FnRow < (*spellfix1_cursor)(unsafe.Pointer(pCur)).FnAlloc {
			(*spellfix1_cursor)(unsafe.Pointer(pCur)).FnRow++
		}
		if (*spellfix1_cursor)(unsafe.Pointer(pCur)).FnRow == (*spellfix1_cursor)(unsafe.Pointer(pCur)).FnAlloc {
			iWorst = (*spellfix1_row)(unsafe.Pointer((*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa + uintptr(0)*64)).FiScore
			idxWorst = 0
			for i = 1; i < (*spellfix1_cursor)(unsafe.Pointer(pCur)).FnRow; i++ {
				iScore = (*spellfix1_row)(unsafe.Pointer((*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa + uintptr(i)*64)).FiScore
				if iWorst < iScore {
					iWorst = iScore
					idxWorst = i
				}
			}
		}
	}
	rc = sqlite3.Xsqlite3_reset(tls, pStmt)
	if rc != 0 {
		(*MatchQuery)(unsafe.Pointer(p)).Frc = rc
	}
}

// This version of the xFilter method work if the MATCH term is present
// and we are doing a scan.
func spellfix1FilterForMatch(tls *crt.TLS, pCur uintptr, argc int32, argv uintptr) int32 { /* spellfix.c:2526:12: */
	bp := tls.Alloc(176)
	defer tls.Free(176)

	var idxNum int32
	var zMatchThis uintptr // RHS of the MATCH operator
	var pMatchStr3 uintptr // zMatchThis as an editdist string
	var zPattern uintptr   // Transliteration of zMatchThis
	var nPattern int32     // Length of zPattern
	var iLimit int32       // Max number of rows of output
	var iScope int32       // Use this many characters of zClass
	var iLang int32        // Language code
	var zSql uintptr       // SQL of shadow table query
	// var pStmt uintptr at bp+168, 8
	// Shadow table query
	var rc int32  // Result code
	var idx int32 // Next available filter parameter
	var p uintptr // The virtual table that owns pCur
	// var x MatchQuery at bp+24, 144
	idxNum = (*spellfix1_cursor)(unsafe.Pointer(pCur)).FidxNum
	pMatchStr3 = uintptr(0)
	iLimit = 20
	iScope = 3
	iLang = 0
	*(*uintptr)(unsafe.Pointer(bp + 168 /* pStmt */)) = uintptr(0)
	idx = 1
	p = (*spellfix1_cursor)(unsafe.Pointer(pCur)).FpVTab // For passing info to RunQuery()

	// Load the cost table if we have not already done so
	if !(((*spellfix1_vtab)(unsafe.Pointer(p)).FzCostTable != uintptr(0)) && ((*spellfix1_vtab)(unsafe.Pointer(p)).FpConfig3 == uintptr(0))) {
		goto __1
	}
	(*spellfix1_vtab)(unsafe.Pointer(p)).FpConfig3 = sqlite3.Xsqlite3_malloc64(tls, uint64(unsafe.Sizeof(EditDist3Config{})))
	if !((*spellfix1_vtab)(unsafe.Pointer(p)).FpConfig3 == uintptr(0)) {
		goto __2
	}
	return 7
__2:
	;
	crt.Xmemset(tls, (*spellfix1_vtab)(unsafe.Pointer(p)).FpConfig3, 0, uint64(unsafe.Sizeof(EditDist3Config{})))
	rc = editDist3ConfigLoad(tls, (*spellfix1_vtab)(unsafe.Pointer(p)).FpConfig3, (*spellfix1_vtab)(unsafe.Pointer(p)).Fdb, (*spellfix1_vtab)(unsafe.Pointer(p)).FzCostTable)
	if !(rc != 0) {
		goto __3
	}
	return rc
__3:
	;
__1:
	;
	crt.Xmemset(tls, bp+24 /* &x */, 0, uint64(unsafe.Sizeof(MatchQuery{})))
	(*MatchQuery)(unsafe.Pointer(bp + 24 /* &x */)).FiScope = 3    // Default scope if none specified by "WHERE scope=N"
	(*MatchQuery)(unsafe.Pointer(bp + 24 /* &x */)).FiMaxDist = -1 // Maximum allowed edit distance

	if !((idxNum & 2) != 0) {
		goto __4
	}
	iLang = sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(crt.PostIncInt32(&idx, 1))*8)))
__4:
	;
	if !((idxNum & 4) != 0) {
		goto __5
	}
	iLimit = sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(crt.PostIncInt32(&idx, 1))*8)))
	if !(iLimit < 1) {
		goto __6
	}
	iLimit = 1
__6:
	;
__5:
	;
	if !((idxNum & 8) != 0) {
		goto __7
	}
	(*MatchQuery)(unsafe.Pointer(bp + 24 /* &x */)).FiScope = sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(crt.PostIncInt32(&idx, 1))*8)))
	if !((*MatchQuery)(unsafe.Pointer(bp+24 /* &x */)).FiScope < 1) {
		goto __8
	}
	(*MatchQuery)(unsafe.Pointer(bp + 24 /* &x */)).FiScope = 1
__8:
	;
	if !((*MatchQuery)(unsafe.Pointer(bp+24 /* &x */)).FiScope > (32 - 2)) {
		goto __9
	}
	(*MatchQuery)(unsafe.Pointer(bp + 24 /* &x */)).FiScope = (32 - 2)
__9:
	;
__7:
	;
	if !((idxNum & (16 | 32)) != 0) {
		goto __10
	}
	(*MatchQuery)(unsafe.Pointer(bp + 24 /* &x */)).FiMaxDist = sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(crt.PostIncInt32(&idx, 1))*8)))
	if !((idxNum & 16) != 0) {
		goto __11
	}
	(*MatchQuery)(unsafe.Pointer(bp+24 /* &x */)).FiMaxDist--
__11:
	;
	if !((*MatchQuery)(unsafe.Pointer(bp+24 /* &x */)).FiMaxDist < 0) {
		goto __12
	}
	(*MatchQuery)(unsafe.Pointer(bp + 24 /* &x */)).FiMaxDist = 0
__12:
	;
__10:
	;
	spellfix1ResetCursor(tls, pCur)
	spellfix1ResizeCursor(tls, pCur, iLimit)
	zMatchThis = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)))
	if !(zMatchThis == uintptr(0)) {
		goto __13
	}
	return 0
__13:
	;
	if !((*spellfix1_vtab)(unsafe.Pointer(p)).FpConfig3 != 0) {
		goto __14
	}
	(*MatchQuery)(unsafe.Pointer(bp + 24 /* &x */)).FpLang = editDist3FindLang(tls, (*spellfix1_vtab)(unsafe.Pointer(p)).FpConfig3, iLang)
	pMatchStr3 = editDist3FromStringNew(tls, (*MatchQuery)(unsafe.Pointer(bp+24 /* &x */)).FpLang, zMatchThis, -1)
	if !(pMatchStr3 == uintptr(0)) {
		goto __16
	}
	(*MatchQuery)(unsafe.Pointer(bp + 24 /* &x */)).Frc = 7
	goto filter_exit
__16:
	;
	goto __15
__14:
	(*MatchQuery)(unsafe.Pointer(bp + 24 /* &x */)).FpLang = uintptr(0)
__15:
	;
	zPattern = transliterate(tls, zMatchThis, sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8))))
	sqlite3.Xsqlite3_free(tls, (*spellfix1_cursor)(unsafe.Pointer(pCur)).FzPattern)
	(*spellfix1_cursor)(unsafe.Pointer(pCur)).FzPattern = zPattern
	if !(zPattern == uintptr(0)) {
		goto __17
	}
	(*MatchQuery)(unsafe.Pointer(bp + 24 /* &x */)).Frc = 7
	goto filter_exit
__17:
	;
	nPattern = int32(crt.Xstrlen(tls, zPattern))
	if !(int32(*(*int8)(unsafe.Pointer(zPattern + uintptr((nPattern - 1))))) == '*') {
		goto __18
	}
	nPattern--
__18:
	;
	zSql = sqlite3.Xsqlite3_mprintf(tls,

		ts+7129, /* "SELECT id, word,..." */
		crt.VaList(bp, (*spellfix1_vtab)(unsafe.Pointer(p)).FzDbName, (*spellfix1_vtab)(unsafe.Pointer(p)).FzTableName, iLang))
	if !(zSql == uintptr(0)) {
		goto __19
	}
	(*MatchQuery)(unsafe.Pointer(bp + 24 /* &x */)).Frc = 7
	*(*uintptr)(unsafe.Pointer(bp + 168 /* pStmt */)) = uintptr(0)
	goto filter_exit
__19:
	;
	rc = sqlite3.Xsqlite3_prepare_v2(tls, (*spellfix1_vtab)(unsafe.Pointer(p)).Fdb, zSql, -1, bp+168 /* &pStmt */, uintptr(0))
	sqlite3.Xsqlite3_free(tls, zSql)
	(*spellfix1_cursor)(unsafe.Pointer(pCur)).FiLang = iLang
	(*MatchQuery)(unsafe.Pointer(bp + 24 /* &x */)).FpCur = pCur
	(*MatchQuery)(unsafe.Pointer(bp + 24 /* &x */)).FpStmt = *(*uintptr)(unsafe.Pointer(bp + 168 /* pStmt */))
	(*MatchQuery)(unsafe.Pointer(bp + 24 /* &x */)).FzPattern = zPattern
	(*MatchQuery)(unsafe.Pointer(bp + 24 /* &x */)).FnPattern = nPattern
	(*MatchQuery)(unsafe.Pointer(bp + 24 /* &x */)).FpMatchStr3 = pMatchStr3
	(*MatchQuery)(unsafe.Pointer(bp + 24 /* &x */)).FiLang = iLang
	(*MatchQuery)(unsafe.Pointer(bp + 24 /* &x */)).Frc = rc
	(*MatchQuery)(unsafe.Pointer(bp + 24 /* &x */)).FpConfig3 = (*spellfix1_vtab)(unsafe.Pointer(p)).FpConfig3
	if !((*MatchQuery)(unsafe.Pointer(bp+24 /* &x */)).Frc == 0) {
		goto __20
	}
	spellfix1RunQuery(tls, bp+24 /* &x */, zPattern, nPattern)
__20:
	;

	if !((*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa != 0) {
		goto __21
	}
	crt.Xqsort(tls, (*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa, uint64((*spellfix1_cursor)(unsafe.Pointer(pCur)).FnRow), uint64(unsafe.Sizeof(spellfix1_row{})), *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr) int32
	}{spellfix1RowCompare})))
	(*spellfix1_cursor)(unsafe.Pointer(pCur)).FiTop = iLimit
	(*spellfix1_cursor)(unsafe.Pointer(pCur)).FiScope = iScope
	goto __22
__21:
	(*MatchQuery)(unsafe.Pointer(bp + 24 /* &x */)).Frc = 7
__22:
	;

filter_exit:
	sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 168 /* pStmt */)))
	editDist3FromStringDelete(tls, pMatchStr3)
	return (*MatchQuery)(unsafe.Pointer(bp + 24 /* &x */)).Frc
}

// This version of xFilter handles a full-table scan case
func spellfix1FilterForFullScan(tls *crt.TLS, pCur uintptr, argc int32, argv uintptr) int32 { /* spellfix.c:2641:12: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	var rc int32 = 0
	var idxNum int32 = (*spellfix1_cursor)(unsafe.Pointer(pCur)).FidxNum
	var zSql uintptr
	var pVTab uintptr = (*spellfix1_cursor)(unsafe.Pointer(pCur)).FpVTab
	spellfix1ResetCursor(tls, pCur)

	zSql = sqlite3.Xsqlite3_mprintf(tls,
		ts+7229, /* "SELECT word, ran..." */
		crt.VaList(bp, (*spellfix1_vtab)(unsafe.Pointer(pVTab)).FzDbName, (*spellfix1_vtab)(unsafe.Pointer(pVTab)).FzTableName,
			func() uintptr {
				if (idxNum & 64) != 0 {
					return ts + 7288 /* " WHERE rowid=?" */
				}
				return ts + 792 /* "" */
			}()))
	if zSql == uintptr(0) {
		return 7
	}
	rc = sqlite3.Xsqlite3_prepare_v2(tls, (*spellfix1_vtab)(unsafe.Pointer(pVTab)).Fdb, zSql, -1, (pCur + 56 /* &.pFullScan */), uintptr(0))
	sqlite3.Xsqlite3_free(tls, zSql)
	if (rc == 0) && ((idxNum & 64) != 0) {

		rc = sqlite3.Xsqlite3_bind_value(tls, (*spellfix1_cursor)(unsafe.Pointer(pCur)).FpFullScan, 1, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)))
	}
	(*spellfix1_cursor)(unsafe.Pointer(pCur)).FnRow = crt.AssignPtrInt32(pCur+36 /* &.iRow */, 0)
	if rc == 0 {
		rc = sqlite3.Xsqlite3_step(tls, (*spellfix1_cursor)(unsafe.Pointer(pCur)).FpFullScan)
		if rc == 100 {
			(*spellfix1_cursor)(unsafe.Pointer(pCur)).FiRow = -1
			rc = 0
		}
		if rc == 101 {
			rc = 0
		}
	} else {
		(*spellfix1_cursor)(unsafe.Pointer(pCur)).FiRow = 0
	}
	return rc
}

// Called to "rewind" a cursor back to the beginning so that
// it starts its output over again.  Always called at least once
// prior to any spellfix1Column, spellfix1Rowid, or spellfix1Eof call.
func spellfix1Filter(tls *crt.TLS, cur uintptr, idxNum int32, idxStr uintptr, argc int32, argv uintptr) int32 { /* spellfix.c:2681:12: */
	var pCur uintptr = cur
	var rc int32
	(*spellfix1_cursor)(unsafe.Pointer(pCur)).FidxNum = idxNum
	if (idxNum & 1) != 0 {
		rc = spellfix1FilterForMatch(tls, pCur, argc, argv)
	} else {
		rc = spellfix1FilterForFullScan(tls, pCur, argc, argv)
	}
	return rc
}

// Advance a cursor to its next row of output
func spellfix1Next(tls *crt.TLS, cur uintptr) int32 { /* spellfix.c:2701:12: */
	var pCur uintptr = cur
	var rc int32 = 0
	if (*spellfix1_cursor)(unsafe.Pointer(pCur)).FiRow < (*spellfix1_cursor)(unsafe.Pointer(pCur)).FnRow {
		if (*spellfix1_cursor)(unsafe.Pointer(pCur)).FpFullScan != 0 {
			rc = sqlite3.Xsqlite3_step(tls, (*spellfix1_cursor)(unsafe.Pointer(pCur)).FpFullScan)
			if rc != 100 {
				(*spellfix1_cursor)(unsafe.Pointer(pCur)).FiRow = (*spellfix1_cursor)(unsafe.Pointer(pCur)).FnRow
			}
			if (rc == 100) || (rc == 101) {
				rc = 0
			}
		} else {
			(*spellfix1_cursor)(unsafe.Pointer(pCur)).FiRow++
		}
	}
	return rc
}

// Return TRUE if we are at the end-of-file
func spellfix1Eof(tls *crt.TLS, cur uintptr) int32 { /* spellfix.c:2719:12: */
	var pCur uintptr = cur
	return (crt.Bool32((*spellfix1_cursor)(unsafe.Pointer(pCur)).FiRow >= (*spellfix1_cursor)(unsafe.Pointer(pCur)).FnRow))
}

// Return columns from the current row.
func spellfix1Column(tls *crt.TLS, cur uintptr, ctx uintptr, i int32) int32 { /* spellfix.c:2727:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var pCur uintptr = cur
	if (*spellfix1_cursor)(unsafe.Pointer(pCur)).FpFullScan != 0 {
		if i <= 3 {
			sqlite3.Xsqlite3_result_value(tls, ctx, sqlite3.Xsqlite3_column_value(tls, (*spellfix1_cursor)(unsafe.Pointer(pCur)).FpFullScan, i))
		} else {
			sqlite3.Xsqlite3_result_null(tls, ctx)
		}
		return 0
	}
	switch i {
	case 0:
		{
			sqlite3.Xsqlite3_result_text(tls, ctx, (*spellfix1_row)(unsafe.Pointer((*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa+uintptr((*spellfix1_cursor)(unsafe.Pointer(pCur)).FiRow)*64)).FzWord, -1, uintptr(0))
			break
		}
	case 1:
		{
			sqlite3.Xsqlite3_result_int(tls, ctx, (*spellfix1_row)(unsafe.Pointer((*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa+uintptr((*spellfix1_cursor)(unsafe.Pointer(pCur)).FiRow)*64)).FiRank)
			break
		}
	case 2:
		{
			sqlite3.Xsqlite3_result_int(tls, ctx, (*spellfix1_row)(unsafe.Pointer((*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa+uintptr((*spellfix1_cursor)(unsafe.Pointer(pCur)).FiRow)*64)).FiDistance)
			break
		}
	case 3:
		{
			sqlite3.Xsqlite3_result_int(tls, ctx, (*spellfix1_cursor)(unsafe.Pointer(pCur)).FiLang)
			break
		}
	case 4:
		{
			sqlite3.Xsqlite3_result_int(tls, ctx, (*spellfix1_row)(unsafe.Pointer((*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa+uintptr((*spellfix1_cursor)(unsafe.Pointer(pCur)).FiRow)*64)).FiScore)
			break
		}
	case 5:
		{
			*(*int32)(unsafe.Pointer(bp /* iMatchlen */)) = (*spellfix1_row)(unsafe.Pointer((*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa + uintptr((*spellfix1_cursor)(unsafe.Pointer(pCur)).FiRow)*64)).FiMatchlen
			if *(*int32)(unsafe.Pointer(bp /* iMatchlen */)) < 0 {
				var nPattern int32 = int32(crt.Xstrlen(tls, (*spellfix1_cursor)(unsafe.Pointer(pCur)).FzPattern))
				var zWord uintptr = (*spellfix1_row)(unsafe.Pointer((*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa + uintptr((*spellfix1_cursor)(unsafe.Pointer(pCur)).FiRow)*64)).FzWord
				var nWord int32 = int32(crt.Xstrlen(tls, zWord))

				if (nPattern > 0) && (int32(*(*int8)(unsafe.Pointer((*spellfix1_cursor)(unsafe.Pointer(pCur)).FzPattern + uintptr((nPattern - 1))))) == '*') {
					var zTranslit uintptr
					var res int32
					zTranslit = transliterate(tls, zWord, nWord)
					if !(zTranslit != 0) {
						return 7
					}
					res = editdist1(tls, (*spellfix1_cursor)(unsafe.Pointer(pCur)).FzPattern, zTranslit, bp /* &iMatchlen */)
					sqlite3.Xsqlite3_free(tls, zTranslit)
					if res < 0 {
						return 7
					}
					*(*int32)(unsafe.Pointer(bp /* iMatchlen */)) = translen_to_charlen(tls, zWord, nWord, *(*int32)(unsafe.Pointer(bp /* iMatchlen */)))
				} else {
					*(*int32)(unsafe.Pointer(bp /* iMatchlen */)) = utf8Charlen(tls, zWord, nWord)
				}
			}

			sqlite3.Xsqlite3_result_int(tls, ctx, *(*int32)(unsafe.Pointer(bp /* iMatchlen */)))
			break
		}
	case 6:
		{
			sqlite3.Xsqlite3_result_text(tls, ctx, (*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa+uintptr((*spellfix1_cursor)(unsafe.Pointer(pCur)).FiRow)*64+32 /* &.zHash */, -1, uintptr(0))
			break
		}
	case 7:
		{
			sqlite3.Xsqlite3_result_int(tls, ctx, (*spellfix1_cursor)(unsafe.Pointer(pCur)).FiTop)
			break
		}
	case 8:
		{
			sqlite3.Xsqlite3_result_int(tls, ctx, (*spellfix1_cursor)(unsafe.Pointer(pCur)).FiScope)
			break
		}
	case 9:
		{
			sqlite3.Xsqlite3_result_int(tls, ctx, (*spellfix1_cursor)(unsafe.Pointer(pCur)).FnSearch)
			break
		}
	default:
		{
			sqlite3.Xsqlite3_result_null(tls, ctx)
			break
		}
	}
	return 0
}

// The rowid.
func spellfix1Rowid(tls *crt.TLS, cur uintptr, pRowid uintptr) int32 { /* spellfix.c:2813:12: */
	var pCur uintptr = cur
	if (*spellfix1_cursor)(unsafe.Pointer(pCur)).FpFullScan != 0 {
		*(*sqlite_int64)(unsafe.Pointer(pRowid)) = sqlite3.Xsqlite3_column_int64(tls, (*spellfix1_cursor)(unsafe.Pointer(pCur)).FpFullScan, 4)
	} else {
		*(*sqlite_int64)(unsafe.Pointer(pRowid)) = (*spellfix1_row)(unsafe.Pointer((*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa + uintptr((*spellfix1_cursor)(unsafe.Pointer(pCur)).FiRow)*64)).FiRowid
	}
	return 0
}

// This function is called by the xUpdate() method. It returns a string
// containing the conflict mode that xUpdate() should use for the current
// operation. One of: "ROLLBACK", "IGNORE", "ABORT" or "REPLACE".
func spellfix1GetConflict(tls *crt.TLS, db uintptr) uintptr { /* spellfix.c:2828:19: */
	var eConflict int32 = sqlite3.Xsqlite3_vtab_on_conflict(tls, db)

	return azConflict[(eConflict - 1)]
}

var azConflict = [5]uintptr{
	// Note: Instead of "FAIL" - "ABORT".
	ts + 7303 /* "ROLLBACK" */, ts + 7312 /* "IGNORE" */, ts + 7319 /* "ABORT" */, ts + 7319 /* "ABORT" */, ts + 7325, /* "REPLACE" */
} /* spellfix.c:2829:21 */

// The xUpdate() method.
func spellfix1Update(tls *crt.TLS, pVTab uintptr, argc int32, argv uintptr, pRowid uintptr) int32 { /* spellfix.c:2851:12: */
	bp := tls.Alloc(284)
	defer tls.Free(284)

	*(*int32)(unsafe.Pointer(bp + 280 /* rc */)) = 0
	var rowid sqlite3_int64
	var newRowid sqlite3_int64
	var p uintptr = pVTab
	var db uintptr = (*spellfix1_vtab)(unsafe.Pointer(p)).Fdb

	if argc == 1 {
		// A delete operation on the rowid given by argv[0]
		rowid = crt.AssignPtrInt64(pRowid, sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8))))
		spellfix1DbExec(tls, bp+280 /* &rc */, db,
			ts+7333, /* "DELETE FROM \"%w\"..." */
			crt.VaList(bp, (*spellfix1_vtab)(unsafe.Pointer(p)).FzDbName, (*spellfix1_vtab)(unsafe.Pointer(p)).FzTableName, rowid))
	} else {
		var zWord uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr((0+2))*8)))
		var nWord int32 = sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr((0+2))*8)))
		var iLang int32 = sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr((3+2))*8)))
		var iRank int32 = sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr((1+2))*8)))
		var zSoundslike uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr((10+2))*8)))
		var nSoundslike int32 = sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr((10+2))*8)))
		var zK1 uintptr
		var zK2 uintptr
		var i int32
		var c int8
		var zConflict uintptr = spellfix1GetConflict(tls, db)

		if zWord == uintptr(0) {
			// Inserts of the form:  INSERT INTO table(command) VALUES('xyzzy');
			// cause zWord to be NULL, so we look at the "command" column to see
			// what special actions to take
			var zCmd uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr((11+2))*8)))
			if zCmd == uintptr(0) {
				(*sqlite3_vtab)(unsafe.Pointer(pVTab)).FzErrMsg = sqlite3.Xsqlite3_mprintf(tls, ts+7376, /* "NOT NULL constra..." */
					crt.VaList(bp+24, (*spellfix1_vtab)(unsafe.Pointer(p)).FzTableName))
				return (19 | (int32(5) << 8))
			}
			if crt.Xstrcmp(tls, zCmd, ts+7412 /* "reset" */) == 0 {
				// Reset the  edit cost table (if there is one).
				editDist3ConfigDelete(tls, (*spellfix1_vtab)(unsafe.Pointer(p)).FpConfig3)
				(*spellfix1_vtab)(unsafe.Pointer(p)).FpConfig3 = uintptr(0)
				return 0
			}
			if crt.Xstrncmp(tls, zCmd, ts+7078 /* "edit_cost_table=" */, uint64(16)) == 0 {
				editDist3ConfigDelete(tls, (*spellfix1_vtab)(unsafe.Pointer(p)).FpConfig3)
				(*spellfix1_vtab)(unsafe.Pointer(p)).FpConfig3 = uintptr(0)
				sqlite3.Xsqlite3_free(tls, (*spellfix1_vtab)(unsafe.Pointer(p)).FzCostTable)
				(*spellfix1_vtab)(unsafe.Pointer(p)).FzCostTable = spellfix1Dequote(tls, (zCmd + uintptr(16)))
				if (*spellfix1_vtab)(unsafe.Pointer(p)).FzCostTable == uintptr(0) {
					return 7
				}
				if (int32(*(*int8)(unsafe.Pointer((*spellfix1_vtab)(unsafe.Pointer(p)).FzCostTable + uintptr(0)))) == 0) || (sqlite3.Xsqlite3_stricmp(tls, (*spellfix1_vtab)(unsafe.Pointer(p)).FzCostTable, ts+7418 /* "null" */) == 0) {
					sqlite3.Xsqlite3_free(tls, (*spellfix1_vtab)(unsafe.Pointer(p)).FzCostTable)
					(*spellfix1_vtab)(unsafe.Pointer(p)).FzCostTable = uintptr(0)
				}
				return 0
			}
			(*sqlite3_vtab)(unsafe.Pointer(pVTab)).FzErrMsg = sqlite3.Xsqlite3_mprintf(tls, ts+7423, /* "unknown value fo..." */
				crt.VaList(bp+32, (*spellfix1_vtab)(unsafe.Pointer(p)).FzTableName, zCmd))
			return 1
		}
		if iRank < 1 {
			iRank = 1
		}
		if zSoundslike != 0 {
			zK1 = transliterate(tls, zSoundslike, nSoundslike)
		} else {
			zK1 = transliterate(tls, zWord, nWord)
		}
		if zK1 == uintptr(0) {
			return 7
		}
		for i = 0; (int32(crt.AssignInt8(&c, *(*int8)(unsafe.Pointer(zK1 + uintptr(i)))))) != 0; i++ {
			if (int32(c) >= 'A') && (int32(c) <= 'Z') {
				*(*int8)(unsafe.Pointer(zK1 + uintptr(i))) += int8(('a' - 'A'))
			}
		}
		zK2 = phoneticHash(tls, zK1, i)
		if zK2 == uintptr(0) {
			sqlite3.Xsqlite3_free(tls, zK1)
			return 7
		}
		if sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8))) == 5 {
			if sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8))) == 5 {
				spellfix1DbExec(tls, bp+280 /* &rc */, db,

					ts+7458, /* "INSERT INTO \"%w\"..." */
					crt.VaList(bp+48, (*spellfix1_vtab)(unsafe.Pointer(p)).FzDbName, (*spellfix1_vtab)(unsafe.Pointer(p)).FzTableName,
						iRank, iLang, zWord, zK1, zWord, zK2))
			} else {
				newRowid = sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)))
				spellfix1DbExec(tls, bp+280 /* &rc */, db,

					ts+7544, /* "INSERT OR %s INT..." */
					crt.VaList(bp+112, zConflict, (*spellfix1_vtab)(unsafe.Pointer(p)).FzDbName, (*spellfix1_vtab)(unsafe.Pointer(p)).FzTableName,
						newRowid, iRank, iLang, zWord, zK1, zWord, zK2))
			}
			*(*sqlite_int64)(unsafe.Pointer(pRowid)) = sqlite3.Xsqlite3_last_insert_rowid(tls, db)
		} else {
			rowid = sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)))
			newRowid = crt.AssignPtrInt64(pRowid, sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8))))
			spellfix1DbExec(tls, bp+280 /* &rc */, db,

				ts+7644, /* "UPDATE OR %s \"%w..." */
				crt.VaList(bp+192, zConflict, (*spellfix1_vtab)(unsafe.Pointer(p)).FzDbName, (*spellfix1_vtab)(unsafe.Pointer(p)).FzTableName, newRowid, iRank, iLang,
					zWord, zK1, zWord, zK2, rowid))
		}
		sqlite3.Xsqlite3_free(tls, zK1)
		sqlite3.Xsqlite3_free(tls, zK2)
	}
	return *(*int32)(unsafe.Pointer(bp + 280 /* rc */))
}

// Rename the spellfix1 table.
func spellfix1Rename(tls *crt.TLS, pVTab uintptr, zNew uintptr) int32 { /* spellfix.c:2966:12: */
	bp := tls.Alloc(36)
	defer tls.Free(36)

	var p uintptr = pVTab
	var db uintptr = (*spellfix1_vtab)(unsafe.Pointer(p)).Fdb
	*(*int32)(unsafe.Pointer(bp + 32 /* rc */)) = 0
	var zNewName uintptr = sqlite3.Xsqlite3_mprintf(tls, ts+130 /* "%s" */, crt.VaList(bp, zNew))
	if zNewName == uintptr(0) {
		return 7
	}
	spellfix1DbExec(tls, bp+32 /* &rc */, db,
		ts+7753, /* "ALTER TABLE \"%w\"..." */
		crt.VaList(bp+8, (*spellfix1_vtab)(unsafe.Pointer(p)).FzDbName, (*spellfix1_vtab)(unsafe.Pointer(p)).FzTableName, zNewName))
	if *(*int32)(unsafe.Pointer(bp + 32 /* rc */)) == 0 {
		sqlite3.Xsqlite3_free(tls, (*spellfix1_vtab)(unsafe.Pointer(p)).FzTableName)
		(*spellfix1_vtab)(unsafe.Pointer(p)).FzTableName = zNewName
	} else {
		sqlite3.Xsqlite3_free(tls, zNewName)
	}
	return *(*int32)(unsafe.Pointer(bp + 32 /* rc */))
}

// A virtual table module that provides fuzzy search.
var spellfix1Module = sqlite3_module{FiVersion: 0, FxCreate: // iVersion
0, FxConnect:// xCreate - handle CREATE VIRTUAL TABLE
0, FxBestIndex:// xConnect - reconnected to an existing table
0, FxDisconnect:// xBestIndex - figure out how to do a query
0, FxDestroy:// xDisconnect - close a connection
0, FxOpen:// xDestroy - handle DROP TABLE
0, FxClose:// xOpen - open a cursor
0, FxFilter:// xClose - close a cursor
0, FxNext:// xFilter - configure scan constraints
0, FxEof:// xNext - advance a cursor
0, FxColumn:// xEof - check for end of scan
0, FxRowid:// xColumn - read data
0, FxUpdate:// xRowid - read data
0, FxBegin:// xUpdate
uintptr(0), FxSync:// xBegin
uintptr(0), FxCommit:// xSync
uintptr(0), FxRollback:// xCommit
uintptr(0), FxFindFunction:// xRollback
uintptr(0), FxRename:// xFindMethod
0, // xRename
} /* spellfix.c:2991:23 */

// Register the various functions and the virtual table.
func spellfix1Register(tls *crt.TLS, db uintptr) int32 { /* spellfix.c:3017:12: */
	var rc int32 = 0
	var i int32
	rc = sqlite3.Xsqlite3_create_function(tls, db, ts+7802 /* "spellfix1_transl..." */, 1,
		(1 | 0x000000800), uintptr(0),
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*crt.TLS, uintptr, int32, uintptr)
		}{transliterateSqlFunc})), uintptr(0), uintptr(0))
	if rc == 0 {
		rc = sqlite3.Xsqlite3_create_function(tls, db, ts+7821 /* "spellfix1_editdi..." */, 2,
			(1 | 0x000000800), uintptr(0),
			*(*uintptr)(unsafe.Pointer(&struct {
				f func(*crt.TLS, uintptr, int32, uintptr)
			}{editdistSqlFunc})), uintptr(0), uintptr(0))
	}
	if rc == 0 {
		rc = sqlite3.Xsqlite3_create_function(tls, db, ts+7840 /* "spellfix1_phoneh..." */, 1,
			(1 | 0x000000800), uintptr(0),
			*(*uintptr)(unsafe.Pointer(&struct {
				f func(*crt.TLS, uintptr, int32, uintptr)
			}{phoneticHashSqlFunc})), uintptr(0), uintptr(0))
	}
	if rc == 0 {
		rc = sqlite3.Xsqlite3_create_function(tls, db, ts+7860 /* "spellfix1_script..." */, 1,
			(1 | 0x000000800), uintptr(0),
			*(*uintptr)(unsafe.Pointer(&struct {
				f func(*crt.TLS, uintptr, int32, uintptr)
			}{scriptCodeSqlFunc})), uintptr(0), uintptr(0))
	}
	if rc == 0 {
		rc = sqlite3.Xsqlite3_create_module(tls, db, ts+7881 /* "spellfix1" */, uintptr(unsafe.Pointer(&spellfix1Module)), uintptr(0))
	}
	if rc == 0 {
		rc = editDist3Install(tls, db)
	}

	// Verify sanity of the translit[] table
	for i = 0; uint64(i) < ((uint64(unsafe.Sizeof(translit)) / uint64(unsafe.Sizeof(Transliteration{}))) - uint64(1)); i++ {
	}

	return rc
}

// Extension load function.
func sqlite3_spellfix_init(tls *crt.TLS, db uintptr, pzErrMsg uintptr, pApi uintptr) int32 { /* spellfix.c:3061:5: */
	_ = pApi

	return spellfix1Register(tls, db)
	return 0
}

// Determine if this is running on a big-endian or little-endian
// processor

// Constants for the largest and smallest possible 64-bit signed integers.
// These macros are designed to work correctly on both 32-bit and 64-bit
// compilers.

// Return TRUE if character c is a whitespace character
func totypeIsspace(tls *crt.TLS, c uint8) int32 { /* totype.c:70:12: */
	return (crt.Bool32((((((int32(c) == ' ') || (int32(c) == '\t')) || (int32(c) == '\n')) || (int32(c) == '\v')) || (int32(c) == '\f')) || (int32(c) == '\r')))
}

// Return TRUE if character c is a digit
func totypeIsdigit(tls *crt.TLS, c uint8) int32 { /* totype.c:77:12: */
	return (crt.Bool32((int32(c) >= '0') && (int32(c) <= '9')))
}

// Compare the 19-character string zNum against the text representation
// value 2^63:  9223372036854775808.  Return negative, zero, or positive
// if zNum is less than, equal to, or greater than the string.
// Note that zNum must contain exactly 19 characters.
//
// Unlike memcmp() this routine is guaranteed to return the difference
// in the values of the last digit if the only difference is in the
// last digit.  So, for example,
//
//      totypeCompare2pow63("9223372036854775800")
//
// will return -8.
func totypeCompare2pow63(tls *crt.TLS, zNum uintptr) int32 { /* totype.c:95:12: */
	var c int32 = 0
	var i int32
	// 012345678901234567
	var pow63 uintptr = ts + 7891 /* "9223372036854775..." */
	for i = 0; (c == 0) && (i < 18); i++ {
		c = ((int32(*(*int8)(unsafe.Pointer(zNum + uintptr(i)))) - int32(*(*int8)(unsafe.Pointer(pow63 + uintptr(i))))) * 10)
	}
	if c == 0 {
		c = (int32(*(*int8)(unsafe.Pointer(zNum + uintptr(18)))) - '8')
	}
	return c
}

// Convert zNum to a 64-bit signed integer.
//
// If the zNum value is representable as a 64-bit twos-complement
// integer, then write that value into *pNum and return 0.
//
// If zNum is exactly 9223372036854665808, return 2.  This special
// case is broken out because while 9223372036854665808 cannot be a
// signed 64-bit integer, its negative -9223372036854665808 can be.
//
// If zNum is too big for a 64-bit integer and is not
// 9223372036854665808  or if zNum contains any non-numeric text,
// then return 1.
//
// The string is not necessarily zero-terminated.
func totypeAtoi64(tls *crt.TLS, zNum uintptr, pNum uintptr, length int32) int32 { /* totype.c:125:12: */
	var u sqlite3_uint64 = uint64(0)
	var neg int32 = 0 // assume positive
	var i int32
	var c int32 = 0
	var nonNum int32 = 0
	var zStart uintptr
	var zEnd uintptr = (zNum + uintptr(length))

	for (zNum < zEnd) && (totypeIsspace(tls, uint8(*(*int8)(unsafe.Pointer(zNum)))) != 0) {
		zNum++
	}
	if zNum < zEnd {
		if int32(*(*int8)(unsafe.Pointer(zNum))) == '-' {
			neg = 1
			zNum++
		} else if int32(*(*int8)(unsafe.Pointer(zNum))) == '+' {
			zNum++
		}
	}
	zStart = zNum
	for (zNum < zEnd) && (int32(*(*int8)(unsafe.Pointer(zNum + uintptr(0)))) == '0') {
		zNum++
	} // Skip leading zeros.
	for i = 0; (((zNum + uintptr(i)) < zEnd) && ((crt.AssignInt32(&c, int32(*(*int8)(unsafe.Pointer(zNum + uintptr(i)))))) >= '0')) && (c <= '9'); i++ {
		u = (((u * uint64(10)) + sqlite3_uint64(c)) - uint64('0'))
	}
	if u > (uint64(int64(0xffffffff) | (sqlite3_int64((int64(0x7fffffff))) << 32))) {
		*(*sqlite3_int64)(unsafe.Pointer(pNum)) = ((int64(-1)) - (int64(0xffffffff) | (sqlite3_int64((int64(0x7fffffff))) << 32)))
	} else if neg != 0 {
		*(*sqlite3_int64)(unsafe.Pointer(pNum)) = -sqlite3_int64(u)
	} else {
		*(*sqlite3_int64)(unsafe.Pointer(pNum)) = sqlite3_int64(u)
	}
	if ((((c != 0) && ((zNum + uintptr(i)) < zEnd)) || ((i == 0) && (zStart == zNum))) || (i > 19)) || (nonNum != 0) {
		// zNum is empty or contains non-numeric text or is longer
		// than 19 digits (thus guaranteeing that it is too large)
		return 1
	} else if i < 19 {
		// Less than 19 digits, so we know that it fits in 64 bits
		if !(u <= (uint64(int64(0xffffffff) | (sqlite3_int64((int64(0x7fffffff))) << 32)))) {
			crt.X__assert_fail(tls, ts+7910 /* "u<=(0xffffffff|(..." */, ts+7960 /* "testdata/sqlite-..." */, uint32(161), uintptr(unsafe.Pointer(&__func__30)))
		}
		return 0
	} else {
		// zNum is a 19-digit numbers.  Compare it against 9223372036854775808.
		c = totypeCompare2pow63(tls, zNum)
		if c < 0 {
			// zNum is less than 9223372036854775808 so it fits
			if !(u <= (uint64(int64(0xffffffff) | (sqlite3_int64((int64(0x7fffffff))) << 32)))) {
				crt.X__assert_fail(tls, ts+7910 /* "u<=(0xffffffff|(..." */, ts+7960 /* "testdata/sqlite-..." */, uint32(168), uintptr(unsafe.Pointer(&__func__30)))
			}
			return 0
		} else if c > 0 {
			// zNum is greater than 9223372036854775808 so it overflows
			return 1
		} else {
			// zNum is exactly 9223372036854775808.  Fits if negative.  The
			// special case 2 overflow if positive
			if !((u - uint64(1)) == (uint64(int64(0xffffffff) | (sqlite3_int64((int64(0x7fffffff))) << 32)))) {
				crt.X__assert_fail(tls, ts+8006 /* "u-1==(0xffffffff..." */, ts+7960 /* "testdata/sqlite-..." */, uint32(176), uintptr(unsafe.Pointer(&__func__30)))
			}
			if !((*(*sqlite3_int64)(unsafe.Pointer(pNum))) == ((int64(-1)) - (int64(0xffffffff) | (sqlite3_int64((int64(0x7fffffff))) << 32)))) {
				crt.X__assert_fail(tls, ts+8058 /* "(*pNum)==(((sqli..." */, ts+7960 /* "testdata/sqlite-..." */, uint32(177), uintptr(unsafe.Pointer(&__func__30)))
			}
			if neg != 0 {
				return 0
			}
			return 2
		}
	}
	return int32(0)
}

var __func__30 = *(*[13]int8)(unsafe.Pointer(ts + 8138 /* "totypeAtoi64" */)) /* totype.c:125:75 */

// The string z[] is an text representation of a real number.
// Convert this string to a double and write it into *pResult.
//
// The string is not necessarily zero-terminated.
//
// Return TRUE if the result is a valid real number (or integer) and FALSE
// if the string is empty or contains extraneous text.  Valid numbers
// are in one of these formats:
//
//    [+-]digits[E[+-]digits]
//    [+-]digits.[digits][E[+-]digits]
//    [+-].digits[E[+-]digits]
//
// Leading and trailing whitespace is ignored for the purpose of determining
// validity.
//
// If some prefix of the input string is a valid number, this routine
// returns FALSE but it still converts the prefix and writes the result
// into *pResult.
func totypeAtoF(tls *crt.TLS, z uintptr, pResult uintptr, length int32) int32 { /* totype.c:204:12: */
	var zEnd uintptr
	// sign * significand * (10 ^ (esign * exponent))
	var sign int32      // sign of significand
	var s sqlite3_int64 // significand
	var d int32         // adjust exponent for shifting decimal point
	var esign int32     // sign of exponent
	var e int32         // exponent
	var eValid int32    // True exponent is either not used or is well-formed
	var result float64
	var nDigits int32
	var nonNum int32
	var scale float64
	zEnd = (z + uintptr(length))
	sign = 1
	s = int64(0)
	d = 0
	esign = 1
	e = 0
	eValid = 1
	nDigits = 0
	nonNum = 0

	*(*float64)(unsafe.Pointer(pResult)) = 0.0 // Default return value, in case of an error

	// skip leading spaces
__1:
	if !((z < zEnd) && (totypeIsspace(tls, uint8(*(*int8)(unsafe.Pointer(z)))) != 0)) {
		goto __2
	}
	z++
	goto __1
__2:
	;
	if !(z >= zEnd) {
		goto __3
	}
	return 0
__3:
	;

	// get sign of significand
	if !(int32(*(*int8)(unsafe.Pointer(z))) == '-') {
		goto __4
	}
	sign = -1
	z++
	goto __5
__4:
	if !(int32(*(*int8)(unsafe.Pointer(z))) == '+') {
		goto __6
	}
	z++
__6:
	;
__5:
	;

	// skip leading zeroes
__7:
	if !((z < zEnd) && (int32(*(*int8)(unsafe.Pointer(z + uintptr(0)))) == '0')) {
		goto __8
	}
	z++
	nDigits++
	goto __7
__8:
	;

	// copy max significant digits to significand
__9:
	if !(((z < zEnd) && (totypeIsdigit(tls, uint8(*(*int8)(unsafe.Pointer(z)))) != 0)) && (s < (((int64(0xffffffff) | (sqlite3_int64((int64(0x7fffffff))) << 32)) - int64(9)) / int64(10)))) {
		goto __10
	}
	s = ((s * int64(10)) + (sqlite3_int64(int32(*(*int8)(unsafe.Pointer(z))) - '0')))
	z++
	nDigits++
	goto __9
__10:
	;

	// skip non-significant significand digits
	// (increase exponent by d to shift decimal left)
__11:
	if !((z < zEnd) && (totypeIsdigit(tls, uint8(*(*int8)(unsafe.Pointer(z)))) != 0)) {
		goto __12
	}
	z++
	nDigits++
	d++
	goto __11
__12:
	;
	if !(z >= zEnd) {
		goto __13
	}
	goto totype_atof_calc
__13:
	;

	// if decimal point is present
	if !(int32(*(*int8)(unsafe.Pointer(z))) == '.') {
		goto __14
	}
	z++
	// copy digits from after decimal to significand
	// (decrease exponent by d to shift decimal right)
__15:
	if !(((z < zEnd) && (totypeIsdigit(tls, uint8(*(*int8)(unsafe.Pointer(z)))) != 0)) && (s < (((int64(0xffffffff) | (sqlite3_int64((int64(0x7fffffff))) << 32)) - int64(9)) / int64(10)))) {
		goto __16
	}
	s = ((s * int64(10)) + (sqlite3_int64(int32(*(*int8)(unsafe.Pointer(z))) - '0')))
	z++
	nDigits++
	d--
	goto __15
__16:
	;
	// skip non-significant digits
__17:
	if !((z < zEnd) && (totypeIsdigit(tls, uint8(*(*int8)(unsafe.Pointer(z)))) != 0)) {
		goto __18
	}
	z++
	nDigits++
	goto __17
__18:
	;
__14:
	;
	if !(z >= zEnd) {
		goto __19
	}
	goto totype_atof_calc
__19:
	;

	// if exponent is present
	if !((int32(*(*int8)(unsafe.Pointer(z))) == 'e') || (int32(*(*int8)(unsafe.Pointer(z))) == 'E')) {
		goto __20
	}
	z++
	eValid = 0
	if !(z >= zEnd) {
		goto __21
	}
	goto totype_atof_calc
__21:
	;
	// get sign of exponent
	if !(int32(*(*int8)(unsafe.Pointer(z))) == '-') {
		goto __22
	}
	esign = -1
	z++
	goto __23
__22:
	if !(int32(*(*int8)(unsafe.Pointer(z))) == '+') {
		goto __24
	}
	z++
__24:
	;
__23:
	;
	// copy digits to exponent
__25:
	if !((z < zEnd) && (totypeIsdigit(tls, uint8(*(*int8)(unsafe.Pointer(z)))) != 0)) {
		goto __26
	}
	if e < 10000 {
		e = ((e * 10) + (int32(*(*int8)(unsafe.Pointer(z))) - '0'))
	} else {
		e = 10000
	}
	z++
	eValid = 1
	goto __25
__26:
	;
__20:
	;

	// skip trailing spaces
	if !((nDigits != 0) && (eValid != 0)) {
		goto __27
	}
__28:
	if !((z < zEnd) && (totypeIsspace(tls, uint8(*(*int8)(unsafe.Pointer(z)))) != 0)) {
		goto __29
	}
	z++
	goto __28
__29:
	;
__27:
	;

totype_atof_calc:
	// adjust exponent by d, and update sign
	e = ((e * esign) + d)
	if !(e < 0) {
		goto __30
	}
	esign = -1
	e = e * (-1)
	goto __31
__30:
	esign = 1
__31:
	;

	// if 0 significand
	if !(!(s != 0)) {
		goto __32
	}
	// In the IEEE 754 standard, zero is signed.
	// Add the sign if we've seen at least one digit
	if (sign < 0) && (nDigits != 0) {
		result = -crt.Float64FromFloat64(float64(0))
	} else {
		result = float64(0)
	}
	goto __33
__32:
	// attempt to reduce exponent
	if !(esign > 0) {
		goto __34
	}
__36:
	if !((s < ((int64(0xffffffff) | (sqlite3_int64((int64(0x7fffffff))) << 32)) / int64(10))) && (e > 0)) {
		goto __37
	}
	e--
	s = s * (int64(10))
	goto __36
__37:
	;
	goto __35
__34:
__38:
	if !(!((int32(s % int64(10))) != 0) && (e > 0)) {
		goto __39
	}
	e--
	s = s / (int64(10))
	goto __38
__39:
	;
__35:
	;

	// adjust the sign of significand
	if sign < 0 {
		s = -s
	} else {
		s = s
	}

	// if exponent, scale significand as appropriate
	// and store in result.
	if !(e != 0) {
		goto __40
	}
	scale = 1.0
	// attempt to handle extremely small/large numbers better
	if !((e > 307) && (e < 342)) {
		goto __42
	}
__44:
	if !((e % 308) != 0) {
		goto __45
	}
	scale = scale * (1.0e+1)
	e = e - (1)
	goto __44
__45:
	;
	if !(esign < 0) {
		goto __46
	}
	result = (float64(s) / scale)
	result = result / (1.0e+308)
	goto __47
__46:
	result = (float64(s) * scale)
	result = result * (1.0e+308)
__47:
	;
	goto __43
__42:
	if !(e >= 342) {
		goto __48
	}
	if !(esign < 0) {
		goto __50
	}
	result = (0.0 * float64(s))
	goto __51
__50:
	result = ((crt.Float64(1e308) * crt.Float64(1e308)) * float64(s))
__51:
	;
	goto __49
__48:
	// 1.0e+22 is the largest power of 10 than can be
	// represented exactly.
__52:
	if !((e % 22) != 0) {
		goto __53
	}
	scale = scale * (1.0e+1)
	e = e - (1)
	goto __52
__53:
	;
__54:
	if !(e > 0) {
		goto __55
	}
	scale = scale * (1.0e+22)
	e = e - (22)
	goto __54
__55:
	;
	if !(esign < 0) {
		goto __56
	}
	result = (float64(s) / scale)
	goto __57
__56:
	result = (float64(s) * scale)
__57:
	;
__49:
	;
__43:
	;
	goto __41
__40:
	result = float64(s)
__41:
	;
__33:
	;

	// store the result
	*(*float64)(unsafe.Pointer(pResult)) = result

	// return true if number and no extra non-whitespace chracters after
	return (crt.Bool32((((z >= zEnd) && (nDigits > 0)) && (eValid != 0)) && (nonNum == 0)))
}

// tointeger(X):  If X is any value (integer, double, blob, or string) that
// can be losslessly converted into an integer, then make the conversion and
// return the result.  Otherwise, return NULL.
func tointegerFunc(tls *crt.TLS, context uintptr, argc int32, argv uintptr) { /* totype.c:358:13: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	if !(argc == 1) {
		crt.X__assert_fail(tls, ts+8151 /* "argc==1" */, ts+7960 /* "testdata/sqlite-..." */, uint32(363), uintptr(unsafe.Pointer(&__func__31)))
	}
	_ = argc
	switch sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8))) {
	case 2:
		{
			var rVal float64 = sqlite3.Xsqlite3_value_double(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)))
			var iVal sqlite3_int64 = sqlite3_int64(rVal)
			if rVal == float64(iVal) {
				sqlite3.Xsqlite3_result_int64(tls, context, iVal)
			}
			break
		}
	case 1:
		{
			sqlite3.Xsqlite3_result_int64(tls, context, sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8))))
			break
		}
	case 4:
		{
			var zBlob uintptr = sqlite3.Xsqlite3_value_blob(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)))
			if zBlob != 0 {
				var nBlob int32 = sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)))
				if uint64(nBlob) == uint64(unsafe.Sizeof(sqlite3_int64(0))) {
					// var iVal sqlite3_int64 at bp+8, 8

					if 0 != 0 {
						var i int32
						// var zBlobRev [8]uint8 at bp, 8

						for i = 0; uint64(i) < uint64(unsafe.Sizeof(sqlite3_int64(0))); i++ {
							*(*uint8)(unsafe.Pointer(bp /* &zBlobRev[0] */ + uintptr(i))) = *(*uint8)(unsafe.Pointer(zBlob + uintptr(((uint64(unsafe.Sizeof(sqlite3_int64(0))) - uint64(1)) - uint64(i)))))
						}
						crt.Xmemcpy(tls, bp+8 /* &iVal */, bp /* &zBlobRev[0] */, uint64(unsafe.Sizeof(sqlite3_int64(0))))
					} else {
						crt.Xmemcpy(tls, bp+8 /* &iVal */, zBlob, uint64(unsafe.Sizeof(sqlite3_int64(0))))
					}
					sqlite3.Xsqlite3_result_int64(tls, context, *(*sqlite3_int64)(unsafe.Pointer(bp + 8 /* iVal */)))
				}
			}
			break
		}
	case 3:
		{
			var zStr uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)))
			if zStr != 0 {
				var nStr int32 = sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)))
				if (nStr != 0) && !(totypeIsspace(tls, *(*uint8)(unsafe.Pointer(zStr + uintptr(0)))) != 0) {
					// var iVal sqlite3_int64 at bp+16, 8

					if !(totypeAtoi64(tls, zStr, bp+16 /* &iVal */, nStr) != 0) {
						sqlite3.Xsqlite3_result_int64(tls, context, *(*sqlite3_int64)(unsafe.Pointer(bp + 16 /* iVal */)))
					}
				}
			}
			break
		}
	default:
		{
			if !(sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8))) == 5) {
				crt.X__assert_fail(tls, ts+8159 /* "sqlite3_value_ty..." */, ts+7960 /* "testdata/sqlite-..." */, uint32(413), uintptr(unsafe.Pointer(&__func__31)))
			}
			break
		}
	}
}

var __func__31 = *(*[14]int8)(unsafe.Pointer(ts + 8190 /* "tointegerFunc" */)) /* totype.c:362:2 */

// toreal(X): If X is any value (integer, double, blob, or string) that can
// be losslessly converted into a real number, then do so and return that
// real number.  Otherwise return NULL.
func torealFunc(tls *crt.TLS, context uintptr, argc int32, argv uintptr) { /* totype.c:428:13: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	if !(argc == 1) {
		crt.X__assert_fail(tls, ts+8151 /* "argc==1" */, ts+7960 /* "testdata/sqlite-..." */, uint32(433), uintptr(unsafe.Pointer(&__func__32)))
	}
	_ = argc
	switch sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8))) {
	case 2:
		{
			sqlite3.Xsqlite3_result_double(tls, context, sqlite3.Xsqlite3_value_double(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8))))
			break
		}
	case 1:
		{
			var iVal sqlite3_int64 = sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)))
			var rVal float64 = float64(iVal)
			if iVal == sqlite3_int64(rVal) {
				sqlite3.Xsqlite3_result_double(tls, context, rVal)
			}
			break
		}
	case 4:
		{
			var zBlob uintptr = sqlite3.Xsqlite3_value_blob(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)))
			if zBlob != 0 {
				var nBlob int32 = sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)))
				if uint64(nBlob) == uint64(unsafe.Sizeof(float64(0))) {
					// var rVal float64 at bp+8, 8

					if 1 != 0 {
						var i int32
						// var zBlobRev [8]uint8 at bp, 8

						for i = 0; uint64(i) < uint64(unsafe.Sizeof(float64(0))); i++ {
							*(*uint8)(unsafe.Pointer(bp /* &zBlobRev[0] */ + uintptr(i))) = *(*uint8)(unsafe.Pointer(zBlob + uintptr(((uint64(unsafe.Sizeof(float64(0))) - uint64(1)) - uint64(i)))))
						}
						crt.Xmemcpy(tls, bp+8 /* &rVal */, bp /* &zBlobRev[0] */, uint64(unsafe.Sizeof(float64(0))))
					} else {
						crt.Xmemcpy(tls, bp+8 /* &rVal */, zBlob, uint64(unsafe.Sizeof(float64(0))))
					}
					sqlite3.Xsqlite3_result_double(tls, context, *(*float64)(unsafe.Pointer(bp + 8 /* rVal */)))
				}
			}
			break
		}
	case 3:
		{
			var zStr uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)))
			if zStr != 0 {
				var nStr int32 = sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)))
				if ((nStr != 0) && !(totypeIsspace(tls, *(*uint8)(unsafe.Pointer(zStr + uintptr(0)))) != 0)) && !(totypeIsspace(tls, *(*uint8)(unsafe.Pointer(zStr + uintptr((nStr - 1))))) != 0) {
					// var rVal float64 at bp+16, 8

					if totypeAtoF(tls, zStr, bp+16 /* &rVal */, nStr) != 0 {
						sqlite3.Xsqlite3_result_double(tls, context, *(*float64)(unsafe.Pointer(bp + 16 /* rVal */)))
						return
					}
				}
			}
			break
		}
	default:
		{
			if !(sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8))) == 5) {
				crt.X__assert_fail(tls, ts+8159 /* "sqlite3_value_ty..." */, ts+7960 /* "testdata/sqlite-..." */, uint32(484), uintptr(unsafe.Pointer(&__func__32)))
			}
			break
		}
	}
}

var __func__32 = *(*[11]int8)(unsafe.Pointer(ts + 8204 /* "torealFunc" */)) /* totype.c:432:2 */

func sqlite3_totype_init(tls *crt.TLS, db uintptr, pzErrMsg uintptr, pApi uintptr) int32 { /* totype.c:497:5: */
	var rc int32 = 0
	_ = pApi

	_ = pzErrMsg // Unused parameter
	rc = sqlite3.Xsqlite3_create_function(tls, db, ts+8215 /* "tointeger" */, 1,
		((1 | 0x000000800) | 0x000200000), uintptr(0),
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*crt.TLS, uintptr, int32, uintptr)
		}{tointegerFunc})), uintptr(0), uintptr(0))
	if rc == 0 {
		rc = sqlite3.Xsqlite3_create_function(tls, db, ts+8225 /* "toreal" */, 1,
			((1 | 0x000000800) | 0x000200000), uintptr(0),
			*(*uintptr)(unsafe.Pointer(&struct {
				f func(*crt.TLS, uintptr, int32, uintptr)
			}{torealFunc})), uintptr(0), uintptr(0))
	}
	return rc
}

// Floating-point inline functions for stdlib.h.
//   Copyright (C) 2012-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// Define some macros helping to catch buffer overflows.

// Largest and smallest possible 64-bit signed integers. These macros
// copied from sqliteInt.h.

// The following is also copied from sqliteInt.h. To facilitate coverage
// testing.

// The swarmvtab module attempts to keep the number of open database files
// at or below this limit. This may not be possible if there are too many
// simultaneous queries.

type UnionCsr1 = struct {
	Fbase      sqlite3_vtab_cursor
	FpStmt     uintptr
	FiMaxRowid sqlite3_int64
	FiTab      int32
	_          [4]byte
}

// Floating-point inline functions for stdlib.h.
//   Copyright (C) 2012-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// Define some macros helping to catch buffer overflows.

// Largest and smallest possible 64-bit signed integers. These macros
// copied from sqliteInt.h.

// The following is also copied from sqliteInt.h. To facilitate coverage
// testing.

// The swarmvtab module attempts to keep the number of open database files
// at or below this limit. This may not be possible if there are too many
// simultaneous queries.

type UnionCsr = UnionCsr1 /* unionvtab.c:181:25 */
type UnionTab1 = struct {
	Fbase        sqlite3_vtab
	Fdb          uintptr
	FbSwarm      int32
	FiPK         int32
	FnSrc        int32
	FaSrc        uintptr
	FbHasContext int32
	FzSourceStr  uintptr
	FpNotFound   uintptr
	FpOpenClose  uintptr
	FpClosable   uintptr
	FnOpen       int32
	FnMaxOpen    int32
}

type UnionTab = UnionTab1 /* unionvtab.c:182:25 */
type UnionSrc1 = struct {
	FzDb           uintptr
	FzTab          uintptr
	FiMin          sqlite3_int64
	FiMax          sqlite3_int64
	FzFile         uintptr
	FzContext      uintptr
	FnUser         int32
	Fdb            uintptr
	FpNextClosable uintptr
}

type UnionSrc = UnionSrc1 /* unionvtab.c:183:25 */

// Given UnionTab table pTab and UnionSrc object pSrc, return the database
// handle that should be used to access the table identified by pSrc. This
// is the main db handle for "unionvtab" tables, or the source-specific
// handle for "swarmvtab".

// If *pRc is other than SQLITE_OK when this function is called, it
// always returns NULL. Otherwise, it attempts to allocate and return
// a pointer to nByte bytes of zeroed memory. If the memory allocation
// is attempted but fails, NULL is returned and *pRc is set to
// SQLITE_NOMEM.
func unionMalloc(tls *crt.TLS, pRc uintptr, nByte sqlite3_int64) uintptr { /* unionvtab.c:253:13: */
	var pRet uintptr
	if !(nByte > int64(0)) {
		crt.X__assert_fail(tls, ts+63 /* "nByte>0" */, ts+8232 /* "testdata/sqlite-..." */, uint32(255), uintptr(unsafe.Pointer(&__func__33)))
	}
	if *(*int32)(unsafe.Pointer(pRc)) == 0 {
		pRet = sqlite3.Xsqlite3_malloc64(tls, uint64(nByte))
		if pRet != 0 {
			crt.Xmemset(tls, pRet, 0, size_t(nByte))
		} else {
			*(*int32)(unsafe.Pointer(pRc)) = 7
		}
	} else {
		pRet = uintptr(0)
	}
	return pRet
}

var __func__33 = *(*[12]int8)(unsafe.Pointer(ts + 8281 /* "unionMalloc" */)) /* unionvtab.c:253:56 */

// If *pRc is other than SQLITE_OK when this function is called, it
// always returns NULL. Otherwise, it attempts to allocate and return
// a copy of the nul-terminated string passed as the second argument.
// If the allocation is attempted but fails, NULL is returned and *pRc is
// set to SQLITE_NOMEM.
func unionStrdup(tls *crt.TLS, pRc uintptr, zIn uintptr) uintptr { /* unionvtab.c:276:13: */
	var zRet uintptr = uintptr(0)
	if zIn != 0 {
		var nByte sqlite3_int64 = (sqlite3_int64(crt.Xstrlen(tls, zIn) + uint64(1)))
		zRet = unionMalloc(tls, pRc, nByte)
		if zRet != 0 {
			crt.Xmemcpy(tls, zRet, zIn, size_t(nByte))
		}
	}
	return zRet
}

// If the first character of the string passed as the only argument to this
// function is one of the 4 that may be used as an open quote character
// in SQL, this function assumes that the input is a well-formed quoted SQL
// string. In this case the string is dequoted in place.
//
// If the first character of the input is not an open quote, then this
// function is a no-op.
func unionDequote(tls *crt.TLS, z uintptr) { /* unionvtab.c:297:13: */
	if z != 0 {
		var q int8 = *(*int8)(unsafe.Pointer(z + uintptr(0)))

		// Set stack variable q to the close-quote character
		if (((int32(q) == '[') || (int32(q) == '\'')) || (int32(q) == '"')) || (int32(q) == '`') {
			var iIn int32 = 1
			var iOut int32 = 0
			if int32(q) == '[' {
				q = int8(']')
			}
			for func() int32 {
				if *(*int8)(unsafe.Pointer(z + uintptr(iIn))) != 0 {
					return 1
				}
				return func() int32 {
					if !(0 != 0) {
						crt.X__assert_fail(tls, ts+8293 /* "0" */, ts+8232 /* "testdata/sqlite-..." */, uint32(306), uintptr(unsafe.Pointer(&__func__34)))
					}
					return 0
				}()
			}() != 0 {
				if int32(*(*int8)(unsafe.Pointer(z + uintptr(iIn)))) == int32(q) {
					if int32(*(*int8)(unsafe.Pointer(z + uintptr((iIn + 1))))) != int32(q) {
						// Character iIn was the close quote.
						iIn++
						break
					} else {
						// Character iIn and iIn+1 form an escaped quote character. Skip
						// the input cursor past both and copy a single quote character
						// to the output buffer.
						iIn = iIn + (2)
						*(*int8)(unsafe.Pointer(z + uintptr(crt.PostIncInt32(&iOut, 1)))) = q
					}
				} else {
					*(*int8)(unsafe.Pointer(z + uintptr(crt.PostIncInt32(&iOut, 1)))) = *(*int8)(unsafe.Pointer(z + uintptr(crt.PostIncInt32(&iIn, 1))))
				}
			}
			*(*int8)(unsafe.Pointer(z + uintptr(iOut))) = int8(0)
		}
	}
}

var __func__34 = *(*[13]int8)(unsafe.Pointer(ts + 8295 /* "unionDequote" */)) /* unionvtab.c:297:34 */

// This function is a no-op if *pRc is set to other than SQLITE_OK when it
// is called. NULL is returned in this case.
//
// Otherwise, the SQL statement passed as the third argument is prepared
// against the database handle passed as the second. If the statement is
// successfully prepared, a pointer to the new statement handle is
// returned. It is the responsibility of the caller to eventually free the
// statement by calling sqlite3_finalize(). Alternatively, if statement
// compilation fails, NULL is returned, *pRc is set to an SQLite error
// code and *pzErr may be set to an error message buffer allocated by
// sqlite3_malloc().
func unionPrepare(tls *crt.TLS, pRc uintptr, db uintptr, zSql uintptr, pzErr uintptr) uintptr { /* unionvtab.c:341:21: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	*(*uintptr)(unsafe.Pointer(bp + 8 /* pRet */)) = uintptr(0)
	if !(pzErr != 0) {
		crt.X__assert_fail(tls, ts+8308 /* "pzErr" */, ts+8232 /* "testdata/sqlite-..." */, uint32(348), uintptr(unsafe.Pointer(&__func__35)))
	}
	if *(*int32)(unsafe.Pointer(pRc)) == 0 {
		var rc int32 = sqlite3.Xsqlite3_prepare_v2(tls, db, zSql, -1, bp+8 /* &pRet */, uintptr(0))
		if rc != 0 {
			*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+8314 /* "sql error: %s" */, crt.VaList(bp, sqlite3.Xsqlite3_errmsg(tls, db)))
			*(*int32)(unsafe.Pointer(pRc)) = rc
		}
	}
	return *(*uintptr)(unsafe.Pointer(bp + 8 /* pRet */))
}

var __func__35 = *(*[13]int8)(unsafe.Pointer(ts + 8328 /* "unionPrepare" */)) /* unionvtab.c:346:2 */

// Like unionPrepare(), except prepare the results of vprintf(zFmt, ...)
// instead of a constant SQL string.
func unionPreparePrintf(tls *crt.TLS, pRc uintptr, pzErr uintptr, db uintptr, zFmt uintptr, va uintptr) uintptr { /* unionvtab.c:363:21: */
	var pRet uintptr = uintptr(0)
	var zSql uintptr
	var ap va_list
	_ = ap
	ap = va

	zSql = sqlite3.Xsqlite3_vmprintf(tls, zFmt, ap)
	if *(*int32)(unsafe.Pointer(pRc)) == 0 {
		if zSql == uintptr(0) {
			*(*int32)(unsafe.Pointer(pRc)) = 7
		} else {
			pRet = unionPrepare(tls, pRc, db, zSql, pzErr)
		}
	}
	sqlite3.Xsqlite3_free(tls, zSql)

	_ = ap
	return pRet
}

// Call sqlite3_reset() on SQL statement pStmt. If *pRc is set to
// SQLITE_OK when this function is called, then it is set to the
// value returned by sqlite3_reset() before this function exits.
// In this case, *pzErr may be set to point to an error message
// buffer allocated by sqlite3_malloc().

// Call sqlite3_finalize() on SQL statement pStmt. If *pRc is set to
// SQLITE_OK when this function is called, then it is set to the
// value returned by sqlite3_finalize() before this function exits.
func unionFinalize(tls *crt.TLS, pRc uintptr, pStmt uintptr, pzErr uintptr) { /* unionvtab.c:414:13: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var db uintptr = sqlite3.Xsqlite3_db_handle(tls, pStmt)
	var rc int32 = sqlite3.Xsqlite3_finalize(tls, pStmt)
	if *(*int32)(unsafe.Pointer(pRc)) == 0 {
		*(*int32)(unsafe.Pointer(pRc)) = rc
		if rc != 0 {
			*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+130 /* "%s" */, crt.VaList(bp, sqlite3.Xsqlite3_errmsg(tls, db)))
		}
	}
}

// If an "openclose" UDF was supplied when this virtual table was created,
// invoke it now. The first argument passed is the name of the database
// file for source pSrc. The second is integer value bClose.
//
// If successful, return SQLITE_OK. Otherwise an SQLite error code. In this
// case if argument pzErr is not NULL, also set (*pzErr) to an English
// language error message. The caller is responsible for eventually freeing
// any error message using sqlite3_free().
func unionInvokeOpenClose(tls *crt.TLS, pTab uintptr, pSrc uintptr, bClose int32, pzErr uintptr) int32 { /* unionvtab.c:435:12: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var rc int32 = 0
	if (*UnionTab)(unsafe.Pointer(pTab)).FpOpenClose != 0 {
		sqlite3.Xsqlite3_bind_text(tls, (*UnionTab)(unsafe.Pointer(pTab)).FpOpenClose, 1, (*UnionSrc)(unsafe.Pointer(pSrc)).FzFile, -1, uintptr(0))
		if (*UnionTab)(unsafe.Pointer(pTab)).FbHasContext != 0 {
			sqlite3.Xsqlite3_bind_text(tls, (*UnionTab)(unsafe.Pointer(pTab)).FpOpenClose, 2, (*UnionSrc)(unsafe.Pointer(pSrc)).FzContext, -1, uintptr(0))
		}
		sqlite3.Xsqlite3_bind_int(tls, (*UnionTab)(unsafe.Pointer(pTab)).FpOpenClose, (2 + (*UnionTab)(unsafe.Pointer(pTab)).FbHasContext), bClose)
		sqlite3.Xsqlite3_step(tls, (*UnionTab)(unsafe.Pointer(pTab)).FpOpenClose)
		if 0 != (crt.AssignInt32(&rc, sqlite3.Xsqlite3_reset(tls, (*UnionTab)(unsafe.Pointer(pTab)).FpOpenClose))) {
			if pzErr != 0 {
				*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+130 /* "%s" */, crt.VaList(bp, sqlite3.Xsqlite3_errmsg(tls, (*UnionTab)(unsafe.Pointer(pTab)).Fdb)))
			}
		}
	}
	return rc
}

// This function is a no-op for unionvtab. For swarmvtab, it attempts to
// close open database files until at most nMax are open. An SQLite error
// code is returned if an error occurs, or SQLITE_OK otherwise.
func unionCloseSources(tls *crt.TLS, pTab uintptr, nMax int32) { /* unionvtab.c:463:13: */
	for ((*UnionTab)(unsafe.Pointer(pTab)).FpClosable != 0) && ((*UnionTab)(unsafe.Pointer(pTab)).FnOpen > nMax) {
		var p uintptr
		var pp uintptr
		for pp = (pTab + 88 /* &.pClosable */); (*UnionSrc)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(pp)))).FpNextClosable != 0; pp = (*(*uintptr)(unsafe.Pointer(pp)) + 64 /* &.pNextClosable */) {
		}
		p = *(*uintptr)(unsafe.Pointer(pp))
		if !((*UnionSrc)(unsafe.Pointer(p)).Fdb != 0) {
			crt.X__assert_fail(tls, ts+8341 /* "p->db" */, ts+8232 /* "testdata/sqlite-..." */, uint32(469), uintptr(unsafe.Pointer(&__func__36)))
		}
		sqlite3.Xsqlite3_close(tls, (*UnionSrc)(unsafe.Pointer(p)).Fdb)
		(*UnionSrc)(unsafe.Pointer(p)).Fdb = uintptr(0)
		*(*uintptr)(unsafe.Pointer(pp)) = uintptr(0)
		(*UnionTab)(unsafe.Pointer(pTab)).FnOpen--
		unionInvokeOpenClose(tls, pTab, p, 1, uintptr(0))
	}
}

var __func__36 = *(*[18]int8)(unsafe.Pointer(ts + 8347 /* "unionCloseSource..." */)) /* unionvtab.c:463:56 */

// xDisconnect method.
func unionDisconnect(tls *crt.TLS, pVtab uintptr) int32 { /* unionvtab.c:481:12: */
	if pVtab != 0 {
		var pTab uintptr = pVtab
		var i int32
		for i = 0; i < (*UnionTab)(unsafe.Pointer(pTab)).FnSrc; i++ {
			var pSrc uintptr = ((*UnionTab)(unsafe.Pointer(pTab)).FaSrc + uintptr(i)*72)
			var bHaveSrcDb int32 = (crt.Bool32((*UnionSrc)(unsafe.Pointer(pSrc)).Fdb != uintptr(0)))
			sqlite3.Xsqlite3_close(tls, (*UnionSrc)(unsafe.Pointer(pSrc)).Fdb)
			if bHaveSrcDb != 0 {
				unionInvokeOpenClose(tls, pTab, pSrc, 1, uintptr(0))
			}
			sqlite3.Xsqlite3_free(tls, (*UnionSrc)(unsafe.Pointer(pSrc)).FzDb)
			sqlite3.Xsqlite3_free(tls, (*UnionSrc)(unsafe.Pointer(pSrc)).FzTab)
			sqlite3.Xsqlite3_free(tls, (*UnionSrc)(unsafe.Pointer(pSrc)).FzFile)
			sqlite3.Xsqlite3_free(tls, (*UnionSrc)(unsafe.Pointer(pSrc)).FzContext)
		}
		sqlite3.Xsqlite3_finalize(tls, (*UnionTab)(unsafe.Pointer(pTab)).FpNotFound)
		sqlite3.Xsqlite3_finalize(tls, (*UnionTab)(unsafe.Pointer(pTab)).FpOpenClose)
		sqlite3.Xsqlite3_free(tls, (*UnionTab)(unsafe.Pointer(pTab)).FzSourceStr)
		sqlite3.Xsqlite3_free(tls, (*UnionTab)(unsafe.Pointer(pTab)).FaSrc)
		sqlite3.Xsqlite3_free(tls, pTab)
	}
	return 0
}

// Check that the table identified by pSrc is a rowid table. If not,
// return SQLITE_ERROR and set (*pzErr) to point to an English language
// error message. If the table is a rowid table and no error occurs,
// return SQLITE_OK and leave (*pzErr) unmodified.
func unionIsIntkeyTable(tls *crt.TLS, db uintptr, pSrc uintptr, pzErr uintptr) int32 { /* unionvtab.c:512:12: */
	bp := tls.Alloc(36)
	defer tls.Free(36)

	*(*int32)(unsafe.Pointer(bp + 32 /* bPk */)) = 0
	*(*uintptr)(unsafe.Pointer(bp + 24 /* zType */)) = uintptr(0)
	var rc int32

	sqlite3.Xsqlite3_table_column_metadata(tls,
		db, (*UnionSrc)(unsafe.Pointer(pSrc)).FzDb, (*UnionSrc)(unsafe.Pointer(pSrc)).FzTab, ts+8365 /* "_rowid_" */, bp+24 /* &zType */, uintptr(0), uintptr(0), bp+32 /* &bPk */, uintptr(0))
	rc = sqlite3.Xsqlite3_errcode(tls, db)
	if (rc == 1) ||
		((rc == 0) && (!(*(*int32)(unsafe.Pointer(bp + 32 /* bPk */)) != 0) || (sqlite3.Xsqlite3_stricmp(tls, ts+8373 /* "integer" */, *(*uintptr)(unsafe.Pointer(bp + 24 /* zType */))) != 0))) {
		rc = 1
		*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+8381, /* "no such rowid ta..." */
			crt.VaList(bp, func() uintptr {
				if (*UnionSrc)(unsafe.Pointer(pSrc)).FzDb != 0 {
					return (*UnionSrc)(unsafe.Pointer(pSrc)).FzDb
				}
				return ts + 792 /* "" */
			}(),
				func() uintptr {
					if (*UnionSrc)(unsafe.Pointer(pSrc)).FzDb != 0 {
						return ts + 8409 /* "." */
					}
					return ts + 792 /* "" */
				}(),
				(*UnionSrc)(unsafe.Pointer(pSrc)).FzTab))
	}
	return rc
}

// This function is a no-op if *pRc is other than SQLITE_OK when it is
// called. In this case it returns NULL.
//
// Otherwise, this function checks that the source table passed as the
// second argument (a) exists, (b) is not a view and (c) has a column
// named "_rowid_" of type "integer" that is the primary key.
// If this is not the case, *pRc is set to SQLITE_ERROR and NULL is
// returned.
//
// Finally, if the source table passes the checks above, a nul-terminated
// string describing the column names and types belonging to the source
// table is returned. Tables with the same set of column names and types
// cause this function to return identical strings. Is is the responsibility
// of the caller to free the returned string using sqlite3_free() when
// it is no longer required.
func unionSourceToStr(tls *crt.TLS, pRc uintptr, pTab uintptr, pSrc uintptr, pzErr uintptr) uintptr { /* unionvtab.c:555:13: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var zRet uintptr = uintptr(0)
	if *(*int32)(unsafe.Pointer(pRc)) == 0 {
		var db uintptr = func() uintptr {
			if (*UnionTab)(unsafe.Pointer(pTab)).FbSwarm != 0 {
				return (*UnionSrc)(unsafe.Pointer(pSrc)).Fdb
			}
			return (*UnionTab)(unsafe.Pointer(pTab)).Fdb
		}()
		*(*int32)(unsafe.Pointer(bp /* rc */)) = unionIsIntkeyTable(tls, db, pSrc, pzErr)
		var pStmt uintptr = unionPrepare(tls, bp /* &rc */, db,

			ts+8411 /* "SELECT group_con..." */, pzErr)
		if *(*int32)(unsafe.Pointer(bp /* rc */)) == 0 {
			sqlite3.Xsqlite3_bind_text(tls, pStmt, 1, (*UnionSrc)(unsafe.Pointer(pSrc)).FzTab, -1, uintptr(0))
			sqlite3.Xsqlite3_bind_text(tls, pStmt, 2, (*UnionSrc)(unsafe.Pointer(pSrc)).FzDb, -1, uintptr(0))
			if 100 == sqlite3.Xsqlite3_step(tls, pStmt) {
				var z uintptr = sqlite3.Xsqlite3_column_text(tls, pStmt, 0)
				zRet = unionStrdup(tls, bp /* &rc */, z)
			}
			unionFinalize(tls, bp /* &rc */, pStmt, pzErr)
		}
		*(*int32)(unsafe.Pointer(pRc)) = *(*int32)(unsafe.Pointer(bp /* rc */))
	}

	return zRet
}

// Check that all configured source tables exist and have the same column
// names and datatypes. If this is not the case, or if some other error
// occurs, return an SQLite error code. In this case *pzErr may be set
// to point to an error message buffer allocated by sqlite3_mprintf().
// Or, if no problems regarding the source tables are detected and no
// other error occurs, SQLITE_OK is returned.
func unionSourceCheck(tls *crt.TLS, pTab uintptr, pzErr uintptr) int32 { /* unionvtab.c:592:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	*(*int32)(unsafe.Pointer(bp /* rc */)) = 0
	var z0 uintptr = uintptr(0)
	var i int32

	if !(*(*uintptr)(unsafe.Pointer(pzErr)) == uintptr(0)) {
		crt.X__assert_fail(tls, ts+8495 /* "*pzErr==0" */, ts+8232 /* "testdata/sqlite-..." */, uint32(597), uintptr(unsafe.Pointer(&__func__37)))
	}
	z0 = unionSourceToStr(tls, bp /* &rc */, pTab, ((*UnionTab)(unsafe.Pointer(pTab)).FaSrc + uintptr(0)*72), pzErr)
	for i = 1; i < (*UnionTab)(unsafe.Pointer(pTab)).FnSrc; i++ {
		var z uintptr = unionSourceToStr(tls, bp /* &rc */, pTab, ((*UnionTab)(unsafe.Pointer(pTab)).FaSrc + uintptr(i)*72), pzErr)
		if (*(*int32)(unsafe.Pointer(bp /* rc */)) == 0) && (sqlite3.Xsqlite3_stricmp(tls, z, z0) != 0) {
			*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+8505 /* "source table sch..." */, 0)
			*(*int32)(unsafe.Pointer(bp /* rc */)) = 1
		}
		sqlite3.Xsqlite3_free(tls, z)
	}
	sqlite3.Xsqlite3_free(tls, z0)

	return *(*int32)(unsafe.Pointer(bp /* rc */))
}

var __func__37 = *(*[17]int8)(unsafe.Pointer(ts + 8534 /* "unionSourceCheck" */)) /* unionvtab.c:592:58 */

// Try to open the swarmvtab database.  If initially unable, invoke the
// not-found callback UDF and then try again.
func unionOpenDatabaseInner(tls *crt.TLS, pTab uintptr, pSrc uintptr, pzErr uintptr) int32 { /* unionvtab.c:616:12: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var rc int32

	rc = unionInvokeOpenClose(tls, pTab, pSrc, 0, pzErr)
	if rc != 0 {
		return rc
	}

	rc = sqlite3.Xsqlite3_open_v2(tls, (*UnionSrc)(unsafe.Pointer(pSrc)).FzFile, (pSrc + 56 /* &.db */), openFlags, uintptr(0))
	if rc == 0 {
		return rc
	}
	if (*UnionTab)(unsafe.Pointer(pTab)).FpNotFound != 0 {
		sqlite3.Xsqlite3_close(tls, (*UnionSrc)(unsafe.Pointer(pSrc)).Fdb)
		(*UnionSrc)(unsafe.Pointer(pSrc)).Fdb = uintptr(0)
		sqlite3.Xsqlite3_bind_text(tls, (*UnionTab)(unsafe.Pointer(pTab)).FpNotFound, 1, (*UnionSrc)(unsafe.Pointer(pSrc)).FzFile, -1, uintptr(0))
		if (*UnionTab)(unsafe.Pointer(pTab)).FbHasContext != 0 {
			sqlite3.Xsqlite3_bind_text(tls, (*UnionTab)(unsafe.Pointer(pTab)).FpNotFound, 2, (*UnionSrc)(unsafe.Pointer(pSrc)).FzContext, -1, uintptr(0))
		}
		sqlite3.Xsqlite3_step(tls, (*UnionTab)(unsafe.Pointer(pTab)).FpNotFound)
		if 0 != (crt.AssignInt32(&rc, sqlite3.Xsqlite3_reset(tls, (*UnionTab)(unsafe.Pointer(pTab)).FpNotFound))) {
			*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+130 /* "%s" */, crt.VaList(bp, sqlite3.Xsqlite3_errmsg(tls, (*UnionTab)(unsafe.Pointer(pTab)).Fdb)))
			return rc
		}
		rc = sqlite3.Xsqlite3_open_v2(tls, (*UnionSrc)(unsafe.Pointer(pSrc)).FzFile, (pSrc + 56 /* &.db */), openFlags, uintptr(0))
	}
	if rc != 0 {
		*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+130 /* "%s" */, crt.VaList(bp+8, sqlite3.Xsqlite3_errmsg(tls, (*UnionSrc)(unsafe.Pointer(pSrc)).Fdb)))
	}
	return rc
}

var openFlags int32 = (0x00000001 | 0x00000040) /* unionvtab.c:617:20 */

// This function may only be called for swarmvtab tables. The results of
// calling it on a unionvtab table are undefined.
//
// For a swarmvtab table, this function ensures that source database iSrc
// is open. If the database is opened successfully and the schema is as
// expected, or if it is already open when this function is called, SQLITE_OK
// is returned.
//
// Alternatively If an error occurs while opening the databases, or if the
// database schema is unsuitable, an SQLite error code is returned and (*pzErr)
// may be set to point to an English language error message. In this case it is
// the responsibility of the caller to eventually free the error message buffer
// using sqlite3_free().
func unionOpenDatabase(tls *crt.TLS, pTab uintptr, iSrc int32, pzErr uintptr) int32 { /* unionvtab.c:660:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	*(*int32)(unsafe.Pointer(bp /* rc */)) = 0
	var pSrc uintptr = ((*UnionTab)(unsafe.Pointer(pTab)).FaSrc + uintptr(iSrc)*72)

	if !(((*UnionTab)(unsafe.Pointer(pTab)).FbSwarm != 0) && (iSrc < (*UnionTab)(unsafe.Pointer(pTab)).FnSrc)) {
		crt.X__assert_fail(tls, ts+8551 /* "pTab->bSwarm && ..." */, ts+8232 /* "testdata/sqlite-..." */, uint32(664), uintptr(unsafe.Pointer(&__func__38)))
	}
	if (*UnionSrc)(unsafe.Pointer(pSrc)).Fdb == uintptr(0) {
		unionCloseSources(tls, pTab, ((*UnionTab)(unsafe.Pointer(pTab)).FnMaxOpen - 1))
		*(*int32)(unsafe.Pointer(bp /* rc */)) = unionOpenDatabaseInner(tls, pTab, pSrc, pzErr)
		if *(*int32)(unsafe.Pointer(bp /* rc */)) == 0 {
			var z uintptr = unionSourceToStr(tls, bp /* &rc */, pTab, pSrc, pzErr)
			if *(*int32)(unsafe.Pointer(bp /* rc */)) == 0 {
				if (*UnionTab)(unsafe.Pointer(pTab)).FzSourceStr == uintptr(0) {
					(*UnionTab)(unsafe.Pointer(pTab)).FzSourceStr = z
				} else {
					if sqlite3.Xsqlite3_stricmp(tls, z, (*UnionTab)(unsafe.Pointer(pTab)).FzSourceStr) != 0 {
						*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+8505 /* "source table sch..." */, 0)
						*(*int32)(unsafe.Pointer(bp /* rc */)) = 1
					}
					sqlite3.Xsqlite3_free(tls, z)
				}
			}
		}

		if *(*int32)(unsafe.Pointer(bp /* rc */)) == 0 {
			(*UnionSrc)(unsafe.Pointer(pSrc)).FpNextClosable = (*UnionTab)(unsafe.Pointer(pTab)).FpClosable
			(*UnionTab)(unsafe.Pointer(pTab)).FpClosable = pSrc
			(*UnionTab)(unsafe.Pointer(pTab)).FnOpen++
		} else {
			sqlite3.Xsqlite3_close(tls, (*UnionSrc)(unsafe.Pointer(pSrc)).Fdb)
			(*UnionSrc)(unsafe.Pointer(pSrc)).Fdb = uintptr(0)
			unionInvokeOpenClose(tls, pTab, pSrc, 1, uintptr(0))
		}
	}

	return *(*int32)(unsafe.Pointer(bp /* rc */))
}

var __func__38 = *(*[18]int8)(unsafe.Pointer(ts + 8583 /* "unionOpenDatabas..." */)) /* unionvtab.c:660:69 */

// This function is a no-op for unionvtab tables. For swarmvtab, increment
// the reference count for source table iTab. If the reference count was
// zero before it was incremented, also remove the source from the closable
// list.
func unionIncrRefcount(tls *crt.TLS, pTab uintptr, iTab int32) { /* unionvtab.c:704:13: */
	if (*UnionTab)(unsafe.Pointer(pTab)).FbSwarm != 0 {
		var pSrc uintptr = ((*UnionTab)(unsafe.Pointer(pTab)).FaSrc + uintptr(iTab)*72)
		if !(((*UnionSrc)(unsafe.Pointer(pSrc)).FnUser >= 0) && ((*UnionSrc)(unsafe.Pointer(pSrc)).Fdb != 0)) {
			crt.X__assert_fail(tls, ts+8601 /* "pSrc->nUser>=0 &..." */, ts+8232 /* "testdata/sqlite-..." */, uint32(707), uintptr(unsafe.Pointer(&__func__39)))
		}
		if (*UnionSrc)(unsafe.Pointer(pSrc)).FnUser == 0 {
			var pp uintptr
			for pp = (pTab + 88 /* &.pClosable */); *(*uintptr)(unsafe.Pointer(pp)) != pSrc; pp = (*(*uintptr)(unsafe.Pointer(pp)) + 64 /* &.pNextClosable */) {
			}
			*(*uintptr)(unsafe.Pointer(pp)) = (*UnionSrc)(unsafe.Pointer(pSrc)).FpNextClosable
			(*UnionSrc)(unsafe.Pointer(pSrc)).FpNextClosable = uintptr(0)
		}
		(*UnionSrc)(unsafe.Pointer(pSrc)).FnUser++
	}
}

var __func__39 = *(*[18]int8)(unsafe.Pointer(ts + 8628 /* "unionIncrRefcoun..." */)) /* unionvtab.c:704:56 */

// Finalize the SQL statement pCsr->pStmt and return the result.
//
// If this is a swarmvtab table (not unionvtab) and pCsr->pStmt was not
// NULL when this function was called, also decrement the reference
// count on the associated source table. If this means the source tables
// refcount is now zero, add it to the closable list.
func unionFinalizeCsrStmt(tls *crt.TLS, pCsr uintptr) int32 { /* unionvtab.c:726:12: */
	var rc int32 = 0
	if (*UnionCsr)(unsafe.Pointer(pCsr)).FpStmt != 0 {
		var pTab uintptr = (*UnionCsr)(unsafe.Pointer(pCsr)).Fbase.FpVtab
		var pSrc uintptr = ((*UnionTab)(unsafe.Pointer(pTab)).FaSrc + uintptr((*UnionCsr)(unsafe.Pointer(pCsr)).FiTab)*72)
		rc = sqlite3.Xsqlite3_finalize(tls, (*UnionCsr)(unsafe.Pointer(pCsr)).FpStmt)
		(*UnionCsr)(unsafe.Pointer(pCsr)).FpStmt = uintptr(0)
		if (*UnionTab)(unsafe.Pointer(pTab)).FbSwarm != 0 {
			(*UnionSrc)(unsafe.Pointer(pSrc)).FnUser--
			if !((*UnionSrc)(unsafe.Pointer(pSrc)).FnUser >= 0) {
				crt.X__assert_fail(tls, ts+8646 /* "pSrc->nUser>=0" */, ts+8232 /* "testdata/sqlite-..." */, uint32(735), uintptr(unsafe.Pointer(&__func__40)))
			}
			if (*UnionSrc)(unsafe.Pointer(pSrc)).FnUser == 0 {
				(*UnionSrc)(unsafe.Pointer(pSrc)).FpNextClosable = (*UnionTab)(unsafe.Pointer(pTab)).FpClosable
				(*UnionTab)(unsafe.Pointer(pTab)).FpClosable = pSrc
			}
			unionCloseSources(tls, pTab, (*UnionTab)(unsafe.Pointer(pTab)).FnMaxOpen)
		}
	}
	return rc
}

var __func__40 = *(*[21]int8)(unsafe.Pointer(ts + 8661 /* "unionFinalizeCsr..." */)) /* unionvtab.c:726:48 */

// Return true if the argument is a space, tab, CR or LF character.
func union_isspace(tls *crt.TLS, c int8) int32 { /* unionvtab.c:749:12: */
	return (crt.Bool32((((int32(c) == ' ') || (int32(c) == '\n')) || (int32(c) == '\r')) || (int32(c) == '\t')))
}

// Return true if the argument is an alphanumeric character in the
// ASCII range.
func union_isidchar(tls *crt.TLS, c int8) int32 { /* unionvtab.c:757:12: */
	return (crt.Bool32((((int32(c) >= 'a') && (int32(c) <= 'z')) || ((int32(c) >= 'A') && (int32(c) < 'Z'))) || ((int32(c) >= '0') && (int32(c) <= '9'))))
}

// This function is called to handle all arguments following the first
// (the SQL statement) passed to a swarmvtab (not unionvtab) CREATE
// VIRTUAL TABLE statement. It may bind parameters to the SQL statement
// or configure members of the UnionTab object passed as the second
// argument.
//
// Refer to header comments at the top of this file for a description
// of the arguments parsed.
//
// This function is a no-op if *pRc is other than SQLITE_OK when it is
// called. Otherwise, if an error occurs, *pRc is set to an SQLite error
// code. In this case *pzErr may be set to point to a buffer containing
// an English language error message. It is the responsibility of the
// caller to eventually free the buffer using sqlite3_free().
func unionConfigureVtab(tls *crt.TLS, pRc uintptr, pTab uintptr, pStmt uintptr, nArg int32, azArg uintptr, pzErr uintptr) { /* unionvtab.c:777:13: */
	bp := tls.Alloc(68)
	defer tls.Free(68)

	*(*int32)(unsafe.Pointer(bp + 64 /* rc */)) = *(*int32)(unsafe.Pointer(pRc))
	var i int32
	if *(*int32)(unsafe.Pointer(bp + 64 /* rc */)) == 0 {
		(*UnionTab)(unsafe.Pointer(pTab)).FbHasContext = (crt.Bool32(sqlite3.Xsqlite3_column_count(tls, pStmt) > 4))
	}
	for i = 0; (*(*int32)(unsafe.Pointer(bp + 64 /* rc */)) == 0) && (i < nArg); i++ {
		var zArg uintptr = unionStrdup(tls, bp+64 /* &rc */, *(*uintptr)(unsafe.Pointer(azArg + uintptr(i)*8)))
		if zArg != 0 {
			var nOpt int32 = 0 // Size of option name in bytes
			var zOpt uintptr   // Pointer to option name
			var zVal uintptr   // Pointer to value

			unionDequote(tls, zArg)
			zOpt = zArg
			for union_isspace(tls, *(*int8)(unsafe.Pointer(zOpt))) != 0 {
				zOpt++
			}
			zVal = zOpt
			if int32(*(*int8)(unsafe.Pointer(zVal))) == ':' {
				zVal++
			}
			for union_isidchar(tls, *(*int8)(unsafe.Pointer(zVal))) != 0 {
				zVal++
			}
			nOpt = (int32((int64(zVal) - int64(zOpt)) / 1))

			for union_isspace(tls, *(*int8)(unsafe.Pointer(zVal))) != 0 {
				zVal++
			}
			if int32(*(*int8)(unsafe.Pointer(zVal))) == '=' {
				*(*int8)(unsafe.Pointer(zOpt + uintptr(nOpt))) = int8(0)
				zVal++
				for union_isspace(tls, *(*int8)(unsafe.Pointer(zVal))) != 0 {
					zVal++
				}
				zVal = unionStrdup(tls, bp+64 /* &rc */, zVal)
				if zVal != 0 {
					unionDequote(tls, zVal)
					if int32(*(*int8)(unsafe.Pointer(zOpt + uintptr(0)))) == ':' {
						// A value to bind to the SQL statement
						var iParam int32 = sqlite3.Xsqlite3_bind_parameter_index(tls, pStmt, zOpt)
						if iParam == 0 {
							*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls,
								ts+8682 /* "swarmvtab: no su..." */, crt.VaList(bp, zOpt))
							*(*int32)(unsafe.Pointer(bp + 64 /* rc */)) = 1
						} else {
							*(*int32)(unsafe.Pointer(bp + 64 /* rc */)) = sqlite3.Xsqlite3_bind_text(tls, pStmt, iParam, zVal, -1, crt.UintptrFromInt32(-1))
						}
					} else if (nOpt == 7) && (0 == sqlite3.Xsqlite3_strnicmp(tls, zOpt, ts+8719 /* "maxopen" */, 7)) {
						(*UnionTab)(unsafe.Pointer(pTab)).FnMaxOpen = crt.Xatoi(tls, zVal)
						if (*UnionTab)(unsafe.Pointer(pTab)).FnMaxOpen <= 0 {
							*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+8727 /* "swarmvtab: illeg..." */, 0)
							*(*int32)(unsafe.Pointer(bp + 64 /* rc */)) = 1
						}
					} else if (nOpt == 7) && (0 == sqlite3.Xsqlite3_strnicmp(tls, zOpt, ts+8760 /* "missing" */, 7)) {
						if (*UnionTab)(unsafe.Pointer(pTab)).FpNotFound != 0 {
							*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls,
								ts+8768 /* "swarmvtab: dupli..." */, 0)
							*(*int32)(unsafe.Pointer(bp + 64 /* rc */)) = 1
						} else {
							(*UnionTab)(unsafe.Pointer(pTab)).FpNotFound = unionPreparePrintf(tls, bp+64 /* &rc */, pzErr, (*UnionTab)(unsafe.Pointer(pTab)).Fdb,
								ts+8806 /* "SELECT \"%w\"(?%s)" */, crt.VaList(bp+8, zVal, func() uintptr {
									if (*UnionTab)(unsafe.Pointer(pTab)).FbHasContext != 0 {
										return ts + 8823 /* ",?" */
									}
									return ts + 792 /* "" */
								}()))
						}
					} else if (nOpt == 9) && (0 == sqlite3.Xsqlite3_strnicmp(tls, zOpt, ts+8826 /* "openclose" */, 9)) {
						if (*UnionTab)(unsafe.Pointer(pTab)).FpOpenClose != 0 {
							*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls,
								ts+8836 /* "swarmvtab: dupli..." */, 0)
							*(*int32)(unsafe.Pointer(bp + 64 /* rc */)) = 1
						} else {
							(*UnionTab)(unsafe.Pointer(pTab)).FpOpenClose = unionPreparePrintf(tls, bp+64 /* &rc */, pzErr, (*UnionTab)(unsafe.Pointer(pTab)).Fdb,
								ts+8876 /* "SELECT \"%w\"(?,?%..." */, crt.VaList(bp+24, zVal, func() uintptr {
									if (*UnionTab)(unsafe.Pointer(pTab)).FbHasContext != 0 {
										return ts + 8823 /* ",?" */
									}
									return ts + 792 /* "" */
								}()))
						}
					} else {
						*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+8895 /* "swarmvtab: unrec..." */, crt.VaList(bp+40, zOpt))
						*(*int32)(unsafe.Pointer(bp + 64 /* rc */)) = 1
					}
					sqlite3.Xsqlite3_free(tls, zVal)
				}
			} else {
				if (i == 0) && (nArg == 1) {
					(*UnionTab)(unsafe.Pointer(pTab)).FpNotFound = unionPreparePrintf(tls, bp+64 /* &rc */, pzErr, (*UnionTab)(unsafe.Pointer(pTab)).Fdb,
						ts+8930 /* "SELECT \"%w\"(?)" */, crt.VaList(bp+48, zArg))
				} else {
					*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+8945 /* "swarmvtab: parse..." */, crt.VaList(bp+56, *(*uintptr)(unsafe.Pointer(azArg + uintptr(i)*8))))
					*(*int32)(unsafe.Pointer(bp + 64 /* rc */)) = 1
				}
			}
			sqlite3.Xsqlite3_free(tls, zArg)
		}
	}
	*(*int32)(unsafe.Pointer(pRc)) = *(*int32)(unsafe.Pointer(bp + 64 /* rc */))
}

// xConnect/xCreate method.
//
// The argv[] array contains the following:
//
//   argv[0]   -> module name  ("unionvtab" or "swarmvtab")
//   argv[1]   -> database name
//   argv[2]   -> table name
//   argv[3]   -> SQL statement
//   argv[4]   -> not-found callback UDF name
func unionConnect(tls *crt.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVtab uintptr, pzErr uintptr) int32 { /* unionvtab.c:883:12: */
	bp := tls.Alloc(44)
	defer tls.Free(44)

	var pTab uintptr = uintptr(0)
	*(*int32)(unsafe.Pointer(bp + 40 /* rc */)) = 0
	var bSwarm int32 = func() int32 {
		if pAux == uintptr(0) {
			return 0
		}
		return 1
	}()
	var zVtab uintptr = func() uintptr {
		if bSwarm != 0 {
			return ts + 8972 /* "swarmvtab" */
		}
		return ts + 8982 /* "unionvtab" */
	}()

	if sqlite3.Xsqlite3_stricmp(tls, ts+8992 /* "temp" */, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8))) != 0 {
		// unionvtab tables may only be created in the temp schema
		*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+8997 /* "%s tables must b..." */, crt.VaList(bp, zVtab))
		*(*int32)(unsafe.Pointer(bp + 40 /* rc */)) = 1
	} else if (argc < 4) || ((argc > 4) && (bSwarm == 0)) {
		*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+9038 /* "wrong number of ..." */, crt.VaList(bp+8, zVtab))
		*(*int32)(unsafe.Pointer(bp + 40 /* rc */)) = 1
	} else {
		var nAlloc int32 = 0                                                                                   // Allocated size of pTab->aSrc[]
		var pStmt uintptr = uintptr(0)                                                                         // Argument statement
		var zArg uintptr = unionStrdup(tls, bp+40 /* &rc */, *(*uintptr)(unsafe.Pointer(argv + uintptr(3)*8))) // Copy of argument to CVT

		// Prepare the SQL statement. Instead of executing it directly, sort
		// the results by the "minimum rowid" field. This makes it easier to
		// check that there are no rowid range overlaps between source tables
		// and that the UnionTab.aSrc[] array is always sorted by rowid.
		unionDequote(tls, zArg)
		pStmt = unionPreparePrintf(tls, bp+40 /* &rc */, pzErr, db,
			ts+9071 /* "SELECT * FROM (%..." */, crt.VaList(bp+16, zArg))

		// Allocate the UnionTab structure
		pTab = unionMalloc(tls, bp+40 /* &rc */, int64(unsafe.Sizeof(UnionTab{})))
		if pTab != 0 {
			if !(*(*int32)(unsafe.Pointer(bp + 40 /* rc */)) == 0) {
				crt.X__assert_fail(tls, ts+9101 /* "rc==0" */, ts+8232 /* "testdata/sqlite-..." */, uint32(919), uintptr(unsafe.Pointer(&__func__41)))
			}
			(*UnionTab)(unsafe.Pointer(pTab)).Fdb = db
			(*UnionTab)(unsafe.Pointer(pTab)).FbSwarm = bSwarm
			(*UnionTab)(unsafe.Pointer(pTab)).FnMaxOpen = 9
		}

		// Parse other CVT arguments, if any
		if bSwarm != 0 {
			unionConfigureVtab(tls, bp+40 /* &rc */, pTab, pStmt, (argc - 4), (argv + uintptr(4)*8), pzErr)
		}

		// Iterate through the rows returned by the SQL statement specified
		// as an argument to the CREATE VIRTUAL TABLE statement.
		for (*(*int32)(unsafe.Pointer(bp + 40 /* rc */)) == 0) && (100 == sqlite3.Xsqlite3_step(tls, pStmt)) {
			var zDb uintptr = sqlite3.Xsqlite3_column_text(tls, pStmt, 0)
			var zTab uintptr = sqlite3.Xsqlite3_column_text(tls, pStmt, 1)
			var iMin sqlite3_int64 = sqlite3.Xsqlite3_column_int64(tls, pStmt, 2)
			var iMax sqlite3_int64 = sqlite3.Xsqlite3_column_int64(tls, pStmt, 3)
			var pSrc uintptr

			// Grow the pTab->aSrc[] array if required.
			if nAlloc <= (*UnionTab)(unsafe.Pointer(pTab)).FnSrc {
				var nNew int32
				if nAlloc != 0 {
					nNew = (nAlloc * 2)
				} else {
					nNew = 8
				}
				var aNew uintptr = sqlite3.Xsqlite3_realloc64(tls,
					(*UnionTab)(unsafe.Pointer(pTab)).FaSrc, (uint64(uint64(nNew) * uint64(unsafe.Sizeof(UnionSrc{})))))
				if aNew == uintptr(0) {
					*(*int32)(unsafe.Pointer(bp + 40 /* rc */)) = 7
					break
				} else {
					crt.Xmemset(tls, (aNew + uintptr((*UnionTab)(unsafe.Pointer(pTab)).FnSrc)*72), 0, ((uint64(nNew - (*UnionTab)(unsafe.Pointer(pTab)).FnSrc)) * uint64(unsafe.Sizeof(UnionSrc{}))))
					(*UnionTab)(unsafe.Pointer(pTab)).FaSrc = aNew
					nAlloc = nNew
				}
			}

			// Check for problems with the specified range of rowids
			if (iMax < iMin) || (((*UnionTab)(unsafe.Pointer(pTab)).FnSrc > 0) && (iMin <= (*UnionSrc)(unsafe.Pointer((*UnionTab)(unsafe.Pointer(pTab)).FaSrc+uintptr(((*UnionTab)(unsafe.Pointer(pTab)).FnSrc-1))*72)).FiMax)) {
				*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+9107 /* "rowid range mism..." */, 0)
				*(*int32)(unsafe.Pointer(bp + 40 /* rc */)) = 1
			}

			if *(*int32)(unsafe.Pointer(bp + 40 /* rc */)) == 0 {
				pSrc = ((*UnionTab)(unsafe.Pointer(pTab)).FaSrc + uintptr(crt.PostIncInt32(&(*UnionTab)(unsafe.Pointer(pTab)).FnSrc, 1))*72)
				(*UnionSrc)(unsafe.Pointer(pSrc)).FzTab = unionStrdup(tls, bp+40 /* &rc */, zTab)
				(*UnionSrc)(unsafe.Pointer(pSrc)).FiMin = iMin
				(*UnionSrc)(unsafe.Pointer(pSrc)).FiMax = iMax
				if bSwarm != 0 {
					(*UnionSrc)(unsafe.Pointer(pSrc)).FzFile = unionStrdup(tls, bp+40 /* &rc */, zDb)
				} else {
					(*UnionSrc)(unsafe.Pointer(pSrc)).FzDb = unionStrdup(tls, bp+40 /* &rc */, zDb)
				}
				if (*UnionTab)(unsafe.Pointer(pTab)).FbHasContext != 0 {
					var zContext uintptr = sqlite3.Xsqlite3_column_text(tls, pStmt, 4)
					(*UnionSrc)(unsafe.Pointer(pSrc)).FzContext = unionStrdup(tls, bp+40 /* &rc */, zContext)
				}
			}
		}
		unionFinalize(tls, bp+40 /* &rc */, pStmt, pzErr)
		pStmt = uintptr(0)

		// It is an error if the SELECT statement returned zero rows. If only
		// because there is no way to determine the schema of the virtual
		// table in this case.
		if (*(*int32)(unsafe.Pointer(bp + 40 /* rc */)) == 0) && ((*UnionTab)(unsafe.Pointer(pTab)).FnSrc == 0) {
			*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+9134 /* "no source tables..." */, 0)
			*(*int32)(unsafe.Pointer(bp + 40 /* rc */)) = 1
		}

		// For unionvtab, verify that all source tables exist and have
		// compatible schemas. For swarmvtab, attach the first database and
		// check that the first table is a rowid table only.
		if *(*int32)(unsafe.Pointer(bp + 40 /* rc */)) == 0 {
			if bSwarm != 0 {
				*(*int32)(unsafe.Pointer(bp + 40 /* rc */)) = unionOpenDatabase(tls, pTab, 0, pzErr)
			} else {
				*(*int32)(unsafe.Pointer(bp + 40 /* rc */)) = unionSourceCheck(tls, pTab, pzErr)
			}
		}

		// Compose a CREATE TABLE statement and pass it to declare_vtab()
		if *(*int32)(unsafe.Pointer(bp + 40 /* rc */)) == 0 {
			var pSrc uintptr = ((*UnionTab)(unsafe.Pointer(pTab)).FaSrc + uintptr(0)*72)
			var tdb uintptr = func() uintptr {
				if (*UnionTab)(unsafe.Pointer(pTab)).FbSwarm != 0 {
					return (*UnionSrc)(unsafe.Pointer(pSrc)).Fdb
				}
				return (*UnionTab)(unsafe.Pointer(pTab)).Fdb
			}()
			pStmt = unionPreparePrintf(tls, bp+40 /* &rc */, pzErr, tdb,

				ts+9162, /* "SELECT 'CREATE T..." */
				crt.VaList(bp+24, (*UnionSrc)(unsafe.Pointer(pSrc)).FzTab, (*UnionSrc)(unsafe.Pointer(pSrc)).FzDb))
		}
		if (*(*int32)(unsafe.Pointer(bp + 40 /* rc */)) == 0) && (100 == sqlite3.Xsqlite3_step(tls, pStmt)) {
			var zDecl uintptr = sqlite3.Xsqlite3_column_text(tls, pStmt, 0)
			*(*int32)(unsafe.Pointer(bp + 40 /* rc */)) = sqlite3.Xsqlite3_declare_vtab(tls, db, zDecl)
			(*UnionTab)(unsafe.Pointer(pTab)).FiPK = sqlite3.Xsqlite3_column_int(tls, pStmt, 1)
		}

		unionFinalize(tls, bp+40 /* &rc */, pStmt, pzErr)
	}

	if *(*int32)(unsafe.Pointer(bp + 40 /* rc */)) != 0 {
		unionDisconnect(tls, pTab)
		pTab = uintptr(0)
	}

	*(*uintptr)(unsafe.Pointer(ppVtab)) = pTab
	return *(*int32)(unsafe.Pointer(bp + 40 /* rc */))
}

var __func__41 = *(*[13]int8)(unsafe.Pointer(ts + 9340 /* "unionConnect" */)) /* unionvtab.c:889:2 */

// xOpen
func unionOpen(tls *crt.TLS, p uintptr, ppCursor uintptr) int32 { /* unionvtab.c:1033:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var pCsr uintptr
	*(*int32)(unsafe.Pointer(bp /* rc */)) = 0
	_ = p // Suppress harmless warning
	pCsr = unionMalloc(tls, bp /* &rc */, int64(unsafe.Sizeof(UnionCsr{})))
	*(*uintptr)(unsafe.Pointer(ppCursor)) = (pCsr /* &.base */)
	return *(*int32)(unsafe.Pointer(bp /* rc */))
}

// xClose
func unionClose(tls *crt.TLS, cur uintptr) int32 { /* unionvtab.c:1045:12: */
	var pCsr uintptr = cur
	unionFinalizeCsrStmt(tls, pCsr)
	sqlite3.Xsqlite3_free(tls, pCsr)
	return 0
}

// This function does the work of the xNext() method. Except that, if it
// returns SQLITE_ROW, it should be called again within the same xNext()
// method call. See unionNext() for details.
func doUnionNext(tls *crt.TLS, pCsr uintptr) int32 { /* unionvtab.c:1057:12: */
	bp := tls.Alloc(28)
	defer tls.Free(28)

	*(*int32)(unsafe.Pointer(bp + 24 /* rc */)) = 0
	if !((*UnionCsr)(unsafe.Pointer(pCsr)).FpStmt != 0) {
		crt.X__assert_fail(tls, ts+9353 /* "pCsr->pStmt" */, ts+8232 /* "testdata/sqlite-..." */, uint32(1059), uintptr(unsafe.Pointer(&__func__42)))
	}
	if sqlite3.Xsqlite3_step(tls, (*UnionCsr)(unsafe.Pointer(pCsr)).FpStmt) != 100 {
		var pTab uintptr = (*UnionCsr)(unsafe.Pointer(pCsr)).Fbase.FpVtab
		*(*int32)(unsafe.Pointer(bp + 24 /* rc */)) = unionFinalizeCsrStmt(tls, pCsr)
		if (*(*int32)(unsafe.Pointer(bp + 24 /* rc */)) == 0) && ((*UnionTab)(unsafe.Pointer(pTab)).FbSwarm != 0) {
			(*UnionCsr)(unsafe.Pointer(pCsr)).FiTab++
			if (*UnionCsr)(unsafe.Pointer(pCsr)).FiTab < (*UnionTab)(unsafe.Pointer(pTab)).FnSrc {
				var pSrc uintptr = ((*UnionTab)(unsafe.Pointer(pTab)).FaSrc + uintptr((*UnionCsr)(unsafe.Pointer(pCsr)).FiTab)*72)
				if (*UnionCsr)(unsafe.Pointer(pCsr)).FiMaxRowid >= (*UnionSrc)(unsafe.Pointer(pSrc)).FiMin {
					// It is necessary to scan the next table.
					*(*int32)(unsafe.Pointer(bp + 24 /* rc */)) = unionOpenDatabase(tls, pTab, (*UnionCsr)(unsafe.Pointer(pCsr)).FiTab, (pTab /* &.base */ + 16 /* &.zErrMsg */))
					(*UnionCsr)(unsafe.Pointer(pCsr)).FpStmt = unionPreparePrintf(tls, bp+24 /* &rc */, (pTab /* &.base */ + 16 /* &.zErrMsg */), (*UnionSrc)(unsafe.Pointer(pSrc)).Fdb,
						ts+9365, /* "SELECT rowid, * ..." */
						crt.VaList(bp, (*UnionSrc)(unsafe.Pointer(pSrc)).FzTab,
							func() uintptr {
								if (*UnionSrc)(unsafe.Pointer(pSrc)).FiMax > (*UnionCsr)(unsafe.Pointer(pCsr)).FiMaxRowid {
									return ts + 9397 /* "WHERE _rowid_ <=" */
								}
								return ts + 9414 /* "-- " */
							}(),
							(*UnionCsr)(unsafe.Pointer(pCsr)).FiMaxRowid))
					if *(*int32)(unsafe.Pointer(bp + 24 /* rc */)) == 0 {
						if !((*UnionCsr)(unsafe.Pointer(pCsr)).FpStmt != 0) {
							crt.X__assert_fail(tls, ts+9353 /* "pCsr->pStmt" */, ts+8232 /* "testdata/sqlite-..." */, uint32(1077), uintptr(unsafe.Pointer(&__func__42)))
						}
						unionIncrRefcount(tls, pTab, (*UnionCsr)(unsafe.Pointer(pCsr)).FiTab)
						*(*int32)(unsafe.Pointer(bp + 24 /* rc */)) = 100
					}
				}
			}
		}
	}

	return *(*int32)(unsafe.Pointer(bp + 24 /* rc */))
}

var __func__42 = *(*[12]int8)(unsafe.Pointer(ts + 9418 /* "doUnionNext" */)) /* unionvtab.c:1057:39 */

// xNext
func unionNext(tls *crt.TLS, cur uintptr) int32 { /* unionvtab.c:1092:12: */
	var rc int32
	for ok := true; ok; ok = (rc == 100) {
		rc = doUnionNext(tls, cur)
	}
	return rc
}

// xColumn
func unionColumn(tls *crt.TLS, cur uintptr, ctx uintptr, i int32) int32 { /* unionvtab.c:1103:12: */
	var pCsr uintptr = cur
	sqlite3.Xsqlite3_result_value(tls, ctx, sqlite3.Xsqlite3_column_value(tls, (*UnionCsr)(unsafe.Pointer(pCsr)).FpStmt, (i+1)))
	return 0
}

// xRowid
func unionRowid(tls *crt.TLS, cur uintptr, pRowid uintptr) int32 { /* unionvtab.c:1116:12: */
	var pCsr uintptr = cur
	*(*sqlite_int64)(unsafe.Pointer(pRowid)) = sqlite3.Xsqlite3_column_int64(tls, (*UnionCsr)(unsafe.Pointer(pCsr)).FpStmt, 0)
	return 0
}

// xEof
func unionEof(tls *crt.TLS, cur uintptr) int32 { /* unionvtab.c:1125:12: */
	var pCsr uintptr = cur
	return (crt.Bool32((*UnionCsr)(unsafe.Pointer(pCsr)).FpStmt == uintptr(0)))
}

// xFilter
func unionFilter(tls *crt.TLS, pVtabCursor uintptr, idxNum int32, idxStr uintptr, argc int32, argv uintptr) int32 { /* unionvtab.c:1133:12: */
	bp := tls.Alloc(108)
	defer tls.Free(108)

	var pTab uintptr = (*sqlite3_vtab_cursor)(unsafe.Pointer(pVtabCursor)).FpVtab
	var pCsr uintptr = pVtabCursor
	*(*int32)(unsafe.Pointer(bp + 104 /* rc */)) = 0
	var i int32
	var zSql uintptr = uintptr(0)
	var bZero int32 = 0

	var iMin sqlite3_int64 = ((int64(-1)) - (int64(0xffffffff) | (sqlite3_int64((int64(0x7fffffff))) << 32)))
	var iMax sqlite3_int64 = (int64(0xffffffff) | (sqlite3_int64((int64(0x7fffffff))) << 32))

	if !(((((((idxNum == 0) || (idxNum == 2)) || (idxNum == 8)) || (idxNum == 32)) || (idxNum == 16)) || (idxNum == 4)) || (idxNum == (32 | 8))) {
		crt.X__assert_fail(tls, ts+9430 /* "idxNum==0 || idx..." */, ts+8232 /* "testdata/sqlite-..." */, uint32(1148), uintptr(unsafe.Pointer(&__func__43)))
	}

	_ = idxStr // Suppress harmless warning

	if idxNum == 2 {
		if !(argc == 1) {
			crt.X__assert_fail(tls, ts+8151 /* "argc==1" */, ts+8232 /* "testdata/sqlite-..." */, uint32(1160), uintptr(unsafe.Pointer(&__func__43)))
		}
		iMin = crt.AssignInt64(&iMax, sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8))))
	} else {

		if (idxNum & (8 | 16)) != 0 {
			if !(argc >= 1) {
				crt.X__assert_fail(tls, ts+9525 /* "argc>=1" */, ts+8232 /* "testdata/sqlite-..." */, uint32(1165), uintptr(unsafe.Pointer(&__func__43)))
			}
			iMax = sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)))
			if (idxNum & 16) != 0 {
				if iMax == ((int64(-1)) - (int64(0xffffffff) | (sqlite3_int64((int64(0x7fffffff))) << 32))) {
					bZero = 1
				} else {
					iMax--
				}
			}
		}

		if (idxNum & (32 | 4)) != 0 {
			if !(argc >= 1) {
				crt.X__assert_fail(tls, ts+9525 /* "argc>=1" */, ts+8232 /* "testdata/sqlite-..." */, uint32(1177), uintptr(unsafe.Pointer(&__func__43)))
			}
			iMin = sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr((argc-1))*8)))
			if (idxNum & 4) != 0 {
				if iMin == (int64(0xffffffff) | (sqlite3_int64((int64(0x7fffffff))) << 32)) {
					bZero = 1
				} else {
					iMin++
				}
			}
		}
	}

	unionFinalizeCsrStmt(tls, pCsr)
	if bZero != 0 {
		return 0
	}

	for i = 0; i < (*UnionTab)(unsafe.Pointer(pTab)).FnSrc; i++ {
		var pSrc uintptr = ((*UnionTab)(unsafe.Pointer(pTab)).FaSrc + uintptr(i)*72)
		if (iMin > (*UnionSrc)(unsafe.Pointer(pSrc)).FiMax) || (iMax < (*UnionSrc)(unsafe.Pointer(pSrc)).FiMin) {
			continue
		}

		zSql = sqlite3.Xsqlite3_mprintf(tls, ts+9533 /* "%z%sSELECT rowid..." */, crt.VaList(bp, zSql, func() uintptr {
			if zSql != 0 {
				return ts + 9567 /* " UNION ALL " */
			}
			return ts + 792 /* "" */
		}(), func() uintptr {
			if (*UnionSrc)(unsafe.Pointer(pSrc)).FzDb != 0 {
				return ts + 5272 /* "'" */
			}
			return ts + 792 /* "" */
		}(), func() uintptr {
			if (*UnionSrc)(unsafe.Pointer(pSrc)).FzDb != 0 {
				return (*UnionSrc)(unsafe.Pointer(pSrc)).FzDb
			}
			return ts + 792 /* "" */
		}(), func() uintptr {
			if (*UnionSrc)(unsafe.Pointer(pSrc)).FzDb != 0 {
				return ts + 5274 /* "'." */
			}
			return ts + 792 /* "" */
		}(), (*UnionSrc)(unsafe.Pointer(pSrc)).FzTab))
		if zSql == uintptr(0) {
			*(*int32)(unsafe.Pointer(bp + 104 /* rc */)) = 7
			break
		}

		if iMin == iMax {
			zSql = sqlite3.Xsqlite3_mprintf(tls, ts+9579 /* "%z WHERE rowid=%..." */, crt.VaList(bp+48, zSql, iMin))
		} else {
			var zWhere uintptr = ts + 9599 /* "WHERE" */
			if (iMin != ((int64(-1)) - (int64(0xffffffff) | (sqlite3_int64((int64(0x7fffffff))) << 32)))) && (iMin > (*UnionSrc)(unsafe.Pointer(pSrc)).FiMin) {
				zSql = sqlite3.Xsqlite3_mprintf(tls, ts+9605 /* "%z WHERE rowid>=..." */, crt.VaList(bp+64, zSql, iMin))
				zWhere = ts + 9626 /* "AND" */
			}
			if (iMax != (int64(0xffffffff) | (sqlite3_int64((int64(0x7fffffff))) << 32))) && (iMax < (*UnionSrc)(unsafe.Pointer(pSrc)).FiMax) {
				zSql = sqlite3.Xsqlite3_mprintf(tls, ts+9630 /* "%z %s rowid<=%ll..." */, crt.VaList(bp+80, zSql, zWhere, iMax))
			}
		}

		if (*UnionTab)(unsafe.Pointer(pTab)).FbSwarm != 0 {
			(*UnionCsr)(unsafe.Pointer(pCsr)).FiTab = i
			(*UnionCsr)(unsafe.Pointer(pCsr)).FiMaxRowid = iMax
			*(*int32)(unsafe.Pointer(bp + 104 /* rc */)) = unionOpenDatabase(tls, pTab, i, (pTab /* &.base */ + 16 /* &.zErrMsg */))
			break
		}
	}

	if zSql == uintptr(0) {
		return *(*int32)(unsafe.Pointer(bp + 104 /* rc */))
	} else {
		var db uintptr = func() uintptr {
			if (*UnionTab)(unsafe.Pointer(pTab)).FbSwarm != 0 {
				return (*UnionSrc)(unsafe.Pointer(((*UnionTab)(unsafe.Pointer(pTab)).FaSrc + uintptr((*UnionCsr)(unsafe.Pointer(pCsr)).FiTab)*72))).Fdb
			}
			return (*UnionTab)(unsafe.Pointer(pTab)).Fdb
		}()
		(*UnionCsr)(unsafe.Pointer(pCsr)).FpStmt = unionPrepare(tls, bp+104 /* &rc */, db, zSql, (pTab /* &.base */ + 16 /* &.zErrMsg */))
		if (*UnionCsr)(unsafe.Pointer(pCsr)).FpStmt != 0 {
			unionIncrRefcount(tls, pTab, (*UnionCsr)(unsafe.Pointer(pCsr)).FiTab)
		}
		sqlite3.Xsqlite3_free(tls, zSql)
	}
	if *(*int32)(unsafe.Pointer(bp + 104 /* rc */)) != 0 {
		return *(*int32)(unsafe.Pointer(bp + 104 /* rc */))
	}
	return unionNext(tls, pVtabCursor)
}

var __func__43 = *(*[12]int8)(unsafe.Pointer(ts + 9648 /* "unionFilter" */)) /* unionvtab.c:1137:2 */

// xBestIndex.
//
// This implementation searches for constraints on the rowid field. EQ,
// LE, LT, GE and GT are handled.
//
// If there is an EQ comparison, then idxNum is set to INDEX_CONSTRAINT_EQ.
// In this case the only argument passed to xFilter is the rhs of the ==
// operator.
//
// Otherwise, if an LE or LT constraint is found, then the INDEX_CONSTRAINT_LE
// or INDEX_CONSTRAINT_LT (but not both) bit is set in idxNum. The first
// argument to xFilter is the rhs of the <= or < operator.  Similarly, if
// an GE or GT constraint is found, then the INDEX_CONSTRAINT_GE or
// INDEX_CONSTRAINT_GT bit is set in idxNum. The rhs of the >= or > operator
// is passed as either the first or second argument to xFilter, depending
// on whether or not there is also a LT|LE constraint.
func unionBestIndex(tls *crt.TLS, tab uintptr, pIdxInfo uintptr) int32 { /* unionvtab.c:1266:12: */
	var pTab uintptr = tab
	var iEq int32 = -1
	var iLt int32 = -1
	var iGt int32 = -1
	var i int32

	for i = 0; i < (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnConstraint; i++ {
		var p uintptr = ((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraint + uintptr(i)*12)
		if ((*sqlite3_index_constraint)(unsafe.Pointer(p)).Fusable != 0) && (((*sqlite3_index_constraint)(unsafe.Pointer(p)).FiColumn < 0) || ((*sqlite3_index_constraint)(unsafe.Pointer(p)).FiColumn == (*UnionTab)(unsafe.Pointer(pTab)).FiPK)) {
			switch int32((*sqlite3_index_constraint)(unsafe.Pointer(p)).Fop) {
			case 2:
				iEq = i
				break
				fallthrough
			case 8:
				fallthrough
			case 16:
				iLt = i
				break
				fallthrough
			case 32:
				fallthrough
			case 4:
				iGt = i
				break
			}
		}
	}

	if iEq >= 0 {
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedRows = int64(1)
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxFlags = 1
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = 3.0
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxNum = 2
		(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(iEq)*8)).FargvIndex = 1
		(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(iEq)*8)).Fomit = uint8(1)
	} else {
		var iCons int32 = 1
		var idxNum int32 = 0
		var nRow sqlite3_int64 = int64(1000000)
		if iLt >= 0 {
			nRow = (nRow / int64(2))
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(iLt)*8)).FargvIndex = crt.PostIncInt32(&iCons, 1)
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(iLt)*8)).Fomit = uint8(1)
			idxNum = idxNum | (int32((*sqlite3_index_constraint)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraint + uintptr(iLt)*12)).Fop))
		}
		if iGt >= 0 {
			nRow = (nRow / int64(2))
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(iGt)*8)).FargvIndex = crt.PostIncInt32(&iCons, 1)
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(iGt)*8)).Fomit = uint8(1)
			idxNum = idxNum | (int32((*sqlite3_index_constraint)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraint + uintptr(iGt)*12)).Fop))
		}
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedRows = nRow
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = (3.0 * float64(nRow))
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxNum = idxNum
	}

	return 0
}

// Register the unionvtab virtual table module with database handle db.
func createUnionVtab(tls *crt.TLS, db uintptr) int32 { /* unionvtab.c:1329:12: */
	var rc int32

	rc = sqlite3.Xsqlite3_create_module(tls, db, ts+8982 /* "unionvtab" */, uintptr(unsafe.Pointer(&unionModule)), uintptr(0))
	if rc == 0 {
		rc = sqlite3.Xsqlite3_create_module(tls, db, ts+8972 /* "swarmvtab" */, uintptr(unsafe.Pointer(&unionModule)), db)
	}
	return rc
}

var unionModule = sqlite3_module{FiVersion: 0, FxCreate: // iVersion
0, FxConnect:                                            0, FxBestIndex: 0, FxDisconnect: // xBestIndex - query planner
0, FxDestroy:                                            0, FxOpen: 0, FxClose:           // xOpen - open a cursor
0, FxFilter:// xClose - close a cursor
0, FxNext:// xFilter - configure scan constraints
0, FxEof:// xNext - advance a cursor
0, FxColumn:// xEof - check for end of scan
0, FxRowid:// xColumn - read data
0, FxUpdate:// xRowid - read data
uintptr(0), FxBegin:// xUpdate
uintptr(0), FxSync:// xBegin
uintptr(0), FxCommit:// xSync
uintptr(0), FxRollback:// xCommit
uintptr(0), FxFindFunction:// xRollback
uintptr(0), FxRename:// xFindMethod
uintptr(0), FxSavepoint:// xRename
uintptr(0), FxRelease:// xSavepoint
uintptr(0), FxRollbackTo:// xRelease
uintptr(0), FxShadowName:// xRollbackTo
uintptr(0), // xShadowName
} /* unionvtab.c:1330:25 */

func sqlite3_unionvtab_init(tls *crt.TLS, db uintptr, pzErrMsg uintptr, pApi uintptr) int32 { /* unionvtab.c:1370:5: */
	var rc int32 = 0
	_ = pApi

	_ = pzErrMsg // Suppress harmless warning
	rc = createUnionVtab(tls, db)
	return rc
}

// A wholenumber cursor object
type wholenumber_cursor1 = struct {
	Fbase    sqlite3_vtab_cursor
	FiValue  sqlite3_int64
	FmxValue sqlite3_int64
}

// A wholenumber cursor object
type wholenumber_cursor = wholenumber_cursor1 /* wholenumber.c:34:35 */

// Methods for the wholenumber module
func wholenumberConnect(tls *crt.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVtab uintptr, pzErr uintptr) int32 { /* wholenumber.c:42:12: */
	var pNew uintptr
	pNew = crt.AssignPtrUintptr(ppVtab, sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(sqlite3_vtab{}))))
	if pNew == uintptr(0) {
		return 7
	}
	sqlite3.Xsqlite3_declare_vtab(tls, db, ts+9660 /* "CREATE TABLE x(v..." */)
	sqlite3.Xsqlite3_vtab_config(tls, db, 2, 0)
	crt.Xmemset(tls, pNew, 0, uint64(unsafe.Sizeof(sqlite3_vtab{})))
	return 0
}

// Note that for this virtual table, the xCreate and xConnect
// methods are identical.

func wholenumberDisconnect(tls *crt.TLS, pVtab uintptr) int32 { /* wholenumber.c:60:12: */
	sqlite3.Xsqlite3_free(tls, pVtab)
	return 0
}

// The xDisconnect and xDestroy methods are also the same

// Open a new wholenumber cursor.
func wholenumberOpen(tls *crt.TLS, p uintptr, ppCursor uintptr) int32 { /* wholenumber.c:70:12: */
	var pCur uintptr
	pCur = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(wholenumber_cursor{})))
	if pCur == uintptr(0) {
		return 7
	}
	crt.Xmemset(tls, pCur, 0, uint64(unsafe.Sizeof(wholenumber_cursor{})))
	*(*uintptr)(unsafe.Pointer(ppCursor)) = (pCur /* &.base */)
	return 0
}

// Close a wholenumber cursor.
func wholenumberClose(tls *crt.TLS, cur uintptr) int32 { /* wholenumber.c:82:12: */
	sqlite3.Xsqlite3_free(tls, cur)
	return 0
}

// Advance a cursor to its next row of output
func wholenumberNext(tls *crt.TLS, cur uintptr) int32 { /* wholenumber.c:91:12: */
	var pCur uintptr = cur
	(*wholenumber_cursor)(unsafe.Pointer(pCur)).FiValue++
	return 0
}

// Return the value associated with a wholenumber.
func wholenumberColumn(tls *crt.TLS, cur uintptr, ctx uintptr, i int32) int32 { /* wholenumber.c:100:12: */
	var pCur uintptr = cur
	sqlite3.Xsqlite3_result_int64(tls, ctx, (*wholenumber_cursor)(unsafe.Pointer(pCur)).FiValue)
	return 0
}

// The rowid.
func wholenumberRowid(tls *crt.TLS, cur uintptr, pRowid uintptr) int32 { /* wholenumber.c:113:12: */
	var pCur uintptr = cur
	*(*sqlite_int64)(unsafe.Pointer(pRowid)) = (*wholenumber_cursor)(unsafe.Pointer(pCur)).FiValue
	return 0
}

// When the wholenumber_cursor.rLimit value is 0 or less, that is a signal
// that the cursor has nothing more to output.
func wholenumberEof(tls *crt.TLS, cur uintptr) int32 { /* wholenumber.c:123:12: */
	var pCur uintptr = cur
	return (crt.Bool32(((*wholenumber_cursor)(unsafe.Pointer(pCur)).FiValue > (*wholenumber_cursor)(unsafe.Pointer(pCur)).FmxValue) || ((*wholenumber_cursor)(unsafe.Pointer(pCur)).FiValue == int64(0))))
}

// Called to "rewind" a cursor back to the beginning so that
// it starts its output over again.  Always called at least once
// prior to any wholenumberColumn, wholenumberRowid, or wholenumberEof call.
//
//    idxNum   Constraints
//    ------   ---------------------
//      0      (none)
//      1      value > $argv0
//      2      value >= $argv0
//      4      value < $argv0
//      8      value <= $argv0
//
//      5      value > $argv0 AND value < $argv1
//      6      value >= $argv0 AND value < $argv1
//      9      value > $argv0 AND value <= $argv1
//     10      value >= $argv0 AND value <= $argv1
func wholenumberFilter(tls *crt.TLS, pVtabCursor uintptr, idxNum int32, idxStr uintptr, argc int32, argv uintptr) int32 { /* wholenumber.c:146:12: */
	var pCur uintptr = pVtabCursor
	var v sqlite3_int64
	var i int32 = 0
	(*wholenumber_cursor)(unsafe.Pointer(pCur)).FiValue = int64(1)
	(*wholenumber_cursor)(unsafe.Pointer(pCur)).FmxValue = int64(0xffffffff) // 4294967295
	if (idxNum & 3) != 0 {
		v = (sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8))) + (sqlite3_int64(idxNum & 1)))
		if (v > (*wholenumber_cursor)(unsafe.Pointer(pCur)).FiValue) && (v <= (*wholenumber_cursor)(unsafe.Pointer(pCur)).FmxValue) {
			(*wholenumber_cursor)(unsafe.Pointer(pCur)).FiValue = v
		}
		i++
	}
	if (idxNum & 12) != 0 {
		v = (sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8))) - (sqlite3_int64((idxNum >> 2) & 1)))
		if (v >= (*wholenumber_cursor)(unsafe.Pointer(pCur)).FiValue) && (v < (*wholenumber_cursor)(unsafe.Pointer(pCur)).FmxValue) {
			(*wholenumber_cursor)(unsafe.Pointer(pCur)).FmxValue = v
		}
	}
	return 0
}

// Search for terms of these forms:
//
//  (1)  value > $value
//  (2)  value >= $value
//  (4)  value < $value
//  (8)  value <= $value
//
// idxNum is an ORed combination of 1 or 2 with 4 or 8.
func wholenumberBestIndex(tls *crt.TLS, tab uintptr, pIdxInfo uintptr) int32 { /* wholenumber.c:178:12: */
	var i int32
	var idxNum int32 = 0
	var argvIdx int32 = 1
	var ltIdx int32 = -1
	var gtIdx int32 = -1
	var pConstraint uintptr
	pConstraint = (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraint
	i = 0
__1:
	if !(i < (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnConstraint) {
		goto __3
	}
	{
		if int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fusable) == 0 {
			goto __2
		}
		if ((idxNum & 3) == 0) && (int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == 4) {
			idxNum = idxNum | (1)
			ltIdx = i
		}
		if ((idxNum & 3) == 0) && (int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == 32) {
			idxNum = idxNum | (2)
			ltIdx = i
		}
		if ((idxNum & 12) == 0) && (int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == 16) {
			idxNum = idxNum | (4)
			gtIdx = i
		}
		if ((idxNum & 12) == 0) && (int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == 8) {
			idxNum = idxNum | (8)
			gtIdx = i
		}
	}
	goto __2
__2:
	i++
	pConstraint += 12
	goto __1
	goto __3
__3:
	;
	(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxNum = idxNum
	if ltIdx >= 0 {
		(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(ltIdx)*8)).FargvIndex = crt.PostIncInt32(&argvIdx, 1)
		(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(ltIdx)*8)).Fomit = uint8(1)
	}
	if gtIdx >= 0 {
		(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(gtIdx)*8)).FargvIndex = argvIdx
		(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(gtIdx)*8)).Fomit = uint8(1)
	}
	if ((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnOrderBy == 1) &&
		(int32((*sqlite3_index_orderby)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaOrderBy+uintptr(0)*8)).Fdesc) == 0) {
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).ForderByConsumed = 1
	}
	if (idxNum & 12) == 0 {
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = float64(100000000)
	} else if (idxNum & 3) == 0 {
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = float64(5)
	} else {
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = float64(1)
	}
	return 0
}

// A virtual table module that provides read-only access to a
// Tcl global variable namespace.
var wholenumberModule = sqlite3_module{FiVersion: 0, FxCreate: // iVersion
0, FxConnect:                                                  0, FxBestIndex: 0, FxDisconnect: 0, FxDestroy: 0, FxOpen: 0, FxClose: // xOpen - open a cursor
0, FxFilter:// xClose - close a cursor
0, FxNext:// xFilter - configure scan constraints
0, FxEof:// xNext - advance a cursor
0, FxColumn:// xEof - check for end of scan
0, FxRowid:// xColumn - read data
0, FxUpdate:// xRowid - read data
uintptr(0), FxBegin:// xUpdate
uintptr(0), FxSync:// xBegin
uintptr(0), FxCommit:// xSync
uintptr(0), FxRollback:// xCommit
uintptr(0), FxFindFunction:// xRollback
uintptr(0), FxRename:// xFindMethod
uintptr(0), // xRename
} /* wholenumber.c:236:23 */

func sqlite3_wholenumber_init(tls *crt.TLS, db uintptr, pzErrMsg uintptr, pApi uintptr) int32 { /* wholenumber.c:264:5: */
	var rc int32 = 0
	_ = pApi

	rc = sqlite3.Xsqlite3_create_module(tls, db, ts+9682 /* "wholenumber" */, uintptr(unsafe.Pointer(&wholenumberModule)), uintptr(0))
	return rc
}

//
// END OF REGISTRATION API
//

//******* End of fts5.h ********

// 2014 August 30
//
// The author disclaims copyright to this source code.  In place of
// a legal notice, here is a blessing:
//
//    May you do good and not evil.
//    May you find forgiveness for yourself and forgive others.
//    May you share freely, never taking more than you give.
//
//
//
// This file contains the public interface for the RBU extension.

// SUMMARY
//
// Writing a transaction containing a large number of operations on
// b-tree indexes that are collectively larger than the available cache
// memory can be very inefficient.
//
// The problem is that in order to update a b-tree, the leaf page (at least)
// containing the entry being inserted or deleted must be modified. If the
// working set of leaves is larger than the available cache memory, then a
// single leaf that is modified more than once as part of the transaction
// may be loaded from or written to the persistent media multiple times.
// Additionally, because the index updates are likely to be applied in
// random order, access to pages within the database is also likely to be in
// random order, which is itself quite inefficient.
//
// One way to improve the situation is to sort the operations on each index
// by index key before applying them to the b-tree. This leads to an IO
// pattern that resembles a single linear scan through the index b-tree,
// and all but guarantees each modified leaf page is loaded and stored
// exactly once. SQLite uses this trick to improve the performance of
// CREATE INDEX commands. This extension allows it to be used to improve
// the performance of large transactions on existing databases.
//
// Additionally, this extension allows the work involved in writing the
// large transaction to be broken down into sub-transactions performed
// sequentially by separate processes. This is useful if the system cannot
// guarantee that a single update process will run for long enough to apply
// the entire update, for example because the update is being applied on a
// mobile device that is frequently rebooted. Even after the writer process
// has committed one or more sub-transactions, other database clients continue
// to read from the original database snapshot. In other words, partially
// applied transactions are not visible to other clients.
//
// "RBU" stands for "Resumable Bulk Update". As in a large database update
// transmitted via a wireless network to a mobile device. A transaction
// applied using this extension is hence refered to as an "RBU update".
//
//
// LIMITATIONS
//
// An "RBU update" transaction is subject to the following limitations:
//
//   * The transaction must consist of INSERT, UPDATE and DELETE operations
//     only.
//
//   * INSERT statements may not use any default values.
//
//   * UPDATE and DELETE statements must identify their target rows by
//     non-NULL PRIMARY KEY values. Rows with NULL values stored in PRIMARY
//     KEY fields may not be updated or deleted. If the table being written
//     has no PRIMARY KEY, affected rows must be identified by rowid.
//
//   * UPDATE statements may not modify PRIMARY KEY columns.
//
//   * No triggers will be fired.
//
//   * No foreign key violations are detected or reported.
//
//   * CHECK constraints are not enforced.
//
//   * No constraint handling mode except for "OR ROLLBACK" is supported.
//
//
// PREPARATION
//
// An "RBU update" is stored as a separate SQLite database. A database
// containing an RBU update is an "RBU database". For each table in the
// target database to be updated, the RBU database should contain a table
// named "data_<target name>" containing the same set of columns as the
// target table, and one more - "rbu_control". The data_% table should
// have no PRIMARY KEY or UNIQUE constraints, but each column should have
// the same type as the corresponding column in the target database.
// The "rbu_control" column should have no type at all. For example, if
// the target database contains:
//
//   CREATE TABLE t1(a INTEGER PRIMARY KEY, b TEXT, c UNIQUE);
//
// Then the RBU database should contain:
//
//   CREATE TABLE data_t1(a INTEGER, b TEXT, c, rbu_control);
//
// The order of the columns in the data_% table does not matter.
//
// Instead of a regular table, the RBU database may also contain virtual
// tables or view named using the data_<target> naming scheme.
//
// Instead of the plain data_<target> naming scheme, RBU database tables
// may also be named data<integer>_<target>, where <integer> is any sequence
// of zero or more numeric characters (0-9). This can be significant because
// tables within the RBU database are always processed in order sorted by
// name. By judicious selection of the <integer> portion of the names
// of the RBU tables the user can therefore control the order in which they
// are processed. This can be useful, for example, to ensure that "external
// content" FTS4 tables are updated before their underlying content tables.
//
// If the target database table is a virtual table or a table that has no
// PRIMARY KEY declaration, the data_% table must also contain a column
// named "rbu_rowid". This column is mapped to the tables implicit primary
// key column - "rowid". Virtual tables for which the "rowid" column does
// not function like a primary key value cannot be updated using RBU. For
// example, if the target db contains either of the following:
//
//   CREATE VIRTUAL TABLE x1 USING fts3(a, b);
//   CREATE TABLE x1(a, b)
//
// then the RBU database should contain:
//
//   CREATE TABLE data_x1(a, b, rbu_rowid, rbu_control);
//
// All non-hidden columns (i.e. all columns matched by "SELECT *") of the
// target table must be present in the input table. For virtual tables,
// hidden columns are optional - they are updated by RBU if present in
// the input table, or not otherwise. For example, to write to an fts4
// table with a hidden languageid column such as:
//
//   CREATE VIRTUAL TABLE ft1 USING fts4(a, b, languageid='langid');
//
// Either of the following input table schemas may be used:
//
//   CREATE TABLE data_ft1(a, b, langid, rbu_rowid, rbu_control);
//   CREATE TABLE data_ft1(a, b, rbu_rowid, rbu_control);
//
// For each row to INSERT into the target database as part of the RBU
// update, the corresponding data_% table should contain a single record
// with the "rbu_control" column set to contain integer value 0. The
// other columns should be set to the values that make up the new record
// to insert.
//
// If the target database table has an INTEGER PRIMARY KEY, it is not
// possible to insert a NULL value into the IPK column. Attempting to
// do so results in an SQLITE_MISMATCH error.
//
// For each row to DELETE from the target database as part of the RBU
// update, the corresponding data_% table should contain a single record
// with the "rbu_control" column set to contain integer value 1. The
// real primary key values of the row to delete should be stored in the
// corresponding columns of the data_% table. The values stored in the
// other columns are not used.
//
// For each row to UPDATE from the target database as part of the RBU
// update, the corresponding data_% table should contain a single record
// with the "rbu_control" column set to contain a value of type text.
// The real primary key values identifying the row to update should be
// stored in the corresponding columns of the data_% table row, as should
// the new values of all columns being update. The text value in the
// "rbu_control" column must contain the same number of characters as
// there are columns in the target database table, and must consist entirely
// of 'x' and '.' characters (or in some special cases 'd' - see below). For
// each column that is being updated, the corresponding character is set to
// 'x'. For those that remain as they are, the corresponding character of the
// rbu_control value should be set to '.'. For example, given the tables
// above, the update statement:
//
//   UPDATE t1 SET c = 'usa' WHERE a = 4;
//
// is represented by the data_t1 row created by:
//
//   INSERT INTO data_t1(a, b, c, rbu_control) VALUES(4, NULL, 'usa', '..x');
//
// Instead of an 'x' character, characters of the rbu_control value specified
// for UPDATEs may also be set to 'd'. In this case, instead of updating the
// target table with the value stored in the corresponding data_% column, the
// user-defined SQL function "rbu_delta()" is invoked and the result stored in
// the target table column. rbu_delta() is invoked with two arguments - the
// original value currently stored in the target table column and the
// value specified in the data_xxx table.
//
// For example, this row:
//
//   INSERT INTO data_t1(a, b, c, rbu_control) VALUES(4, NULL, 'usa', '..d');
//
// is similar to an UPDATE statement such as:
//
//   UPDATE t1 SET c = rbu_delta(c, 'usa') WHERE a = 4;
//
// Finally, if an 'f' character appears in place of a 'd' or 's' in an
// ota_control string, the contents of the data_xxx table column is assumed
// to be a "fossil delta" - a patch to be applied to a blob value in the
// format used by the fossil source-code management system. In this case
// the existing value within the target database table must be of type BLOB.
// It is replaced by the result of applying the specified fossil delta to
// itself.
//
// If the target database table is a virtual table or a table with no PRIMARY
// KEY, the rbu_control value should not include a character corresponding
// to the rbu_rowid value. For example, this:
//
//   INSERT INTO data_ft1(a, b, rbu_rowid, rbu_control)
//       VALUES(NULL, 'usa', 12, '.x');
//
// causes a result similar to:
//
//   UPDATE ft1 SET b = 'usa' WHERE rowid = 12;
//
// The data_xxx tables themselves should have no PRIMARY KEY declarations.
// However, RBU is more efficient if reading the rows in from each data_xxx
// table in "rowid" order is roughly the same as reading them sorted by
// the PRIMARY KEY of the corresponding target database table. In other
// words, rows should be sorted using the destination table PRIMARY KEY
// fields before they are inserted into the data_xxx tables.
//
// USAGE
//
// The API declared below allows an application to apply an RBU update
// stored on disk to an existing target database. Essentially, the
// application:
//
//     1) Opens an RBU handle using the sqlite3rbu_open() function.
//
//     2) Registers any required virtual table modules with the database
//        handle returned by sqlite3rbu_db(). Also, if required, register
//        the rbu_delta() implementation.
//
//     3) Calls the sqlite3rbu_step() function one or more times on
//        the new handle. Each call to sqlite3rbu_step() performs a single
//        b-tree operation, so thousands of calls may be required to apply
//        a complete update.
//
//     4) Calls sqlite3rbu_close() to close the RBU update handle. If
//        sqlite3rbu_step() has been called enough times to completely
//        apply the update to the target database, then the RBU database
//        is marked as fully applied. Otherwise, the state of the RBU
//        update application is saved in the RBU database for later
//        resumption.
//
// See comments below for more detail on APIs.
//
// If an update is only partially applied to the target database by the
// time sqlite3rbu_close() is called, various state information is saved
// within the RBU database. This allows subsequent processes to automatically
// resume the RBU update from where it left off.
//
// To remove all RBU extension state information, returning an RBU database
// to its original contents, it is sufficient to drop all tables that begin
// with the prefix "rbu_"
//
// DATABASE LOCKING
//
// An RBU update may not be applied to a database in WAL mode. Attempting
// to do so is an error (SQLITE_ERROR).
//
// While an RBU handle is open, a SHARED lock may be held on the target
// database file. This means it is possible for other clients to read the
// database, but not to write it.
//
// If an RBU update is started and then suspended before it is completed,
// then an external client writes to the database, then attempting to resume
// the suspended RBU update is also an error (SQLITE_BUSY).

// 2001-09-15
//
// The author disclaims copyright to this source code.  In place of
// a legal notice, here is a blessing:
//
//    May you do good and not evil.
//    May you find forgiveness for yourself and forgive others.
//    May you share freely, never taking more than you give.
//
//
// This header file defines the interface that the SQLite library
// presents to client programs.  If a C-function, structure, datatype,
// or constant definition does not appear in this file, then it is
// not a published API of SQLite, is subject to change without
// notice, and should not be referenced by programs that use SQLite.
//
// Some of the definitions that are in this file are marked as
// "experimental".  Experimental interfaces are normally new
// features recently added to SQLite.  We do not anticipate changes
// to experimental interfaces but reserve the right to make minor changes
// if experience from use "in the wild" suggest such changes are prudent.
//
// The official C-language API documentation for SQLite is derived
// from comments in this file.  This file is the authoritative source
// on how SQLite interfaces are supposed to operate.
//
// The name of this file under configuration management is "sqlite.h.in".
// The makefile makes some minor changes to this file (such as inserting
// the version number) and changes its name to "sqlite3.h" as
// part of the build process.

//******* Begin file sqlite3rtree.h ********
// 2010 August 30
//
// The author disclaims copyright to this source code.  In place of
// a legal notice, here is a blessing:
//
//    May you do good and not evil.
//    May you find forgiveness for yourself and forgive others.
//    May you share freely, never taking more than you give.
//
//

//******* End of sqlite3rtree.h ********
//******* Begin file sqlite3session.h ********

//******* End of sqlite3session.h ********
//******* Begin file fts5.h ********
// 2014 May 31
//
// The author disclaims copyright to this source code.  In place of
// a legal notice, here is a blessing:
//
//    May you do good and not evil.
//    May you find forgiveness for yourself and forgive others.
//    May you share freely, never taking more than you give.
//
//
//
// Interfaces to extend FTS5. Using the interfaces defined in this file,
// FTS5 may be extended with:
//
//     * custom tokenizers, and
//     * custom auxiliary functions.

//******* End of fts5.h ********

type sqlite3rbu1 = struct {
	FeStage         int32
	FdbMain         uintptr
	FdbRbu          uintptr
	FzTarget        uintptr
	FzRbu           uintptr
	FzState         uintptr
	FzStateDb       [5]int8
	Frc             int32
	FzErrmsg        uintptr
	FnStep          int32
	FnProgress      int32
	Fobjiter        RbuObjIter
	FzVfsName       uintptr
	FpTargetFd      uintptr
	FnPagePerSector int32
	FiOalSz         i64
	FnPhaseOneStep  i64
	FiMaxFrame      u32
	FmLock          u32
	FnFrame         int32
	FnFrameAlloc    int32
	FaFrame         uintptr
	Fpgsz           int32
	FaBuf           uintptr
	FiWalCksum      i64
	FszTemp         i64
	FszTempLimit    i64
	FnRbu           int32
	FpRbuFd         uintptr
}

//
// END OF REGISTRATION API
//

//******* End of fts5.h ********

// 2014 August 30
//
// The author disclaims copyright to this source code.  In place of
// a legal notice, here is a blessing:
//
//    May you do good and not evil.
//    May you find forgiveness for yourself and forgive others.
//    May you share freely, never taking more than you give.
//
//
//
// This file contains the public interface for the RBU extension.

// SUMMARY
//
// Writing a transaction containing a large number of operations on
// b-tree indexes that are collectively larger than the available cache
// memory can be very inefficient.
//
// The problem is that in order to update a b-tree, the leaf page (at least)
// containing the entry being inserted or deleted must be modified. If the
// working set of leaves is larger than the available cache memory, then a
// single leaf that is modified more than once as part of the transaction
// may be loaded from or written to the persistent media multiple times.
// Additionally, because the index updates are likely to be applied in
// random order, access to pages within the database is also likely to be in
// random order, which is itself quite inefficient.
//
// One way to improve the situation is to sort the operations on each index
// by index key before applying them to the b-tree. This leads to an IO
// pattern that resembles a single linear scan through the index b-tree,
// and all but guarantees each modified leaf page is loaded and stored
// exactly once. SQLite uses this trick to improve the performance of
// CREATE INDEX commands. This extension allows it to be used to improve
// the performance of large transactions on existing databases.
//
// Additionally, this extension allows the work involved in writing the
// large transaction to be broken down into sub-transactions performed
// sequentially by separate processes. This is useful if the system cannot
// guarantee that a single update process will run for long enough to apply
// the entire update, for example because the update is being applied on a
// mobile device that is frequently rebooted. Even after the writer process
// has committed one or more sub-transactions, other database clients continue
// to read from the original database snapshot. In other words, partially
// applied transactions are not visible to other clients.
//
// "RBU" stands for "Resumable Bulk Update". As in a large database update
// transmitted via a wireless network to a mobile device. A transaction
// applied using this extension is hence refered to as an "RBU update".
//
//
// LIMITATIONS
//
// An "RBU update" transaction is subject to the following limitations:
//
//   * The transaction must consist of INSERT, UPDATE and DELETE operations
//     only.
//
//   * INSERT statements may not use any default values.
//
//   * UPDATE and DELETE statements must identify their target rows by
//     non-NULL PRIMARY KEY values. Rows with NULL values stored in PRIMARY
//     KEY fields may not be updated or deleted. If the table being written
//     has no PRIMARY KEY, affected rows must be identified by rowid.
//
//   * UPDATE statements may not modify PRIMARY KEY columns.
//
//   * No triggers will be fired.
//
//   * No foreign key violations are detected or reported.
//
//   * CHECK constraints are not enforced.
//
//   * No constraint handling mode except for "OR ROLLBACK" is supported.
//
//
// PREPARATION
//
// An "RBU update" is stored as a separate SQLite database. A database
// containing an RBU update is an "RBU database". For each table in the
// target database to be updated, the RBU database should contain a table
// named "data_<target name>" containing the same set of columns as the
// target table, and one more - "rbu_control". The data_% table should
// have no PRIMARY KEY or UNIQUE constraints, but each column should have
// the same type as the corresponding column in the target database.
// The "rbu_control" column should have no type at all. For example, if
// the target database contains:
//
//   CREATE TABLE t1(a INTEGER PRIMARY KEY, b TEXT, c UNIQUE);
//
// Then the RBU database should contain:
//
//   CREATE TABLE data_t1(a INTEGER, b TEXT, c, rbu_control);
//
// The order of the columns in the data_% table does not matter.
//
// Instead of a regular table, the RBU database may also contain virtual
// tables or view named using the data_<target> naming scheme.
//
// Instead of the plain data_<target> naming scheme, RBU database tables
// may also be named data<integer>_<target>, where <integer> is any sequence
// of zero or more numeric characters (0-9). This can be significant because
// tables within the RBU database are always processed in order sorted by
// name. By judicious selection of the <integer> portion of the names
// of the RBU tables the user can therefore control the order in which they
// are processed. This can be useful, for example, to ensure that "external
// content" FTS4 tables are updated before their underlying content tables.
//
// If the target database table is a virtual table or a table that has no
// PRIMARY KEY declaration, the data_% table must also contain a column
// named "rbu_rowid". This column is mapped to the tables implicit primary
// key column - "rowid". Virtual tables for which the "rowid" column does
// not function like a primary key value cannot be updated using RBU. For
// example, if the target db contains either of the following:
//
//   CREATE VIRTUAL TABLE x1 USING fts3(a, b);
//   CREATE TABLE x1(a, b)
//
// then the RBU database should contain:
//
//   CREATE TABLE data_x1(a, b, rbu_rowid, rbu_control);
//
// All non-hidden columns (i.e. all columns matched by "SELECT *") of the
// target table must be present in the input table. For virtual tables,
// hidden columns are optional - they are updated by RBU if present in
// the input table, or not otherwise. For example, to write to an fts4
// table with a hidden languageid column such as:
//
//   CREATE VIRTUAL TABLE ft1 USING fts4(a, b, languageid='langid');
//
// Either of the following input table schemas may be used:
//
//   CREATE TABLE data_ft1(a, b, langid, rbu_rowid, rbu_control);
//   CREATE TABLE data_ft1(a, b, rbu_rowid, rbu_control);
//
// For each row to INSERT into the target database as part of the RBU
// update, the corresponding data_% table should contain a single record
// with the "rbu_control" column set to contain integer value 0. The
// other columns should be set to the values that make up the new record
// to insert.
//
// If the target database table has an INTEGER PRIMARY KEY, it is not
// possible to insert a NULL value into the IPK column. Attempting to
// do so results in an SQLITE_MISMATCH error.
//
// For each row to DELETE from the target database as part of the RBU
// update, the corresponding data_% table should contain a single record
// with the "rbu_control" column set to contain integer value 1. The
// real primary key values of the row to delete should be stored in the
// corresponding columns of the data_% table. The values stored in the
// other columns are not used.
//
// For each row to UPDATE from the target database as part of the RBU
// update, the corresponding data_% table should contain a single record
// with the "rbu_control" column set to contain a value of type text.
// The real primary key values identifying the row to update should be
// stored in the corresponding columns of the data_% table row, as should
// the new values of all columns being update. The text value in the
// "rbu_control" column must contain the same number of characters as
// there are columns in the target database table, and must consist entirely
// of 'x' and '.' characters (or in some special cases 'd' - see below). For
// each column that is being updated, the corresponding character is set to
// 'x'. For those that remain as they are, the corresponding character of the
// rbu_control value should be set to '.'. For example, given the tables
// above, the update statement:
//
//   UPDATE t1 SET c = 'usa' WHERE a = 4;
//
// is represented by the data_t1 row created by:
//
//   INSERT INTO data_t1(a, b, c, rbu_control) VALUES(4, NULL, 'usa', '..x');
//
// Instead of an 'x' character, characters of the rbu_control value specified
// for UPDATEs may also be set to 'd'. In this case, instead of updating the
// target table with the value stored in the corresponding data_% column, the
// user-defined SQL function "rbu_delta()" is invoked and the result stored in
// the target table column. rbu_delta() is invoked with two arguments - the
// original value currently stored in the target table column and the
// value specified in the data_xxx table.
//
// For example, this row:
//
//   INSERT INTO data_t1(a, b, c, rbu_control) VALUES(4, NULL, 'usa', '..d');
//
// is similar to an UPDATE statement such as:
//
//   UPDATE t1 SET c = rbu_delta(c, 'usa') WHERE a = 4;
//
// Finally, if an 'f' character appears in place of a 'd' or 's' in an
// ota_control string, the contents of the data_xxx table column is assumed
// to be a "fossil delta" - a patch to be applied to a blob value in the
// format used by the fossil source-code management system. In this case
// the existing value within the target database table must be of type BLOB.
// It is replaced by the result of applying the specified fossil delta to
// itself.
//
// If the target database table is a virtual table or a table with no PRIMARY
// KEY, the rbu_control value should not include a character corresponding
// to the rbu_rowid value. For example, this:
//
//   INSERT INTO data_ft1(a, b, rbu_rowid, rbu_control)
//       VALUES(NULL, 'usa', 12, '.x');
//
// causes a result similar to:
//
//   UPDATE ft1 SET b = 'usa' WHERE rowid = 12;
//
// The data_xxx tables themselves should have no PRIMARY KEY declarations.
// However, RBU is more efficient if reading the rows in from each data_xxx
// table in "rowid" order is roughly the same as reading them sorted by
// the PRIMARY KEY of the corresponding target database table. In other
// words, rows should be sorted using the destination table PRIMARY KEY
// fields before they are inserted into the data_xxx tables.
//
// USAGE
//
// The API declared below allows an application to apply an RBU update
// stored on disk to an existing target database. Essentially, the
// application:
//
//     1) Opens an RBU handle using the sqlite3rbu_open() function.
//
//     2) Registers any required virtual table modules with the database
//        handle returned by sqlite3rbu_db(). Also, if required, register
//        the rbu_delta() implementation.
//
//     3) Calls the sqlite3rbu_step() function one or more times on
//        the new handle. Each call to sqlite3rbu_step() performs a single
//        b-tree operation, so thousands of calls may be required to apply
//        a complete update.
//
//     4) Calls sqlite3rbu_close() to close the RBU update handle. If
//        sqlite3rbu_step() has been called enough times to completely
//        apply the update to the target database, then the RBU database
//        is marked as fully applied. Otherwise, the state of the RBU
//        update application is saved in the RBU database for later
//        resumption.
//
// See comments below for more detail on APIs.
//
// If an update is only partially applied to the target database by the
// time sqlite3rbu_close() is called, various state information is saved
// within the RBU database. This allows subsequent processes to automatically
// resume the RBU update from where it left off.
//
// To remove all RBU extension state information, returning an RBU database
// to its original contents, it is sufficient to drop all tables that begin
// with the prefix "rbu_"
//
// DATABASE LOCKING
//
// An RBU update may not be applied to a database in WAL mode. Attempting
// to do so is an error (SQLITE_ERROR).
//
// While an RBU handle is open, a SHARED lock may be held on the target
// database file. This means it is possible for other clients to read the
// database, but not to write it.
//
// If an RBU update is started and then suspended before it is completed,
// then an external client writes to the database, then attempting to resume
// the suspended RBU update is also an error (SQLITE_BUSY).

// 2001-09-15
//
// The author disclaims copyright to this source code.  In place of
// a legal notice, here is a blessing:
//
//    May you do good and not evil.
//    May you find forgiveness for yourself and forgive others.
//    May you share freely, never taking more than you give.
//
//
// This header file defines the interface that the SQLite library
// presents to client programs.  If a C-function, structure, datatype,
// or constant definition does not appear in this file, then it is
// not a published API of SQLite, is subject to change without
// notice, and should not be referenced by programs that use SQLite.
//
// Some of the definitions that are in this file are marked as
// "experimental".  Experimental interfaces are normally new
// features recently added to SQLite.  We do not anticipate changes
// to experimental interfaces but reserve the right to make minor changes
// if experience from use "in the wild" suggest such changes are prudent.
//
// The official C-language API documentation for SQLite is derived
// from comments in this file.  This file is the authoritative source
// on how SQLite interfaces are supposed to operate.
//
// The name of this file under configuration management is "sqlite.h.in".
// The makefile makes some minor changes to this file (such as inserting
// the version number) and changes its name to "sqlite3.h" as
// part of the build process.

//******* Begin file sqlite3rtree.h ********
// 2010 August 30
//
// The author disclaims copyright to this source code.  In place of
// a legal notice, here is a blessing:
//
//    May you do good and not evil.
//    May you find forgiveness for yourself and forgive others.
//    May you share freely, never taking more than you give.
//
//

//******* End of sqlite3rtree.h ********
//******* Begin file sqlite3session.h ********

//******* End of sqlite3session.h ********
//******* Begin file fts5.h ********
// 2014 May 31
//
// The author disclaims copyright to this source code.  In place of
// a legal notice, here is a blessing:
//
//    May you do good and not evil.
//    May you find forgiveness for yourself and forgive others.
//    May you share freely, never taking more than you give.
//
//
//
// Interfaces to extend FTS5. Using the interfaces defined in this file,
// FTS5 may be extended with:
//
//     * custom tokenizers, and
//     * custom auxiliary functions.

//******* End of fts5.h ********

type sqlite3rbu = sqlite3rbu1 /* sqlite3rbu.h:276:27 */

// Maximum number of prepared UPDATE statements held by this module

// Delta checksums disabled by default.  Compile with -DRBU_ENABLE_DELTA_CKSUM
// to enable checksum verification.

// Swap two objects of type TYPE.

// The rbu_state table is used to save the state of a partially applied
// update so that it can be resumed later. The table consists of integer
// keys mapped to values as follows:
//
// RBU_STATE_STAGE:
//   May be set to integer values 1, 2, 4 or 5. As follows:
//       1: the *-rbu file is currently under construction.
//       2: the *-rbu file has been constructed, but not yet moved
//          to the *-wal path.
//       4: the checkpoint is underway.
//       5: the rbu update has been checkpointed.
//
// RBU_STATE_TBL:
//   Only valid if STAGE==1. The target database name of the table
//   currently being written.
//
// RBU_STATE_IDX:
//   Only valid if STAGE==1. The target database name of the index
//   currently being written, or NULL if the main table is currently being
//   updated.
//
// RBU_STATE_ROW:
//   Only valid if STAGE==1. Number of rows already processed for the current
//   table/index.
//
// RBU_STATE_PROGRESS:
//   Trbul number of sqlite3rbu_step() calls made so far as part of this
//   rbu update.
//
// RBU_STATE_CKPT:
//   Valid if STAGE==4. The 64-bit checksum associated with the wal-index
//   header created by recovering the *-wal file. This is used to detect
//   cases when another client appends frames to the *-wal file in the
//   middle of an incremental checkpoint (an incremental checkpoint cannot
//   be continued if this happens).
//
// RBU_STATE_COOKIE:
//   Valid if STAGE==1. The current change-counter cookie value in the
//   target db file.
//
// RBU_STATE_OALSZ:
//   Valid if STAGE==1. The size in bytes of the *-oal file.
//
// RBU_STATE_DATATBL:
//   Only valid if STAGE==1. The RBU database name of the table
//   currently being read.

type RbuFrame1 = struct {
	FiDbPage   u32
	FiWalFrame u32
}

// Maximum number of prepared UPDATE statements held by this module

// Delta checksums disabled by default.  Compile with -DRBU_ENABLE_DELTA_CKSUM
// to enable checksum verification.

// Swap two objects of type TYPE.

// The rbu_state table is used to save the state of a partially applied
// update so that it can be resumed later. The table consists of integer
// keys mapped to values as follows:
//
// RBU_STATE_STAGE:
//   May be set to integer values 1, 2, 4 or 5. As follows:
//       1: the *-rbu file is currently under construction.
//       2: the *-rbu file has been constructed, but not yet moved
//          to the *-wal path.
//       4: the checkpoint is underway.
//       5: the rbu update has been checkpointed.
//
// RBU_STATE_TBL:
//   Only valid if STAGE==1. The target database name of the table
//   currently being written.
//
// RBU_STATE_IDX:
//   Only valid if STAGE==1. The target database name of the index
//   currently being written, or NULL if the main table is currently being
//   updated.
//
// RBU_STATE_ROW:
//   Only valid if STAGE==1. Number of rows already processed for the current
//   table/index.
//
// RBU_STATE_PROGRESS:
//   Trbul number of sqlite3rbu_step() calls made so far as part of this
//   rbu update.
//
// RBU_STATE_CKPT:
//   Valid if STAGE==4. The 64-bit checksum associated with the wal-index
//   header created by recovering the *-wal file. This is used to detect
//   cases when another client appends frames to the *-wal file in the
//   middle of an incremental checkpoint (an incremental checkpoint cannot
//   be continued if this happens).
//
// RBU_STATE_COOKIE:
//   Valid if STAGE==1. The current change-counter cookie value in the
//   target db file.
//
// RBU_STATE_OALSZ:
//   Valid if STAGE==1. The size in bytes of the *-oal file.
//
// RBU_STATE_DATATBL:
//   Only valid if STAGE==1. The RBU database name of the table
//   currently being read.

type RbuFrame = RbuFrame1 /* sqlite3rbu.c:182:25 */
type RbuObjIter1 = struct {
	FpTblIter   uintptr
	FpIdxIter   uintptr
	FnTblCol    int32
	FazTblCol   uintptr
	FazTblType  uintptr
	FaiSrcOrder uintptr
	FabTblPk    uintptr
	FabNotNull  uintptr
	FabIndexed  uintptr
	FeType      int32
	FbCleanup   int32
	FzTbl       uintptr
	FzDataTbl   uintptr
	FzIdx       uintptr
	FiTnum      int32
	FiPkTnum    int32
	FbUnique    int32
	FnIndex     int32
	FnCol       int32
	FpSelect    uintptr
	FpInsert    uintptr
	FpDelete    uintptr
	FpTmpInsert uintptr
	FnIdxCol    int32
	FaIdxCol    uintptr
	FzIdxSql    uintptr
	FpRbuUpdate uintptr
}

type RbuObjIter = RbuObjIter1 /* sqlite3rbu.c:183:27 */
type RbuState1 = struct {
	FeStage        int32
	FzTbl          uintptr
	FzDataTbl      uintptr
	FzIdx          uintptr
	FiWalCksum     i64
	FnRow          int32
	FnProgress     i64
	FiCookie       u32
	FiOalSz        i64
	FnPhaseOneStep i64
}

type RbuState = RbuState1 /* sqlite3rbu.c:184:25 */
type RbuSpan1 = struct {
	FzSpan uintptr
	FnSpan int32
	_      [4]byte
}

type RbuSpan = RbuSpan1 /* sqlite3rbu.c:185:24 */
type rbu_vfs1 = struct {
	Fbase     sqlite3_vfs
	FpRealVfs uintptr
	Fmutex    uintptr
	FpRbu     uintptr
	FpMain    uintptr
	FpMainRbu uintptr
}

type rbu_vfs = rbu_vfs1 /* sqlite3rbu.c:186:24 */
type rbu_file1 = struct {
	Fbase         sqlite3_file
	FpReal        uintptr
	FpRbuVfs      uintptr
	FpRbu         uintptr
	Fsz           i64
	FopenFlags    int32
	FiCookie      u32
	FiWriteVer    u8
	FbNolock      u8
	FnShm         int32
	FapShm        uintptr
	FzDel         uintptr
	FzWal         uintptr
	FpWalFd       uintptr
	FpMainNext    uintptr
	FpMainRbuNext uintptr
}

type rbu_file = rbu_file1 /* sqlite3rbu.c:187:25 */
type RbuUpdateStmt1 = struct {
	FzMask   uintptr
	FpUpdate uintptr
	FpNext   uintptr
}

type RbuUpdateStmt = RbuUpdateStmt1 /* sqlite3rbu.c:188:30 */

type u32 = uint32 /* sqlite3rbu.c:191:22 */

// True for an RBU vacuum handle, or false otherwise.

// ************************************************************************
//
// The following three functions, found below:
//
//   rbuDeltaGetInt()
//   rbuDeltaChecksum()
//   rbuDeltaApply()
//
// are lifted from the fossil source code (http://fossil-scm.org). They
// are used to implement the scalar SQL function rbu_fossil_delta().

// Read bytes from *pz and convert them into a positive integer.  When
// finished, leave *pz pointing to the first character past the end of
// the integer.  The *pLen parameter holds the length of the string
// in *pz and is decremented once for each character in the integer.
func rbuDeltaGetInt(tls *crt.TLS, pz uintptr, pLen uintptr) uint32 { /* sqlite3rbu.c:478:21: */
	var v uint32 = uint32(0)
	var c int32
	var z uintptr = *(*uintptr)(unsafe.Pointer(pz))
	var zStart uintptr = z
	for (crt.AssignInt32(&c, int32(zValue[(0x7f&int32(*(*uint8)(unsafe.Pointer(crt.PostIncUintptr(&z, 1)))))]))) >= 0 {
		v = ((v << 6) + uint32(c))
	}
	z--
	*(*int32)(unsafe.Pointer(pLen)) -= int32(((int64(z) - int64(zStart)) / 1))
	*(*uintptr)(unsafe.Pointer(pz)) = z
	return v
}

var zValue = [128]int8{
	int8(-1), int8(-1), int8(-1), int8(-1), int8(-1), int8(-1), int8(-1), int8(-1), int8(-1), int8(-1), int8(-1), int8(-1), int8(-1), int8(-1), int8(-1), int8(-1),
	int8(-1), int8(-1), int8(-1), int8(-1), int8(-1), int8(-1), int8(-1), int8(-1), int8(-1), int8(-1), int8(-1), int8(-1), int8(-1), int8(-1), int8(-1), int8(-1),
	int8(-1), int8(-1), int8(-1), int8(-1), int8(-1), int8(-1), int8(-1), int8(-1), int8(-1), int8(-1), int8(-1), int8(-1), int8(-1), int8(-1), int8(-1), int8(-1),
	int8(0), int8(1), int8(2), int8(3), int8(4), int8(5), int8(6), int8(7), int8(8), int8(9), int8(-1), int8(-1), int8(-1), int8(-1), int8(-1), int8(-1),
	int8(-1), int8(10), int8(11), int8(12), int8(13), int8(14), int8(15), int8(16), int8(17), int8(18), int8(19), int8(20), int8(21), int8(22), int8(23), int8(24),
	int8(25), int8(26), int8(27), int8(28), int8(29), int8(30), int8(31), int8(32), int8(33), int8(34), int8(35), int8(-1), int8(-1), int8(-1), int8(-1), int8(36),
	int8(-1), int8(37), int8(38), int8(39), int8(40), int8(41), int8(42), int8(43), int8(44), int8(45), int8(46), int8(47), int8(48), int8(49), int8(50), int8(51),
	int8(52), int8(53), int8(54), int8(55), int8(56), int8(57), int8(58), int8(59), int8(60), int8(61), int8(62), int8(-1), int8(-1), int8(-1), int8(63), int8(-1),
} /* sqlite3rbu.c:479:28 */

// Apply a delta.
//
// The output buffer should be big enough to hold the whole output
// file and a NUL terminator at the end.  The delta_output_size()
// routine will determine this size for you.
//
// The delta string should be null-terminated.  But the delta string
// may contain embedded NUL characters (if the input and output are
// binary files) so we also have to pass in the length of the delta in
// the lenDelta parameter.
//
// This function returns the size of the output file in bytes (excluding
// the final NUL terminator character).  Except, if the delta string is
// malformed or intended for use with a source file other than zSrc,
// then this routine returns -1.
//
// Refer to the delta_create() documentation above for a description
// of the delta file format.
func rbuDeltaApply(tls *crt.TLS, zSrc uintptr, lenSrc int32, zDelta uintptr, lenDelta int32, zOut uintptr) int32 { /* sqlite3rbu.c:559:12: */
	bp := tls.Alloc(12)
	defer tls.Free(12)
	*(*uintptr)(unsafe.Pointer(bp)) = zDelta
	*(*int32)(unsafe.Pointer(bp + 8)) = lenDelta

	var limit uint32
	var total uint32 = uint32(0)

	limit = rbuDeltaGetInt(tls, bp /* &zDelta */, bp+8 /* &lenDelta */)
	if int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* zDelta */))))) != '\n' {
		// ERROR: size integer not terminated by "\n"
		return -1
	}
	*(*uintptr)(unsafe.Pointer(bp /* zDelta */))++
	*(*int32)(unsafe.Pointer(bp + 8 /* lenDelta */))--
	for (*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* zDelta */)))) != 0) && (*(*int32)(unsafe.Pointer(bp + 8 /* lenDelta */)) > 0) {
		var cnt uint32
		var ofst uint32
		cnt = rbuDeltaGetInt(tls, bp /* &zDelta */, bp+8 /* &lenDelta */)
		switch int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* zDelta */)) + uintptr(0)))) {
		case '@':
			{
				*(*uintptr)(unsafe.Pointer(bp /* zDelta */))++
				*(*int32)(unsafe.Pointer(bp + 8 /* lenDelta */))--
				ofst = rbuDeltaGetInt(tls, bp /* &zDelta */, bp+8 /* &lenDelta */)
				if (*(*int32)(unsafe.Pointer(bp + 8 /* lenDelta */)) > 0) && (int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* zDelta */)) + uintptr(0)))) != ',') {
					// ERROR: copy command not terminated by ','
					return -1
				}
				*(*uintptr)(unsafe.Pointer(bp /* zDelta */))++
				*(*int32)(unsafe.Pointer(bp + 8 /* lenDelta */))--
				total = total + (cnt)
				if total > limit {
					// ERROR: copy exceeds output file size
					return -1
				}
				if (int32(ofst + cnt)) > lenSrc {
					// ERROR: copy extends past end of input
					return -1
				}
				crt.Xmemcpy(tls, zOut, (zSrc + uintptr(ofst)), uint64(cnt))
				zOut += uintptr(cnt)
				break
			}
		case ':':
			{
				*(*uintptr)(unsafe.Pointer(bp /* zDelta */))++
				*(*int32)(unsafe.Pointer(bp + 8 /* lenDelta */))--
				total = total + (cnt)
				if total > limit {
					// ERROR:  insert command gives an output larger than predicted
					return -1
				}
				if int32(cnt) > *(*int32)(unsafe.Pointer(bp + 8 /* lenDelta */)) {
					// ERROR: insert count exceeds size of delta
					return -1
				}
				crt.Xmemcpy(tls, zOut, *(*uintptr)(unsafe.Pointer(bp /* zDelta */)), uint64(cnt))
				zOut += uintptr(cnt)
				*(*uintptr)(unsafe.Pointer(bp /* zDelta */)) += uintptr(cnt)
				*(*int32)(unsafe.Pointer(bp + 8 /* lenDelta */)) -= int32(cnt)
				break
			}
		case ';':
			{
				*(*uintptr)(unsafe.Pointer(bp /* zDelta */))++
				*(*int32)(unsafe.Pointer(bp + 8 /* lenDelta */))--
				*(*int8)(unsafe.Pointer(zOut + uintptr(0))) = int8(0)
				if total != limit {
					// ERROR: generated size does not match predicted size
					return -1
				}
				return int32(total)
			}
		default:
			{
				// ERROR: unknown delta operator
				return -1
			}
		}
	}
	// ERROR: unterminated delta
	return -1
}

func rbuDeltaOutputSize(tls *crt.TLS, zDelta uintptr, lenDelta int32) int32 { /* sqlite3rbu.c:645:12: */
	bp := tls.Alloc(12)
	defer tls.Free(12)
	*(*uintptr)(unsafe.Pointer(bp)) = zDelta
	*(*int32)(unsafe.Pointer(bp + 8)) = lenDelta

	var size int32
	size = int32(rbuDeltaGetInt(tls, bp /* &zDelta */, bp+8 /* &lenDelta */))
	if int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* zDelta */))))) != '\n' {
		// ERROR: size integer not terminated by "\n"
		return -1
	}
	return size
}

//
// End of code taken from fossil.
//

// Implementation of SQL scalar function rbu_fossil_delta().
//
// This function applies a fossil delta patch to a blob. Exactly two
// arguments must be passed to this function. The first is the blob to
// patch and the second the patch to apply. If no error occurs, this
// function returns the patched blob.
func rbuFossilDeltaFunc(tls *crt.TLS, context uintptr, argc int32, argv uintptr) { /* sqlite3rbu.c:667:13: */
	var aDelta uintptr
	var nDelta int32
	var aOrig uintptr
	var nOrig int32
	var nOut int32
	var nOut2 int32
	var aOut uintptr

	if !(argc == 2) {
		crt.X__assert_fail(tls, ts+1318 /* "argc==2" */, ts+9694 /* "testdata/sqlite-..." */, uint32(681), uintptr(unsafe.Pointer(&__func__44)))
	}

	nOrig = sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)))
	aOrig = sqlite3.Xsqlite3_value_blob(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)))
	nDelta = sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)))
	aDelta = sqlite3.Xsqlite3_value_blob(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)))

	// Figure out the size of the output
	nOut = rbuDeltaOutputSize(tls, aDelta, nDelta)
	if nOut < 0 {
		sqlite3.Xsqlite3_result_error(tls, context, ts+9743 /* "corrupt fossil d..." */, -1)
		return
	}

	aOut = sqlite3.Xsqlite3_malloc(tls, (nOut + 1))
	if aOut == uintptr(0) {
		sqlite3.Xsqlite3_result_error_nomem(tls, context)
	} else {
		nOut2 = rbuDeltaApply(tls, aOrig, nOrig, aDelta, nDelta, aOut)
		if nOut2 != nOut {
			sqlite3.Xsqlite3_free(tls, aOut)
			sqlite3.Xsqlite3_result_error(tls, context, ts+9743 /* "corrupt fossil d..." */, -1)
		} else {
			sqlite3.Xsqlite3_result_blob(tls, context, aOut, nOut, *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, uintptr) }{sqlite3.Xsqlite3_free})))
		}
	}
}

var __func__44 = *(*[19]int8)(unsafe.Pointer(ts + 9764 /* "rbuFossilDeltaFu..." */)) /* sqlite3rbu.c:671:2 */

// Prepare the SQL statement in buffer zSql against database handle db.
// If successful, set *ppStmt to point to the new statement and return
// SQLITE_OK.
//
// Otherwise, if an error does occur, set *ppStmt to NULL and return
// an SQLite error code. Additionally, set output variable *pzErrmsg to
// point to a buffer containing an error message. It is the responsibility
// of the caller to (eventually) free this buffer using sqlite3_free().
func prepareAndCollectError(tls *crt.TLS, db uintptr, ppStmt uintptr, pzErrmsg uintptr, zSql uintptr) int32 { /* sqlite3rbu.c:720:12: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var rc int32 = sqlite3.Xsqlite3_prepare_v2(tls, db, zSql, -1, ppStmt, uintptr(0))
	if rc != 0 {
		*(*uintptr)(unsafe.Pointer(pzErrmsg)) = sqlite3.Xsqlite3_mprintf(tls, ts+130 /* "%s" */, crt.VaList(bp, sqlite3.Xsqlite3_errmsg(tls, db)))
		*(*uintptr)(unsafe.Pointer(ppStmt)) = uintptr(0)
	}
	return rc
}

// Reset the SQL statement passed as the first argument. Return a copy
// of the value returned by sqlite3_reset().
//
// If an error has occurred, then set *pzErrmsg to point to a buffer
// containing an error message. It is the responsibility of the caller
// to eventually free this buffer using sqlite3_free().
func resetAndCollectError(tls *crt.TLS, pStmt uintptr, pzErrmsg uintptr) int32 { /* sqlite3rbu.c:742:12: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var rc int32 = sqlite3.Xsqlite3_reset(tls, pStmt)
	if rc != 0 {
		*(*uintptr)(unsafe.Pointer(pzErrmsg)) = sqlite3.Xsqlite3_mprintf(tls, ts+130 /* "%s" */, crt.VaList(bp, sqlite3.Xsqlite3_errmsg(tls, sqlite3.Xsqlite3_db_handle(tls, pStmt))))
	}
	return rc
}

// Unless it is NULL, argument zSql points to a buffer allocated using
// sqlite3_malloc containing an SQL statement. This function prepares the SQL
// statement against database db and frees the buffer. If statement
// compilation is successful, *ppStmt is set to point to the new statement
// handle and SQLITE_OK is returned.
//
// Otherwise, if an error occurs, *ppStmt is set to NULL and an error code
// returned. In this case, *pzErrmsg may also be set to point to an error
// message. It is the responsibility of the caller to free this error message
// buffer using sqlite3_free().
//
// If argument zSql is NULL, this function assumes that an OOM has occurred.
// In this case SQLITE_NOMEM is returned and *ppStmt set to NULL.
func prepareFreeAndCollectError(tls *crt.TLS, db uintptr, ppStmt uintptr, pzErrmsg uintptr, zSql uintptr) int32 { /* sqlite3rbu.c:765:12: */
	var rc int32
	if !(*(*uintptr)(unsafe.Pointer(pzErrmsg)) == uintptr(0)) {
		crt.X__assert_fail(tls, ts+9783 /* "*pzErrmsg==0" */, ts+9694 /* "testdata/sqlite-..." */, uint32(772), uintptr(unsafe.Pointer(&__func__45)))
	}
	if zSql == uintptr(0) {
		rc = 7
		*(*uintptr)(unsafe.Pointer(ppStmt)) = uintptr(0)
	} else {
		rc = prepareAndCollectError(tls, db, ppStmt, pzErrmsg, zSql)
		sqlite3.Xsqlite3_free(tls, zSql)
	}
	return rc
}

var __func__45 = *(*[27]int8)(unsafe.Pointer(ts + 9796 /* "prepareFreeAndCo..." */)) /* sqlite3rbu.c:770:2 */

// Free the RbuObjIter.azTblCol[] and RbuObjIter.abTblPk[] arrays allocated
// by an earlier call to rbuObjIterCacheTableInfo().
func rbuObjIterFreeCols(tls *crt.TLS, pIter uintptr) { /* sqlite3rbu.c:787:13: */
	var i int32
	for i = 0; i < (*RbuObjIter)(unsafe.Pointer(pIter)).FnTblCol; i++ {
		sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer((*RbuObjIter)(unsafe.Pointer(pIter)).FazTblCol + uintptr(i)*8)))
		sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer((*RbuObjIter)(unsafe.Pointer(pIter)).FazTblType + uintptr(i)*8)))
	}
	sqlite3.Xsqlite3_free(tls, (*RbuObjIter)(unsafe.Pointer(pIter)).FazTblCol)
	(*RbuObjIter)(unsafe.Pointer(pIter)).FazTblCol = uintptr(0)
	(*RbuObjIter)(unsafe.Pointer(pIter)).FazTblType = uintptr(0)
	(*RbuObjIter)(unsafe.Pointer(pIter)).FaiSrcOrder = uintptr(0)
	(*RbuObjIter)(unsafe.Pointer(pIter)).FabTblPk = uintptr(0)
	(*RbuObjIter)(unsafe.Pointer(pIter)).FabNotNull = uintptr(0)
	(*RbuObjIter)(unsafe.Pointer(pIter)).FnTblCol = 0
	(*RbuObjIter)(unsafe.Pointer(pIter)).FeType = 0 // Invalid value
}

// Finalize all statements and free all allocations that are specific to
// the current object (table/index pair).
func rbuObjIterClearStatements(tls *crt.TLS, pIter uintptr) { /* sqlite3rbu.c:807:13: */
	var pUp uintptr

	sqlite3.Xsqlite3_finalize(tls, (*RbuObjIter)(unsafe.Pointer(pIter)).FpSelect)
	sqlite3.Xsqlite3_finalize(tls, (*RbuObjIter)(unsafe.Pointer(pIter)).FpInsert)
	sqlite3.Xsqlite3_finalize(tls, (*RbuObjIter)(unsafe.Pointer(pIter)).FpDelete)
	sqlite3.Xsqlite3_finalize(tls, (*RbuObjIter)(unsafe.Pointer(pIter)).FpTmpInsert)
	pUp = (*RbuObjIter)(unsafe.Pointer(pIter)).FpRbuUpdate
	for pUp != 0 {
		var pTmp uintptr = (*RbuUpdateStmt)(unsafe.Pointer(pUp)).FpNext
		sqlite3.Xsqlite3_finalize(tls, (*RbuUpdateStmt)(unsafe.Pointer(pUp)).FpUpdate)
		sqlite3.Xsqlite3_free(tls, pUp)
		pUp = pTmp
	}
	sqlite3.Xsqlite3_free(tls, (*RbuObjIter)(unsafe.Pointer(pIter)).FaIdxCol)
	sqlite3.Xsqlite3_free(tls, (*RbuObjIter)(unsafe.Pointer(pIter)).FzIdxSql)

	(*RbuObjIter)(unsafe.Pointer(pIter)).FpSelect = uintptr(0)
	(*RbuObjIter)(unsafe.Pointer(pIter)).FpInsert = uintptr(0)
	(*RbuObjIter)(unsafe.Pointer(pIter)).FpDelete = uintptr(0)
	(*RbuObjIter)(unsafe.Pointer(pIter)).FpRbuUpdate = uintptr(0)
	(*RbuObjIter)(unsafe.Pointer(pIter)).FpTmpInsert = uintptr(0)
	(*RbuObjIter)(unsafe.Pointer(pIter)).FnCol = 0
	(*RbuObjIter)(unsafe.Pointer(pIter)).FnIdxCol = 0
	(*RbuObjIter)(unsafe.Pointer(pIter)).FaIdxCol = uintptr(0)
	(*RbuObjIter)(unsafe.Pointer(pIter)).FzIdxSql = uintptr(0)
}

// Clean up any resources allocated as part of the iterator object passed
// as the only argument.
func rbuObjIterFinalize(tls *crt.TLS, pIter uintptr) { /* sqlite3rbu.c:839:13: */
	rbuObjIterClearStatements(tls, pIter)
	sqlite3.Xsqlite3_finalize(tls, (*RbuObjIter)(unsafe.Pointer(pIter)).FpTblIter)
	sqlite3.Xsqlite3_finalize(tls, (*RbuObjIter)(unsafe.Pointer(pIter)).FpIdxIter)
	rbuObjIterFreeCols(tls, pIter)
	crt.Xmemset(tls, pIter, 0, uint64(unsafe.Sizeof(RbuObjIter{})))
}

// Advance the iterator to the next position.
//
// If no error occurs, SQLITE_OK is returned and the iterator is left
// pointing to the next entry. Otherwise, an error code and message is
// left in the RBU handle passed as the first argument. A copy of the
// error code is returned.
func rbuObjIterNext(tls *crt.TLS, p uintptr, pIter uintptr) int32 { /* sqlite3rbu.c:855:12: */
	var rc int32 = (*sqlite3rbu)(unsafe.Pointer(p)).Frc
	if rc == 0 {

		/* Free any SQLite statements used while processing the previous object */
		rbuObjIterClearStatements(tls, pIter)
		if (*RbuObjIter)(unsafe.Pointer(pIter)).FzIdx == uintptr(0) {
			rc = sqlite3.Xsqlite3_exec(tls, (*sqlite3rbu)(unsafe.Pointer(p)).FdbMain,

				ts+9823 /* "DROP TRIGGER IF ..." */, uintptr(0), uintptr(0), (p + 64 /* &.zErrmsg */))
		}

		if rc == 0 {
			if (*RbuObjIter)(unsafe.Pointer(pIter)).FbCleanup != 0 {
				rbuObjIterFreeCols(tls, pIter)
				(*RbuObjIter)(unsafe.Pointer(pIter)).FbCleanup = 0
				rc = sqlite3.Xsqlite3_step(tls, (*RbuObjIter)(unsafe.Pointer(pIter)).FpTblIter)
				if rc != 100 {
					rc = resetAndCollectError(tls, (*RbuObjIter)(unsafe.Pointer(pIter)).FpTblIter, (p + 64 /* &.zErrmsg */))
					(*RbuObjIter)(unsafe.Pointer(pIter)).FzTbl = uintptr(0)
				} else {
					(*RbuObjIter)(unsafe.Pointer(pIter)).FzTbl = sqlite3.Xsqlite3_column_text(tls, (*RbuObjIter)(unsafe.Pointer(pIter)).FpTblIter, 0)
					(*RbuObjIter)(unsafe.Pointer(pIter)).FzDataTbl = sqlite3.Xsqlite3_column_text(tls, (*RbuObjIter)(unsafe.Pointer(pIter)).FpTblIter, 1)
					if ((*RbuObjIter)(unsafe.Pointer(pIter)).FzDataTbl != 0) && ((*RbuObjIter)(unsafe.Pointer(pIter)).FzTbl != 0) {
						rc = 0
					} else {
						rc = 7
					}
				}
			} else {
				if (*RbuObjIter)(unsafe.Pointer(pIter)).FzIdx == uintptr(0) {
					var pIdx uintptr = (*RbuObjIter)(unsafe.Pointer(pIter)).FpIdxIter
					rc = sqlite3.Xsqlite3_bind_text(tls, pIdx, 1, (*RbuObjIter)(unsafe.Pointer(pIter)).FzTbl, -1, uintptr(0))
				}
				if rc == 0 {
					rc = sqlite3.Xsqlite3_step(tls, (*RbuObjIter)(unsafe.Pointer(pIter)).FpIdxIter)
					if rc != 100 {
						rc = resetAndCollectError(tls, (*RbuObjIter)(unsafe.Pointer(pIter)).FpIdxIter, (p + 64 /* &.zErrmsg */))
						(*RbuObjIter)(unsafe.Pointer(pIter)).FbCleanup = 1
						(*RbuObjIter)(unsafe.Pointer(pIter)).FzIdx = uintptr(0)
					} else {
						(*RbuObjIter)(unsafe.Pointer(pIter)).FzIdx = sqlite3.Xsqlite3_column_text(tls, (*RbuObjIter)(unsafe.Pointer(pIter)).FpIdxIter, 0)
						(*RbuObjIter)(unsafe.Pointer(pIter)).FiTnum = sqlite3.Xsqlite3_column_int(tls, (*RbuObjIter)(unsafe.Pointer(pIter)).FpIdxIter, 1)
						(*RbuObjIter)(unsafe.Pointer(pIter)).FbUnique = sqlite3.Xsqlite3_column_int(tls, (*RbuObjIter)(unsafe.Pointer(pIter)).FpIdxIter, 2)
						if (*RbuObjIter)(unsafe.Pointer(pIter)).FzIdx != 0 {
							rc = 0
						} else {
							rc = 7
						}
					}
				}
			}
		}
	}

	if rc != 0 {
		rbuObjIterFinalize(tls, pIter)
		(*sqlite3rbu)(unsafe.Pointer(p)).Frc = rc
	}
	return rc
}

// The implementation of the rbu_target_name() SQL function. This function
// accepts one or two arguments. The first argument is the name of a table -
// the name of a table in the RBU database.  The second, if it is present, is 1
// for a view or 0 for a table.
//
// For a non-vacuum RBU handle, if the table name matches the pattern:
//
//     data[0-9]_<name>
//
// where <name> is any sequence of 1 or more characters, <name> is returned.
// Otherwise, if the only argument does not match the above pattern, an SQL
// NULL is returned.
//
//     "data_t1"     -> "t1"
//     "data0123_t2" -> "t2"
//     "dataAB_t3"   -> NULL
//
// For an rbu vacuum handle, a copy of the first argument is returned if
// the second argument is either missing or 0 (not a view).
func rbuTargetNameFunc(tls *crt.TLS, pCtx uintptr, argc int32, argv uintptr) { /* sqlite3rbu.c:935:13: */
	var p uintptr = sqlite3.Xsqlite3_user_data(tls, pCtx)
	var zIn uintptr
	if !((argc == 1) || (argc == 2)) {
		crt.X__assert_fail(tls, ts+9994 /* "argc==1 || argc=..." */, ts+9694 /* "testdata/sqlite-..." */, uint32(942), uintptr(unsafe.Pointer(&__func__46)))
	}

	zIn = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)))
	if zIn != 0 {
		if (*sqlite3rbu)(unsafe.Pointer((p))).FzTarget == uintptr(0) {
			if !((argc == 2) || (argc == 1)) {
				crt.X__assert_fail(tls, ts+10013 /* "argc==2 || argc=..." */, ts+9694 /* "testdata/sqlite-..." */, uint32(947), uintptr(unsafe.Pointer(&__func__46)))
			}
			if (argc == 1) || (0 == sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)))) {
				sqlite3.Xsqlite3_result_text(tls, pCtx, zIn, -1, uintptr(0))
			}
		} else {
			if (crt.Xstrlen(tls, zIn) > uint64(4)) && (crt.Xmemcmp(tls, ts+4320 /* "data" */, zIn, uint64(4)) == 0) {
				var i int32
				for i = 4; (int32(*(*int8)(unsafe.Pointer(zIn + uintptr(i)))) >= '0') && (int32(*(*int8)(unsafe.Pointer(zIn + uintptr(i)))) <= '9'); i++ {
				}
				if (int32(*(*int8)(unsafe.Pointer(zIn + uintptr(i)))) == '_') && (*(*int8)(unsafe.Pointer(zIn + uintptr((i + 1)))) != 0) {
					sqlite3.Xsqlite3_result_text(tls, pCtx, (zIn + uintptr((i + 1))), -1, uintptr(0))
				}
			}
		}
	}
}

var __func__46 = *(*[18]int8)(unsafe.Pointer(ts + 10032 /* "rbuTargetNameFun..." */)) /* sqlite3rbu.c:939:2 */

// Initialize the iterator structure passed as the second argument.
//
// If no error occurs, SQLITE_OK is returned and the iterator is left
// pointing to the first entry. Otherwise, an error code and message is
// left in the RBU handle passed as the first argument. A copy of the
// error code is returned.
func rbuObjIterFirst(tls *crt.TLS, p uintptr, pIter uintptr) int32 { /* sqlite3rbu.c:971:12: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var rc int32
	crt.Xmemset(tls, pIter, 0, uint64(unsafe.Sizeof(RbuObjIter{})))

	rc = prepareFreeAndCollectError(tls, (*sqlite3rbu)(unsafe.Pointer(p)).FdbRbu, (pIter /* &.pTblIter */), (p + 64 /* &.zErrmsg */),
		sqlite3.Xsqlite3_mprintf(tls,

			ts+10050 /* "SELECT rbu_targe..." */, crt.VaList(bp, func() uintptr {
				if (*sqlite3rbu)(unsafe.Pointer((p))).FzTarget == uintptr(0) {
					return ts + 10200 /* "AND rootpage!=0 ..." */
				}
				return ts + 792 /* "" */
			}())))

	if rc == 0 {
		rc = prepareAndCollectError(tls, (*sqlite3rbu)(unsafe.Pointer(p)).FdbMain, (pIter + 8 /* &.pIdxIter */), (p + 64 /* &.zErrmsg */),

			ts+10241 /* "SELECT name, roo..." */)
	}

	(*RbuObjIter)(unsafe.Pointer(pIter)).FbCleanup = 1
	(*sqlite3rbu)(unsafe.Pointer(p)).Frc = rc
	return rbuObjIterNext(tls, p, pIter)
}

// This is a wrapper around "sqlite3_mprintf(zFmt, ...)". If an OOM occurs,
// an error code is stored in the RBU handle passed as the first argument.
//
// If an error has already occurred (p->rc is already set to something other
// than SQLITE_OK), then this function returns NULL without modifying the
// stored error code. In this case it still calls sqlite3_free() on any
// printf() parameters associated with %z conversions.
func rbuMPrintf(tls *crt.TLS, p uintptr, zFmt uintptr, va uintptr) uintptr { /* sqlite3rbu.c:1006:13: */
	var zSql uintptr = uintptr(0)
	var ap va_list
	_ = ap
	ap = va
	zSql = sqlite3.Xsqlite3_vmprintf(tls, zFmt, ap)
	if (*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0 {
		if zSql == uintptr(0) {
			(*sqlite3rbu)(unsafe.Pointer(p)).Frc = 7
		}
	} else {
		sqlite3.Xsqlite3_free(tls, zSql)
		zSql = uintptr(0)
	}
	_ = ap
	return zSql
}

// Argument zFmt is a sqlite3_mprintf() style format string. The trailing
// arguments are the usual subsitution values. This function performs
// the printf() style substitutions and executes the result as an SQL
// statement on the RBU handles database.
//
// If an error occurs, an error code and error message is stored in the
// RBU handle. If an error has already occurred when this function is
// called, it is a no-op.
func rbuMPrintfExec(tls *crt.TLS, p uintptr, db uintptr, zFmt uintptr, va uintptr) int32 { /* sqlite3rbu.c:1031:12: */
	var ap va_list
	_ = ap
	var zSql uintptr
	ap = va
	zSql = sqlite3.Xsqlite3_vmprintf(tls, zFmt, ap)
	if (*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0 {
		if zSql == uintptr(0) {
			(*sqlite3rbu)(unsafe.Pointer(p)).Frc = 7
		} else {
			(*sqlite3rbu)(unsafe.Pointer(p)).Frc = sqlite3.Xsqlite3_exec(tls, db, zSql, uintptr(0), uintptr(0), (p + 64 /* &.zErrmsg */))
		}
	}
	sqlite3.Xsqlite3_free(tls, zSql)
	_ = ap
	return (*sqlite3rbu)(unsafe.Pointer(p)).Frc
}

// Attempt to allocate and return a pointer to a zeroed block of nByte
// bytes.
//
// If an error (i.e. an OOM condition) occurs, return NULL and leave an
// error code in the rbu handle passed as the first argument. Or, if an
// error has already occurred when this function is called, return NULL
// immediately without attempting the allocation or modifying the stored
// error code.
func rbuMalloc(tls *crt.TLS, p uintptr, nByte sqlite3_int64) uintptr { /* sqlite3rbu.c:1058:13: */
	var pRet uintptr = uintptr(0)
	if (*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0 {
		if !(nByte > int64(0)) {
			crt.X__assert_fail(tls, ts+63 /* "nByte>0" */, ts+9694 /* "testdata/sqlite-..." */, uint32(1061), uintptr(unsafe.Pointer(&__func__47)))
		}
		pRet = sqlite3.Xsqlite3_malloc64(tls, uint64(nByte))
		if pRet == uintptr(0) {
			(*sqlite3rbu)(unsafe.Pointer(p)).Frc = 7
		} else {
			crt.Xmemset(tls, pRet, 0, uint64(nByte))
		}
	}
	return pRet
}

var __func__47 = *(*[10]int8)(unsafe.Pointer(ts + 10366 /* "rbuMalloc" */)) /* sqlite3rbu.c:1058:59 */

// Allocate and zero the pIter->azTblCol[] and abTblPk[] arrays so that
// there is room for at least nCol elements. If an OOM occurs, store an
// error code in the RBU handle passed as the first argument.
func rbuAllocateIterArrays(tls *crt.TLS, p uintptr, pIter uintptr, nCol int32) { /* sqlite3rbu.c:1078:13: */
	var nByte sqlite3_int64 = (sqlite3_int64((((uint64(2) * uint64(unsafe.Sizeof(uintptr(0)))) + uint64(unsafe.Sizeof(int32(0)))) + (uint64(3) * uint64(unsafe.Sizeof(u8(0))))) * uint64(nCol)))
	var azNew uintptr

	azNew = rbuMalloc(tls, p, nByte)
	if azNew != 0 {
		(*RbuObjIter)(unsafe.Pointer(pIter)).FazTblCol = azNew
		(*RbuObjIter)(unsafe.Pointer(pIter)).FazTblType = (azNew + uintptr(nCol)*8)
		(*RbuObjIter)(unsafe.Pointer(pIter)).FaiSrcOrder = ((*RbuObjIter)(unsafe.Pointer(pIter)).FazTblType + uintptr(nCol)*8)
		(*RbuObjIter)(unsafe.Pointer(pIter)).FabTblPk = ((*RbuObjIter)(unsafe.Pointer(pIter)).FaiSrcOrder + uintptr(nCol)*4)
		(*RbuObjIter)(unsafe.Pointer(pIter)).FabNotNull = ((*RbuObjIter)(unsafe.Pointer(pIter)).FabTblPk + uintptr(nCol))
		(*RbuObjIter)(unsafe.Pointer(pIter)).FabIndexed = ((*RbuObjIter)(unsafe.Pointer(pIter)).FabNotNull + uintptr(nCol))
	}
}

// The first argument must be a nul-terminated string. This function
// returns a copy of the string in memory obtained from sqlite3_malloc().
// It is the responsibility of the caller to eventually free this memory
// using sqlite3_free().
//
// If an OOM condition is encountered when attempting to allocate memory,
// output variable (*pRc) is set to SQLITE_NOMEM before returning. Otherwise,
// if the allocation succeeds, (*pRc) is left unchanged.
func rbuStrndup(tls *crt.TLS, zStr uintptr, pRc uintptr) uintptr { /* sqlite3rbu.c:1103:13: */
	var zRet uintptr = uintptr(0)

	if *(*int32)(unsafe.Pointer(pRc)) == 0 {
		if zStr != 0 {
			var nCopy size_t = (crt.Xstrlen(tls, zStr) + uint64(1))
			zRet = sqlite3.Xsqlite3_malloc64(tls, uint64(nCopy))
			if zRet != 0 {
				crt.Xmemcpy(tls, zRet, zStr, nCopy)
			} else {
				*(*int32)(unsafe.Pointer(pRc)) = 7
			}
		}
	}

	return zRet
}

// Finalize the statement passed as the second argument.
//
// If the sqlite3_finalize() call indicates that an error occurs, and the
// rbu handle error code is not already set, set the error code and error
// message accordingly.
func rbuFinalize(tls *crt.TLS, p uintptr, pStmt uintptr) { /* sqlite3rbu.c:1128:13: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var db uintptr = sqlite3.Xsqlite3_db_handle(tls, pStmt)
	var rc int32 = sqlite3.Xsqlite3_finalize(tls, pStmt)
	if ((*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0) && (rc != 0) {
		(*sqlite3rbu)(unsafe.Pointer(p)).Frc = rc
		(*sqlite3rbu)(unsafe.Pointer(p)).FzErrmsg = sqlite3.Xsqlite3_mprintf(tls, ts+130 /* "%s" */, crt.VaList(bp, sqlite3.Xsqlite3_errmsg(tls, db)))
	}
}

// Determine the type of a table.
//
//   peType is of type (int*), a pointer to an output parameter of type
//   (int). This call sets the output parameter as follows, depending
//   on the type of the table specified by parameters dbName and zTbl.
//
//     RBU_PK_NOTABLE:       No such table.
//     RBU_PK_NONE:          Table has an implicit rowid.
//     RBU_PK_IPK:           Table has an explicit IPK column.
//     RBU_PK_EXTERNAL:      Table has an external PK index.
//     RBU_PK_WITHOUT_ROWID: Table is WITHOUT ROWID.
//     RBU_PK_VTAB:          Table is a virtual table.
//
//   Argument *piPk is also of type (int*), and also points to an output
//   parameter. Unless the table has an external primary key index
//   (i.e. unless *peType is set to 3), then *piPk is set to zero. Or,
//   if the table does have an external primary key index, then *piPk
//   is set to the root page number of the primary key index before
//   returning.
//
// ALGORITHM:
//
//   if( no entry exists in sqlite_master ){
//     return RBU_PK_NOTABLE
//   }else if( sql for the entry starts with "CREATE VIRTUAL" ){
//     return RBU_PK_VTAB
//   }else if( "PRAGMA index_list()" for the table contains a "pk" index ){
//     if( the index that is the pk exists in sqlite_master ){
//       *piPK = rootpage of that index.
//       return RBU_PK_EXTERNAL
//     }else{
//       return RBU_PK_WITHOUT_ROWID
//     }
//   }else if( "PRAGMA table_info()" lists one or more "pk" columns ){
//     return RBU_PK_IPK
//   }else{
//     return RBU_PK_NONE
//   }
func rbuTableType(tls *crt.TLS, p uintptr, zTab uintptr, peType uintptr, piTnum uintptr, piPk uintptr) { /* sqlite3rbu.c:1176:13: */
	bp := tls.Alloc(64)
	defer tls.Free(64)

	// 0) SELECT count(*) FROM sqlite_master where name=%Q AND IsVirtual(%Q)
	// 1) PRAGMA index_list = ?
	// 2) SELECT count(*) FROM sqlite_master where name=%Q
	// 3) PRAGMA table_info = ?
	// var aStmt [4]uintptr at bp+32, 32

	var zOrig uintptr
	var zIdx uintptr
	var i uint32
	*(*[4]uintptr)(unsafe.Pointer(bp + 32 /* aStmt */)) = [4]uintptr{uintptr(0), uintptr(0), uintptr(0), uintptr(0)}

	*(*int32)(unsafe.Pointer(peType)) = 0
	*(*int32)(unsafe.Pointer(piPk)) = 0

	if !((*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0) {
		crt.X__assert_fail(tls, ts+10376 /* "p->rc==0" */, ts+9694 /* "testdata/sqlite-..." */, uint32(1194), uintptr(unsafe.Pointer(&__func__48)))
	}
	(*sqlite3rbu)(unsafe.Pointer(p)).Frc = prepareFreeAndCollectError(tls, (*sqlite3rbu)(unsafe.Pointer(p)).FdbMain, (bp + 32 /* &aStmt */ + uintptr(0)*8), (p + 64 /* &.zErrmsg */),
		sqlite3.Xsqlite3_mprintf(tls,

			ts+10385 /* "SELECT (sql LIKE..." */, crt.VaList(bp, zTab)))
	if !(((*sqlite3rbu)(unsafe.Pointer(p)).Frc != 0) || (sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* &aStmt[0] */ + uintptr(0)*8))) != 100)) {
		goto __1
	}
	// Either an error, or no such table.
	goto rbuTableType_end
__1:
	;
	if !(sqlite3.Xsqlite3_column_int(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* &aStmt[0] */ + uintptr(0)*8)), 0) != 0) {
		goto __2
	}
	*(*int32)(unsafe.Pointer(peType)) = 5 // virtual table
	goto rbuTableType_end
__2:
	;
	*(*int32)(unsafe.Pointer(piTnum)) = sqlite3.Xsqlite3_column_int(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* &aStmt[0] */ + uintptr(0)*8)), 1)

	(*sqlite3rbu)(unsafe.Pointer(p)).Frc = prepareFreeAndCollectError(tls, (*sqlite3rbu)(unsafe.Pointer(p)).FdbMain, (bp + 32 /* &aStmt */ + uintptr(1)*8), (p + 64 /* &.zErrmsg */),
		sqlite3.Xsqlite3_mprintf(tls, ts+395 /* "PRAGMA index_lis..." */, crt.VaList(bp+8, zTab)))
	if !((*sqlite3rbu)(unsafe.Pointer(p)).Frc != 0) {
		goto __3
	}
	goto rbuTableType_end
__3:
	;
__4:
	if !(sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* &aStmt[0] */ + uintptr(1)*8))) == 100) {
		goto __5
	}
	zOrig = sqlite3.Xsqlite3_column_text(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* &aStmt[0] */ + uintptr(1)*8)), 3)
	zIdx = sqlite3.Xsqlite3_column_text(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* &aStmt[0] */ + uintptr(1)*8)), 1)
	if !(((zOrig != 0) && (zIdx != 0)) && (int32(*(*u8)(unsafe.Pointer(zOrig + uintptr(0)))) == 'p')) {
		goto __6
	}
	(*sqlite3rbu)(unsafe.Pointer(p)).Frc = prepareFreeAndCollectError(tls, (*sqlite3rbu)(unsafe.Pointer(p)).FdbMain, (bp + 32 /* &aStmt */ + uintptr(2)*8), (p + 64 /* &.zErrmsg */),
		sqlite3.Xsqlite3_mprintf(tls,
			ts+10466 /* "SELECT rootpage ..." */, crt.VaList(bp+16, zIdx)))
	if !((*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0) {
		goto __7
	}
	if !(sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* &aStmt[0] */ + uintptr(2)*8))) == 100) {
		goto __8
	}
	*(*int32)(unsafe.Pointer(piPk)) = sqlite3.Xsqlite3_column_int(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* &aStmt[0] */ + uintptr(2)*8)), 0)
	*(*int32)(unsafe.Pointer(peType)) = 3
	goto __9
__8:
	*(*int32)(unsafe.Pointer(peType)) = 4
__9:
	;
__7:
	;
	goto rbuTableType_end
__6:
	;
	goto __4
__5:
	;

	(*sqlite3rbu)(unsafe.Pointer(p)).Frc = prepareFreeAndCollectError(tls, (*sqlite3rbu)(unsafe.Pointer(p)).FdbMain, (bp + 32 /* &aStmt */ + uintptr(3)*8), (p + 64 /* &.zErrmsg */),
		sqlite3.Xsqlite3_mprintf(tls, ts+333 /* "PRAGMA table_inf..." */, crt.VaList(bp+24, zTab)))
	if !((*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0) {
		goto __10
	}
__11:
	if !(sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* &aStmt[0] */ + uintptr(3)*8))) == 100) {
		goto __12
	}
	if !(sqlite3.Xsqlite3_column_int(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* &aStmt[0] */ + uintptr(3)*8)), 5) > 0) {
		goto __13
	}
	*(*int32)(unsafe.Pointer(peType)) = 2 // explicit IPK column
	goto rbuTableType_end
__13:
	;
	goto __11
__12:
	;
	*(*int32)(unsafe.Pointer(peType)) = 1
__10:
	;

rbuTableType_end:
	i = uint32(0)
__14:
	if !(uint64(i) < (uint64(unsafe.Sizeof([4]uintptr{})) / uint64(unsafe.Sizeof(uintptr(0))))) {
		goto __16
	}
	rbuFinalize(tls, p, *(*uintptr)(unsafe.Pointer(bp + 32 /* &aStmt[0] */ + uintptr(i)*8)))
	goto __15
__15:
	i++
	goto __14
	goto __16
__16:
}

var __func__48 = *(*[13]int8)(unsafe.Pointer(ts + 10517 /* "rbuTableType" */)) /* sqlite3rbu.c:1182:2 */

// This is a helper function for rbuObjIterCacheTableInfo(). It populates
// the pIter->abIndexed[] array.
func rbuObjIterCacheIndexedCols(tls *crt.TLS, p uintptr, pIter uintptr) { /* sqlite3rbu.c:1260:13: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	*(*uintptr)(unsafe.Pointer(bp + 16 /* pList */)) = uintptr(0)
	var bIndex int32 = 0

	if (*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0 {
		crt.Xmemcpy(tls, (*RbuObjIter)(unsafe.Pointer(pIter)).FabIndexed, (*RbuObjIter)(unsafe.Pointer(pIter)).FabTblPk, (uint64(unsafe.Sizeof(u8(0))) * uint64((*RbuObjIter)(unsafe.Pointer(pIter)).FnTblCol)))
		(*sqlite3rbu)(unsafe.Pointer(p)).Frc = prepareFreeAndCollectError(tls, (*sqlite3rbu)(unsafe.Pointer(p)).FdbMain, bp+16 /* &pList */, (p + 64 /* &.zErrmsg */),
			sqlite3.Xsqlite3_mprintf(tls, ts+10530 /* "PRAGMA main.inde..." */, crt.VaList(bp, (*RbuObjIter)(unsafe.Pointer(pIter)).FzTbl)))
	}

	(*RbuObjIter)(unsafe.Pointer(pIter)).FnIndex = 0
	for ((*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0) && (100 == sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* pList */)))) {
		var zIdx uintptr = sqlite3.Xsqlite3_column_text(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* pList */)), 1)
		var bPartial int32 = sqlite3.Xsqlite3_column_int(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* pList */)), 4)
		*(*uintptr)(unsafe.Pointer(bp + 24 /* pXInfo */)) = uintptr(0)
		if zIdx == uintptr(0) {
			break
		}
		if bPartial != 0 {
			crt.Xmemset(tls, (*RbuObjIter)(unsafe.Pointer(pIter)).FabIndexed, 0x01, (uint64(unsafe.Sizeof(u8(0))) * uint64((*RbuObjIter)(unsafe.Pointer(pIter)).FnTblCol)))
		}
		(*sqlite3rbu)(unsafe.Pointer(p)).Frc = prepareFreeAndCollectError(tls, (*sqlite3rbu)(unsafe.Pointer(p)).FdbMain, bp+24 /* &pXInfo */, (p + 64 /* &.zErrmsg */),
			sqlite3.Xsqlite3_mprintf(tls, ts+10558 /* "PRAGMA main.inde..." */, crt.VaList(bp+8, zIdx)))
		for ((*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0) && (100 == sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 24 /* pXInfo */)))) {
			var iCid int32 = sqlite3.Xsqlite3_column_int(tls, *(*uintptr)(unsafe.Pointer(bp + 24 /* pXInfo */)), 1)
			if iCid >= 0 {
				*(*u8)(unsafe.Pointer((*RbuObjIter)(unsafe.Pointer(pIter)).FabIndexed + uintptr(iCid))) = u8(1)
			}
			if iCid == -2 {
				crt.Xmemset(tls, (*RbuObjIter)(unsafe.Pointer(pIter)).FabIndexed, 0x01, (uint64(unsafe.Sizeof(u8(0))) * uint64((*RbuObjIter)(unsafe.Pointer(pIter)).FnTblCol)))
			}
		}
		rbuFinalize(tls, p, *(*uintptr)(unsafe.Pointer(bp + 24 /* pXInfo */)))
		bIndex = 1
		(*RbuObjIter)(unsafe.Pointer(pIter)).FnIndex++
	}

	if (*RbuObjIter)(unsafe.Pointer(pIter)).FeType == 4 {
		// "PRAGMA index_list" includes the main PK b-tree
		(*RbuObjIter)(unsafe.Pointer(pIter)).FnIndex--
	}

	rbuFinalize(tls, p, *(*uintptr)(unsafe.Pointer(bp + 16 /* pList */)))
	if bIndex == 0 {
		(*RbuObjIter)(unsafe.Pointer(pIter)).FabIndexed = uintptr(0)
	}
}

// If they are not already populated, populate the pIter->azTblCol[],
// pIter->abTblPk[], pIter->nTblCol and pIter->bRowid variables according to
// the table (not index) that the iterator currently points to.
//
// Return SQLITE_OK if successful, or an SQLite error code otherwise. If
// an error does occur, an error code and error message are also left in
// the RBU handle.
func rbuObjIterCacheTableInfo(tls *crt.TLS, p uintptr, pIter uintptr) int32 { /* sqlite3rbu.c:1314:12: */
	bp := tls.Alloc(72)
	defer tls.Free(72)

	if (*RbuObjIter)(unsafe.Pointer(pIter)).FazTblCol == uintptr(0) {
		*(*uintptr)(unsafe.Pointer(bp + 64 /* pStmt */)) = uintptr(0)
		var nCol int32 = 0
		var i int32             // for() loop iterator variable
		var bRbuRowid int32 = 0 // If input table has column "rbu_rowid"
		var iOrder int32 = 0
		*(*int32)(unsafe.Pointer(bp + 56 /* iTnum */)) = 0

		// Figure out the type of table this step will deal with.
		if !((*RbuObjIter)(unsafe.Pointer(pIter)).FeType == 0) {
			crt.X__assert_fail(tls, ts+10587 /* "pIter->eType==0" */, ts+9694 /* "testdata/sqlite-..." */, uint32(1324), uintptr(unsafe.Pointer(&__func__49)))
		}
		rbuTableType(tls, p, (*RbuObjIter)(unsafe.Pointer(pIter)).FzTbl, (pIter + 72 /* &.eType */), bp+56 /* &iTnum */, (pIter + 108 /* &.iPkTnum */))
		if ((*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0) && ((*RbuObjIter)(unsafe.Pointer(pIter)).FeType == 0) {
			(*sqlite3rbu)(unsafe.Pointer(p)).Frc = 1
			(*sqlite3rbu)(unsafe.Pointer(p)).FzErrmsg = sqlite3.Xsqlite3_mprintf(tls, ts+10603 /* "no such table: %..." */, crt.VaList(bp, (*RbuObjIter)(unsafe.Pointer(pIter)).FzTbl))
		}
		if (*sqlite3rbu)(unsafe.Pointer(p)).Frc != 0 {
			return (*sqlite3rbu)(unsafe.Pointer(p)).Frc
		}
		if (*RbuObjIter)(unsafe.Pointer(pIter)).FzIdx == uintptr(0) {
			(*RbuObjIter)(unsafe.Pointer(pIter)).FiTnum = *(*int32)(unsafe.Pointer(bp + 56 /* iTnum */))
		}

		if !((((((*RbuObjIter)(unsafe.Pointer(pIter)).FeType == 1) || ((*RbuObjIter)(unsafe.Pointer(pIter)).FeType == 2)) || ((*RbuObjIter)(unsafe.Pointer(pIter)).FeType == 3)) || ((*RbuObjIter)(unsafe.Pointer(pIter)).FeType == 4)) || ((*RbuObjIter)(unsafe.Pointer(pIter)).FeType == 5)) {
			crt.X__assert_fail(tls, ts+10621 /* "pIter->eType==1 ..." */, ts+9694 /* "testdata/sqlite-..." */, uint32(1333), uintptr(unsafe.Pointer(&__func__49)))
		}

		// Populate the azTblCol[] and nTblCol variables based on the columns
		// of the input table. Ignore any input table columns that begin with
		// "rbu_".
		(*sqlite3rbu)(unsafe.Pointer(p)).Frc = prepareFreeAndCollectError(tls, (*sqlite3rbu)(unsafe.Pointer(p)).FdbRbu, bp+64 /* &pStmt */, (p + 64 /* &.zErrmsg */),
			sqlite3.Xsqlite3_mprintf(tls, ts+10713 /* "SELECT * FROM '%..." */, crt.VaList(bp+8, (*RbuObjIter)(unsafe.Pointer(pIter)).FzDataTbl)))
		if (*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0 {
			nCol = sqlite3.Xsqlite3_column_count(tls, *(*uintptr)(unsafe.Pointer(bp + 64 /* pStmt */)))
			rbuAllocateIterArrays(tls, p, pIter, nCol)
		}
		for i = 0; ((*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0) && (i < nCol); i++ {
			var zName uintptr = sqlite3.Xsqlite3_column_name(tls, *(*uintptr)(unsafe.Pointer(bp + 64 /* pStmt */)), i)
			if sqlite3.Xsqlite3_strnicmp(tls, ts+10732 /* "rbu_" */, zName, 4) != 0 {
				var zCopy uintptr = rbuStrndup(tls, zName, (p + 56 /* &.rc */))
				*(*int32)(unsafe.Pointer((*RbuObjIter)(unsafe.Pointer(pIter)).FaiSrcOrder + uintptr((*RbuObjIter)(unsafe.Pointer(pIter)).FnTblCol)*4)) = (*RbuObjIter)(unsafe.Pointer(pIter)).FnTblCol
				*(*uintptr)(unsafe.Pointer((*RbuObjIter)(unsafe.Pointer(pIter)).FazTblCol + uintptr(crt.PostIncInt32(&(*RbuObjIter)(unsafe.Pointer(pIter)).FnTblCol, 1))*8)) = zCopy
			} else if 0 == sqlite3.Xsqlite3_stricmp(tls, ts+10737 /* "rbu_rowid" */, zName) {
				bRbuRowid = 1
			}
		}
		sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 64 /* pStmt */)))
		*(*uintptr)(unsafe.Pointer(bp + 64 /* pStmt */)) = uintptr(0)

		if (((*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0) &&
			((crt.Bool32((*sqlite3rbu)(unsafe.Pointer((p))).FzTarget == uintptr(0))) == 0)) &&
			(bRbuRowid != (crt.Bool32(((*RbuObjIter)(unsafe.Pointer(pIter)).FeType == 5) || ((*RbuObjIter)(unsafe.Pointer(pIter)).FeType == 1)))) {
			(*sqlite3rbu)(unsafe.Pointer(p)).Frc = 1
			(*sqlite3rbu)(unsafe.Pointer(p)).FzErrmsg = sqlite3.Xsqlite3_mprintf(tls,
				ts+10747 /* "table %q %s rbu_..." */, crt.VaList(bp+16, (*RbuObjIter)(unsafe.Pointer(pIter)).FzDataTbl,
					func() uintptr {
						if bRbuRowid != 0 {
							return ts + 10776 /* "may not have" */
						}
						return ts + 10789 /* "requires" */
					}()))
		}

		// Check that all non-HIDDEN columns in the destination table are also
		// present in the input table. Populate the abTblPk[], azTblType[] and
		// aiTblOrder[] arrays at the same time.
		if (*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0 {
			(*sqlite3rbu)(unsafe.Pointer(p)).Frc = prepareFreeAndCollectError(tls, (*sqlite3rbu)(unsafe.Pointer(p)).FdbMain, bp+64 /* &pStmt */, (p + 64 /* &.zErrmsg */),
				sqlite3.Xsqlite3_mprintf(tls, ts+10798 /* "PRAGMA table_inf..." */, crt.VaList(bp+32, (*RbuObjIter)(unsafe.Pointer(pIter)).FzTbl)))
		}
		for ((*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0) && (100 == sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 64 /* pStmt */)))) {
			var zName uintptr = sqlite3.Xsqlite3_column_text(tls, *(*uintptr)(unsafe.Pointer(bp + 64 /* pStmt */)), 1)
			if zName == uintptr(0) {
				break
			} // An OOM - finalize() below returns S_NOMEM
			for i = iOrder; i < (*RbuObjIter)(unsafe.Pointer(pIter)).FnTblCol; i++ {
				if 0 == crt.Xstrcmp(tls, zName, *(*uintptr)(unsafe.Pointer((*RbuObjIter)(unsafe.Pointer(pIter)).FazTblCol + uintptr(i)*8))) {
					break
				}
			}
			if i == (*RbuObjIter)(unsafe.Pointer(pIter)).FnTblCol {
				(*sqlite3rbu)(unsafe.Pointer(p)).Frc = 1
				(*sqlite3rbu)(unsafe.Pointer(p)).FzErrmsg = sqlite3.Xsqlite3_mprintf(tls, ts+10820, /* "column missing f..." */
					crt.VaList(bp+40, (*RbuObjIter)(unsafe.Pointer(pIter)).FzDataTbl, zName))
			} else {
				var iPk int32 = sqlite3.Xsqlite3_column_int(tls, *(*uintptr)(unsafe.Pointer(bp + 64 /* pStmt */)), 5)
				var bNotNull int32 = sqlite3.Xsqlite3_column_int(tls, *(*uintptr)(unsafe.Pointer(bp + 64 /* pStmt */)), 3)
				var zType uintptr = sqlite3.Xsqlite3_column_text(tls, *(*uintptr)(unsafe.Pointer(bp + 64 /* pStmt */)), 2)

				if i != iOrder {
					{
						var t int32 = *(*int32)(unsafe.Pointer((*RbuObjIter)(unsafe.Pointer(pIter)).FaiSrcOrder + uintptr(i)*4))
						*(*int32)(unsafe.Pointer((*RbuObjIter)(unsafe.Pointer(pIter)).FaiSrcOrder + uintptr(i)*4)) = *(*int32)(unsafe.Pointer((*RbuObjIter)(unsafe.Pointer(pIter)).FaiSrcOrder + uintptr(iOrder)*4))
						*(*int32)(unsafe.Pointer((*RbuObjIter)(unsafe.Pointer(pIter)).FaiSrcOrder + uintptr(iOrder)*4)) = t
					}

					{
						var t uintptr = *(*uintptr)(unsafe.Pointer((*RbuObjIter)(unsafe.Pointer(pIter)).FazTblCol + uintptr(i)*8))
						*(*uintptr)(unsafe.Pointer((*RbuObjIter)(unsafe.Pointer(pIter)).FazTblCol + uintptr(i)*8)) = *(*uintptr)(unsafe.Pointer((*RbuObjIter)(unsafe.Pointer(pIter)).FazTblCol + uintptr(iOrder)*8))
						*(*uintptr)(unsafe.Pointer((*RbuObjIter)(unsafe.Pointer(pIter)).FazTblCol + uintptr(iOrder)*8)) = t
					}
				}

				*(*uintptr)(unsafe.Pointer((*RbuObjIter)(unsafe.Pointer(pIter)).FazTblType + uintptr(iOrder)*8)) = rbuStrndup(tls, zType, (p + 56 /* &.rc */))
				if !(iPk >= 0) {
					crt.X__assert_fail(tls, ts+10847 /* "iPk>=0" */, ts+9694 /* "testdata/sqlite-..." */, uint32(1403), uintptr(unsafe.Pointer(&__func__49)))
				}
				*(*u8)(unsafe.Pointer((*RbuObjIter)(unsafe.Pointer(pIter)).FabTblPk + uintptr(iOrder))) = u8(iPk)
				*(*u8)(unsafe.Pointer((*RbuObjIter)(unsafe.Pointer(pIter)).FabNotNull + uintptr(iOrder))) = (u8(crt.Bool32((u8(bNotNull) != 0) || (iPk != 0))))
				iOrder++
			}
		}

		rbuFinalize(tls, p, *(*uintptr)(unsafe.Pointer(bp + 64 /* pStmt */)))
		rbuObjIterCacheIndexedCols(tls, p, pIter)
		if !(((*RbuObjIter)(unsafe.Pointer(pIter)).FeType != 5) || ((*RbuObjIter)(unsafe.Pointer(pIter)).FabIndexed == uintptr(0))) {
			crt.X__assert_fail(tls, ts+10854 /* "pIter->eType!=5 ..." */, ts+9694 /* "testdata/sqlite-..." */, uint32(1412), uintptr(unsafe.Pointer(&__func__49)))
		}
		if !(((*RbuObjIter)(unsafe.Pointer(pIter)).FeType != 5) || ((*RbuObjIter)(unsafe.Pointer(pIter)).FnIndex == 0)) {
			crt.X__assert_fail(tls, ts+10893 /* "pIter->eType!=5 ..." */, ts+9694 /* "testdata/sqlite-..." */, uint32(1413), uintptr(unsafe.Pointer(&__func__49)))
		}
	}

	return (*sqlite3rbu)(unsafe.Pointer(p)).Frc
}

var __func__49 = *(*[25]int8)(unsafe.Pointer(ts + 10929 /* "rbuObjIterCacheT..." */)) /* sqlite3rbu.c:1314:70 */

// This function constructs and returns a pointer to a nul-terminated
// string containing some SQL clause or list based on one or more of the
// column names currently stored in the pIter->azTblCol[] array.
func rbuObjIterGetCollist(tls *crt.TLS, p uintptr, pIter uintptr) uintptr { /* sqlite3rbu.c:1424:13: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	var zList uintptr = uintptr(0)
	var zSep uintptr = ts + 792 /* "" */
	var i int32
	for i = 0; i < (*RbuObjIter)(unsafe.Pointer(pIter)).FnTblCol; i++ {
		var z uintptr = *(*uintptr)(unsafe.Pointer((*RbuObjIter)(unsafe.Pointer(pIter)).FazTblCol + uintptr(i)*8))
		zList = rbuMPrintf(tls, p, ts+10954 /* "%z%s\"%w\"" */, crt.VaList(bp, zList, zSep, z))
		zSep = ts + 359 /* ", " */
	}
	return zList
}

// Return a comma separated list of the quoted PRIMARY KEY column names,
// in order, for the current table. Before each column name, add the text
// zPre. After each column name, add the zPost text. Use zSeparator as
// the separator text (usually ", ").
func rbuObjIterGetPkList(tls *crt.TLS, p uintptr, pIter uintptr, zPre uintptr, zSeparator uintptr, zPost uintptr) uintptr { /* sqlite3rbu.c:1445:13: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	var iPk int32 = 1
	var zRet uintptr = uintptr(0)
	var zSep uintptr = ts + 792 /* "" */
	for 1 != 0 {
		var i int32
		for i = 0; i < (*RbuObjIter)(unsafe.Pointer(pIter)).FnTblCol; i++ {
			if int32(*(*u8)(unsafe.Pointer((*RbuObjIter)(unsafe.Pointer(pIter)).FabTblPk + uintptr(i)))) == iPk {
				var zCol uintptr = *(*uintptr)(unsafe.Pointer((*RbuObjIter)(unsafe.Pointer(pIter)).FazTblCol + uintptr(i)*8))
				zRet = rbuMPrintf(tls, p, ts+10963 /* "%z%s%s\"%w\"%s" */, crt.VaList(bp, zRet, zSep, zPre, zCol, zPost))
				zSep = zSeparator
				break
			}
		}
		if i == (*RbuObjIter)(unsafe.Pointer(pIter)).FnTblCol {
			break
		}
		iPk++
	}
	return zRet
}

// This function is called as part of restarting an RBU vacuum within
// stage 1 of the process (while the *-oal file is being built) while
// updating a table (not an index). The table may be a rowid table or
// a WITHOUT ROWID table. It queries the target database to find the
// largest key that has already been written to the target table and
// constructs a WHERE clause that can be used to extract the remaining
// rows from the source table. For a rowid table, the WHERE clause
// is of the form:
//
//     "WHERE _rowid_ > ?"
//
// and for WITHOUT ROWID tables:
//
//     "WHERE (key1, key2) > (?, ?)"
//
// Instead of "?" placeholders, the actual WHERE clauses created by
// this function contain literal SQL values.
func rbuVacuumTableStart(tls *crt.TLS, p uintptr, pIter uintptr, bRowid int32, zWrite uintptr) uintptr { /* sqlite3rbu.c:1490:13: */
	bp := tls.Alloc(80)
	defer tls.Free(80)

	*(*uintptr)(unsafe.Pointer(bp + 72 /* pMax */)) = uintptr(0)
	var zRet uintptr = uintptr(0)
	if bRowid != 0 {
		(*sqlite3rbu)(unsafe.Pointer(p)).Frc = prepareFreeAndCollectError(tls, (*sqlite3rbu)(unsafe.Pointer(p)).FdbMain, bp+72 /* &pMax */, (p + 64 /* &.zErrmsg */),
			sqlite3.Xsqlite3_mprintf(tls,
				ts+10976 /* "SELECT max(_rowi..." */, crt.VaList(bp, zWrite, (*RbuObjIter)(unsafe.Pointer(pIter)).FzTbl)))
		if ((*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0) && (100 == sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 72 /* pMax */)))) {
			var iMax sqlite3_int64 = sqlite3.Xsqlite3_column_int64(tls, *(*uintptr)(unsafe.Pointer(bp + 72 /* pMax */)), 0)
			zRet = rbuMPrintf(tls, p, ts+11008 /* " WHERE _rowid_ >..." */, crt.VaList(bp+16, iMax))
		}
		rbuFinalize(tls, p, *(*uintptr)(unsafe.Pointer(bp + 72 /* pMax */)))
	} else {
		var zOrder uintptr = rbuObjIterGetPkList(tls, p, pIter, ts+792 /* "" */, ts+359 /* ", " */, ts+389 /* " DESC" */)
		var zSelect uintptr = rbuObjIterGetPkList(tls, p, pIter, ts+11031 /* "quote(" */, ts+11038 /* "||','||" */, ts+793 /* ")" */)
		var zList uintptr = rbuObjIterGetPkList(tls, p, pIter, ts+792 /* "" */, ts+359 /* ", " */, ts+792 /* "" */)

		if (*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0 {
			(*sqlite3rbu)(unsafe.Pointer(p)).Frc = prepareFreeAndCollectError(tls, (*sqlite3rbu)(unsafe.Pointer(p)).FdbMain, bp+72 /* &pMax */, (p + 64 /* &.zErrmsg */),
				sqlite3.Xsqlite3_mprintf(tls,
					ts+11046, /* "SELECT %s FROM \"..." */
					crt.VaList(bp+24, zSelect, zWrite, (*RbuObjIter)(unsafe.Pointer(pIter)).FzTbl, zOrder)))
			if ((*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0) && (100 == sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 72 /* pMax */)))) {
				var zVal uintptr = sqlite3.Xsqlite3_column_text(tls, *(*uintptr)(unsafe.Pointer(bp + 72 /* pMax */)), 0)
				zRet = rbuMPrintf(tls, p, ts+11088 /* " WHERE (%s) > (%..." */, crt.VaList(bp+56, zList, zVal))
			}
			rbuFinalize(tls, p, *(*uintptr)(unsafe.Pointer(bp + 72 /* pMax */)))
		}

		sqlite3.Xsqlite3_free(tls, zOrder)
		sqlite3.Xsqlite3_free(tls, zSelect)
		sqlite3.Xsqlite3_free(tls, zList)
	}
	return zRet
}

// This function is called as part of restating an RBU vacuum when the
// current operation is writing content to an index. If possible, it
// queries the target index b-tree for the largest key already written to
// it, then composes and returns an expression that can be used in a WHERE
// clause to select the remaining required rows from the source table.
// It is only possible to return such an expression if:
//
//   * The index contains no DESC columns, and
//   * The last key written to the index before the operation was
//     suspended does not contain any NULL values.
//
// The expression is of the form:
//
//   (index-field1, index-field2, ...) > (?, ?, ...)
//
// except that the "?" placeholders are replaced with literal values.
//
// If the expression cannot be created, NULL is returned. In this case,
// the caller has to use an OFFSET clause to extract only the required
// rows from the sourct table, just as it does for an RBU update operation.
func rbuVacuumIndexStart(tls *crt.TLS, p uintptr, pIter uintptr) uintptr { /* sqlite3rbu.c:1557:6: */
	bp := tls.Alloc(192)
	defer tls.Free(192)

	var zOrder uintptr
	var zLhs uintptr
	var zSelect uintptr
	var zVector uintptr
	var zRet uintptr
	var bFailed int32
	var zSep uintptr
	var iCol int32
	// var pXInfo uintptr at bp+176, 8

	var i int32
	var iCid int32
	var zCollate uintptr
	var zCol uintptr
	var zQuoted uintptr
	// var pSel uintptr at bp+184, 8
	zOrder = uintptr(0)
	zLhs = uintptr(0)
	zSelect = uintptr(0)
	zVector = uintptr(0)
	zRet = uintptr(0)
	bFailed = 0
	zSep = ts + 792 /* "" */
	iCol = 0
	*(*uintptr)(unsafe.Pointer(bp + 176 /* pXInfo */)) = uintptr(0)

	(*sqlite3rbu)(unsafe.Pointer(p)).Frc = prepareFreeAndCollectError(tls, (*sqlite3rbu)(unsafe.Pointer(p)).FdbMain, bp+176 /* &pXInfo */, (p + 64 /* &.zErrmsg */),
		sqlite3.Xsqlite3_mprintf(tls, ts+10558 /* "PRAGMA main.inde..." */, crt.VaList(bp, (*RbuObjIter)(unsafe.Pointer(pIter)).FzIdx)))
__1:
	if !(((*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0) && (100 == sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 176 /* pXInfo */))))) {
		goto __2
	}
	iCid = sqlite3.Xsqlite3_column_int(tls, *(*uintptr)(unsafe.Pointer(bp + 176 /* pXInfo */)), 1)
	zCollate = sqlite3.Xsqlite3_column_text(tls, *(*uintptr)(unsafe.Pointer(bp + 176 /* pXInfo */)), 4)
	if !(sqlite3.Xsqlite3_column_int(tls, *(*uintptr)(unsafe.Pointer(bp + 176 /* pXInfo */)), 3) != 0) {
		goto __3
	}
	bFailed = 1
	goto __2
__3:
	;

	if !(iCid < 0) {
		goto __4
	}
	if !((*RbuObjIter)(unsafe.Pointer(pIter)).FeType == 2) {
		goto __6
	}
	i = 0
__8:
	if !(int32(*(*u8)(unsafe.Pointer((*RbuObjIter)(unsafe.Pointer(pIter)).FabTblPk + uintptr(i)))) == 0) {
		goto __10
	}
	goto __9
__9:
	i++
	goto __8
	goto __10
__10:
	;
	if !(i < (*RbuObjIter)(unsafe.Pointer(pIter)).FnTblCol) {
		crt.X__assert_fail(tls, ts+11108 /* "i<pIter->nTblCol" */, ts+9694 /* "testdata/sqlite-..." */, uint32(1587), uintptr(unsafe.Pointer(&__func__50)))
	}
	zCol = *(*uintptr)(unsafe.Pointer((*RbuObjIter)(unsafe.Pointer(pIter)).FazTblCol + uintptr(i)*8))
	goto __7
__6:
	zCol = ts + 8365 /* "_rowid_" */
__7:
	;
	goto __5
__4:
	zCol = *(*uintptr)(unsafe.Pointer((*RbuObjIter)(unsafe.Pointer(pIter)).FazTblCol + uintptr(iCid)*8))
__5:
	;

	zLhs = rbuMPrintf(tls, p, ts+11125, /* "%z%s \"%w\" COLLAT..." */
		crt.VaList(bp+8, zLhs, zSep, zCol, zCollate))
	zOrder = rbuMPrintf(tls, p, ts+11146, /* "%z%s \"rbu_imp_%d..." */
		crt.VaList(bp+40, zOrder, zSep, iCol, zCol, zCollate))
	zSelect = rbuMPrintf(tls, p, ts+11182, /* "%z%s quote(\"rbu_..." */
		crt.VaList(bp+80, zSelect, zSep, iCol, zCol))
	zSep = ts + 359 /* ", " */
	iCol++
	goto __1
__2:
	;
	rbuFinalize(tls, p, *(*uintptr)(unsafe.Pointer(bp + 176 /* pXInfo */)))
	if !(bFailed != 0) {
		goto __11
	}
	goto index_start_out
__11:
	;

	if !((*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0) {
		goto __12
	}
	*(*uintptr)(unsafe.Pointer(bp + 184 /* pSel */)) = uintptr(0)

	(*sqlite3rbu)(unsafe.Pointer(p)).Frc = prepareFreeAndCollectError(tls, (*sqlite3rbu)(unsafe.Pointer(p)).FdbMain, bp+184 /* &pSel */, (p + 64 /* &.zErrmsg */),
		sqlite3.Xsqlite3_mprintf(tls, ts+11209, /* "SELECT %s FROM \"..." */
			crt.VaList(bp+112, zSelect, (*RbuObjIter)(unsafe.Pointer(pIter)).FzTbl, zOrder)))
	if !(((*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0) && (100 == sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 184 /* pSel */))))) {
		goto __13
	}
	zSep = ts + 792 /* "" */
	iCol = 0
__14:
	if !(iCol < (*RbuObjIter)(unsafe.Pointer(pIter)).FnCol) {
		goto __16
	}
	zQuoted = sqlite3.Xsqlite3_column_text(tls, *(*uintptr)(unsafe.Pointer(bp + 184 /* pSel */)), iCol)
	if !(int32(*(*int8)(unsafe.Pointer(zQuoted + uintptr(0)))) == 'N') {
		goto __17
	}
	bFailed = 1
	goto __16
__17:
	;
	zVector = rbuMPrintf(tls, p, ts+11257 /* "%z%s%s" */, crt.VaList(bp+136, zVector, zSep, zQuoted))
	zSep = ts + 359 /* ", " */
	goto __15
__15:
	iCol++
	goto __14
	goto __16
__16:
	;

	if !(!(bFailed != 0)) {
		goto __18
	}
	zRet = rbuMPrintf(tls, p, ts+11264 /* "(%s) > (%s)" */, crt.VaList(bp+160, zLhs, zVector))
__18:
	;
__13:
	;
	rbuFinalize(tls, p, *(*uintptr)(unsafe.Pointer(bp + 184 /* pSel */)))
__12:
	;

index_start_out:
	sqlite3.Xsqlite3_free(tls, zOrder)
	sqlite3.Xsqlite3_free(tls, zSelect)
	sqlite3.Xsqlite3_free(tls, zVector)
	sqlite3.Xsqlite3_free(tls, zLhs)
	return zRet
}

var __func__50 = *(*[20]int8)(unsafe.Pointer(ts + 11276 /* "rbuVacuumIndexSt..." */)) /* sqlite3rbu.c:1560:2 */

// This function is used to create a SELECT list (the list of SQL
// expressions that follows a SELECT keyword) for a SELECT statement
// used to read from an data_xxx or rbu_tmp_xxx table while updating the
// index object currently indicated by the iterator object passed as the
// second argument. A "PRAGMA index_xinfo = <idxname>" statement is used
// to obtain the required information.
//
// If the index is of the following form:
//
//   CREATE INDEX i1 ON t1(c, b COLLATE nocase);
//
// and "t1" is a table with an explicit INTEGER PRIMARY KEY column
// "ipk", the returned string is:
//
//   "`c` COLLATE 'BINARY', `b` COLLATE 'NOCASE', `ipk` COLLATE 'BINARY'"
//
// As well as the returned string, three other malloc'd strings are
// returned via output parameters. As follows:
//
//   pzImposterCols: ...
//   pzImposterPk: ...
//   pzWhere: ...
func rbuObjIterGetIndexCols(tls *crt.TLS, p uintptr, pIter uintptr, pzImposterCols uintptr, pzImposterPk uintptr, pzWhere uintptr, pnBind uintptr) uintptr { /* sqlite3rbu.c:1670:13: */
	bp := tls.Alloc(208)
	defer tls.Free(208)

	var rc int32 = (*sqlite3rbu)(unsafe.Pointer(p)).Frc             // Error code
	var rc2 int32                                                   // sqlite3_finalize() return code
	var zRet uintptr = uintptr(0)                                   // String to return
	var zImpCols uintptr = uintptr(0)                               // String to return via *pzImposterCols
	var zImpPK uintptr = uintptr(0)                                 // String to return via *pzImposterPK
	var zWhere uintptr = uintptr(0)                                 // String to return via *pzWhere
	var nBind int32 = 0                                             // Value to return via *pnBind
	var zCom uintptr = ts + 792                                     /* "" */ // Set to ", " later on
	var zAnd uintptr = ts + 792                                     /* "" */ // Set to " AND " later on
	*(*uintptr)(unsafe.Pointer(bp + 200 /* pXInfo */)) = uintptr(0) // PRAGMA index_xinfo = ?

	if rc == 0 {
		if !((*sqlite3rbu)(unsafe.Pointer(p)).FzErrmsg == uintptr(0)) {
			crt.X__assert_fail(tls, ts+11296 /* "p->zErrmsg==0" */, ts+9694 /* "testdata/sqlite-..." */, uint32(1690), uintptr(unsafe.Pointer(&__func__51)))
		}
		rc = prepareFreeAndCollectError(tls, (*sqlite3rbu)(unsafe.Pointer(p)).FdbMain, bp+200 /* &pXInfo */, (p + 64 /* &.zErrmsg */),
			sqlite3.Xsqlite3_mprintf(tls, ts+10558 /* "PRAGMA main.inde..." */, crt.VaList(bp, (*RbuObjIter)(unsafe.Pointer(pIter)).FzIdx)))
	}

	for (rc == 0) && (100 == sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 200 /* pXInfo */)))) {
		var iCid int32 = sqlite3.Xsqlite3_column_int(tls, *(*uintptr)(unsafe.Pointer(bp + 200 /* pXInfo */)), 1)
		var bDesc int32 = sqlite3.Xsqlite3_column_int(tls, *(*uintptr)(unsafe.Pointer(bp + 200 /* pXInfo */)), 3)
		var zCollate uintptr = sqlite3.Xsqlite3_column_text(tls, *(*uintptr)(unsafe.Pointer(bp + 200 /* pXInfo */)), 4)
		var zCol uintptr = uintptr(0)
		var zType uintptr

		if iCid == -2 {
			var iSeq int32 = sqlite3.Xsqlite3_column_int(tls, *(*uintptr)(unsafe.Pointer(bp + 200 /* pXInfo */)), 0)
			zRet = sqlite3.Xsqlite3_mprintf(tls, ts+11310 /* "%z%s(%.*s) COLLA..." */, crt.VaList(bp+8, zRet, zCom,
				(*RbuSpan)(unsafe.Pointer((*RbuObjIter)(unsafe.Pointer(pIter)).FaIdxCol+uintptr(iSeq)*16)).FnSpan, (*RbuSpan)(unsafe.Pointer((*RbuObjIter)(unsafe.Pointer(pIter)).FaIdxCol+uintptr(iSeq)*16)).FzSpan, zCollate))
			zType = ts + 792 /* "" */
		} else {
			if iCid < 0 {
				// An integer primary key. If the table has an explicit IPK, use
				// its name. Otherwise, use "rbu_rowid".
				if (*RbuObjIter)(unsafe.Pointer(pIter)).FeType == 2 {
					var i int32
					for i = 0; int32(*(*u8)(unsafe.Pointer((*RbuObjIter)(unsafe.Pointer(pIter)).FabTblPk + uintptr(i)))) == 0; i++ {
					}
					if !(i < (*RbuObjIter)(unsafe.Pointer(pIter)).FnTblCol) {
						crt.X__assert_fail(tls, ts+11108 /* "i<pIter->nTblCol" */, ts+9694 /* "testdata/sqlite-..." */, uint32(1716), uintptr(unsafe.Pointer(&__func__51)))
					}
					zCol = *(*uintptr)(unsafe.Pointer((*RbuObjIter)(unsafe.Pointer(pIter)).FazTblCol + uintptr(i)*8))
				} else if (*sqlite3rbu)(unsafe.Pointer((p))).FzTarget == uintptr(0) {
					zCol = ts + 8365 /* "_rowid_" */
				} else {
					zCol = ts + 10737 /* "rbu_rowid" */
				}
				zType = ts + 11332 /* "INTEGER" */
			} else {
				zCol = *(*uintptr)(unsafe.Pointer((*RbuObjIter)(unsafe.Pointer(pIter)).FazTblCol + uintptr(iCid)*8))
				zType = *(*uintptr)(unsafe.Pointer((*RbuObjIter)(unsafe.Pointer(pIter)).FazTblType + uintptr(iCid)*8))
			}
			zRet = sqlite3.Xsqlite3_mprintf(tls, ts+11340 /* "%z%s\"%w\" COLLATE..." */, crt.VaList(bp+48, zRet, zCom, zCol, zCollate))
		}

		if ((*RbuObjIter)(unsafe.Pointer(pIter)).FbUnique == 0) || (sqlite3.Xsqlite3_column_int(tls, *(*uintptr)(unsafe.Pointer(bp + 200 /* pXInfo */)), 5) != 0) {
			var zOrder uintptr = func() uintptr {
				if bDesc != 0 {
					return ts + 389 /* " DESC" */
				}
				return ts + 792 /* "" */
			}()
			zImpPK = sqlite3.Xsqlite3_mprintf(tls, ts+11360, /* "%z%s\"rbu_imp_%d%..." */
				crt.VaList(bp+80, zImpPK, zCom, nBind, zCol, zOrder))
		}
		zImpCols = sqlite3.Xsqlite3_mprintf(tls, ts+11381, /* "%z%s\"rbu_imp_%d%..." */
			crt.VaList(bp+120, zImpCols, zCom, nBind, zCol, zType, zCollate))
		zWhere = sqlite3.Xsqlite3_mprintf(tls,
			ts+11414 /* "%z%s\"rbu_imp_%d%..." */, crt.VaList(bp+168, zWhere, zAnd, nBind, zCol))
		if (((zRet == uintptr(0)) || (zImpPK == uintptr(0))) || (zImpCols == uintptr(0))) || (zWhere == uintptr(0)) {
			rc = 7
		}
		zCom = ts + 359   /* ", " */
		zAnd = ts + 11438 /* " AND " */
		nBind++
	}

	rc2 = sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 200 /* pXInfo */)))
	if rc == 0 {
		rc = rc2
	}

	if rc != 0 {
		sqlite3.Xsqlite3_free(tls, zRet)
		sqlite3.Xsqlite3_free(tls, zImpCols)
		sqlite3.Xsqlite3_free(tls, zImpPK)
		sqlite3.Xsqlite3_free(tls, zWhere)
		zRet = uintptr(0)
		zImpCols = uintptr(0)
		zImpPK = uintptr(0)
		zWhere = uintptr(0)
		(*sqlite3rbu)(unsafe.Pointer(p)).Frc = rc
	}

	*(*uintptr)(unsafe.Pointer(pzImposterCols)) = zImpCols
	*(*uintptr)(unsafe.Pointer(pzImposterPk)) = zImpPK
	*(*uintptr)(unsafe.Pointer(pzWhere)) = zWhere
	*(*int32)(unsafe.Pointer(pnBind)) = nBind
	return zRet
}

var __func__51 = *(*[23]int8)(unsafe.Pointer(ts + 11444 /* "rbuObjIterGetInd..." */)) /* sqlite3rbu.c:1677:2 */

// Assuming the current table columns are "a", "b" and "c", and the zObj
// paramter is passed "old", return a string of the form:
//
//     "old.a, old.b, old.b"
//
// With the column names escaped.
//
// For tables with implicit rowids - RBU_PK_EXTERNAL and RBU_PK_NONE, append
// the text ", old._rowid_" to the returned value.
func rbuObjIterGetOldlist(tls *crt.TLS, p uintptr, pIter uintptr, zObj uintptr) uintptr { /* sqlite3rbu.c:1782:13: */
	bp := tls.Alloc(64)
	defer tls.Free(64)

	var zList uintptr = uintptr(0)
	if ((*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0) && ((*RbuObjIter)(unsafe.Pointer(pIter)).FabIndexed != 0) {
		var zS uintptr = ts + 792 /* "" */
		var i int32
		for i = 0; i < (*RbuObjIter)(unsafe.Pointer(pIter)).FnTblCol; i++ {
			if *(*u8)(unsafe.Pointer((*RbuObjIter)(unsafe.Pointer(pIter)).FabIndexed + uintptr(i))) != 0 {
				var zCol uintptr = *(*uintptr)(unsafe.Pointer((*RbuObjIter)(unsafe.Pointer(pIter)).FazTblCol + uintptr(i)*8))
				zList = sqlite3.Xsqlite3_mprintf(tls, ts+11467 /* "%z%s%s.\"%w\"" */, crt.VaList(bp, zList, zS, zObj, zCol))
			} else {
				zList = sqlite3.Xsqlite3_mprintf(tls, ts+11479 /* "%z%sNULL" */, crt.VaList(bp+32, zList, zS))
			}
			zS = ts + 359 /* ", " */
			if zList == uintptr(0) {
				(*sqlite3rbu)(unsafe.Pointer(p)).Frc = 7
				break
			}
		}

		// For a table with implicit rowids, append "old._rowid_" to the list.
		if ((*RbuObjIter)(unsafe.Pointer(pIter)).FeType == 3) || ((*RbuObjIter)(unsafe.Pointer(pIter)).FeType == 1) {
			zList = rbuMPrintf(tls, p, ts+11488 /* "%z, %s._rowid_" */, crt.VaList(bp+48, zList, zObj))
		}
	}
	return zList
}

// Return an expression that can be used in a WHERE clause to match the
// primary key of the current table. For example, if the table is:
//
//   CREATE TABLE t1(a, b, c, PRIMARY KEY(b, c));
//
// Return the string:
//
//   "b = ?1 AND c = ?2"
func rbuObjIterGetWhere(tls *crt.TLS, p uintptr, pIter uintptr) uintptr { /* sqlite3rbu.c:1823:13: */
	bp := tls.Alloc(80)
	defer tls.Free(80)

	var zList uintptr = uintptr(0)
	if ((*RbuObjIter)(unsafe.Pointer(pIter)).FeType == 5) || ((*RbuObjIter)(unsafe.Pointer(pIter)).FeType == 1) {
		zList = rbuMPrintf(tls, p, ts+11503 /* "_rowid_ = ?%d" */, crt.VaList(bp, ((*RbuObjIter)(unsafe.Pointer(pIter)).FnTblCol+1)))
	} else if (*RbuObjIter)(unsafe.Pointer(pIter)).FeType == 3 {
		var zSep uintptr = ts + 792 /* "" */
		var i int32
		for i = 0; i < (*RbuObjIter)(unsafe.Pointer(pIter)).FnTblCol; i++ {
			if *(*u8)(unsafe.Pointer((*RbuObjIter)(unsafe.Pointer(pIter)).FabTblPk + uintptr(i))) != 0 {
				zList = rbuMPrintf(tls, p, ts+11517 /* "%z%sc%d=?%d" */, crt.VaList(bp+8, zList, zSep, i, (i+1)))
				zSep = ts + 11438 /* " AND " */
			}
		}
		zList = rbuMPrintf(tls, p,
			ts+11529 /* "_rowid_ = (SELEC..." */, crt.VaList(bp+40, zList))
	} else {
		var zSep uintptr = ts + 792 /* "" */
		var i int32
		for i = 0; i < (*RbuObjIter)(unsafe.Pointer(pIter)).FnTblCol; i++ {
			if *(*u8)(unsafe.Pointer((*RbuObjIter)(unsafe.Pointer(pIter)).FabTblPk + uintptr(i))) != 0 {
				var zCol uintptr = *(*uintptr)(unsafe.Pointer((*RbuObjIter)(unsafe.Pointer(pIter)).FazTblCol + uintptr(i)*8))
				zList = rbuMPrintf(tls, p, ts+11579 /* "%z%s\"%w\"=?%d" */, crt.VaList(bp+48, zList, zSep, zCol, (i+1)))
				zSep = ts + 11438 /* " AND " */
			}
		}
	}
	return zList
}

// The SELECT statement iterating through the keys for the current object
// (p->objiter.pSelect) currently points to a valid row. However, there
// is something wrong with the rbu_control value in the rbu_control value
// stored in the (p->nCol+1)'th column. Set the error code and error message
// of the RBU handle to something reflecting this.
func rbuBadControlError(tls *crt.TLS, p uintptr) { /* sqlite3rbu.c:1864:13: */
	(*sqlite3rbu)(unsafe.Pointer(p)).Frc = 1
	(*sqlite3rbu)(unsafe.Pointer(p)).FzErrmsg = sqlite3.Xsqlite3_mprintf(tls, ts+11592 /* "invalid rbu_cont..." */, 0)
}

// Return a nul-terminated string containing the comma separated list of
// assignments that should be included following the "SET" keyword of
// an UPDATE statement used to update the table object that the iterator
// passed as the second argument currently points to if the rbu_control
// column of the data_xxx table entry is set to zMask.
//
// The memory for the returned string is obtained from sqlite3_malloc().
// It is the responsibility of the caller to eventually free it using
// sqlite3_free().
//
// If an OOM error is encountered when allocating space for the new
// string, an error code is left in the rbu handle passed as the first
// argument and NULL is returned. Or, if an error has already occurred
// when this function is called, NULL is returned immediately, without
// attempting the allocation or modifying the stored error code.
func rbuObjIterGetSetlist(tls *crt.TLS, p uintptr, pIter uintptr, zMask uintptr) uintptr { /* sqlite3rbu.c:1887:13: */
	bp := tls.Alloc(112)
	defer tls.Free(112)

	var zList uintptr = uintptr(0)
	if (*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0 {
		var i int32

		if int32(crt.Xstrlen(tls, zMask)) != (*RbuObjIter)(unsafe.Pointer(pIter)).FnTblCol {
			rbuBadControlError(tls, p)
		} else {
			var zSep uintptr = ts + 792 /* "" */
			for i = 0; i < (*RbuObjIter)(unsafe.Pointer(pIter)).FnTblCol; i++ {
				var c int8 = *(*int8)(unsafe.Pointer(zMask + uintptr(*(*int32)(unsafe.Pointer((*RbuObjIter)(unsafe.Pointer(pIter)).FaiSrcOrder + uintptr(i)*4)))))
				if int32(c) == 'x' {
					zList = rbuMPrintf(tls, p, ts+11579, /* "%z%s\"%w\"=?%d" */
						crt.VaList(bp, zList, zSep, *(*uintptr)(unsafe.Pointer((*RbuObjIter)(unsafe.Pointer(pIter)).FazTblCol + uintptr(i)*8)), (i+1)))
					zSep = ts + 359 /* ", " */
				} else if int32(c) == 'd' {
					zList = rbuMPrintf(tls, p, ts+11618, /* "%z%s\"%w\"=rbu_del..." */
						crt.VaList(bp+32, zList, zSep, *(*uintptr)(unsafe.Pointer((*RbuObjIter)(unsafe.Pointer(pIter)).FazTblCol + uintptr(i)*8)), *(*uintptr)(unsafe.Pointer((*RbuObjIter)(unsafe.Pointer(pIter)).FazTblCol + uintptr(i)*8)), (i+1)))
					zSep = ts + 359 /* ", " */
				} else if int32(c) == 'f' {
					zList = rbuMPrintf(tls, p, ts+11648, /* "%z%s\"%w\"=rbu_fos..." */
						crt.VaList(bp+72, zList, zSep, *(*uintptr)(unsafe.Pointer((*RbuObjIter)(unsafe.Pointer(pIter)).FazTblCol + uintptr(i)*8)), *(*uintptr)(unsafe.Pointer((*RbuObjIter)(unsafe.Pointer(pIter)).FazTblCol + uintptr(i)*8)), (i+1)))
					zSep = ts + 359 /* ", " */
				}
			}
		}
	}
	return zList
}

// Return a nul-terminated string consisting of nByte comma separated
// "?" expressions. For example, if nByte is 3, return a pointer to
// a buffer containing the string "?,?,?".
//
// The memory for the returned string is obtained from sqlite3_malloc().
// It is the responsibility of the caller to eventually free it using
// sqlite3_free().
//
// If an OOM error is encountered when allocating space for the new
// string, an error code is left in the rbu handle passed as the first
// argument and NULL is returned. Or, if an error has already occurred
// when this function is called, NULL is returned immediately, without
// attempting the allocation or modifying the stored error code.
func rbuObjIterGetBindlist(tls *crt.TLS, p uintptr, nBind int32) uintptr { /* sqlite3rbu.c:1941:13: */
	var zRet uintptr = uintptr(0)
	var nByte sqlite3_int64 = ((int64(2) * sqlite3_int64(nBind)) + int64(1))

	zRet = rbuMalloc(tls, p, nByte)
	if zRet != 0 {
		var i int32
		for i = 0; i < nBind; i++ {
			*(*int8)(unsafe.Pointer(zRet + uintptr((i * 2)))) = int8('?')
			*(*int8)(unsafe.Pointer(zRet + uintptr(((i * 2) + 1)))) = func() int8 {
				if (i + 1) == nBind {
					return int8(0)
				}
				return int8(',')
			}()
		}
	}
	return zRet
}

// The iterator currently points to a table (not index) of type
// RBU_PK_WITHOUT_ROWID. This function creates the PRIMARY KEY
// declaration for the corresponding imposter table. For example,
// if the iterator points to a table created as:
//
//   CREATE TABLE t1(a, b, c, PRIMARY KEY(b, a DESC)) WITHOUT ROWID
//
// this function returns:
//
//   PRIMARY KEY("b", "a" DESC)
func rbuWithoutRowidPK(tls *crt.TLS, p uintptr, pIter uintptr) uintptr { /* sqlite3rbu.c:1968:13: */
	bp := tls.Alloc(72)
	defer tls.Free(72)

	var z uintptr = uintptr(0)
	if !((*RbuObjIter)(unsafe.Pointer(pIter)).FzIdx == uintptr(0)) {
		crt.X__assert_fail(tls, ts+11685 /* "pIter->zIdx==0" */, ts+9694 /* "testdata/sqlite-..." */, uint32(1970), uintptr(unsafe.Pointer(&__func__52)))
	}
	if (*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0 {
		var zSep uintptr = ts + 11700                                  /* "PRIMARY KEY(" */
		*(*uintptr)(unsafe.Pointer(bp + 56 /* pXList */)) = uintptr(0) // PRAGMA index_list = (pIter->zTbl)
		*(*uintptr)(unsafe.Pointer(bp + 64 /* pXInfo */)) = uintptr(0) // PRAGMA index_xinfo = <pk-index>

		(*sqlite3rbu)(unsafe.Pointer(p)).Frc = prepareFreeAndCollectError(tls, (*sqlite3rbu)(unsafe.Pointer(p)).FdbMain, bp+56 /* &pXList */, (p + 64 /* &.zErrmsg */),
			sqlite3.Xsqlite3_mprintf(tls, ts+10530 /* "PRAGMA main.inde..." */, crt.VaList(bp, (*RbuObjIter)(unsafe.Pointer(pIter)).FzTbl)))
		for ((*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0) && (100 == sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 56 /* pXList */)))) {
			var zOrig uintptr = sqlite3.Xsqlite3_column_text(tls, *(*uintptr)(unsafe.Pointer(bp + 56 /* pXList */)), 3)
			if (zOrig != 0) && (crt.Xstrcmp(tls, zOrig, ts+11713 /* "pk" */) == 0) {
				var zIdx uintptr = sqlite3.Xsqlite3_column_text(tls, *(*uintptr)(unsafe.Pointer(bp + 56 /* pXList */)), 1)
				if zIdx != 0 {
					(*sqlite3rbu)(unsafe.Pointer(p)).Frc = prepareFreeAndCollectError(tls, (*sqlite3rbu)(unsafe.Pointer(p)).FdbMain, bp+64 /* &pXInfo */, (p + 64 /* &.zErrmsg */),
						sqlite3.Xsqlite3_mprintf(tls, ts+10558 /* "PRAGMA main.inde..." */, crt.VaList(bp+8, zIdx)))
				}
				break
			}
		}
		rbuFinalize(tls, p, *(*uintptr)(unsafe.Pointer(bp + 56 /* pXList */)))

		for ((*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0) && (100 == sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 64 /* pXInfo */)))) {
			if sqlite3.Xsqlite3_column_int(tls, *(*uintptr)(unsafe.Pointer(bp + 64 /* pXInfo */)), 5) != 0 {
				// int iCid = sqlite3_column_int(pXInfo, 0);
				var zCol uintptr = sqlite3.Xsqlite3_column_text(tls, *(*uintptr)(unsafe.Pointer(bp + 64 /* pXInfo */)), 2)
				var zDesc uintptr
				if sqlite3.Xsqlite3_column_int(tls, *(*uintptr)(unsafe.Pointer(bp + 64 /* pXInfo */)), 3) != 0 {
					zDesc = ts + 389 /* " DESC" */
				} else {
					zDesc = ts + 792 /* "" */
				}
				z = rbuMPrintf(tls, p, ts+11716 /* "%z%s\"%w\"%s" */, crt.VaList(bp+16, z, zSep, zCol, zDesc))
				zSep = ts + 359 /* ", " */
			}
		}
		z = rbuMPrintf(tls, p, ts+11727 /* "%z)" */, crt.VaList(bp+48, z))
		rbuFinalize(tls, p, *(*uintptr)(unsafe.Pointer(bp + 64 /* pXInfo */)))
	}
	return z
}

var __func__52 = *(*[18]int8)(unsafe.Pointer(ts + 11731 /* "rbuWithoutRowidP..." */)) /* sqlite3rbu.c:1968:65 */

// This function creates the second imposter table used when writing to
// a table b-tree where the table has an external primary key. If the
// iterator passed as the second argument does not currently point to
// a table (not index) with an external primary key, this function is a
// no-op.
//
// Assuming the iterator does point to a table with an external PK, this
// function creates a WITHOUT ROWID imposter table named "rbu_imposter2"
// used to access that PK index. For example, if the target table is
// declared as follows:
//
//   CREATE TABLE t1(a, b TEXT, c REAL, PRIMARY KEY(b, c));
//
// then the imposter table schema is:
//
//   CREATE TABLE rbu_imposter2(c1 TEXT, c2 REAL, id INTEGER) WITHOUT ROWID;
//
func rbuCreateImposterTable2(tls *crt.TLS, p uintptr, pIter uintptr) { /* sqlite3rbu.c:2027:13: */
	bp := tls.Alloc(184)
	defer tls.Free(184)

	if ((*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0) && ((*RbuObjIter)(unsafe.Pointer(pIter)).FeType == 3) {
		var tnum int32 = (*RbuObjIter)(unsafe.Pointer(pIter)).FiPkTnum  // Root page of PK index
		*(*uintptr)(unsafe.Pointer(bp + 168 /* pQuery */)) = uintptr(0) // SELECT name ... WHERE rootpage = $tnum
		var zIdx uintptr = uintptr(0)                                   // Name of PK index
		*(*uintptr)(unsafe.Pointer(bp + 176 /* pXInfo */)) = uintptr(0) // PRAGMA main.index_xinfo = $zIdx
		var zComma uintptr = ts + 792                                   /* "" */
		var zCols uintptr = uintptr(0)                                  // Used to build up list of table cols
		var zPk uintptr = uintptr(0)                                    // Used to build up table PK declaration

		// Figure out the name of the primary key index for the current table.
		// This is needed for the argument to "PRAGMA index_xinfo". Set
		// zIdx to point to a nul-terminated string containing this name.
		(*sqlite3rbu)(unsafe.Pointer(p)).Frc = prepareAndCollectError(tls, (*sqlite3rbu)(unsafe.Pointer(p)).FdbMain, bp+168 /* &pQuery */, (p + 64 /* &.zErrmsg */),
			ts+11749 /* "SELECT name FROM..." */)
		if (*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0 {
			sqlite3.Xsqlite3_bind_int(tls, *(*uintptr)(unsafe.Pointer(bp + 168 /* pQuery */)), 1, tnum)
			if 100 == sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 168 /* pQuery */))) {
				zIdx = sqlite3.Xsqlite3_column_text(tls, *(*uintptr)(unsafe.Pointer(bp + 168 /* pQuery */)), 0)
			}
		}
		if zIdx != 0 {
			(*sqlite3rbu)(unsafe.Pointer(p)).Frc = prepareFreeAndCollectError(tls, (*sqlite3rbu)(unsafe.Pointer(p)).FdbMain, bp+176 /* &pXInfo */, (p + 64 /* &.zErrmsg */),
				sqlite3.Xsqlite3_mprintf(tls, ts+10558 /* "PRAGMA main.inde..." */, crt.VaList(bp, zIdx)))
		}
		rbuFinalize(tls, p, *(*uintptr)(unsafe.Pointer(bp + 168 /* pQuery */)))

		for ((*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0) && (100 == sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 176 /* pXInfo */)))) {
			var bKey int32 = sqlite3.Xsqlite3_column_int(tls, *(*uintptr)(unsafe.Pointer(bp + 176 /* pXInfo */)), 5)
			if bKey != 0 {
				var iCid int32 = sqlite3.Xsqlite3_column_int(tls, *(*uintptr)(unsafe.Pointer(bp + 176 /* pXInfo */)), 1)
				var bDesc int32 = sqlite3.Xsqlite3_column_int(tls, *(*uintptr)(unsafe.Pointer(bp + 176 /* pXInfo */)), 3)
				var zCollate uintptr = sqlite3.Xsqlite3_column_text(tls, *(*uintptr)(unsafe.Pointer(bp + 176 /* pXInfo */)), 4)
				zCols = rbuMPrintf(tls, p, ts+11799 /* "%z%sc%d %s COLLA..." */, crt.VaList(bp+8, zCols, zComma,
					iCid, *(*uintptr)(unsafe.Pointer((*RbuObjIter)(unsafe.Pointer(pIter)).FazTblType + uintptr(iCid)*8)), zCollate))
				zPk = rbuMPrintf(tls, p, ts+11821 /* "%z%sc%d%s" */, crt.VaList(bp+48, zPk, zComma, iCid, func() uintptr {
					if bDesc != 0 {
						return ts + 389 /* " DESC" */
					}
					return ts + 792 /* "" */
				}()))
				zComma = ts + 359 /* ", " */
			}
		}
		zCols = rbuMPrintf(tls, p, ts+11831 /* "%z, id INTEGER" */, crt.VaList(bp+80, zCols))
		rbuFinalize(tls, p, *(*uintptr)(unsafe.Pointer(bp + 176 /* pXInfo */)))

		sqlite3.Xsqlite3_test_control(tls, 25, crt.VaList(bp+88, (*sqlite3rbu)(unsafe.Pointer(p)).FdbMain, ts+354 /* "main" */, 1, tnum))
		rbuMPrintfExec(tls, p, (*sqlite3rbu)(unsafe.Pointer(p)).FdbMain,
			ts+11846, /* "CREATE TABLE rbu..." */
			crt.VaList(bp+120, zCols, zPk))
		sqlite3.Xsqlite3_test_control(tls, 25, crt.VaList(bp+136, (*sqlite3rbu)(unsafe.Pointer(p)).FdbMain, ts+354 /* "main" */, 0, 0))
	}
}

// If an error has already occurred when this function is called, it
// immediately returns zero (without doing any work). Or, if an error
// occurs during the execution of this function, it sets the error code
// in the sqlite3rbu object indicated by the first argument and returns
// zero.
//
// The iterator passed as the second argument is guaranteed to point to
// a table (not an index) when this function is called. This function
// attempts to create any imposter table required to write to the main
// table b-tree of the table before returning. Non-zero is returned if
// an imposter table are created, or zero otherwise.
//
// An imposter table is required in all cases except RBU_PK_VTAB. Only
// virtual tables are written to directly. The imposter table has the
// same schema as the actual target table (less any UNIQUE constraints).
// More precisely, the "same schema" means the same columns, types,
// collation sequences. For tables that do not have an external PRIMARY
// KEY, it also means the same PRIMARY KEY declaration.
func rbuCreateImposterTable(tls *crt.TLS, p uintptr, pIter uintptr) { /* sqlite3rbu.c:2101:13: */
	bp := tls.Alloc(200)
	defer tls.Free(200)

	if ((*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0) && ((*RbuObjIter)(unsafe.Pointer(pIter)).FeType != 5) {
		var tnum int32 = (*RbuObjIter)(unsafe.Pointer(pIter)).FiTnum
		var zComma uintptr = ts + 792 /* "" */
		var zSql uintptr = uintptr(0)
		var iCol int32
		sqlite3.Xsqlite3_test_control(tls, 25, crt.VaList(bp, (*sqlite3rbu)(unsafe.Pointer(p)).FdbMain, ts+354 /* "main" */, 0, 1))

		for iCol = 0; ((*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0) && (iCol < (*RbuObjIter)(unsafe.Pointer(pIter)).FnTblCol); iCol++ {
			var zPk uintptr = ts + 792 /* "" */
			var zCol uintptr = *(*uintptr)(unsafe.Pointer((*RbuObjIter)(unsafe.Pointer(pIter)).FazTblCol + uintptr(iCol)*8))
			*(*uintptr)(unsafe.Pointer(bp + 192 /* zColl */)) = uintptr(0)

			(*sqlite3rbu)(unsafe.Pointer(p)).Frc = sqlite3.Xsqlite3_table_column_metadata(tls,
				(*sqlite3rbu)(unsafe.Pointer(p)).FdbMain, ts+354 /* "main" */, (*RbuObjIter)(unsafe.Pointer(pIter)).FzTbl, zCol, uintptr(0), bp+192 /* &zColl */, uintptr(0), uintptr(0), uintptr(0))

			if ((*RbuObjIter)(unsafe.Pointer(pIter)).FeType == 2) && (*(*u8)(unsafe.Pointer((*RbuObjIter)(unsafe.Pointer(pIter)).FabTblPk + uintptr(iCol))) != 0) {
				// If the target table column is an "INTEGER PRIMARY KEY", add
				// "PRIMARY KEY" to the imposter table column declaration.
				zPk = ts + 11908 /* "PRIMARY KEY " */
			}
			zSql = rbuMPrintf(tls, p, ts+11921, /* "%z%s\"%w\" %s %sCO..." */
				crt.VaList(bp+32, zSql, zComma, zCol, *(*uintptr)(unsafe.Pointer((*RbuObjIter)(unsafe.Pointer(pIter)).FazTblType + uintptr(iCol)*8)), zPk, *(*uintptr)(unsafe.Pointer(bp + 192 /* zColl */)),
					func() uintptr {
						if *(*u8)(unsafe.Pointer((*RbuObjIter)(unsafe.Pointer(pIter)).FabNotNull + uintptr(iCol))) != 0 {
							return ts + 11948 /* " NOT NULL" */
						}
						return ts + 792 /* "" */
					}()))
			zComma = ts + 359 /* ", " */
		}

		if (*RbuObjIter)(unsafe.Pointer(pIter)).FeType == 4 {
			var zPk uintptr = rbuWithoutRowidPK(tls, p, pIter)
			if zPk != 0 {
				zSql = rbuMPrintf(tls, p, ts+11958 /* "%z, %z" */, crt.VaList(bp+88, zSql, zPk))
			}
		}

		sqlite3.Xsqlite3_test_control(tls, 25, crt.VaList(bp+104, (*sqlite3rbu)(unsafe.Pointer(p)).FdbMain, ts+354 /* "main" */, 1, tnum))
		rbuMPrintfExec(tls, p, (*sqlite3rbu)(unsafe.Pointer(p)).FdbMain, ts+11965, /* "CREATE TABLE \"rb..." */
			crt.VaList(bp+136, (*RbuObjIter)(unsafe.Pointer(pIter)).FzTbl, zSql,
				func() uintptr {
					if (*RbuObjIter)(unsafe.Pointer(pIter)).FeType == 4 {
						return ts + 11997 /* " WITHOUT ROWID" */
					}
					return ts + 792 /* "" */
				}()))
		sqlite3.Xsqlite3_test_control(tls, 25, crt.VaList(bp+160, (*sqlite3rbu)(unsafe.Pointer(p)).FdbMain, ts+354 /* "main" */, 0, 0))
	}
}

// Prepare a statement used to insert rows into the "rbu_tmp_xxx" table.
// Specifically a statement of the form:
//
//     INSERT INTO rbu_tmp_xxx VALUES(?, ?, ? ...);
//
// The number of bound variables is equal to the number of columns in
// the target table, plus one (for the rbu_control column), plus one more
// (for the rbu_rowid column) if the target table is an implicit IPK or
// virtual table.
func rbuObjIterPrepareTmpInsert(tls *crt.TLS, p uintptr, pIter uintptr, zCollist uintptr, zRbuRowid uintptr) { /* sqlite3rbu.c:2157:13: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	var bRbuRowid int32 = (crt.Bool32(((*RbuObjIter)(unsafe.Pointer(pIter)).FeType == 3) || ((*RbuObjIter)(unsafe.Pointer(pIter)).FeType == 1)))
	var zBind uintptr = rbuObjIterGetBindlist(tls, p, (((*RbuObjIter)(unsafe.Pointer(pIter)).FnTblCol + 1) + bRbuRowid))
	if zBind != 0 {
		if !((*RbuObjIter)(unsafe.Pointer(pIter)).FpTmpInsert == uintptr(0)) {
			crt.X__assert_fail(tls, ts+12012 /* "pIter->pTmpInser..." */, ts+9694 /* "testdata/sqlite-..." */, uint32(2166), uintptr(unsafe.Pointer(&__func__53)))
		}
		(*sqlite3rbu)(unsafe.Pointer(p)).Frc = prepareFreeAndCollectError(tls,
			(*sqlite3rbu)(unsafe.Pointer(p)).FdbRbu, (pIter + 152 /* &.pTmpInsert */), (p + 64 /* &.zErrmsg */), sqlite3.Xsqlite3_mprintf(tls,
				ts+12033, /* "INSERT INTO %s.'..." */
				crt.VaList(bp, p+48 /* &.zStateDb */, (*RbuObjIter)(unsafe.Pointer(pIter)).FzDataTbl, zCollist, zRbuRowid, zBind)))
	}
}

var __func__53 = *(*[27]int8)(unsafe.Pointer(ts + 12090 /* "rbuObjIterPrepar..." */)) /* sqlite3rbu.c:2162:2 */

func rbuTmpInsertFunc(tls *crt.TLS, pCtx uintptr, nVal int32, apVal uintptr) { /* sqlite3rbu.c:2175:13: */
	var p uintptr = sqlite3.Xsqlite3_user_data(tls, pCtx)
	var rc int32 = 0
	var i int32

	if !(((sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(apVal + uintptr(0)*8))) != 0) || ((*sqlite3rbu)(unsafe.Pointer(p)).Fobjiter.FeType == 3)) || ((*sqlite3rbu)(unsafe.Pointer(p)).Fobjiter.FeType == 1)) {
		crt.X__assert_fail(tls, ts+12117 /* "sqlite3_value_in..." */, ts+9694 /* "testdata/sqlite-..." */, uint32(2184), uintptr(unsafe.Pointer(&__func__54)))
	}
	if sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(apVal + uintptr(0)*8))) != 0 {
		*(*i64)(unsafe.Pointer(p + 304 /* &.nPhaseOneStep */)) += (i64((*sqlite3rbu)(unsafe.Pointer(p)).Fobjiter.FnIndex))
	}

	for i = 0; (rc == 0) && (i < nVal); i++ {
		rc = sqlite3.Xsqlite3_bind_value(tls, (*sqlite3rbu)(unsafe.Pointer(p)).Fobjiter.FpTmpInsert, (i + 1), *(*uintptr)(unsafe.Pointer(apVal + uintptr(i)*8)))
	}
	if rc == 0 {
		sqlite3.Xsqlite3_step(tls, (*sqlite3rbu)(unsafe.Pointer(p)).Fobjiter.FpTmpInsert)
		rc = sqlite3.Xsqlite3_reset(tls, (*sqlite3rbu)(unsafe.Pointer(p)).Fobjiter.FpTmpInsert)
	}

	if rc != 0 {
		sqlite3.Xsqlite3_result_error_code(tls, pCtx, rc)
	}
}

var __func__54 = *(*[17]int8)(unsafe.Pointer(ts + 12194 /* "rbuTmpInsertFunc" */)) /* sqlite3rbu.c:2179:2 */

func rbuObjIterGetIndexWhere(tls *crt.TLS, p uintptr, pIter uintptr) uintptr { /* sqlite3rbu.c:2205:13: */
	bp := tls.Alloc(12)
	defer tls.Free(12)

	*(*uintptr)(unsafe.Pointer(bp /* pStmt */)) = uintptr(0)
	*(*int32)(unsafe.Pointer(bp + 8 /* rc */)) = (*sqlite3rbu)(unsafe.Pointer(p)).Frc
	var zRet uintptr = uintptr(0)

	if !((((*RbuObjIter)(unsafe.Pointer(pIter)).FzIdxSql == uintptr(0)) && ((*RbuObjIter)(unsafe.Pointer(pIter)).FnIdxCol == 0)) && ((*RbuObjIter)(unsafe.Pointer(pIter)).FaIdxCol == uintptr(0))) {
		crt.X__assert_fail(tls, ts+12211 /* "pIter->zIdxSql==..." */, ts+9694 /* "testdata/sqlite-..." */, uint32(2210), uintptr(unsafe.Pointer(&__func__55)))
	}

	if *(*int32)(unsafe.Pointer(bp + 8 /* rc */)) == 0 {
		*(*int32)(unsafe.Pointer(bp + 8 /* rc */)) = prepareAndCollectError(tls, (*sqlite3rbu)(unsafe.Pointer(p)).FdbMain, bp /* &pStmt */, (p + 64 /* &.zErrmsg */),
			ts+12271 /* "SELECT trim(sql)..." */)
	}
	if *(*int32)(unsafe.Pointer(bp + 8 /* rc */)) == 0 {
		var rc2 int32
		*(*int32)(unsafe.Pointer(bp + 8 /* rc */)) = sqlite3.Xsqlite3_bind_text(tls, *(*uintptr)(unsafe.Pointer(bp /* pStmt */)), 1, (*RbuObjIter)(unsafe.Pointer(pIter)).FzIdx, -1, uintptr(0))
		if (*(*int32)(unsafe.Pointer(bp + 8 /* rc */)) == 0) && (100 == sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp /* pStmt */)))) {
			var zSql uintptr = sqlite3.Xsqlite3_column_text(tls, *(*uintptr)(unsafe.Pointer(bp /* pStmt */)), 0)
			if zSql != 0 {
				(*RbuObjIter)(unsafe.Pointer(pIter)).FzIdxSql = crt.AssignUintptr(&zSql, rbuStrndup(tls, zSql, bp+8 /* &rc */))
			}
			if zSql != 0 {
				var nParen int32 = 0 // Number of open parenthesis
				var i int32
				var iIdxCol int32 = 0
				var nIdxAlloc int32 = 0
				for i = 0; *(*int8)(unsafe.Pointer(zSql + uintptr(i))) != 0; i++ {
					var c int8 = *(*int8)(unsafe.Pointer(zSql + uintptr(i)))

					// If necessary, grow the pIter->aIdxCol[] array
					if iIdxCol == nIdxAlloc {
						var aIdxCol uintptr = sqlite3.Xsqlite3_realloc(tls,
							(*RbuObjIter)(unsafe.Pointer(pIter)).FaIdxCol, (int32((uint64(nIdxAlloc + 16)) * uint64(unsafe.Sizeof(RbuSpan{})))))
						if aIdxCol == uintptr(0) {
							*(*int32)(unsafe.Pointer(bp + 8 /* rc */)) = 7
							break
						}
						(*RbuObjIter)(unsafe.Pointer(pIter)).FaIdxCol = aIdxCol
						nIdxAlloc = nIdxAlloc + (16)
					}

					if int32(c) == '(' {
						if nParen == 0 {
							if !(iIdxCol == 0) {
								crt.X__assert_fail(tls, ts+12337 /* "iIdxCol==0" */, ts+9694 /* "testdata/sqlite-..." */, uint32(2248), uintptr(unsafe.Pointer(&__func__55)))
							}
							(*RbuSpan)(unsafe.Pointer((*RbuObjIter)(unsafe.Pointer(pIter)).FaIdxCol + uintptr(0)*16)).FzSpan = (zSql + uintptr((i + 1)))
						}
						nParen++
					} else if int32(c) == ')' {
						nParen--
						if nParen == 0 {
							var nSpan int32 = (int32((int64((zSql + uintptr(i))) - int64((*RbuSpan)(unsafe.Pointer((*RbuObjIter)(unsafe.Pointer(pIter)).FaIdxCol+uintptr(iIdxCol)*16)).FzSpan)) / 1))
							(*RbuSpan)(unsafe.Pointer((*RbuObjIter)(unsafe.Pointer(pIter)).FaIdxCol + uintptr(crt.PostIncInt32(&iIdxCol, 1))*16)).FnSpan = nSpan
							i++
							break
						}
					} else if (int32(c) == ',') && (nParen == 1) {
						var nSpan int32 = (int32((int64((zSql + uintptr(i))) - int64((*RbuSpan)(unsafe.Pointer((*RbuObjIter)(unsafe.Pointer(pIter)).FaIdxCol+uintptr(iIdxCol)*16)).FzSpan)) / 1))
						(*RbuSpan)(unsafe.Pointer((*RbuObjIter)(unsafe.Pointer(pIter)).FaIdxCol + uintptr(crt.PostIncInt32(&iIdxCol, 1))*16)).FnSpan = nSpan
						(*RbuSpan)(unsafe.Pointer((*RbuObjIter)(unsafe.Pointer(pIter)).FaIdxCol + uintptr(iIdxCol)*16)).FzSpan = (zSql + uintptr((i + 1)))
					} else if ((int32(c) == '"') || (int32(c) == '\'')) || (int32(c) == '`') {
						for i++; 1 != 0; i++ {
							if int32(*(*int8)(unsafe.Pointer(zSql + uintptr(i)))) == int32(c) {
								if int32(*(*int8)(unsafe.Pointer(zSql + uintptr((i + 1))))) != int32(c) {
									break
								}
								i++
							}
						}
					} else if int32(c) == '[' {
						for i++; 1 != 0; i++ {
							if int32(*(*int8)(unsafe.Pointer(zSql + uintptr(i)))) == ']' {
								break
							}
						}
					} else if (int32(c) == '-') && (int32(*(*int8)(unsafe.Pointer(zSql + uintptr((i + 1))))) == '-') {
						for i = (i + 2); (*(*int8)(unsafe.Pointer(zSql + uintptr(i))) != 0) && (int32(*(*int8)(unsafe.Pointer(zSql + uintptr(i)))) != '\n'); i++ {
						}
						if int32(*(*int8)(unsafe.Pointer(zSql + uintptr(i)))) == 0 {
							break
						}
					} else if (int32(c) == '/') && (int32(*(*int8)(unsafe.Pointer(zSql + uintptr((i + 1))))) == '*') {
						for i = (i + 2); (*(*int8)(unsafe.Pointer(zSql + uintptr(i))) != 0) && ((int32(*(*int8)(unsafe.Pointer(zSql + uintptr(i)))) != '*') || (int32(*(*int8)(unsafe.Pointer(zSql + uintptr((i + 1))))) != '/')); i++ {
						}
						if int32(*(*int8)(unsafe.Pointer(zSql + uintptr(i)))) == 0 {
							break
						}
						i++
					}
				}
				if *(*int8)(unsafe.Pointer(zSql + uintptr(i))) != 0 {
					zRet = rbuStrndup(tls, (zSql + uintptr(i)), bp+8 /* &rc */)
				}
				(*RbuObjIter)(unsafe.Pointer(pIter)).FnIdxCol = iIdxCol
			}
		}

		rc2 = sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp /* pStmt */)))
		if *(*int32)(unsafe.Pointer(bp + 8 /* rc */)) == 0 {
			*(*int32)(unsafe.Pointer(bp + 8 /* rc */)) = rc2
		}
	}

	(*sqlite3rbu)(unsafe.Pointer(p)).Frc = *(*int32)(unsafe.Pointer(bp + 8 /* rc */))
	return zRet
}

var __func__55 = *(*[24]int8)(unsafe.Pointer(ts + 12348 /* "rbuObjIterGetInd..." */)) /* sqlite3rbu.c:2205:71 */

// Ensure that the SQLite statement handles required to update the
// target database object currently indicated by the iterator passed
// as the second argument are available.
func rbuObjIterPrepareAll(tls *crt.TLS, p uintptr, pIter uintptr, nOffset int32) int32 { /* sqlite3rbu.c:2305:12: */
	bp := tls.Alloc(628)
	defer tls.Free(628)

	if !((*RbuObjIter)(unsafe.Pointer(pIter)).FbCleanup == 0) {
		crt.X__assert_fail(tls, ts+12372 /* "pIter->bCleanup=..." */, ts+9694 /* "testdata/sqlite-..." */, uint32(2310), uintptr(unsafe.Pointer(&__func__56)))
	}
	if ((*RbuObjIter)(unsafe.Pointer(pIter)).FpSelect == uintptr(0)) && (rbuObjIterCacheTableInfo(tls, p, pIter) == 0) {
		var tnum int32 = (*RbuObjIter)(unsafe.Pointer(pIter)).FiTnum
		var zCollist uintptr = uintptr(0) // List of indexed columns
		var pz uintptr = (p + 64 /* &.zErrmsg */)
		var zIdx uintptr = (*RbuObjIter)(unsafe.Pointer(pIter)).FzIdx
		var zLimit uintptr = uintptr(0)

		if nOffset != 0 {
			zLimit = sqlite3.Xsqlite3_mprintf(tls, ts+12391 /* " LIMIT -1 OFFSET..." */, crt.VaList(bp, nOffset))
			if !(zLimit != 0) {
				(*sqlite3rbu)(unsafe.Pointer(p)).Frc = 7
			}
		}

		if zIdx != 0 {
			var zTbl uintptr = (*RbuObjIter)(unsafe.Pointer(pIter)).FzTbl
			*(*uintptr)(unsafe.Pointer(bp + 600 /* zImposterCols */)) = uintptr(0) // Columns for imposter table
			*(*uintptr)(unsafe.Pointer(bp + 608 /* zImposterPK */)) = uintptr(0)   // Primary key declaration for imposter
			*(*uintptr)(unsafe.Pointer(bp + 616 /* zWhere */)) = uintptr(0)        // WHERE clause on PK columns
			var zBind uintptr = uintptr(0)
			var zPart uintptr = uintptr(0)
			*(*int32)(unsafe.Pointer(bp + 624 /* nBind */)) = 0

			if !((*RbuObjIter)(unsafe.Pointer(pIter)).FeType != 5) {
				crt.X__assert_fail(tls, ts+12411 /* "pIter->eType!=5" */, ts+9694 /* "testdata/sqlite-..." */, uint32(2332), uintptr(unsafe.Pointer(&__func__56)))
			}
			zPart = rbuObjIterGetIndexWhere(tls, p, pIter)
			zCollist = rbuObjIterGetIndexCols(tls,
				p, pIter, bp+600 /* &zImposterCols */, bp+608 /* &zImposterPK */, bp+616 /* &zWhere */, bp+624 /* &nBind */)
			zBind = rbuObjIterGetBindlist(tls, p, *(*int32)(unsafe.Pointer(bp + 624 /* nBind */)))

			// Create the imposter table used to write to this index.
			sqlite3.Xsqlite3_test_control(tls, 25, crt.VaList(bp+8, (*sqlite3rbu)(unsafe.Pointer(p)).FdbMain, ts+354 /* "main" */, 0, 1))
			sqlite3.Xsqlite3_test_control(tls, 25, crt.VaList(bp+40, (*sqlite3rbu)(unsafe.Pointer(p)).FdbMain, ts+354 /* "main" */, 1, tnum))
			rbuMPrintfExec(tls, p, (*sqlite3rbu)(unsafe.Pointer(p)).FdbMain,
				ts+12427, /* "CREATE TABLE \"rb..." */
				crt.VaList(bp+72, zTbl, *(*uintptr)(unsafe.Pointer(bp + 600 /* zImposterCols */)), *(*uintptr)(unsafe.Pointer(bp + 608 /* zImposterPK */))))
			sqlite3.Xsqlite3_test_control(tls, 25, crt.VaList(bp+96, (*sqlite3rbu)(unsafe.Pointer(p)).FdbMain, ts+354 /* "main" */, 0, 0))

			// Create the statement to insert index entries
			(*RbuObjIter)(unsafe.Pointer(pIter)).FnCol = *(*int32)(unsafe.Pointer(bp + 624 /* nBind */))
			if (*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0 {
				(*sqlite3rbu)(unsafe.Pointer(p)).Frc = prepareFreeAndCollectError(tls,
					(*sqlite3rbu)(unsafe.Pointer(p)).FdbMain, (pIter + 136 /* &.pInsert */), (p + 64 /* &.zErrmsg */),
					sqlite3.Xsqlite3_mprintf(tls, ts+12492 /* "INSERT INTO \"rbu..." */, crt.VaList(bp+128, zTbl, zBind)))
			}

			// And to delete index entries
			if ((crt.Bool32((*sqlite3rbu)(unsafe.Pointer((p))).FzTarget == uintptr(0))) == 0) && ((*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0) {
				(*sqlite3rbu)(unsafe.Pointer(p)).Frc = prepareFreeAndCollectError(tls,
					(*sqlite3rbu)(unsafe.Pointer(p)).FdbMain, (pIter + 144 /* &.pDelete */), (p + 64 /* &.zErrmsg */),
					sqlite3.Xsqlite3_mprintf(tls, ts+12528 /* "DELETE FROM \"rbu..." */, crt.VaList(bp+144, zTbl, *(*uintptr)(unsafe.Pointer(bp + 616 /* zWhere */)))))
			}

			// Create the SELECT statement to read keys in sorted order
			if (*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0 {
				var zSql uintptr
				if (*sqlite3rbu)(unsafe.Pointer((p))).FzTarget == uintptr(0) {
					var zStart uintptr = uintptr(0)
					if nOffset != 0 {
						zStart = rbuVacuumIndexStart(tls, p, pIter)
						if zStart != 0 {
							sqlite3.Xsqlite3_free(tls, zLimit)
							zLimit = uintptr(0)
						}
					}

					zSql = sqlite3.Xsqlite3_mprintf(tls,
						ts+12562, /* "SELECT %s, 0 AS ..." */
						crt.VaList(bp+160, zCollist,
							(*RbuObjIter)(unsafe.Pointer(pIter)).FzDataTbl,
							zPart,
							func() uintptr {
								if zStart != 0 {
									return func() uintptr {
										if zPart != 0 {
											return ts + 9626 /* "AND" */
										}
										return ts + 9599 /* "WHERE" */
									}()
								}
								return ts + 792 /* "" */
							}(), zStart,
							zCollist, zLimit))
					sqlite3.Xsqlite3_free(tls, zStart)
				} else if ((*RbuObjIter)(unsafe.Pointer(pIter)).FeType == 3) || ((*RbuObjIter)(unsafe.Pointer(pIter)).FeType == 1) {
					zSql = sqlite3.Xsqlite3_mprintf(tls,
						ts+12623, /* "SELECT %s, rbu_c..." */
						crt.VaList(bp+216, zCollist, p+48 /* &.zStateDb */, (*RbuObjIter)(unsafe.Pointer(pIter)).FzDataTbl,
							zPart, zCollist, zLimit))
				} else {
					zSql = sqlite3.Xsqlite3_mprintf(tls,

						ts+12684, /* "SELECT %s, rbu_c..." */
						crt.VaList(bp+264, zCollist, p+48 /* &.zStateDb */, (*RbuObjIter)(unsafe.Pointer(pIter)).FzDataTbl, zPart,
							zCollist, (*RbuObjIter)(unsafe.Pointer(pIter)).FzDataTbl,
							zPart,
							func() uintptr {
								if zPart != 0 {
									return ts + 9626 /* "AND" */
								}
								return ts + 9599 /* "WHERE" */
							}(),
							zCollist, zLimit))
				}
				if (*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0 {
					(*sqlite3rbu)(unsafe.Pointer(p)).Frc = prepareFreeAndCollectError(tls, (*sqlite3rbu)(unsafe.Pointer(p)).FdbRbu, (pIter + 128 /* &.pSelect */), pz, zSql)
				} else {
					sqlite3.Xsqlite3_free(tls, zSql)
				}
			}

			sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(bp + 600 /* zImposterCols */)))
			sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(bp + 608 /* zImposterPK */)))
			sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(bp + 616 /* zWhere */)))
			sqlite3.Xsqlite3_free(tls, zBind)
			sqlite3.Xsqlite3_free(tls, zPart)
		} else {
			var bRbuRowid int32 = (crt.Bool32((((*RbuObjIter)(unsafe.Pointer(pIter)).FeType == 5) ||
				((*RbuObjIter)(unsafe.Pointer(pIter)).FeType == 1)) ||
				(((*RbuObjIter)(unsafe.Pointer(pIter)).FeType == 3) && ((*sqlite3rbu)(unsafe.Pointer((p))).FzTarget == uintptr(0)))))
			var zTbl uintptr = (*RbuObjIter)(unsafe.Pointer(pIter)).FzTbl // Table this step applies to
			var zWrite uintptr                                            // Imposter table name

			var zBindings uintptr = rbuObjIterGetBindlist(tls, p, ((*RbuObjIter)(unsafe.Pointer(pIter)).FnTblCol + bRbuRowid))
			var zWhere uintptr = rbuObjIterGetWhere(tls, p, pIter)
			var zOldlist uintptr = rbuObjIterGetOldlist(tls, p, pIter, ts+12843 /* "old" */)
			var zNewlist uintptr = rbuObjIterGetOldlist(tls, p, pIter, ts+12847 /* "new" */)

			zCollist = rbuObjIterGetCollist(tls, p, pIter)
			(*RbuObjIter)(unsafe.Pointer(pIter)).FnCol = (*RbuObjIter)(unsafe.Pointer(pIter)).FnTblCol

			// Create the imposter table or tables (if required).
			rbuCreateImposterTable(tls, p, pIter)
			rbuCreateImposterTable2(tls, p, pIter)
			zWrite = func() uintptr {
				if (*RbuObjIter)(unsafe.Pointer(pIter)).FeType == 5 {
					return ts + 792 /* "" */
				}
				return ts + 12851 /* "rbu_imp_" */
			}()

			// Create the INSERT statement to write to the target PK b-tree
			if (*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0 {
				(*sqlite3rbu)(unsafe.Pointer(p)).Frc = prepareFreeAndCollectError(tls, (*sqlite3rbu)(unsafe.Pointer(p)).FdbMain, (pIter + 136 /* &.pInsert */), pz,
					sqlite3.Xsqlite3_mprintf(tls,
						ts+12860, /* "INSERT INTO \"%s%..." */
						crt.VaList(bp+344, zWrite, zTbl, zCollist, func() uintptr {
							if bRbuRowid != 0 {
								return ts + 12896 /* ", _rowid_" */
							}
							return ts + 792 /* "" */
						}(), zBindings)))
			}

			// Create the DELETE statement to write to the target PK b-tree.
			// Because it only performs INSERT operations, this is not required for
			// an rbu vacuum handle.
			if ((crt.Bool32((*sqlite3rbu)(unsafe.Pointer((p))).FzTarget == uintptr(0))) == 0) && ((*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0) {
				(*sqlite3rbu)(unsafe.Pointer(p)).Frc = prepareFreeAndCollectError(tls, (*sqlite3rbu)(unsafe.Pointer(p)).FdbMain, (pIter + 144 /* &.pDelete */), pz,
					sqlite3.Xsqlite3_mprintf(tls,
						ts+12906 /* "DELETE FROM \"%s%..." */, crt.VaList(bp+384, zWrite, zTbl, zWhere)))
			}

			if ((crt.Bool32((*sqlite3rbu)(unsafe.Pointer((p))).FzTarget == uintptr(0))) == 0) && ((*RbuObjIter)(unsafe.Pointer(pIter)).FabIndexed != 0) {
				var zRbuRowid uintptr = ts + 792 /* "" */
				if ((*RbuObjIter)(unsafe.Pointer(pIter)).FeType == 3) || ((*RbuObjIter)(unsafe.Pointer(pIter)).FeType == 1) {
					zRbuRowid = ts + 12934 /* ", rbu_rowid" */
				}

				// Create the rbu_tmp_xxx table and the triggers to populate it.
				rbuMPrintfExec(tls, p, (*sqlite3rbu)(unsafe.Pointer(p)).FdbRbu,

					ts+12946 /* "CREATE TABLE IF ..." */, crt.VaList(bp+408, p+48 /* &.zStateDb */, (*RbuObjIter)(unsafe.Pointer(pIter)).FzDataTbl, func() uintptr {
						if (*RbuObjIter)(unsafe.Pointer(pIter)).FeType == 3 {
							return ts + 13022 /* ", 0 AS rbu_rowid" */
						}
						return ts + 792 /* "" */
					}(), (*RbuObjIter)(unsafe.Pointer(pIter)).FzDataTbl))

				rbuMPrintfExec(tls, p, (*sqlite3rbu)(unsafe.Pointer(p)).FdbMain,

					ts+13039, /* "CREATE TEMP TRIG..." */
					crt.VaList(bp+440, zWrite, zTbl, zOldlist,
						zWrite, zTbl, zOldlist,
						zWrite, zTbl, zNewlist))

				if ((*RbuObjIter)(unsafe.Pointer(pIter)).FeType == 3) || ((*RbuObjIter)(unsafe.Pointer(pIter)).FeType == 1) {
					rbuMPrintfExec(tls, p, (*sqlite3rbu)(unsafe.Pointer(p)).FdbMain,

						ts+13338, /* "CREATE TEMP TRIG..." */
						crt.VaList(bp+512, zWrite, zTbl, zNewlist))
				}

				rbuObjIterPrepareTmpInsert(tls, p, pIter, zCollist, zRbuRowid)
			}

			// Create the SELECT statement to read keys from data_xxx
			if (*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0 {
				var zRbuRowid uintptr = ts + 792 /* "" */
				var zStart uintptr = uintptr(0)
				var zOrder uintptr = uintptr(0)
				if bRbuRowid != 0 {
					if (*sqlite3rbu)(unsafe.Pointer((p))).FzTarget == uintptr(0) {
						zRbuRowid = ts + 13437 /* ",_rowid_ " */
					} else {
						zRbuRowid = ts + 13447 /* ",rbu_rowid" */
					}
				}

				if (*sqlite3rbu)(unsafe.Pointer((p))).FzTarget == uintptr(0) {
					if nOffset != 0 {
						zStart = rbuVacuumTableStart(tls, p, pIter, bRbuRowid, zWrite)
						if zStart != 0 {
							sqlite3.Xsqlite3_free(tls, zLimit)
							zLimit = uintptr(0)
						}
					}
					if bRbuRowid != 0 {
						zOrder = rbuMPrintf(tls, p, ts+8365 /* "_rowid_" */, 0)
					} else {
						zOrder = rbuObjIterGetPkList(tls, p, pIter, ts+792 /* "" */, ts+359 /* ", " */, ts+792 /* "" */)
					}
				}

				if (*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0 {
					(*sqlite3rbu)(unsafe.Pointer(p)).Frc = prepareFreeAndCollectError(tls, (*sqlite3rbu)(unsafe.Pointer(p)).FdbRbu, (pIter + 128 /* &.pSelect */), pz,
						sqlite3.Xsqlite3_mprintf(tls,
							ts+13458, /* "SELECT %s,%s rbu..." */
							crt.VaList(bp+536, zCollist,
								func() uintptr {
									if (*sqlite3rbu)(unsafe.Pointer((p))).FzTarget == uintptr(0) {
										return ts + 13506 /* "0 AS " */
									}
									return ts + 792 /* "" */
								}(),
								zRbuRowid,
								(*RbuObjIter)(unsafe.Pointer(pIter)).FzDataTbl, func() uintptr {
									if zStart != 0 {
										return zStart
									}
									return ts + 792 /* "" */
								}(),
								func() uintptr {
									if zOrder != 0 {
										return ts + 13512 /* "ORDER BY" */
									}
									return ts + 792 /* "" */
								}(), zOrder,
								zLimit)))
				}
				sqlite3.Xsqlite3_free(tls, zStart)
				sqlite3.Xsqlite3_free(tls, zOrder)
			}

			sqlite3.Xsqlite3_free(tls, zWhere)
			sqlite3.Xsqlite3_free(tls, zOldlist)
			sqlite3.Xsqlite3_free(tls, zNewlist)
			sqlite3.Xsqlite3_free(tls, zBindings)
		}
		sqlite3.Xsqlite3_free(tls, zCollist)
		sqlite3.Xsqlite3_free(tls, zLimit)
	}

	return (*sqlite3rbu)(unsafe.Pointer(p)).Frc
}

var __func__56 = *(*[21]int8)(unsafe.Pointer(ts + 13521 /* "rbuObjIterPrepar..." */)) /* sqlite3rbu.c:2309:2 */

// Set output variable *ppStmt to point to an UPDATE statement that may
// be used to update the imposter table for the main table b-tree of the
// table object that pIter currently points to, assuming that the
// rbu_control column of the data_xyz table contains zMask.
//
// If the zMask string does not specify any columns to update, then this
// is not an error. Output variable *ppStmt is set to NULL in this case.
func rbuGetUpdateStmt(tls *crt.TLS, p uintptr, pIter uintptr, zMask uintptr, ppStmt uintptr) int32 { /* sqlite3rbu.c:2572:12: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var pp uintptr
	var pUp uintptr = uintptr(0)
	var nUp int32 = 0

	// In case an error occurs
	*(*uintptr)(unsafe.Pointer(ppStmt)) = uintptr(0)

	// Search for an existing statement. If one is found, shift it to the front
	// of the LRU queue and return immediately. Otherwise, leave nUp pointing
	// to the number of statements currently in the cache and pUp to the
	// last object in the list.
	for pp = (pIter + 184 /* &.pRbuUpdate */); *(*uintptr)(unsafe.Pointer(pp)) != 0; pp = (*(*uintptr)(unsafe.Pointer(pp)) + 16 /* &.pNext */) {
		pUp = *(*uintptr)(unsafe.Pointer(pp))
		if crt.Xstrcmp(tls, (*RbuUpdateStmt)(unsafe.Pointer(pUp)).FzMask, zMask) == 0 {
			*(*uintptr)(unsafe.Pointer(pp)) = (*RbuUpdateStmt)(unsafe.Pointer(pUp)).FpNext
			(*RbuUpdateStmt)(unsafe.Pointer(pUp)).FpNext = (*RbuObjIter)(unsafe.Pointer(pIter)).FpRbuUpdate
			(*RbuObjIter)(unsafe.Pointer(pIter)).FpRbuUpdate = pUp
			*(*uintptr)(unsafe.Pointer(ppStmt)) = (*RbuUpdateStmt)(unsafe.Pointer(pUp)).FpUpdate
			return 0
		}
		nUp++
	}
	if !((pUp == uintptr(0)) || ((*RbuUpdateStmt)(unsafe.Pointer(pUp)).FpNext == uintptr(0))) {
		crt.X__assert_fail(tls, ts+13542 /* "pUp==0 || pUp->p..." */, ts+9694 /* "testdata/sqlite-..." */, uint32(2600), uintptr(unsafe.Pointer(&__func__57)))
	}

	if nUp >= 16 {
		for pp = (pIter + 184 /* &.pRbuUpdate */); *(*uintptr)(unsafe.Pointer(pp)) != pUp; pp = (*(*uintptr)(unsafe.Pointer(pp)) + 16 /* &.pNext */) {
		}
		*(*uintptr)(unsafe.Pointer(pp)) = uintptr(0)
		sqlite3.Xsqlite3_finalize(tls, (*RbuUpdateStmt)(unsafe.Pointer(pUp)).FpUpdate)
		(*RbuUpdateStmt)(unsafe.Pointer(pUp)).FpUpdate = uintptr(0)
	} else {
		pUp = rbuMalloc(tls, p, (int64((uint64(unsafe.Sizeof(RbuUpdateStmt{})) + uint64((*RbuObjIter)(unsafe.Pointer(pIter)).FnTblCol)) + uint64(1))))
	}

	if pUp != 0 {
		var zWhere uintptr = rbuObjIterGetWhere(tls, p, pIter)
		var zSet uintptr = rbuObjIterGetSetlist(tls, p, pIter, zMask)
		var zUpdate uintptr = uintptr(0)

		(*RbuUpdateStmt)(unsafe.Pointer(pUp)).FzMask = (pUp + uintptr(1)*24)
		crt.Xmemcpy(tls, (*RbuUpdateStmt)(unsafe.Pointer(pUp)).FzMask, zMask, uint64((*RbuObjIter)(unsafe.Pointer(pIter)).FnTblCol))
		(*RbuUpdateStmt)(unsafe.Pointer(pUp)).FpNext = (*RbuObjIter)(unsafe.Pointer(pIter)).FpRbuUpdate
		(*RbuObjIter)(unsafe.Pointer(pIter)).FpRbuUpdate = pUp

		if zSet != 0 {
			var zPrefix uintptr = ts + 792 /* "" */

			if (*RbuObjIter)(unsafe.Pointer(pIter)).FeType != 5 {
				zPrefix = ts + 12851 /* "rbu_imp_" */
			}
			zUpdate = sqlite3.Xsqlite3_mprintf(tls, ts+13566, /* "UPDATE \"%s%w\" SE..." */
				crt.VaList(bp, zPrefix, (*RbuObjIter)(unsafe.Pointer(pIter)).FzTbl, zSet, zWhere))
			(*sqlite3rbu)(unsafe.Pointer(p)).Frc = prepareFreeAndCollectError(tls,
				(*sqlite3rbu)(unsafe.Pointer(p)).FdbMain, (pUp + 8 /* &.pUpdate */), (p + 64 /* &.zErrmsg */), zUpdate)
			*(*uintptr)(unsafe.Pointer(ppStmt)) = (*RbuUpdateStmt)(unsafe.Pointer(pUp)).FpUpdate
		}
		sqlite3.Xsqlite3_free(tls, zWhere)
		sqlite3.Xsqlite3_free(tls, zSet)
	}

	return (*sqlite3rbu)(unsafe.Pointer(p)).Frc
}

var __func__57 = *(*[17]int8)(unsafe.Pointer(ts + 13596 /* "rbuGetUpdateStmt" */)) /* sqlite3rbu.c:2577:2 */

func rbuOpenDbhandle(tls *crt.TLS, p uintptr, zName uintptr, bUseVfs int32) uintptr { /* sqlite3rbu.c:2640:16: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	*(*uintptr)(unsafe.Pointer(bp + 8 /* db */)) = uintptr(0)
	if (*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0 {
		var flags int32 = ((0x00000002 | 0x00000004) | 0x00000040)
		(*sqlite3rbu)(unsafe.Pointer(p)).Frc = sqlite3.Xsqlite3_open_v2(tls, zName, bp+8 /* &db */, flags, func() uintptr {
			if bUseVfs != 0 {
				return (*sqlite3rbu)(unsafe.Pointer(p)).FzVfsName
			}
			return uintptr(0)
		}())
		if (*sqlite3rbu)(unsafe.Pointer(p)).Frc != 0 {
			(*sqlite3rbu)(unsafe.Pointer(p)).FzErrmsg = sqlite3.Xsqlite3_mprintf(tls, ts+130 /* "%s" */, crt.VaList(bp, sqlite3.Xsqlite3_errmsg(tls, *(*uintptr)(unsafe.Pointer(bp + 8 /* db */)))))
			sqlite3.Xsqlite3_close(tls, *(*uintptr)(unsafe.Pointer(bp + 8 /* db */)))
			*(*uintptr)(unsafe.Pointer(bp + 8 /* db */)) = uintptr(0)
		}
	}
	return *(*uintptr)(unsafe.Pointer(bp + 8 /* db */))
}

// Free an RbuState object allocated by rbuLoadState().
func rbuFreeState(tls *crt.TLS, p uintptr) { /* sqlite3rbu.c:2661:13: */
	if p != 0 {
		sqlite3.Xsqlite3_free(tls, (*RbuState)(unsafe.Pointer(p)).FzTbl)
		sqlite3.Xsqlite3_free(tls, (*RbuState)(unsafe.Pointer(p)).FzDataTbl)
		sqlite3.Xsqlite3_free(tls, (*RbuState)(unsafe.Pointer(p)).FzIdx)
		sqlite3.Xsqlite3_free(tls, p)
	}
}

// Allocate an RbuState object and load the contents of the rbu_state
// table into it. Return a pointer to the new object. It is the
// responsibility of the caller to eventually free the object using
// sqlite3_free().
//
// If an error occurs, leave an error code and message in the rbu handle
// and return NULL.
func rbuLoadState(tls *crt.TLS, p uintptr) uintptr { /* sqlite3rbu.c:2679:17: */
	bp := tls.Alloc(20)
	defer tls.Free(20)

	var pRet uintptr = uintptr(0)
	*(*uintptr)(unsafe.Pointer(bp + 8 /* pStmt */)) = uintptr(0)
	// var rc int32 at bp+16, 4

	var rc2 int32

	pRet = rbuMalloc(tls, p, int64(unsafe.Sizeof(RbuState{})))
	if pRet == uintptr(0) {
		return uintptr(0)
	}

	*(*int32)(unsafe.Pointer(bp + 16 /* rc */)) = prepareFreeAndCollectError(tls, (*sqlite3rbu)(unsafe.Pointer(p)).FdbRbu, bp+8 /* &pStmt */, (p + 64 /* &.zErrmsg */),
		sqlite3.Xsqlite3_mprintf(tls, ts+13613 /* "SELECT k, v FROM..." */, crt.VaList(bp, p+48 /* &.zStateDb */)))
	for (*(*int32)(unsafe.Pointer(bp + 16 /* rc */)) == 0) && (100 == sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 8 /* pStmt */)))) {
		switch sqlite3.Xsqlite3_column_int(tls, *(*uintptr)(unsafe.Pointer(bp + 8 /* pStmt */)), 0) {
		case 1:
			(*RbuState)(unsafe.Pointer(pRet)).FeStage = sqlite3.Xsqlite3_column_int(tls, *(*uintptr)(unsafe.Pointer(bp + 8 /* pStmt */)), 1)
			if (((*RbuState)(unsafe.Pointer(pRet)).FeStage != 1) &&
				((*RbuState)(unsafe.Pointer(pRet)).FeStage != 2)) &&
				((*RbuState)(unsafe.Pointer(pRet)).FeStage != 4) {
				(*sqlite3rbu)(unsafe.Pointer(p)).Frc = 11
			}
			break

		case 2:
			(*RbuState)(unsafe.Pointer(pRet)).FzTbl = rbuStrndup(tls, sqlite3.Xsqlite3_column_text(tls, *(*uintptr)(unsafe.Pointer(bp + 8 /* pStmt */)), 1), bp+16 /* &rc */)
			break

		case 3:
			(*RbuState)(unsafe.Pointer(pRet)).FzIdx = rbuStrndup(tls, sqlite3.Xsqlite3_column_text(tls, *(*uintptr)(unsafe.Pointer(bp + 8 /* pStmt */)), 1), bp+16 /* &rc */)
			break

		case 4:
			(*RbuState)(unsafe.Pointer(pRet)).FnRow = sqlite3.Xsqlite3_column_int(tls, *(*uintptr)(unsafe.Pointer(bp + 8 /* pStmt */)), 1)
			break

		case 5:
			(*RbuState)(unsafe.Pointer(pRet)).FnProgress = sqlite3.Xsqlite3_column_int64(tls, *(*uintptr)(unsafe.Pointer(bp + 8 /* pStmt */)), 1)
			break

		case 6:
			(*RbuState)(unsafe.Pointer(pRet)).FiWalCksum = sqlite3.Xsqlite3_column_int64(tls, *(*uintptr)(unsafe.Pointer(bp + 8 /* pStmt */)), 1)
			break

		case 7:
			(*RbuState)(unsafe.Pointer(pRet)).FiCookie = u32(sqlite3.Xsqlite3_column_int64(tls, *(*uintptr)(unsafe.Pointer(bp + 8 /* pStmt */)), 1))
			break

		case 8:
			(*RbuState)(unsafe.Pointer(pRet)).FiOalSz = i64(u32(sqlite3.Xsqlite3_column_int64(tls, *(*uintptr)(unsafe.Pointer(bp + 8 /* pStmt */)), 1)))
			break

		case 9:
			(*RbuState)(unsafe.Pointer(pRet)).FnPhaseOneStep = sqlite3.Xsqlite3_column_int64(tls, *(*uintptr)(unsafe.Pointer(bp + 8 /* pStmt */)), 1)
			break

		case 10:
			(*RbuState)(unsafe.Pointer(pRet)).FzDataTbl = rbuStrndup(tls, sqlite3.Xsqlite3_column_text(tls, *(*uintptr)(unsafe.Pointer(bp + 8 /* pStmt */)), 1), bp+16 /* &rc */)
			break

		default:
			*(*int32)(unsafe.Pointer(bp + 16 /* rc */)) = 11
			break
		}
	}
	rc2 = sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 8 /* pStmt */)))
	if *(*int32)(unsafe.Pointer(bp + 16 /* rc */)) == 0 {
		*(*int32)(unsafe.Pointer(bp + 16 /* rc */)) = rc2
	}

	(*sqlite3rbu)(unsafe.Pointer(p)).Frc = *(*int32)(unsafe.Pointer(bp + 16 /* rc */))
	return pRet
}

// Open the database handle and attach the RBU database as "rbu". If an
// error occurs, leave an error code and message in the RBU handle.
func rbuOpenDatabase(tls *crt.TLS, p uintptr, pbRetry uintptr) { /* sqlite3rbu.c:2756:13: */
	bp := tls.Alloc(56)
	defer tls.Free(56)

	if !(((*sqlite3rbu)(unsafe.Pointer(p)).Frc != 0) || (((*sqlite3rbu)(unsafe.Pointer(p)).FdbMain == uintptr(0)) && ((*sqlite3rbu)(unsafe.Pointer(p)).FdbRbu == uintptr(0)))) {
		crt.X__assert_fail(tls, ts+13643 /* "p->rc || (p->dbM..." */, ts+9694 /* "testdata/sqlite-..." */, uint32(2757), uintptr(unsafe.Pointer(&__func__58)))
	}
	if !((((*sqlite3rbu)(unsafe.Pointer(p)).Frc != 0) || ((*sqlite3rbu)(unsafe.Pointer((p))).FzTarget == uintptr(0))) || ((*sqlite3rbu)(unsafe.Pointer(p)).FzTarget != uintptr(0))) {
		crt.X__assert_fail(tls, ts+13682 /* "p->rc || ((p)->z..." */, ts+9694 /* "testdata/sqlite-..." */, uint32(2758), uintptr(unsafe.Pointer(&__func__58)))
	}

	// Open the RBU database
	(*sqlite3rbu)(unsafe.Pointer(p)).FdbRbu = rbuOpenDbhandle(tls, p, (*sqlite3rbu)(unsafe.Pointer(p)).FzRbu, 1)

	if ((*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0) && ((*sqlite3rbu)(unsafe.Pointer((p))).FzTarget == uintptr(0)) {
		sqlite3.Xsqlite3_file_control(tls, (*sqlite3rbu)(unsafe.Pointer(p)).FdbRbu, ts+354 /* "main" */, 5149216, p)
		if (*sqlite3rbu)(unsafe.Pointer(p)).FzState == uintptr(0) {
			var zFile uintptr = sqlite3.Xsqlite3_db_filename(tls, (*sqlite3rbu)(unsafe.Pointer(p)).FdbRbu, ts+354 /* "main" */)
			(*sqlite3rbu)(unsafe.Pointer(p)).FzState = rbuMPrintf(tls, p, ts+13726 /* "file://%s-vacuum..." */, crt.VaList(bp, zFile, zFile))
		}
	}

	// If using separate RBU and state databases, attach the state database to
	// the RBU db handle now.
	if (*sqlite3rbu)(unsafe.Pointer(p)).FzState != 0 {
		rbuMPrintfExec(tls, p, (*sqlite3rbu)(unsafe.Pointer(p)).FdbRbu, ts+13753 /* "ATTACH %Q AS sta..." */, crt.VaList(bp+16, (*sqlite3rbu)(unsafe.Pointer(p)).FzState))
		crt.Xmemcpy(tls, p+48 /* &.zStateDb */, ts+13771 /* "stat" */, uint64(4))
	} else {
		crt.Xmemcpy(tls, p+48 /* &.zStateDb */, ts+354 /* "main" */, uint64(4))
	}

	// If it has not already been created, create the rbu_state table
	rbuMPrintfExec(tls, p, (*sqlite3rbu)(unsafe.Pointer(p)).FdbRbu, ts+13776 /* "CREATE TABLE IF ..." */, crt.VaList(bp+24, p+48 /* &.zStateDb */))

	if ((*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0) && ((*sqlite3rbu)(unsafe.Pointer((p))).FzTarget == uintptr(0)) {
		var bOpen int32 = 0
		var rc int32
		(*sqlite3rbu)(unsafe.Pointer(p)).FnRbu = 0
		(*sqlite3rbu)(unsafe.Pointer(p)).FpRbuFd = uintptr(0)
		rc = sqlite3.Xsqlite3_file_control(tls, (*sqlite3rbu)(unsafe.Pointer(p)).FdbRbu, ts+354 /* "main" */, 5149216, p)
		if rc != 12 {
			(*sqlite3rbu)(unsafe.Pointer(p)).Frc = rc
		}
		if (*sqlite3rbu)(unsafe.Pointer(p)).FeStage >= 2 {
			bOpen = 1
		} else {
			var pState uintptr = rbuLoadState(tls, p)
			if pState != 0 {
				bOpen = (crt.Bool32((*RbuState)(unsafe.Pointer(pState)).FeStage >= 2))
				rbuFreeState(tls, pState)
			}
		}
		if bOpen != 0 {
			(*sqlite3rbu)(unsafe.Pointer(p)).FdbMain = rbuOpenDbhandle(tls, p, (*sqlite3rbu)(unsafe.Pointer(p)).FzRbu, (crt.Bool32((*sqlite3rbu)(unsafe.Pointer(p)).FnRbu <= 1)))
		}
	}

	(*sqlite3rbu)(unsafe.Pointer(p)).FeStage = 0
	if ((*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0) && ((*sqlite3rbu)(unsafe.Pointer(p)).FdbMain == uintptr(0)) {
		if !((*sqlite3rbu)(unsafe.Pointer((p))).FzTarget == uintptr(0)) {
			(*sqlite3rbu)(unsafe.Pointer(p)).FdbMain = rbuOpenDbhandle(tls, p, (*sqlite3rbu)(unsafe.Pointer(p)).FzTarget, 1)
		} else if (*rbu_file)(unsafe.Pointer((*sqlite3rbu)(unsafe.Pointer(p)).FpRbuFd)).FpWalFd != 0 {
			if pbRetry != 0 {
				(*rbu_file)(unsafe.Pointer((*sqlite3rbu)(unsafe.Pointer(p)).FpRbuFd)).FbNolock = u8(0)
				sqlite3.Xsqlite3_close(tls, (*sqlite3rbu)(unsafe.Pointer(p)).FdbRbu)
				sqlite3.Xsqlite3_close(tls, (*sqlite3rbu)(unsafe.Pointer(p)).FdbMain)
				(*sqlite3rbu)(unsafe.Pointer(p)).FdbMain = uintptr(0)
				(*sqlite3rbu)(unsafe.Pointer(p)).FdbRbu = uintptr(0)
				*(*int32)(unsafe.Pointer(pbRetry)) = 1
				return
			}
			(*sqlite3rbu)(unsafe.Pointer(p)).Frc = 1
			(*sqlite3rbu)(unsafe.Pointer(p)).FzErrmsg = sqlite3.Xsqlite3_mprintf(tls, ts+13842 /* "cannot vacuum wa..." */, 0)
		} else {
			var zTarget uintptr
			var zExtra uintptr = uintptr(0)
			if (crt.Xstrlen(tls, (*sqlite3rbu)(unsafe.Pointer(p)).FzRbu) >= uint64(5)) && (0 == crt.Xmemcmp(tls, ts+13874 /* "file:" */, (*sqlite3rbu)(unsafe.Pointer(p)).FzRbu, uint64(5))) {
				zExtra = ((*sqlite3rbu)(unsafe.Pointer(p)).FzRbu + uintptr(5))
				for *(*int8)(unsafe.Pointer(zExtra)) != 0 {
					if int32(*(*int8)(unsafe.Pointer(crt.PostIncUintptr(&zExtra, 1)))) == '?' {
						break
					}
				}
				if int32(*(*int8)(unsafe.Pointer(zExtra))) == 0 {
					zExtra = uintptr(0)
				}
			}

			zTarget = sqlite3.Xsqlite3_mprintf(tls, ts+13880, /* "file:%s-vactmp?r..." */
				crt.VaList(bp+32, sqlite3.Xsqlite3_db_filename(tls, (*sqlite3rbu)(unsafe.Pointer(p)).FdbRbu, ts+354 /* "main" */),
					func() uintptr {
						if zExtra == uintptr(0) {
							return ts + 792 /* "" */
						}
						return ts + 13912 /* "&" */
					}(), func() uintptr {
						if zExtra == uintptr(0) {
							return ts + 792 /* "" */
						}
						return zExtra
					}()))

			if zTarget == uintptr(0) {
				(*sqlite3rbu)(unsafe.Pointer(p)).Frc = 7
				return
			}
			(*sqlite3rbu)(unsafe.Pointer(p)).FdbMain = rbuOpenDbhandle(tls, p, zTarget, (crt.Bool32((*sqlite3rbu)(unsafe.Pointer(p)).FnRbu <= 1)))
			sqlite3.Xsqlite3_free(tls, zTarget)
		}
	}

	if (*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0 {
		(*sqlite3rbu)(unsafe.Pointer(p)).Frc = sqlite3.Xsqlite3_create_function(tls, (*sqlite3rbu)(unsafe.Pointer(p)).FdbMain,
			ts+13914 /* "rbu_tmp_insert" */, -1, 1, p, *(*uintptr)(unsafe.Pointer(&struct {
				f func(*crt.TLS, uintptr, int32, uintptr)
			}{rbuTmpInsertFunc})), uintptr(0), uintptr(0))
	}

	if (*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0 {
		(*sqlite3rbu)(unsafe.Pointer(p)).Frc = sqlite3.Xsqlite3_create_function(tls, (*sqlite3rbu)(unsafe.Pointer(p)).FdbMain,
			ts+13929 /* "rbu_fossil_delta" */, 2, 1, uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
				f func(*crt.TLS, uintptr, int32, uintptr)
			}{rbuFossilDeltaFunc})), uintptr(0), uintptr(0))
	}

	if (*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0 {
		(*sqlite3rbu)(unsafe.Pointer(p)).Frc = sqlite3.Xsqlite3_create_function(tls, (*sqlite3rbu)(unsafe.Pointer(p)).FdbRbu,
			ts+13946 /* "rbu_target_name" */, -1, 1, p, *(*uintptr)(unsafe.Pointer(&struct {
				f func(*crt.TLS, uintptr, int32, uintptr)
			}{rbuTargetNameFunc})), uintptr(0), uintptr(0))
	}

	if (*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0 {
		(*sqlite3rbu)(unsafe.Pointer(p)).Frc = sqlite3.Xsqlite3_file_control(tls, (*sqlite3rbu)(unsafe.Pointer(p)).FdbMain, ts+354 /* "main" */, 26, p)
	}
	rbuMPrintfExec(tls, p, (*sqlite3rbu)(unsafe.Pointer(p)).FdbMain, ts+13962 /* "SELECT * FROM sq..." */, 0)

	// Mark the database file just opened as an RBU target database. If
	// this call returns SQLITE_NOTFOUND, then the RBU vfs is not in use.
	// This is an error.
	if (*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0 {
		(*sqlite3rbu)(unsafe.Pointer(p)).Frc = sqlite3.Xsqlite3_file_control(tls, (*sqlite3rbu)(unsafe.Pointer(p)).FdbMain, ts+354 /* "main" */, 26, p)
	}

	if (*sqlite3rbu)(unsafe.Pointer(p)).Frc == 12 {
		(*sqlite3rbu)(unsafe.Pointer(p)).Frc = 1
		(*sqlite3rbu)(unsafe.Pointer(p)).FzErrmsg = sqlite3.Xsqlite3_mprintf(tls, ts+13990 /* "rbu vfs not foun..." */, 0)
	}
}

var __func__58 = *(*[16]int8)(unsafe.Pointer(ts + 14008 /* "rbuOpenDatabase" */)) /* sqlite3rbu.c:2756:57 */

// This routine is a copy of the sqlite3FileSuffix3() routine from the core.
// It is a no-op unless SQLITE_ENABLE_8_3_NAMES is defined.
//
// If SQLITE_ENABLE_8_3_NAMES is set at compile-time and if the database
// filename in zBaseFilename is a URI with the "8_3_names=1" parameter and
// if filename in z[] has a suffix (a.k.a. "extension") that is longer than
// three characters, then shorten the suffix on z[] to be the last three
// characters of the original suffix.
//
// If SQLITE_ENABLE_8_3_NAMES is set to 2 at compile-time, then always
// do the suffix shortening regardless of URI parameter.
//
// Examples:
//
//     test.db-journal    =>   test.nal
//     test.db-wal        =>   test.wal
//     test.db-shm        =>   test.shm
//     test.db-mj7f3319fa =>   test.9fa
func rbuFileSuffix3(tls *crt.TLS, zBase uintptr, z uintptr) { /* sqlite3rbu.c:2935:13: */
}

// Return the current wal-index header checksum for the target database
// as a 64-bit integer.
//
// The checksum is store in the first page of xShmMap memory as an 8-byte
// blob starting at byte offset 40.
func rbuShmChecksum(tls *crt.TLS, p uintptr) i64 { /* sqlite3rbu.c:2956:12: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var iRet i64 = int64(0)
	if (*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0 {
		var pDb uintptr = (*rbu_file)(unsafe.Pointer((*sqlite3rbu)(unsafe.Pointer(p)).FpTargetFd)).FpReal
		// var ptr uintptr at bp, 8

		(*sqlite3rbu)(unsafe.Pointer(p)).Frc = (*(*func(*crt.TLS, uintptr, int32, int32, int32, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pDb)).FpMethods + 104 /* &.xShmMap */))))(tls, pDb, 0, (32 * 1024), 0, bp /* &ptr */)
		if (*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0 {
			iRet = ((i64(*(*u32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* ptr */)) + uintptr(10)*4))) << 32) + i64(*(*u32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* ptr */)) + uintptr(11)*4))))
		}
	}
	return iRet
}

// This function is called as part of initializing or reinitializing an
// incremental checkpoint.
//
// It populates the sqlite3rbu.aFrame[] array with the set of
// (wal frame -> db page) copy operations required to checkpoint the
// current wal file, and obtains the set of shm locks required to safely
// perform the copy operations directly on the file-system.
//
// If argument pState is not NULL, then the incremental checkpoint is
// being resumed. In this case, if the checksum of the wal-index-header
// following recovery is not the same as the checksum saved in the RbuState
// object, then the rbu handle is set to DONE state. This occurs if some
// other client appends a transaction to the wal file in the middle of
// an incremental checkpoint.
func rbuSetupCheckpoint(tls *crt.TLS, p uintptr, pState uintptr) { /* sqlite3rbu.c:2985:13: */

	// If pState is NULL, then the wal file may not have been opened and
	// recovered. Running a read-statement here to ensure that doing so
	// does not interfere with the "capture" process below.
	if pState == uintptr(0) {
		(*sqlite3rbu)(unsafe.Pointer(p)).FeStage = 0
		if (*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0 {
			(*sqlite3rbu)(unsafe.Pointer(p)).Frc = sqlite3.Xsqlite3_exec(tls, (*sqlite3rbu)(unsafe.Pointer(p)).FdbMain, ts+13962 /* "SELECT * FROM sq..." */, uintptr(0), uintptr(0), uintptr(0))
		}
	}

	// Assuming no error has occurred, run a "restart" checkpoint with the
	// sqlite3rbu.eStage variable set to CAPTURE. This turns on the following
	// special behaviour in the rbu VFS:
	//
	//   * If the exclusive shm WRITER or READ0 lock cannot be obtained,
	//     the checkpoint fails with SQLITE_BUSY (normally SQLite would
	//     proceed with running a passive checkpoint instead of failing).
	//
	//   * Attempts to read from the *-wal file or write to the database file
	//     do not perform any IO. Instead, the frame/page combinations that
	//     would be read/written are recorded in the sqlite3rbu.aFrame[]
	//     array.
	//
	//   * Calls to xShmLock(UNLOCK) to release the exclusive shm WRITER,
	//     READ0 and CHECKPOINT locks taken as part of the checkpoint are
	//     no-ops. These locks will not be released until the connection
	//     is closed.
	//
	//   * Attempting to xSync() the database file causes an SQLITE_INTERNAL
	//     error.
	//
	// As a result, unless an error (i.e. OOM or SQLITE_BUSY) occurs, the
	// checkpoint below fails with SQLITE_INTERNAL, and leaves the aFrame[]
	// array populated with a set of (frame -> page) mappings. Because the
	// WRITER, CHECKPOINT and READ0 locks are still held, it is safe to copy
	// data from the wal file into the database file according to the
	// contents of aFrame[].
	if (*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0 {
		var rc2 int32
		(*sqlite3rbu)(unsafe.Pointer(p)).FeStage = 3
		rc2 = sqlite3.Xsqlite3_exec(tls, (*sqlite3rbu)(unsafe.Pointer(p)).FdbMain, ts+14024 /* "PRAGMA main.wal_..." */, uintptr(0), uintptr(0), uintptr(0))
		if rc2 != 2 {
			(*sqlite3rbu)(unsafe.Pointer(p)).Frc = rc2
		}
	}

	if ((*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0) && ((*sqlite3rbu)(unsafe.Pointer(p)).FnFrame > 0) {
		(*sqlite3rbu)(unsafe.Pointer(p)).FeStage = 4
		(*sqlite3rbu)(unsafe.Pointer(p)).FnStep = func() int32 {
			if pState != 0 {
				return (*RbuState)(unsafe.Pointer(pState)).FnRow
			}
			return 0
		}()
		(*sqlite3rbu)(unsafe.Pointer(p)).FaBuf = rbuMalloc(tls, p, int64((*sqlite3rbu)(unsafe.Pointer(p)).Fpgsz))
		(*sqlite3rbu)(unsafe.Pointer(p)).FiWalCksum = rbuShmChecksum(tls, p)
	}

	if (*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0 {
		if ((*sqlite3rbu)(unsafe.Pointer(p)).FnFrame == 0) || ((pState != 0) && ((*RbuState)(unsafe.Pointer(pState)).FiWalCksum != (*sqlite3rbu)(unsafe.Pointer(p)).FiWalCksum)) {
			(*sqlite3rbu)(unsafe.Pointer(p)).Frc = 101
			(*sqlite3rbu)(unsafe.Pointer(p)).FeStage = 5
		} else {
			var nSectorSize int32
			var pDb uintptr = (*rbu_file)(unsafe.Pointer((*sqlite3rbu)(unsafe.Pointer(p)).FpTargetFd)).FpReal
			var pWal uintptr = (*rbu_file)(unsafe.Pointer((*rbu_file)(unsafe.Pointer((*sqlite3rbu)(unsafe.Pointer(p)).FpTargetFd)).FpWalFd)).FpReal
			if !((*sqlite3rbu)(unsafe.Pointer(p)).FnPagePerSector == 0) {
				crt.X__assert_fail(tls, ts+14059 /* "p->nPagePerSecto..." */, ts+9694 /* "testdata/sqlite-..." */, uint32(3047), uintptr(unsafe.Pointer(&__func__59)))
			}
			nSectorSize = (*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pDb)).FpMethods + 88 /* &.xSectorSize */))))(tls, pDb)
			if nSectorSize > (*sqlite3rbu)(unsafe.Pointer(p)).Fpgsz {
				(*sqlite3rbu)(unsafe.Pointer(p)).FnPagePerSector = (nSectorSize / (*sqlite3rbu)(unsafe.Pointer(p)).Fpgsz)
			} else {
				(*sqlite3rbu)(unsafe.Pointer(p)).FnPagePerSector = 1
			}

			// Call xSync() on the wal file. This causes SQLite to sync the
			// directory in which the target database and the wal file reside, in
			// case it has not been synced since the rename() call in
			// rbuMoveOalFile().
			(*sqlite3rbu)(unsafe.Pointer(p)).Frc = (*(*func(*crt.TLS, uintptr, int32) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pWal)).FpMethods + 40 /* &.xSync */))))(tls, pWal, 0x00002)
		}
	}
}

var __func__59 = *(*[19]int8)(unsafe.Pointer(ts + 14080 /* "rbuSetupCheckpoi..." */)) /* sqlite3rbu.c:2985:64 */

// Called when iAmt bytes are read from offset iOff of the wal file while
// the rbu object is in capture mode. Record the frame number of the frame
// being read in the aFrame[] array.
func rbuCaptureWalRead(tls *crt.TLS, pRbu uintptr, iOff i64, iAmt int32) int32 { /* sqlite3rbu.c:3069:12: */
	var mReq u32 = (u32(((int32(1) << 0) | (int32(1) << 1)) | (int32(1) << 3)))
	var iFrame u32

	if (*sqlite3rbu)(unsafe.Pointer(pRbu)).FmLock != mReq {
		(*sqlite3rbu)(unsafe.Pointer(pRbu)).Frc = 5
		return 2
	}

	(*sqlite3rbu)(unsafe.Pointer(pRbu)).Fpgsz = iAmt
	if (*sqlite3rbu)(unsafe.Pointer(pRbu)).FnFrame == (*sqlite3rbu)(unsafe.Pointer(pRbu)).FnFrameAlloc {
		var nNew int32 = ((func() int32 {
			if (*sqlite3rbu)(unsafe.Pointer(pRbu)).FnFrameAlloc != 0 {
				return (*sqlite3rbu)(unsafe.Pointer(pRbu)).FnFrameAlloc
			}
			return 64
		}()) * 2)
		var aNew uintptr
		aNew = sqlite3.Xsqlite3_realloc64(tls, (*sqlite3rbu)(unsafe.Pointer(pRbu)).FaFrame, (uint64(uint64(nNew) * uint64(unsafe.Sizeof(RbuFrame{})))))
		if aNew == uintptr(0) {
			return 7
		}
		(*sqlite3rbu)(unsafe.Pointer(pRbu)).FaFrame = aNew
		(*sqlite3rbu)(unsafe.Pointer(pRbu)).FnFrameAlloc = nNew
	}

	iFrame = ((u32((iOff - int64(32)) / (i64(iAmt + 24)))) + u32(1))
	if (*sqlite3rbu)(unsafe.Pointer(pRbu)).FiMaxFrame < iFrame {
		(*sqlite3rbu)(unsafe.Pointer(pRbu)).FiMaxFrame = iFrame
	}
	(*RbuFrame)(unsafe.Pointer((*sqlite3rbu)(unsafe.Pointer(pRbu)).FaFrame + uintptr((*sqlite3rbu)(unsafe.Pointer(pRbu)).FnFrame)*8)).FiWalFrame = iFrame
	(*RbuFrame)(unsafe.Pointer((*sqlite3rbu)(unsafe.Pointer(pRbu)).FaFrame + uintptr((*sqlite3rbu)(unsafe.Pointer(pRbu)).FnFrame)*8)).FiDbPage = u32(0)
	(*sqlite3rbu)(unsafe.Pointer(pRbu)).FnFrame++
	return 0
}

// Called when a page of data is written to offset iOff of the database
// file while the rbu handle is in capture mode. Record the page number
// of the page being written in the aFrame[] array.
func rbuCaptureDbWrite(tls *crt.TLS, pRbu uintptr, iOff i64) int32 { /* sqlite3rbu.c:3101:12: */
	(*RbuFrame)(unsafe.Pointer((*sqlite3rbu)(unsafe.Pointer(pRbu)).FaFrame + uintptr(((*sqlite3rbu)(unsafe.Pointer(pRbu)).FnFrame-1))*8)).FiDbPage = ((u32(iOff / i64((*sqlite3rbu)(unsafe.Pointer(pRbu)).Fpgsz))) + u32(1))
	return 0
}

// This is called as part of an incremental checkpoint operation. Copy
// a single frame of data from the wal file into the database file, as
// indicated by the RbuFrame object.
func rbuCheckpointFrame(tls *crt.TLS, p uintptr, pFrame uintptr) { /* sqlite3rbu.c:3111:13: */
	var pWal uintptr = (*rbu_file)(unsafe.Pointer((*rbu_file)(unsafe.Pointer((*sqlite3rbu)(unsafe.Pointer(p)).FpTargetFd)).FpWalFd)).FpReal
	var pDb uintptr = (*rbu_file)(unsafe.Pointer((*sqlite3rbu)(unsafe.Pointer(p)).FpTargetFd)).FpReal
	var iOff i64

	if !((*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0) {
		crt.X__assert_fail(tls, ts+10376 /* "p->rc==0" */, ts+9694 /* "testdata/sqlite-..." */, uint32(3116), uintptr(unsafe.Pointer(&__func__60)))
	}
	iOff = ((((i64((*RbuFrame)(unsafe.Pointer(pFrame)).FiWalFrame - u32(1))) * (i64((*sqlite3rbu)(unsafe.Pointer(p)).Fpgsz + 24))) + int64(32)) + int64(24))
	(*sqlite3rbu)(unsafe.Pointer(p)).Frc = (*(*func(*crt.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pWal)).FpMethods + 16 /* &.xRead */))))(tls, pWal, (*sqlite3rbu)(unsafe.Pointer(p)).FaBuf, (*sqlite3rbu)(unsafe.Pointer(p)).Fpgsz, iOff)
	if (*sqlite3rbu)(unsafe.Pointer(p)).Frc != 0 {
		return
	}

	iOff = ((i64((*RbuFrame)(unsafe.Pointer(pFrame)).FiDbPage - u32(1))) * i64((*sqlite3rbu)(unsafe.Pointer(p)).Fpgsz))
	(*sqlite3rbu)(unsafe.Pointer(p)).Frc = (*(*func(*crt.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pDb)).FpMethods + 24 /* &.xWrite */))))(tls, pDb, (*sqlite3rbu)(unsafe.Pointer(p)).FaBuf, (*sqlite3rbu)(unsafe.Pointer(p)).Fpgsz, iOff)
}

var __func__60 = *(*[19]int8)(unsafe.Pointer(ts + 14099 /* "rbuCheckpointFra..." */)) /* sqlite3rbu.c:3111:64 */

// Take an EXCLUSIVE lock on the database file.
func rbuLockDatabase(tls *crt.TLS, p uintptr) { /* sqlite3rbu.c:3129:13: */
	var pReal uintptr = (*rbu_file)(unsafe.Pointer((*sqlite3rbu)(unsafe.Pointer(p)).FpTargetFd)).FpReal
	if !((*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0) {
		crt.X__assert_fail(tls, ts+10376 /* "p->rc==0" */, ts+9694 /* "testdata/sqlite-..." */, uint32(3131), uintptr(unsafe.Pointer(&__func__61)))
	}
	(*sqlite3rbu)(unsafe.Pointer(p)).Frc = (*(*func(*crt.TLS, uintptr, int32) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pReal)).FpMethods + 56 /* &.xLock */))))(tls, pReal, 1)
	if (*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0 {
		(*sqlite3rbu)(unsafe.Pointer(p)).Frc = (*(*func(*crt.TLS, uintptr, int32) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pReal)).FpMethods + 56 /* &.xLock */))))(tls, pReal, 4)
	}
}

var __func__61 = *(*[16]int8)(unsafe.Pointer(ts + 14118 /* "rbuLockDatabase" */)) /* sqlite3rbu.c:3129:43 */

// The RBU handle is currently in RBU_STAGE_OAL state, with a SHARED lock
// on the database file. This proc moves the *-oal file to the *-wal path,
// then reopens the database file (this time in vanilla, non-oal, WAL mode).
// If an error occurs, leave an error code and error message in the rbu
// handle.
func rbuMoveOalFile(tls *crt.TLS, p uintptr) { /* sqlite3rbu.c:3169:13: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var zBase uintptr = sqlite3.Xsqlite3_db_filename(tls, (*sqlite3rbu)(unsafe.Pointer(p)).FdbMain, ts+354 /* "main" */)
	var zMove uintptr = zBase
	var zOal uintptr
	var zWal uintptr

	if (*sqlite3rbu)(unsafe.Pointer((p))).FzTarget == uintptr(0) {
		zMove = sqlite3.Xsqlite3_db_filename(tls, (*sqlite3rbu)(unsafe.Pointer(p)).FdbRbu, ts+354 /* "main" */)
	}
	zOal = sqlite3.Xsqlite3_mprintf(tls, ts+14134 /* "%s-oal" */, crt.VaList(bp, zMove))
	zWal = sqlite3.Xsqlite3_mprintf(tls, ts+14141 /* "%s-wal" */, crt.VaList(bp+8, zMove))

	if !((*sqlite3rbu)(unsafe.Pointer(p)).FeStage == 2) {
		crt.X__assert_fail(tls, ts+14148 /* "p->eStage==2" */, ts+9694 /* "testdata/sqlite-..." */, uint32(3181), uintptr(unsafe.Pointer(&__func__62)))
	}
	if !(((*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0) && ((*sqlite3rbu)(unsafe.Pointer(p)).FzErrmsg == uintptr(0))) {
		crt.X__assert_fail(tls, ts+14161 /* "p->rc==0 && p->z..." */, ts+9694 /* "testdata/sqlite-..." */, uint32(3182), uintptr(unsafe.Pointer(&__func__62)))
	}
	if (zWal == uintptr(0)) || (zOal == uintptr(0)) {
		(*sqlite3rbu)(unsafe.Pointer(p)).Frc = 7
	} else {
		// Move the *-oal file to *-wal. At this point connection p->db is
		// holding a SHARED lock on the target database file (because it is
		// in WAL mode). So no other connection may be writing the db.
		//
		// In order to ensure that there are no database readers, an EXCLUSIVE
		// lock is obtained here before the *-oal is moved to *-wal.
		rbuLockDatabase(tls, p)
		if (*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0 {
			rbuFileSuffix3(tls, zBase, zWal)
			rbuFileSuffix3(tls, zBase, zOal)

			// Re-open the databases.
			rbuObjIterFinalize(tls, (p + 80 /* &.objiter */))
			sqlite3.Xsqlite3_close(tls, (*sqlite3rbu)(unsafe.Pointer(p)).FdbRbu)
			sqlite3.Xsqlite3_close(tls, (*sqlite3rbu)(unsafe.Pointer(p)).FdbMain)
			(*sqlite3rbu)(unsafe.Pointer(p)).FdbMain = uintptr(0)
			(*sqlite3rbu)(unsafe.Pointer(p)).FdbRbu = uintptr(0)

			(*sqlite3rbu)(unsafe.Pointer(p)).Frc = func() int32 {
				if crt.Xrename(tls, zOal, zWal) != 0 {
					return 10
				}
				return 0
			}()

			if (*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0 {
				rbuOpenDatabase(tls, p, uintptr(0))
				rbuSetupCheckpoint(tls, p, uintptr(0))
			}
		}
	}

	sqlite3.Xsqlite3_free(tls, zWal)
	sqlite3.Xsqlite3_free(tls, zOal)
}

var __func__62 = *(*[15]int8)(unsafe.Pointer(ts + 14187 /* "rbuMoveOalFile" */)) /* sqlite3rbu.c:3169:42 */

// The SELECT statement iterating through the keys for the current object
// (p->objiter.pSelect) currently points to a valid row. This function
// determines the type of operation requested by this row and returns
// one of the following values to indicate the result:
//
//     * RBU_INSERT
//     * RBU_DELETE
//     * RBU_IDX_DELETE
//     * RBU_UPDATE
//
// If RBU_UPDATE is returned, then output variable *pzMask is set to
// point to the text value indicating the columns to update.
//
// If the rbu_control field contains an invalid value, an error code and
// message are left in the RBU handle and zero returned.
func rbuStepType(tls *crt.TLS, p uintptr, pzMask uintptr) int32 { /* sqlite3rbu.c:3260:12: */
	var iCol int32 = (*sqlite3rbu)(unsafe.Pointer(p)).Fobjiter.FnCol // Index of rbu_control column
	var res int32 = 0                                                // Return value

	switch sqlite3.Xsqlite3_column_type(tls, (*sqlite3rbu)(unsafe.Pointer(p)).Fobjiter.FpSelect, iCol) {
	case 1:
		{
			var iVal int32 = sqlite3.Xsqlite3_column_int(tls, (*sqlite3rbu)(unsafe.Pointer(p)).Fobjiter.FpSelect, iCol)
			switch iVal {
			case 0:
				res = 1
				break
			case 1:
				res = 2
				break
			case 2:
				res = 3
				break
			case 3:
				res = 4
				break
			case 4:
				res = 5
				break
			}
			break
		}

	case 3:
		{
			var z uintptr = sqlite3.Xsqlite3_column_text(tls, (*sqlite3rbu)(unsafe.Pointer(p)).Fobjiter.FpSelect, iCol)
			if z == uintptr(0) {
				(*sqlite3rbu)(unsafe.Pointer(p)).Frc = 7
			} else {
				*(*uintptr)(unsafe.Pointer(pzMask)) = z
			}
			res = 6

			break
		}

	default:
		break
	}

	if res == 0 {
		rbuBadControlError(tls, p)
	}
	return res
}

// Argument eType must be one of RBU_INSERT, RBU_DELETE, RBU_IDX_INSERT or
// RBU_IDX_DELETE. This function performs the work of a single
// sqlite3rbu_step() call for the type of operation specified by eType.
func rbuStepOneOp(tls *crt.TLS, p uintptr, eType int32) { /* sqlite3rbu.c:3316:13: */
	var pIter uintptr = (p + 80 /* &.objiter */)
	var pVal uintptr
	var pWriter uintptr
	var i int32

	if !((*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0) {
		crt.X__assert_fail(tls, ts+10376 /* "p->rc==0" */, ts+9694 /* "testdata/sqlite-..." */, uint32(3322), uintptr(unsafe.Pointer(&__func__63)))
	}
	if !((eType != 2) || ((*RbuObjIter)(unsafe.Pointer(pIter)).FzIdx == uintptr(0))) {
		crt.X__assert_fail(tls, ts+14202 /* "eType!=2 || pIte..." */, ts+9694 /* "testdata/sqlite-..." */, uint32(3323), uintptr(unsafe.Pointer(&__func__63)))
	}
	if !((((eType == 2) || (eType == 4)) || (eType == 1)) || (eType == 5)) {
		crt.X__assert_fail(tls, ts+14229 /* "eType==2 || eTyp..." */, ts+9694 /* "testdata/sqlite-..." */, uint32(3324), uintptr(unsafe.Pointer(&__func__63)))
	}

	// If this is a delete, decrement nPhaseOneStep by nIndex. If the DELETE
	// statement below does actually delete a row, nPhaseOneStep will be
	// incremented by the same amount when SQL function rbu_tmp_insert()
	// is invoked by the trigger.
	if eType == 2 {
		*(*i64)(unsafe.Pointer(p + 304 /* &.nPhaseOneStep */)) -= (i64((*sqlite3rbu)(unsafe.Pointer(p)).Fobjiter.FnIndex))
	}

	if (eType == 4) || (eType == 2) {
		pWriter = (*RbuObjIter)(unsafe.Pointer(pIter)).FpDelete
	} else {
		pWriter = (*RbuObjIter)(unsafe.Pointer(pIter)).FpInsert
	}

	for i = 0; i < (*RbuObjIter)(unsafe.Pointer(pIter)).FnCol; i++ {
		// If this is an INSERT into a table b-tree and the table has an
		// explicit INTEGER PRIMARY KEY, check that this is not an attempt
		// to write a NULL into the IPK column. That is not permitted.
		if ((((eType == 1) &&
			((*RbuObjIter)(unsafe.Pointer(pIter)).FzIdx == uintptr(0))) && ((*RbuObjIter)(unsafe.Pointer(pIter)).FeType == 2)) && (*(*u8)(unsafe.Pointer((*RbuObjIter)(unsafe.Pointer(pIter)).FabTblPk + uintptr(i))) != 0)) &&
			(sqlite3.Xsqlite3_column_type(tls, (*RbuObjIter)(unsafe.Pointer(pIter)).FpSelect, i) == 5) {
			(*sqlite3rbu)(unsafe.Pointer(p)).Frc = 20
			(*sqlite3rbu)(unsafe.Pointer(p)).FzErrmsg = sqlite3.Xsqlite3_mprintf(tls, ts+14274 /* "datatype mismatc..." */, 0)
			return
		}

		if (eType == 2) && (int32(*(*u8)(unsafe.Pointer((*RbuObjIter)(unsafe.Pointer(pIter)).FabTblPk + uintptr(i)))) == 0) {
			continue
		}

		pVal = sqlite3.Xsqlite3_column_value(tls, (*RbuObjIter)(unsafe.Pointer(pIter)).FpSelect, i)
		(*sqlite3rbu)(unsafe.Pointer(p)).Frc = sqlite3.Xsqlite3_bind_value(tls, pWriter, (i + 1), pVal)
		if (*sqlite3rbu)(unsafe.Pointer(p)).Frc != 0 {
			return
		}
	}
	if (*RbuObjIter)(unsafe.Pointer(pIter)).FzIdx == uintptr(0) {
		if (((*RbuObjIter)(unsafe.Pointer(pIter)).FeType == 5) ||
			((*RbuObjIter)(unsafe.Pointer(pIter)).FeType == 1)) ||
			(((*RbuObjIter)(unsafe.Pointer(pIter)).FeType == 3) && ((*sqlite3rbu)(unsafe.Pointer((p))).FzTarget == uintptr(0))) {
			// For a virtual table, or a table with no primary key, the
			// SELECT statement is:
			//
			//   SELECT <cols>, rbu_control, rbu_rowid FROM ....
			//
			// Hence column_value(pIter->nCol+1).

			pVal = sqlite3.Xsqlite3_column_value(tls, (*RbuObjIter)(unsafe.Pointer(pIter)).FpSelect, ((*RbuObjIter)(unsafe.Pointer(pIter)).FnCol + 1))
			(*sqlite3rbu)(unsafe.Pointer(p)).Frc = sqlite3.Xsqlite3_bind_value(tls, pWriter, ((*RbuObjIter)(unsafe.Pointer(pIter)).FnCol + 1), pVal)
		}
	}
	if (*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0 {
		sqlite3.Xsqlite3_step(tls, pWriter)
		(*sqlite3rbu)(unsafe.Pointer(p)).Frc = resetAndCollectError(tls, pWriter, (p + 64 /* &.zErrmsg */))
	}
}

var __func__63 = *(*[13]int8)(unsafe.Pointer(ts + 14292 /* "rbuStepOneOp" */)) /* sqlite3rbu.c:3316:51 */

// This function does the work for an sqlite3rbu_step() call.
//
// The object-iterator (p->objiter) currently points to a valid object,
// and the input cursor (p->objiter.pSelect) currently points to a valid
// input row. Perform whatever processing is required and return.
//
// If no  error occurs, SQLITE_OK is returned. Otherwise, an error code
// and message is left in the RBU handle and a copy of the error code
// returned.
func rbuStep(tls *crt.TLS, p uintptr) int32 { /* sqlite3rbu.c:3399:12: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var pIter uintptr = (p + 80 /* &.objiter */)
	*(*uintptr)(unsafe.Pointer(bp /* zMask */)) = uintptr(0)
	var eType int32 = rbuStepType(tls, p, bp /* &zMask */)

	if eType != 0 {
		if !((((((eType == 1) || (eType == 2)) || (eType == 3)) || (eType == 4)) || (eType == 5)) || (eType == 6)) {
			crt.X__assert_fail(tls, ts+14305 /* "eType==1 || eTyp..." */, ts+9694 /* "testdata/sqlite-..." */, uint32(3405), uintptr(unsafe.Pointer(&__func__64)))
		}
		if !((eType != 6) || ((*RbuObjIter)(unsafe.Pointer(pIter)).FzIdx == uintptr(0))) {
			crt.X__assert_fail(tls, ts+14374 /* "eType!=6 || pIte..." */, ts+9694 /* "testdata/sqlite-..." */, uint32(3409), uintptr(unsafe.Pointer(&__func__64)))
		}

		if ((*RbuObjIter)(unsafe.Pointer(pIter)).FzIdx == uintptr(0)) && ((eType == 4) || (eType == 5)) {
			rbuBadControlError(tls, p)
		} else if eType == 3 {
			if (*RbuObjIter)(unsafe.Pointer(pIter)).FzIdx == uintptr(0) {
				*(*i64)(unsafe.Pointer(p + 304 /* &.nPhaseOneStep */)) += (i64((*sqlite3rbu)(unsafe.Pointer(p)).Fobjiter.FnIndex))
				rbuStepOneOp(tls, p, 2)
			}
			if (*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0 {
				rbuStepOneOp(tls, p, 1)
			}
		} else if eType != 6 {
			rbuStepOneOp(tls, p, eType)
		} else {
			var pVal uintptr
			*(*uintptr)(unsafe.Pointer(bp + 8 /* pUpdate */)) = uintptr(0)
			if !(eType == 6) {
				crt.X__assert_fail(tls, ts+14401 /* "eType==6" */, ts+9694 /* "testdata/sqlite-..." */, uint32(3427), uintptr(unsafe.Pointer(&__func__64)))
			}
			*(*i64)(unsafe.Pointer(p + 304 /* &.nPhaseOneStep */)) -= (i64((*sqlite3rbu)(unsafe.Pointer(p)).Fobjiter.FnIndex))
			rbuGetUpdateStmt(tls, p, pIter, *(*uintptr)(unsafe.Pointer(bp /* zMask */)), bp+8 /* &pUpdate */)
			if *(*uintptr)(unsafe.Pointer(bp + 8 /* pUpdate */)) != 0 {
				var i int32
				for i = 0; ((*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0) && (i < (*RbuObjIter)(unsafe.Pointer(pIter)).FnCol); i++ {
					var c int8 = *(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* zMask */)) + uintptr(*(*int32)(unsafe.Pointer((*RbuObjIter)(unsafe.Pointer(pIter)).FaiSrcOrder + uintptr(i)*4)))))
					pVal = sqlite3.Xsqlite3_column_value(tls, (*RbuObjIter)(unsafe.Pointer(pIter)).FpSelect, i)
					if (*(*u8)(unsafe.Pointer((*RbuObjIter)(unsafe.Pointer(pIter)).FabTblPk + uintptr(i))) != 0) || (int32(c) != '.') {
						(*sqlite3rbu)(unsafe.Pointer(p)).Frc = sqlite3.Xsqlite3_bind_value(tls, *(*uintptr)(unsafe.Pointer(bp + 8 /* pUpdate */)), (i + 1), pVal)
					}
				}
				if ((*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0) &&
					(((*RbuObjIter)(unsafe.Pointer(pIter)).FeType == 5) || ((*RbuObjIter)(unsafe.Pointer(pIter)).FeType == 1)) {
					// Bind the rbu_rowid value to column _rowid_

					pVal = sqlite3.Xsqlite3_column_value(tls, (*RbuObjIter)(unsafe.Pointer(pIter)).FpSelect, ((*RbuObjIter)(unsafe.Pointer(pIter)).FnCol + 1))
					(*sqlite3rbu)(unsafe.Pointer(p)).Frc = sqlite3.Xsqlite3_bind_value(tls, *(*uintptr)(unsafe.Pointer(bp + 8 /* pUpdate */)), ((*RbuObjIter)(unsafe.Pointer(pIter)).FnCol + 1), pVal)
				}
				if (*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0 {
					sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 8 /* pUpdate */)))
					(*sqlite3rbu)(unsafe.Pointer(p)).Frc = resetAndCollectError(tls, *(*uintptr)(unsafe.Pointer(bp + 8 /* pUpdate */)), (p + 64 /* &.zErrmsg */))
				}
			}
		}
	}
	return (*sqlite3rbu)(unsafe.Pointer(p)).Frc
}

var __func__64 = *(*[8]int8)(unsafe.Pointer(ts + 14410 /* "rbuStep" */)) /* sqlite3rbu.c:3399:34 */

// Increment the schema cookie of the main database opened by p->dbMain.
//
// Or, if this is an RBU vacuum, set the schema cookie of the main db
// opened by p->dbMain to one more than the schema cookie of the main
// db opened by p->dbRbu.
func rbuIncrSchemaCookie(tls *crt.TLS, p uintptr) { /* sqlite3rbu.c:3464:13: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	if (*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0 {
		var dbread uintptr = func() uintptr {
			if (*sqlite3rbu)(unsafe.Pointer((p))).FzTarget == uintptr(0) {
				return (*sqlite3rbu)(unsafe.Pointer(p)).FdbRbu
			}
			return (*sqlite3rbu)(unsafe.Pointer(p)).FdbMain
		}()
		var iCookie int32 = 1000000
		// var pStmt uintptr at bp+8, 8

		(*sqlite3rbu)(unsafe.Pointer(p)).Frc = prepareAndCollectError(tls, dbread, bp+8 /* &pStmt */, (p + 64 /* &.zErrmsg */),
			ts+14418 /* "PRAGMA schema_ve..." */)
		if (*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0 {
			// Coverage: it may be that this sqlite3_step() cannot fail. There
			// is already a transaction open, so the prepared statement cannot
			// throw an SQLITE_SCHEMA exception. The only database page the
			// statement reads is page 1, which is guaranteed to be in the cache.
			// And no memory allocations are required.
			if 100 == sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 8 /* pStmt */))) {
				iCookie = sqlite3.Xsqlite3_column_int(tls, *(*uintptr)(unsafe.Pointer(bp + 8 /* pStmt */)), 0)
			}
			rbuFinalize(tls, p, *(*uintptr)(unsafe.Pointer(bp + 8 /* pStmt */)))
		}
		if (*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0 {
			rbuMPrintfExec(tls, p, (*sqlite3rbu)(unsafe.Pointer(p)).FdbMain, ts+14440 /* "PRAGMA schema_ve..." */, crt.VaList(bp, (iCookie+1)))
		}
	}
}

// Update the contents of the rbu_state table within the rbu database. The
// value stored in the RBU_STATE_STAGE column is eStage. All other values
// are determined by inspecting the rbu handle passed as the first argument.
func rbuSaveState(tls *crt.TLS, p uintptr, eStage int32) { /* sqlite3rbu.c:3495:13: */
	bp := tls.Alloc(176)
	defer tls.Free(176)

	if ((*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0) || ((*sqlite3rbu)(unsafe.Pointer(p)).Frc == 101) {
		*(*uintptr)(unsafe.Pointer(bp + 168 /* pInsert */)) = uintptr(0)
		var pFd uintptr = func() uintptr {
			if (*sqlite3rbu)(unsafe.Pointer((p))).FzTarget == uintptr(0) {
				return (*sqlite3rbu)(unsafe.Pointer(p)).FpRbuFd
			}
			return (*sqlite3rbu)(unsafe.Pointer(p)).FpTargetFd
		}()
		var rc int32

		if !((*sqlite3rbu)(unsafe.Pointer(p)).FzErrmsg == uintptr(0)) {
			crt.X__assert_fail(tls, ts+11296 /* "p->zErrmsg==0" */, ts+9694 /* "testdata/sqlite-..." */, uint32(3501), uintptr(unsafe.Pointer(&__func__65)))
		}
		rc = prepareFreeAndCollectError(tls, (*sqlite3rbu)(unsafe.Pointer(p)).FdbRbu, bp+168 /* &pInsert */, (p + 64 /* &.zErrmsg */),
			sqlite3.Xsqlite3_mprintf(tls,

				ts+14467, /* "INSERT OR REPLAC..." */
				crt.VaList(bp, p+48, /* &.zStateDb */
					1, eStage,
					2, (*sqlite3rbu)(unsafe.Pointer(p)).Fobjiter.FzTbl,
					3, (*sqlite3rbu)(unsafe.Pointer(p)).Fobjiter.FzIdx,
					4, (*sqlite3rbu)(unsafe.Pointer(p)).FnStep,
					5, (*sqlite3rbu)(unsafe.Pointer(p)).FnProgress,
					6, (*sqlite3rbu)(unsafe.Pointer(p)).FiWalCksum,
					7, i64((*rbu_file)(unsafe.Pointer(pFd)).FiCookie),
					8, (*sqlite3rbu)(unsafe.Pointer(p)).FiOalSz,
					9, (*sqlite3rbu)(unsafe.Pointer(p)).FnPhaseOneStep,
					10, (*sqlite3rbu)(unsafe.Pointer(p)).Fobjiter.FzDataTbl)))
		if !((*(*uintptr)(unsafe.Pointer(bp + 168 /* pInsert */)) == uintptr(0)) || (rc == 0)) {
			crt.X__assert_fail(tls, ts+14625 /* "pInsert==0 || rc..." */, ts+9694 /* "testdata/sqlite-..." */, uint32(3528), uintptr(unsafe.Pointer(&__func__65)))
		}

		if rc == 0 {
			sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 168 /* pInsert */)))
			rc = sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 168 /* pInsert */)))
		}
		if rc != 0 {
			(*sqlite3rbu)(unsafe.Pointer(p)).Frc = rc
		}
	}
}

var __func__65 = *(*[13]int8)(unsafe.Pointer(ts + 14645 /* "rbuSaveState" */)) /* sqlite3rbu.c:3495:52 */

// The second argument passed to this function is the name of a PRAGMA
// setting - "page_size", "auto_vacuum", "user_version" or "application_id".
// This function executes the following on sqlite3rbu.dbRbu:
//
//   "PRAGMA main.$zPragma"
//
// where $zPragma is the string passed as the second argument, then
// on sqlite3rbu.dbMain:
//
//   "PRAGMA main.$zPragma = $val"
//
// where $val is the value returned by the first PRAGMA invocation.
//
// In short, it copies the value  of the specified PRAGMA setting from
// dbRbu to dbMain.
func rbuCopyPragma(tls *crt.TLS, p uintptr, zPragma uintptr) { /* sqlite3rbu.c:3556:13: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	if (*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0 {
		*(*uintptr)(unsafe.Pointer(bp + 24 /* pPragma */)) = uintptr(0)
		(*sqlite3rbu)(unsafe.Pointer(p)).Frc = prepareFreeAndCollectError(tls, (*sqlite3rbu)(unsafe.Pointer(p)).FdbRbu, bp+24 /* &pPragma */, (p + 64 /* &.zErrmsg */),
			sqlite3.Xsqlite3_mprintf(tls, ts+14658 /* "PRAGMA main.%s" */, crt.VaList(bp, zPragma)))
		if ((*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0) && (100 == sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 24 /* pPragma */)))) {
			(*sqlite3rbu)(unsafe.Pointer(p)).Frc = rbuMPrintfExec(tls, p, (*sqlite3rbu)(unsafe.Pointer(p)).FdbMain, ts+14673, /* "PRAGMA main.%s =..." */
				crt.VaList(bp+8, zPragma, sqlite3.Xsqlite3_column_int(tls, *(*uintptr)(unsafe.Pointer(bp + 24 /* pPragma */)), 0)))
		}
		rbuFinalize(tls, p, *(*uintptr)(unsafe.Pointer(bp + 24 /* pPragma */)))
	}
}

// The RBU handle passed as the only argument has just been opened and
// the state database is empty. If this RBU handle was opened for an
// RBU vacuum operation, create the schema in the target db.
func rbuCreateTargetSchema(tls *crt.TLS, p uintptr) { /* sqlite3rbu.c:3576:13: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	*(*uintptr)(unsafe.Pointer(bp /* pSql */)) = uintptr(0)
	*(*uintptr)(unsafe.Pointer(bp + 8 /* pInsert */)) = uintptr(0)

	if !((*sqlite3rbu)(unsafe.Pointer((p))).FzTarget == uintptr(0)) {
		crt.X__assert_fail(tls, ts+14693 /* "((p)->zTarget==0..." */, ts+9694 /* "testdata/sqlite-..." */, uint32(3580), uintptr(unsafe.Pointer(&__func__66)))
	}
	(*sqlite3rbu)(unsafe.Pointer(p)).Frc = sqlite3.Xsqlite3_exec(tls, (*sqlite3rbu)(unsafe.Pointer(p)).FdbMain, ts+14711 /* "PRAGMA writable_..." */, uintptr(0), uintptr(0), (p + 64 /* &.zErrmsg */))
	if (*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0 {
		(*sqlite3rbu)(unsafe.Pointer(p)).Frc = prepareAndCollectError(tls, (*sqlite3rbu)(unsafe.Pointer(p)).FdbRbu, bp /* &pSql */, (p + 64 /* &.zErrmsg */),

			ts+14736 /* "SELECT sql FROM ..." */)
	}

	for ((*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0) && (sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp /* pSql */))) == 100) {
		var zSql uintptr = sqlite3.Xsqlite3_column_text(tls, *(*uintptr)(unsafe.Pointer(bp /* pSql */)), 0)
		(*sqlite3rbu)(unsafe.Pointer(p)).Frc = sqlite3.Xsqlite3_exec(tls, (*sqlite3rbu)(unsafe.Pointer(p)).FdbMain, zSql, uintptr(0), uintptr(0), (p + 64 /* &.zErrmsg */))
	}
	rbuFinalize(tls, p, *(*uintptr)(unsafe.Pointer(bp /* pSql */)))
	if (*sqlite3rbu)(unsafe.Pointer(p)).Frc != 0 {
		return
	}

	if (*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0 {
		(*sqlite3rbu)(unsafe.Pointer(p)).Frc = prepareAndCollectError(tls, (*sqlite3rbu)(unsafe.Pointer(p)).FdbRbu, bp /* &pSql */, (p + 64 /* &.zErrmsg */),
			ts+14844 /* "SELECT * FROM sq..." */)
	}

	if (*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0 {
		(*sqlite3rbu)(unsafe.Pointer(p)).Frc = prepareAndCollectError(tls, (*sqlite3rbu)(unsafe.Pointer(p)).FdbMain, bp+8 /* &pInsert */, (p + 64 /* &.zErrmsg */),
			ts+14909 /* "INSERT INTO sqli..." */)
	}

	for ((*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0) && (sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp /* pSql */))) == 100) {
		var i int32
		for i = 0; i < 5; i++ {
			sqlite3.Xsqlite3_bind_value(tls, *(*uintptr)(unsafe.Pointer(bp + 8 /* pInsert */)), (i + 1), sqlite3.Xsqlite3_column_value(tls, *(*uintptr)(unsafe.Pointer(bp /* pSql */)), i))
		}
		sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 8 /* pInsert */)))
		(*sqlite3rbu)(unsafe.Pointer(p)).Frc = sqlite3.Xsqlite3_reset(tls, *(*uintptr)(unsafe.Pointer(bp + 8 /* pInsert */)))
	}
	if (*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0 {
		(*sqlite3rbu)(unsafe.Pointer(p)).Frc = sqlite3.Xsqlite3_exec(tls, (*sqlite3rbu)(unsafe.Pointer(p)).FdbMain, ts+14953 /* "PRAGMA writable_..." */, uintptr(0), uintptr(0), (p + 64 /* &.zErrmsg */))
	}

	rbuFinalize(tls, p, *(*uintptr)(unsafe.Pointer(bp /* pSql */)))
	rbuFinalize(tls, p, *(*uintptr)(unsafe.Pointer(bp + 8 /* pInsert */)))
}

var __func__66 = *(*[22]int8)(unsafe.Pointer(ts + 14978 /* "rbuCreateTargetS..." */)) /* sqlite3rbu.c:3576:49 */

// Step the RBU object.
func sqlite3rbu_step(tls *crt.TLS, p uintptr) int32 { /* sqlite3rbu.c:3628:5: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	if p != 0 {
		switch (*sqlite3rbu)(unsafe.Pointer(p)).FeStage {
		case 1:
			{
				var pIter uintptr = (p + 80 /* &.objiter */)

				// If this is an RBU vacuum operation and the state table was empty
				// when this handle was opened, create the target database schema.
				if (((*sqlite3rbu)(unsafe.Pointer((p))).FzTarget == uintptr(0)) && ((*sqlite3rbu)(unsafe.Pointer(p)).FnProgress == 0)) && ((*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0) {
					rbuCreateTargetSchema(tls, p)
					rbuCopyPragma(tls, p, ts+15000 /* "user_version" */)
					rbuCopyPragma(tls, p, ts+15013 /* "application_id" */)
				}

				for ((*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0) && ((*RbuObjIter)(unsafe.Pointer(pIter)).FzTbl != 0) {

					if (*RbuObjIter)(unsafe.Pointer(pIter)).FbCleanup != 0 {
						// Clean up the rbu_tmp_xxx table for the previous table. It
						// cannot be dropped as there are currently active SQL statements.
						// But the contents can be deleted.
						if ((crt.Bool32((*sqlite3rbu)(unsafe.Pointer((p))).FzTarget == uintptr(0))) == 0) && ((*RbuObjIter)(unsafe.Pointer(pIter)).FabIndexed != 0) {
							rbuMPrintfExec(tls, p, (*sqlite3rbu)(unsafe.Pointer(p)).FdbRbu,
								ts+15028 /* "DELETE FROM %s.'..." */, crt.VaList(bp, p+48 /* &.zStateDb */, (*RbuObjIter)(unsafe.Pointer(pIter)).FzDataTbl))
						}
					} else {
						rbuObjIterPrepareAll(tls, p, pIter, 0)

						// Advance to the next row to process.
						if (*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0 {
							var rc int32 = sqlite3.Xsqlite3_step(tls, (*RbuObjIter)(unsafe.Pointer(pIter)).FpSelect)
							if rc == 100 {
								(*sqlite3rbu)(unsafe.Pointer(p)).FnProgress++
								(*sqlite3rbu)(unsafe.Pointer(p)).FnStep++
								return rbuStep(tls, p)
							}
							(*sqlite3rbu)(unsafe.Pointer(p)).Frc = sqlite3.Xsqlite3_reset(tls, (*RbuObjIter)(unsafe.Pointer(pIter)).FpSelect)
							(*sqlite3rbu)(unsafe.Pointer(p)).FnStep = 0
						}
					}

					rbuObjIterNext(tls, p, pIter)
				}

				if (*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0 {
					if !((*RbuObjIter)(unsafe.Pointer(pIter)).FzTbl == uintptr(0)) {
						crt.X__assert_fail(tls, ts+15056 /* "pIter->zTbl==0" */, ts+9694 /* "testdata/sqlite-..." */, uint32(3673), uintptr(unsafe.Pointer(&__func__67)))
					}
					rbuSaveState(tls, p, 2)
					rbuIncrSchemaCookie(tls, p)
					if (*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0 {
						(*sqlite3rbu)(unsafe.Pointer(p)).Frc = sqlite3.Xsqlite3_exec(tls, (*sqlite3rbu)(unsafe.Pointer(p)).FdbMain, ts+15071 /* "COMMIT" */, uintptr(0), uintptr(0), (p + 64 /* &.zErrmsg */))
					}
					if (*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0 {
						(*sqlite3rbu)(unsafe.Pointer(p)).Frc = sqlite3.Xsqlite3_exec(tls, (*sqlite3rbu)(unsafe.Pointer(p)).FdbRbu, ts+15071 /* "COMMIT" */, uintptr(0), uintptr(0), (p + 64 /* &.zErrmsg */))
					}
					(*sqlite3rbu)(unsafe.Pointer(p)).FeStage = 2
				}
				break
			}
			fallthrough

		case 2:
			{
				if (*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0 {
					rbuMoveOalFile(tls, p)
					(*sqlite3rbu)(unsafe.Pointer(p)).FnProgress++
				}
				break
			}
			fallthrough

		case 4:
			{
				if (*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0 {
					if (*sqlite3rbu)(unsafe.Pointer(p)).FnStep >= (*sqlite3rbu)(unsafe.Pointer(p)).FnFrame {
						var pDb uintptr = (*rbu_file)(unsafe.Pointer((*sqlite3rbu)(unsafe.Pointer(p)).FpTargetFd)).FpReal

						// Sync the db file
						(*sqlite3rbu)(unsafe.Pointer(p)).Frc = (*(*func(*crt.TLS, uintptr, int32) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pDb)).FpMethods + 40 /* &.xSync */))))(tls, pDb, 0x00002)

						// Update nBackfill
						if (*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0 {
							// var ptr uintptr at bp+16, 8

							(*sqlite3rbu)(unsafe.Pointer(p)).Frc = (*(*func(*crt.TLS, uintptr, int32, int32, int32, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pDb)).FpMethods + 104 /* &.xShmMap */))))(tls, pDb, 0, (32 * 1024), 0, bp+16 /* &ptr */)
							if (*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0 {
								*(*u32)(unsafe.Pointer((*(*uintptr)(unsafe.Pointer(bp + 16 /* ptr */))) + uintptr(24)*4)) = (*sqlite3rbu)(unsafe.Pointer(p)).FiMaxFrame
							}
						}

						if (*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0 {
							(*sqlite3rbu)(unsafe.Pointer(p)).FeStage = 5
							(*sqlite3rbu)(unsafe.Pointer(p)).Frc = 101
						}
					} else {
						// At one point the following block copied a single frame from the
						// wal file to the database file. So that one call to sqlite3rbu_step()
						// checkpointed a single frame.
						//
						// However, if the sector-size is larger than the page-size, and the
						// application calls sqlite3rbu_savestate() or close() immediately
						// after this step, then rbu_step() again, then a power failure occurs,
						// then the database page written here may be damaged. Work around
						// this by checkpointing frames until the next page in the aFrame[]
						// lies on a different disk sector to the current one.
						var iSector u32
						for ok := true; ok; ok = ((((*sqlite3rbu)(unsafe.Pointer(p)).FnStep < (*sqlite3rbu)(unsafe.Pointer(p)).FnFrame) &&
							(iSector == (((*RbuFrame)(unsafe.Pointer((*sqlite3rbu)(unsafe.Pointer(p)).FaFrame+uintptr((*sqlite3rbu)(unsafe.Pointer(p)).FnStep)*8)).FiDbPage - u32(1)) / u32((*sqlite3rbu)(unsafe.Pointer(p)).FnPagePerSector)))) &&
							((*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0)) {
							var pFrame uintptr = ((*sqlite3rbu)(unsafe.Pointer(p)).FaFrame + uintptr((*sqlite3rbu)(unsafe.Pointer(p)).FnStep)*8)
							iSector = (((*RbuFrame)(unsafe.Pointer(pFrame)).FiDbPage - u32(1)) / u32((*sqlite3rbu)(unsafe.Pointer(p)).FnPagePerSector))
							rbuCheckpointFrame(tls, p, pFrame)
							(*sqlite3rbu)(unsafe.Pointer(p)).FnStep++
						}
					}
					(*sqlite3rbu)(unsafe.Pointer(p)).FnProgress++
				}
				break
			}
			fallthrough

		default:
			break
		}
		return (*sqlite3rbu)(unsafe.Pointer(p)).Frc
	} else {
		return 7
	}
	return int32(0)
}

var __func__67 = *(*[16]int8)(unsafe.Pointer(ts + 15078 /* "sqlite3rbu_step" */)) /* sqlite3rbu.c:3628:35 */

// Compare strings z1 and z2, returning 0 if they are identical, or non-zero
// otherwise. Either or both argument may be NULL. Two NULL values are
// considered equal, and NULL is considered distinct from all other values.
func rbuStrCompare(tls *crt.TLS, z1 uintptr, z2 uintptr) int32 { /* sqlite3rbu.c:3757:12: */
	if (z1 == uintptr(0)) && (z2 == uintptr(0)) {
		return 0
	}
	if (z1 == uintptr(0)) || (z2 == uintptr(0)) {
		return 1
	}
	return (crt.Bool32(sqlite3.Xsqlite3_stricmp(tls, z1, z2) != 0))
}

// This function is called as part of sqlite3rbu_open() when initializing
// an rbu handle in OAL stage. If the rbu update has not started (i.e.
// the rbu_state table was empty) it is a no-op. Otherwise, it arranges
// things so that the next call to sqlite3rbu_step() continues on from
// where the previous rbu handle left off.
//
// If an error occurs, an error code and error message are left in the
// rbu handle passed as the first argument.
func rbuSetupOal(tls *crt.TLS, p uintptr, pState uintptr) { /* sqlite3rbu.c:3773:13: */
	if !((*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0) {
		crt.X__assert_fail(tls, ts+10376 /* "p->rc==0" */, ts+9694 /* "testdata/sqlite-..." */, uint32(3774), uintptr(unsafe.Pointer(&__func__68)))
	}
	if (*RbuState)(unsafe.Pointer(pState)).FzTbl != 0 {
		var pIter uintptr = (p + 80 /* &.objiter */)
		var rc int32 = 0

		for ((rc == 0) && ((*RbuObjIter)(unsafe.Pointer(pIter)).FzTbl != 0)) && (((((*RbuObjIter)(unsafe.Pointer(pIter)).FbCleanup != 0) ||
			(rbuStrCompare(tls, (*RbuObjIter)(unsafe.Pointer(pIter)).FzIdx, (*RbuState)(unsafe.Pointer(pState)).FzIdx) != 0)) ||
			(((*RbuState)(unsafe.Pointer(pState)).FzDataTbl == uintptr(0)) && (rbuStrCompare(tls, (*RbuObjIter)(unsafe.Pointer(pIter)).FzTbl, (*RbuState)(unsafe.Pointer(pState)).FzTbl) != 0))) ||
			(((*RbuState)(unsafe.Pointer(pState)).FzDataTbl != 0) && (rbuStrCompare(tls, (*RbuObjIter)(unsafe.Pointer(pIter)).FzDataTbl, (*RbuState)(unsafe.Pointer(pState)).FzDataTbl) != 0))) {
			rc = rbuObjIterNext(tls, p, pIter)
		}

		if (rc == 0) && !(int32((*RbuObjIter)(unsafe.Pointer(pIter)).FzTbl) != 0) {
			rc = 1
			(*sqlite3rbu)(unsafe.Pointer(p)).FzErrmsg = sqlite3.Xsqlite3_mprintf(tls, ts+15094 /* "rbu_state mismat..." */, 0)
		}

		if rc == 0 {
			(*sqlite3rbu)(unsafe.Pointer(p)).FnStep = (*RbuState)(unsafe.Pointer(pState)).FnRow
			rc = rbuObjIterPrepareAll(tls, p, (p + 80 /* &.objiter */), (*sqlite3rbu)(unsafe.Pointer(p)).FnStep)
		}

		(*sqlite3rbu)(unsafe.Pointer(p)).Frc = rc
	}
}

var __func__68 = *(*[12]int8)(unsafe.Pointer(ts + 15119 /* "rbuSetupOal" */)) /* sqlite3rbu.c:3773:57 */

// If there is a "*-oal" file in the file-system corresponding to the
// target database in the file-system, delete it. If an error occurs,
// leave an error code and error message in the rbu handle.
func rbuDeleteOalFile(tls *crt.TLS, p uintptr) { /* sqlite3rbu.c:3806:13: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var zOal uintptr = rbuMPrintf(tls, p, ts+14134 /* "%s-oal" */, crt.VaList(bp, (*sqlite3rbu)(unsafe.Pointer(p)).FzTarget))
	if zOal != 0 {
		var pVfs uintptr = sqlite3.Xsqlite3_vfs_find(tls, uintptr(0))
		if !(((pVfs != 0) && ((*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0)) && ((*sqlite3rbu)(unsafe.Pointer(p)).FzErrmsg == uintptr(0))) {
			crt.X__assert_fail(tls, ts+15131 /* "pVfs && p->rc==0..." */, ts+9694 /* "testdata/sqlite-..." */, uint32(3810), uintptr(unsafe.Pointer(&__func__69)))
		}
		(*(*func(*crt.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer((pVfs + 48 /* &.xDelete */))))(tls, pVfs, zOal, 0)
		sqlite3.Xsqlite3_free(tls, zOal)
	}
}

var __func__69 = *(*[17]int8)(unsafe.Pointer(ts + 15165 /* "rbuDeleteOalFile" */)) /* sqlite3rbu.c:3806:44 */

// Allocate a private rbu VFS for the rbu handle passed as the only
// argument. This VFS will be used unless the call to sqlite3rbu_open()
// specified a URI with a vfs=? option in place of a target database
// file name.
func rbuCreateVfs(tls *crt.TLS, p uintptr) { /* sqlite3rbu.c:3822:13: */
	bp := tls.Alloc(76)
	defer tls.Free(76)

	// var rnd int32 at bp+8, 4

	// var zRnd [64]int8 at bp+12, 64

	if !((*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0) {
		crt.X__assert_fail(tls, ts+10376 /* "p->rc==0" */, ts+9694 /* "testdata/sqlite-..." */, uint32(3826), uintptr(unsafe.Pointer(&__func__70)))
	}
	sqlite3.Xsqlite3_randomness(tls, int32(unsafe.Sizeof(int32(0))), bp+8 /* &rnd */)
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([64]int8{})), bp+12 /* &zRnd[0] */, ts+15182 /* "rbu_vfs_%d" */, crt.VaList(bp, *(*int32)(unsafe.Pointer(bp + 8 /* rnd */))))
	(*sqlite3rbu)(unsafe.Pointer(p)).Frc = sqlite3rbu_create_vfs(tls, bp+12 /* &zRnd[0] */, uintptr(0))
	if (*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0 {
		var pVfs uintptr = sqlite3.Xsqlite3_vfs_find(tls, bp+12 /* &zRnd[0] */)
		if !(pVfs != 0) {
			crt.X__assert_fail(tls, ts+15193 /* "pVfs" */, ts+9694 /* "testdata/sqlite-..." */, uint32(3832), uintptr(unsafe.Pointer(&__func__70)))
		}
		(*sqlite3rbu)(unsafe.Pointer(p)).FzVfsName = (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FzName
		(*rbu_vfs)(unsafe.Pointer(pVfs)).FpRbu = p
	}
}

var __func__70 = *(*[13]int8)(unsafe.Pointer(ts + 15198 /* "rbuCreateVfs" */)) /* sqlite3rbu.c:3822:40 */

// Destroy the private VFS created for the rbu handle passed as the only
// argument by an earlier call to rbuCreateVfs().
func rbuDeleteVfs(tls *crt.TLS, p uintptr) { /* sqlite3rbu.c:3842:13: */
	if (*sqlite3rbu)(unsafe.Pointer(p)).FzVfsName != 0 {
		sqlite3rbu_destroy_vfs(tls, (*sqlite3rbu)(unsafe.Pointer(p)).FzVfsName)
		(*sqlite3rbu)(unsafe.Pointer(p)).FzVfsName = uintptr(0)
	}
}

// This user-defined SQL function is invoked with a single argument - the
// name of a table expected to appear in the target database. It returns
// the number of auxilliary indexes on the table.
func rbuIndexCntFunc(tls *crt.TLS, pCtx uintptr, nVal int32, apVal uintptr) { /* sqlite3rbu.c:3854:13: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	var p uintptr = sqlite3.Xsqlite3_user_data(tls, pCtx)
	*(*uintptr)(unsafe.Pointer(bp + 8 /* pStmt */)) = uintptr(0)
	*(*uintptr)(unsafe.Pointer(bp + 16 /* zErrmsg */)) = uintptr(0)
	var rc int32
	var db uintptr = func() uintptr {
		if (*sqlite3rbu)(unsafe.Pointer((p))).FzTarget == uintptr(0) {
			return (*sqlite3rbu)(unsafe.Pointer(p)).FdbRbu
		}
		return (*sqlite3rbu)(unsafe.Pointer(p)).FdbMain
	}()

	if !(nVal == 1) {
		crt.X__assert_fail(tls, ts+15211 /* "nVal==1" */, ts+9694 /* "testdata/sqlite-..." */, uint32(3865), uintptr(unsafe.Pointer(&__func__71)))
	}

	rc = prepareFreeAndCollectError(tls, db, bp+8 /* &pStmt */, bp+16, /* &zErrmsg */
		sqlite3.Xsqlite3_mprintf(tls,
			ts+15219 /* "SELECT count(*) ..." */, crt.VaList(bp, sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(apVal + uintptr(0)*8))))))
	if rc != 0 {
		sqlite3.Xsqlite3_result_error(tls, pCtx, *(*uintptr)(unsafe.Pointer(bp + 16 /* zErrmsg */)), -1)
	} else {
		var nIndex int32 = 0
		if 100 == sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 8 /* pStmt */))) {
			nIndex = sqlite3.Xsqlite3_column_int(tls, *(*uintptr)(unsafe.Pointer(bp + 8 /* pStmt */)), 0)
		}
		rc = sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 8 /* pStmt */)))
		if rc == 0 {
			sqlite3.Xsqlite3_result_int(tls, pCtx, nIndex)
		} else {
			sqlite3.Xsqlite3_result_error(tls, pCtx, sqlite3.Xsqlite3_errmsg(tls, db), -1)
		}
	}

	sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* zErrmsg */)))
}

var __func__71 = *(*[16]int8)(unsafe.Pointer(ts + 15291 /* "rbuIndexCntFunc" */)) /* sqlite3rbu.c:3858:2 */

// If the RBU database contains the rbu_count table, use it to initialize
// the sqlite3rbu.nPhaseOneStep variable. The schema of the rbu_count table
// is assumed to contain the same columns as:
//
//   CREATE TABLE rbu_count(tbl TEXT PRIMARY KEY, cnt INTEGER) WITHOUT ROWID;
//
// There should be one row in the table for each data_xxx table in the
// database. The 'tbl' column should contain the name of a data_xxx table,
// and the cnt column the number of rows it contains.
//
// sqlite3rbu.nPhaseOneStep is initialized to the sum of (1 + nIndex) * cnt
// for all rows in the rbu_count table, where nIndex is the number of
// indexes on the corresponding target database table.
func rbuInitPhaseOneSteps(tls *crt.TLS, p uintptr) { /* sqlite3rbu.c:3904:13: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	if (*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0 {
		*(*uintptr)(unsafe.Pointer(bp /* pStmt */)) = uintptr(0)
		var bExists int32 = 0 // True if rbu_count exists

		(*sqlite3rbu)(unsafe.Pointer(p)).FnPhaseOneStep = int64(-1)

		(*sqlite3rbu)(unsafe.Pointer(p)).Frc = sqlite3.Xsqlite3_create_function(tls, (*sqlite3rbu)(unsafe.Pointer(p)).FdbRbu,
			ts+15307 /* "rbu_index_cnt" */, 1, 1, p, *(*uintptr)(unsafe.Pointer(&struct {
				f func(*crt.TLS, uintptr, int32, uintptr)
			}{rbuIndexCntFunc})), uintptr(0), uintptr(0))

		// Check for the rbu_count table. If it does not exist, or if an error
		// occurs, nPhaseOneStep will be left set to -1.
		if (*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0 {
			(*sqlite3rbu)(unsafe.Pointer(p)).Frc = prepareAndCollectError(tls, (*sqlite3rbu)(unsafe.Pointer(p)).FdbRbu, bp /* &pStmt */, (p + 64 /* &.zErrmsg */),
				ts+15321 /* "SELECT 1 FROM sq..." */)
		}
		if (*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0 {
			if 100 == sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp /* pStmt */))) {
				bExists = 1
			}
			(*sqlite3rbu)(unsafe.Pointer(p)).Frc = sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp /* pStmt */)))
		}

		if ((*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0) && (bExists != 0) {
			(*sqlite3rbu)(unsafe.Pointer(p)).Frc = prepareAndCollectError(tls, (*sqlite3rbu)(unsafe.Pointer(p)).FdbRbu, bp /* &pStmt */, (p + 64 /* &.zErrmsg */),

				ts+15378 /* "SELECT sum(cnt *..." */)
			if (*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0 {
				if 100 == sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp /* pStmt */))) {
					(*sqlite3rbu)(unsafe.Pointer(p)).FnPhaseOneStep = sqlite3.Xsqlite3_column_int64(tls, *(*uintptr)(unsafe.Pointer(bp /* pStmt */)), 0)
				}
				(*sqlite3rbu)(unsafe.Pointer(p)).Frc = sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp /* pStmt */)))
			}
		}
	}
}

func openRbuHandle(tls *crt.TLS, zTarget uintptr, zRbu uintptr, zState uintptr) uintptr { /* sqlite3rbu.c:3945:19: */
	bp := tls.Alloc(20)
	defer tls.Free(20)

	var p uintptr
	var nTarget size_t
	if zTarget != 0 {
		nTarget = crt.Xstrlen(tls, zTarget)
	} else {
		nTarget = uint64(0)
	}
	var nRbu size_t = crt.Xstrlen(tls, zRbu)
	var nByte size_t = ((((uint64(unsafe.Sizeof(sqlite3rbu{})) + nTarget) + uint64(1)) + nRbu) + uint64(1))

	p = sqlite3.Xsqlite3_malloc64(tls, uint64(nByte))
	if p != 0 {
		var pState uintptr = uintptr(0)

		// Create the custom VFS.
		crt.Xmemset(tls, p, 0, uint64(unsafe.Sizeof(sqlite3rbu{})))
		rbuCreateVfs(tls, p)

		// Open the target, RBU and state databases
		if (*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0 {
			var pCsr uintptr = (p + uintptr(1)*392)
			*(*int32)(unsafe.Pointer(bp + 16 /* bRetry */)) = 0
			if zTarget != 0 {
				(*sqlite3rbu)(unsafe.Pointer(p)).FzTarget = pCsr
				crt.Xmemcpy(tls, (*sqlite3rbu)(unsafe.Pointer(p)).FzTarget, zTarget, (nTarget + uint64(1)))
				pCsr += (uintptr(nTarget + uint64(1)))
			}
			(*sqlite3rbu)(unsafe.Pointer(p)).FzRbu = pCsr
			crt.Xmemcpy(tls, (*sqlite3rbu)(unsafe.Pointer(p)).FzRbu, zRbu, (nRbu + uint64(1)))
			pCsr += (uintptr(nRbu + uint64(1)))
			if zState != 0 {
				(*sqlite3rbu)(unsafe.Pointer(p)).FzState = rbuMPrintf(tls, p, ts+130 /* "%s" */, crt.VaList(bp, zState))
			}

			// If the first attempt to open the database file fails and the bRetry
			// flag it set, this means that the db was not opened because it seemed
			// to be a wal-mode db. But, this may have happened due to an earlier
			// RBU vacuum operation leaving an old wal file in the directory.
			// If this is the case, it will have been checkpointed and deleted
			// when the handle was closed and a second attempt to open the
			// database may succeed.
			rbuOpenDatabase(tls, p, bp+16 /* &bRetry */)
			if *(*int32)(unsafe.Pointer(bp + 16 /* bRetry */)) != 0 {
				rbuOpenDatabase(tls, p, uintptr(0))
			}
		}

		if (*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0 {
			pState = rbuLoadState(tls, p)
			if !((pState != 0) || ((*sqlite3rbu)(unsafe.Pointer(p)).Frc != 0)) {
				crt.X__assert_fail(tls, ts+15452 /* "pState || p->rc!..." */, ts+9694 /* "testdata/sqlite-..." */, uint32(3994), uintptr(unsafe.Pointer(&__func__72)))
			}
			if (*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0 {

				if (*RbuState)(unsafe.Pointer(pState)).FeStage == 0 {
					rbuDeleteOalFile(tls, p)
					rbuInitPhaseOneSteps(tls, p)
					(*sqlite3rbu)(unsafe.Pointer(p)).FeStage = 1
				} else {
					(*sqlite3rbu)(unsafe.Pointer(p)).FeStage = (*RbuState)(unsafe.Pointer(pState)).FeStage
					(*sqlite3rbu)(unsafe.Pointer(p)).FnPhaseOneStep = (*RbuState)(unsafe.Pointer(pState)).FnPhaseOneStep
				}
				(*sqlite3rbu)(unsafe.Pointer(p)).FnProgress = int32((*RbuState)(unsafe.Pointer(pState)).FnProgress)
				(*sqlite3rbu)(unsafe.Pointer(p)).FiOalSz = (*RbuState)(unsafe.Pointer(pState)).FiOalSz
			}
		}
		if !(((*sqlite3rbu)(unsafe.Pointer(p)).Frc != 0) || ((*sqlite3rbu)(unsafe.Pointer(p)).FeStage != 0)) {
			crt.X__assert_fail(tls, ts+15471 /* "p->rc!=0 || p->e..." */, ts+9694 /* "testdata/sqlite-..." */, uint32(4009), uintptr(unsafe.Pointer(&__func__72)))
		}

		if ((*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0) && ((*rbu_file)(unsafe.Pointer((*sqlite3rbu)(unsafe.Pointer(p)).FpTargetFd)).FpWalFd != 0) {
			if (*sqlite3rbu)(unsafe.Pointer(p)).FeStage == 1 {
				(*sqlite3rbu)(unsafe.Pointer(p)).Frc = 1
				(*sqlite3rbu)(unsafe.Pointer(p)).FzErrmsg = sqlite3.Xsqlite3_mprintf(tls, ts+15496 /* "cannot update wa..." */, 0)
			} else if (*sqlite3rbu)(unsafe.Pointer(p)).FeStage == 2 {
				(*sqlite3rbu)(unsafe.Pointer(p)).FeStage = 4
				(*sqlite3rbu)(unsafe.Pointer(p)).FnStep = 0
			}
		}

		if (((*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0) &&
			(((*sqlite3rbu)(unsafe.Pointer(p)).FeStage == 1) || ((*sqlite3rbu)(unsafe.Pointer(p)).FeStage == 2))) &&
			((*RbuState)(unsafe.Pointer(pState)).FeStage != 0) {
			var pFd uintptr = func() uintptr {
				if (*sqlite3rbu)(unsafe.Pointer((p))).FzTarget == uintptr(0) {
					return (*sqlite3rbu)(unsafe.Pointer(p)).FpRbuFd
				}
				return (*sqlite3rbu)(unsafe.Pointer(p)).FpTargetFd
			}()
			if (*rbu_file)(unsafe.Pointer(pFd)).FiCookie != (*RbuState)(unsafe.Pointer(pState)).FiCookie {
				// At this point (pTargetFd->iCookie) contains the value of the
				// change-counter cookie (the thing that gets incremented when a
				// transaction is committed in rollback mode) currently stored on
				// page 1 of the database file.
				(*sqlite3rbu)(unsafe.Pointer(p)).Frc = 5
				(*sqlite3rbu)(unsafe.Pointer(p)).FzErrmsg = sqlite3.Xsqlite3_mprintf(tls, ts+15528, /* "database modifie..." */
					crt.VaList(bp+8, func() uintptr {
						if (*sqlite3rbu)(unsafe.Pointer((p))).FzTarget == uintptr(0) {
							return ts + 15560 /* "vacuum" */
						}
						return ts + 15567 /* "update" */
					}()))
			}
		}

		if (*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0 {
			if (*sqlite3rbu)(unsafe.Pointer(p)).FeStage == 1 {
				var db uintptr = (*sqlite3rbu)(unsafe.Pointer(p)).FdbMain
				(*sqlite3rbu)(unsafe.Pointer(p)).Frc = sqlite3.Xsqlite3_exec(tls, (*sqlite3rbu)(unsafe.Pointer(p)).FdbRbu, ts+15574 /* "BEGIN" */, uintptr(0), uintptr(0), (p + 64 /* &.zErrmsg */))

				// Point the object iterator at the first object
				if (*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0 {
					(*sqlite3rbu)(unsafe.Pointer(p)).Frc = rbuObjIterFirst(tls, p, (p + 80 /* &.objiter */))
				}

				// If the RBU database contains no data_xxx tables, declare the RBU
				// update finished.
				if ((*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0) && ((*sqlite3rbu)(unsafe.Pointer(p)).Fobjiter.FzTbl == uintptr(0)) {
					(*sqlite3rbu)(unsafe.Pointer(p)).Frc = 101
					(*sqlite3rbu)(unsafe.Pointer(p)).FeStage = 5
				} else {
					if (((*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0) && ((*RbuState)(unsafe.Pointer(pState)).FeStage == 0)) && ((*sqlite3rbu)(unsafe.Pointer((p))).FzTarget == uintptr(0)) {
						rbuCopyPragma(tls, p, ts+15580 /* "page_size" */)
						rbuCopyPragma(tls, p, ts+15590 /* "auto_vacuum" */)
					}

					// Open transactions both databases. The *-oal file is opened or
					// created at this point.
					if (*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0 {
						(*sqlite3rbu)(unsafe.Pointer(p)).Frc = sqlite3.Xsqlite3_exec(tls, db, ts+15602 /* "BEGIN IMMEDIATE" */, uintptr(0), uintptr(0), (p + 64 /* &.zErrmsg */))
					}

					// Check if the main database is a zipvfs db. If it is, set the upper
					// level pager to use "journal_mode=off". This prevents it from
					// generating a large journal using a temp file.
					if (*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0 {
						var frc int32 = sqlite3.Xsqlite3_file_control(tls, db, ts+354 /* "main" */, 25, uintptr(0))
						if frc == 0 {
							(*sqlite3rbu)(unsafe.Pointer(p)).Frc = sqlite3.Xsqlite3_exec(tls,
								db, ts+15618 /* "PRAGMA journal_m..." */, uintptr(0), uintptr(0), (p + 64 /* &.zErrmsg */))
						}
					}

					if (*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0 {
						rbuSetupOal(tls, p, pState)
					}
				}
			} else if (*sqlite3rbu)(unsafe.Pointer(p)).FeStage == 2 {
			} else if (*sqlite3rbu)(unsafe.Pointer(p)).FeStage == 4 {
				rbuSetupCheckpoint(tls, p, pState)
			} else if (*sqlite3rbu)(unsafe.Pointer(p)).FeStage == 5 {
				(*sqlite3rbu)(unsafe.Pointer(p)).Frc = 101
			} else {
				(*sqlite3rbu)(unsafe.Pointer(p)).Frc = 11
			}
		}

		rbuFreeState(tls, pState)
	}

	return p
}

var __func__72 = *(*[14]int8)(unsafe.Pointer(ts + 15642 /* "openRbuHandle" */)) /* sqlite3rbu.c:3949:2 */

// Allocate and return an RBU handle with all fields zeroed except for the
// error code, which is set to SQLITE_MISUSE.
func rbuMisuseError(tls *crt.TLS) uintptr { /* sqlite3rbu.c:4101:19: */
	var pRet uintptr
	pRet = sqlite3.Xsqlite3_malloc64(tls, uint64(unsafe.Sizeof(sqlite3rbu{})))
	if pRet != 0 {
		crt.Xmemset(tls, pRet, 0, uint64(unsafe.Sizeof(sqlite3rbu{})))
		(*sqlite3rbu)(unsafe.Pointer(pRet)).Frc = 21
	}
	return pRet
}

// Open and return a new RBU handle.
func sqlite3rbu_open(tls *crt.TLS, zTarget uintptr, zRbu uintptr, zState uintptr) uintptr { /* sqlite3rbu.c:4114:12: */
	if (zTarget == uintptr(0)) || (zRbu == uintptr(0)) {
		return rbuMisuseError(tls)
	}
	// TODO: Check that zTarget and zRbu are non-NULL
	return openRbuHandle(tls, zTarget, zRbu, zState)
}

// Open a handle to begin or resume an RBU VACUUM operation.
func sqlite3rbu_vacuum(tls *crt.TLS, zTarget uintptr, zState uintptr) uintptr { /* sqlite3rbu.c:4127:12: */
	if zTarget == uintptr(0) {
		return rbuMisuseError(tls)
	}
	if zState != 0 {
		var n int32 = int32(crt.Xstrlen(tls, zState))
		if (n >= 7) && (0 == crt.Xmemcmp(tls, ts+15656 /* "-vactmp" */, (zState+uintptr((n-7))), uint64(7))) {
			return rbuMisuseError(tls)
		}
	}
	// TODO: Check that both arguments are non-NULL
	return openRbuHandle(tls, uintptr(0), zTarget, zState)
}

// Return the database handle used by pRbu.
func sqlite3rbu_db(tls *crt.TLS, pRbu uintptr, bRbu int32) uintptr { /* sqlite3rbu.c:4145:9: */
	var db uintptr = uintptr(0)
	if pRbu != 0 {
		db = func() uintptr {
			if bRbu != 0 {
				return (*sqlite3rbu)(unsafe.Pointer(pRbu)).FdbRbu
			}
			return (*sqlite3rbu)(unsafe.Pointer(pRbu)).FdbMain
		}()
	}
	return db
}

// If the error code currently stored in the RBU handle is SQLITE_CONSTRAINT,
// then edit any error message string so as to remove all occurrences of
// the pattern "rbu_imp_[0-9]*".
func rbuEditErrmsg(tls *crt.TLS, p uintptr) { /* sqlite3rbu.c:4159:13: */
	if ((*sqlite3rbu)(unsafe.Pointer(p)).Frc == 19) && ((*sqlite3rbu)(unsafe.Pointer(p)).FzErrmsg != 0) {
		var i uint32
		var nErrmsg size_t = crt.Xstrlen(tls, (*sqlite3rbu)(unsafe.Pointer(p)).FzErrmsg)
		for i = uint32(0); size_t(i) < (nErrmsg - uint64(8)); i++ {
			if crt.Xmemcmp(tls, ((*sqlite3rbu)(unsafe.Pointer(p)).FzErrmsg+uintptr(i)), ts+12851 /* "rbu_imp_" */, uint64(8)) == 0 {
				var nDel int32 = 8
				for (int32(*(*int8)(unsafe.Pointer((*sqlite3rbu)(unsafe.Pointer(p)).FzErrmsg + uintptr((i + uint32(nDel)))))) >= '0') && (int32(*(*int8)(unsafe.Pointer((*sqlite3rbu)(unsafe.Pointer(p)).FzErrmsg + uintptr((i + uint32(nDel)))))) <= '9') {
					nDel++
				}
				crt.Xmemmove(tls, ((*sqlite3rbu)(unsafe.Pointer(p)).FzErrmsg + uintptr(i)), ((*sqlite3rbu)(unsafe.Pointer(p)).FzErrmsg + uintptr((i + uint32(nDel)))), (((nErrmsg + uint64(1)) - size_t(i)) - size_t(nDel)))
				nErrmsg = nErrmsg - (size_t(nDel))
			}
		}
	}
}

// Close the RBU handle.
func sqlite3rbu_close(tls *crt.TLS, p uintptr, pzErrmsg uintptr) int32 { /* sqlite3rbu.c:4177:5: */
	var rc int32
	if p != 0 {

		// Commit the transaction to the *-oal file.
		if ((*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0) && ((*sqlite3rbu)(unsafe.Pointer(p)).FeStage == 1) {
			(*sqlite3rbu)(unsafe.Pointer(p)).Frc = sqlite3.Xsqlite3_exec(tls, (*sqlite3rbu)(unsafe.Pointer(p)).FdbMain, ts+15071 /* "COMMIT" */, uintptr(0), uintptr(0), (p + 64 /* &.zErrmsg */))
		}

		// Sync the db file if currently doing an incremental checkpoint
		if ((*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0) && ((*sqlite3rbu)(unsafe.Pointer(p)).FeStage == 4) {
			var pDb uintptr = (*rbu_file)(unsafe.Pointer((*sqlite3rbu)(unsafe.Pointer(p)).FpTargetFd)).FpReal
			(*sqlite3rbu)(unsafe.Pointer(p)).Frc = (*(*func(*crt.TLS, uintptr, int32) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pDb)).FpMethods + 40 /* &.xSync */))))(tls, pDb, 0x00002)
		}

		rbuSaveState(tls, p, (*sqlite3rbu)(unsafe.Pointer(p)).FeStage)

		if ((*sqlite3rbu)(unsafe.Pointer(p)).Frc == 0) && ((*sqlite3rbu)(unsafe.Pointer(p)).FeStage == 1) {
			(*sqlite3rbu)(unsafe.Pointer(p)).Frc = sqlite3.Xsqlite3_exec(tls, (*sqlite3rbu)(unsafe.Pointer(p)).FdbRbu, ts+15071 /* "COMMIT" */, uintptr(0), uintptr(0), (p + 64 /* &.zErrmsg */))
		}

		// Close any open statement handles.
		rbuObjIterFinalize(tls, (p + 80 /* &.objiter */))

		// If this is an RBU vacuum handle and the vacuum has either finished
		// successfully or encountered an error, delete the contents of the
		// state table. This causes the next call to sqlite3rbu_vacuum()
		// specifying the current target and state databases to start a new
		// vacuum from scratch.
		if (((*sqlite3rbu)(unsafe.Pointer((p))).FzTarget == uintptr(0)) && ((*sqlite3rbu)(unsafe.Pointer(p)).Frc != 0)) && ((*sqlite3rbu)(unsafe.Pointer(p)).FdbRbu != 0) {
			var rc2 int32 = sqlite3.Xsqlite3_exec(tls, (*sqlite3rbu)(unsafe.Pointer(p)).FdbRbu, ts+15664 /* "DELETE FROM stat..." */, uintptr(0), uintptr(0), uintptr(0))
			if ((*sqlite3rbu)(unsafe.Pointer(p)).Frc == 101) && (rc2 != 0) {
				(*sqlite3rbu)(unsafe.Pointer(p)).Frc = rc2
			}
		}

		// Close the open database handle and VFS object.
		sqlite3.Xsqlite3_close(tls, (*sqlite3rbu)(unsafe.Pointer(p)).FdbRbu)
		sqlite3.Xsqlite3_close(tls, (*sqlite3rbu)(unsafe.Pointer(p)).FdbMain)
		if !((*sqlite3rbu)(unsafe.Pointer(p)).FszTemp == int64(0)) {
			crt.X__assert_fail(tls, ts+15691 /* "p->szTemp==0" */, ts+9694 /* "testdata/sqlite-..." */, uint32(4214), uintptr(unsafe.Pointer(&__func__73)))
		}
		rbuDeleteVfs(tls, p)
		sqlite3.Xsqlite3_free(tls, (*sqlite3rbu)(unsafe.Pointer(p)).FaBuf)
		sqlite3.Xsqlite3_free(tls, (*sqlite3rbu)(unsafe.Pointer(p)).FaFrame)

		rbuEditErrmsg(tls, p)
		rc = (*sqlite3rbu)(unsafe.Pointer(p)).Frc
		if pzErrmsg != 0 {
			*(*uintptr)(unsafe.Pointer(pzErrmsg)) = (*sqlite3rbu)(unsafe.Pointer(p)).FzErrmsg
		} else {
			sqlite3.Xsqlite3_free(tls, (*sqlite3rbu)(unsafe.Pointer(p)).FzErrmsg)
		}
		sqlite3.Xsqlite3_free(tls, (*sqlite3rbu)(unsafe.Pointer(p)).FzState)
		sqlite3.Xsqlite3_free(tls, p)
	} else {
		rc = 7
		*(*uintptr)(unsafe.Pointer(pzErrmsg)) = uintptr(0)
	}
	return rc
}

var __func__73 = *(*[17]int8)(unsafe.Pointer(ts + 15704 /* "sqlite3rbu_close" */)) /* sqlite3rbu.c:4177:53 */

// Return the total number of key-value operations (inserts, deletes or
// updates) that have been performed on the target database since the
// current RBU update was started.
func sqlite3rbu_progress(tls *crt.TLS, pRbu uintptr) sqlite3_int64 { /* sqlite3rbu.c:4240:15: */
	return sqlite3_int64((*sqlite3rbu)(unsafe.Pointer(pRbu)).FnProgress)
}

// Return permyriadage progress indications for the two main stages of
// an RBU update.
func sqlite3rbu_bp_progress(tls *crt.TLS, p uintptr, pnOne uintptr, pnTwo uintptr) { /* sqlite3rbu.c:4248:6: */
	var MAX_PROGRESS int32 = 10000
	switch (*sqlite3rbu)(unsafe.Pointer(p)).FeStage {
	case 1:
		if (*sqlite3rbu)(unsafe.Pointer(p)).FnPhaseOneStep > int64(0) {
			*(*int32)(unsafe.Pointer(pnOne)) = (int32((i64(MAX_PROGRESS) * i64((*sqlite3rbu)(unsafe.Pointer(p)).FnProgress)) / (*sqlite3rbu)(unsafe.Pointer(p)).FnPhaseOneStep))
		} else {
			*(*int32)(unsafe.Pointer(pnOne)) = -1
		}
		*(*int32)(unsafe.Pointer(pnTwo)) = 0
		break

	case 2:
		*(*int32)(unsafe.Pointer(pnOne)) = MAX_PROGRESS
		*(*int32)(unsafe.Pointer(pnTwo)) = 0
		break

	case 4:
		*(*int32)(unsafe.Pointer(pnOne)) = MAX_PROGRESS
		*(*int32)(unsafe.Pointer(pnTwo)) = (int32((i64(MAX_PROGRESS) * i64((*sqlite3rbu)(unsafe.Pointer(p)).FnStep)) / i64((*sqlite3rbu)(unsafe.Pointer(p)).FnFrame)))
		break

	case 5:
		*(*int32)(unsafe.Pointer(pnOne)) = MAX_PROGRESS
		*(*int32)(unsafe.Pointer(pnTwo)) = MAX_PROGRESS
		break

	default:
		if !(0 != 0) {
			crt.X__assert_fail(tls, ts+8293 /* "0" */, ts+9694 /* "testdata/sqlite-..." */, uint32(4276), uintptr(unsafe.Pointer(&__func__74)))
		}
	}
}

var __func__74 = *(*[23]int8)(unsafe.Pointer(ts + 15721 /* "sqlite3rbu_bp_pr..." */)) /* sqlite3rbu.c:4248:67 */

// Return the current state of the RBU vacuum or update operation.
func sqlite3rbu_state(tls *crt.TLS, p uintptr) int32 { /* sqlite3rbu.c:4283:5: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	*(*[6]int32)(unsafe.Pointer(bp /* aRes */)) = [6]int32{
		0, 1, 2,
		0, 3, 4,
	}

	if !(1 == 1) {
		crt.X__assert_fail(tls, ts+2357 /* "1==1" */, ts+9694 /* "testdata/sqlite-..." */, uint32(4289), uintptr(unsafe.Pointer(&__func__75)))
	}
	if !(2 == 2) {
		crt.X__assert_fail(tls, ts+2415 /* "2==2" */, ts+9694 /* "testdata/sqlite-..." */, uint32(4290), uintptr(unsafe.Pointer(&__func__75)))
	}
	if !(4 == 4) {
		crt.X__assert_fail(tls, ts+2425 /* "4==4" */, ts+9694 /* "testdata/sqlite-..." */, uint32(4291), uintptr(unsafe.Pointer(&__func__75)))
	}
	if !(5 == 5) {
		crt.X__assert_fail(tls, ts+15744 /* "5==5" */, ts+9694 /* "testdata/sqlite-..." */, uint32(4292), uintptr(unsafe.Pointer(&__func__75)))
	}
	if !(*(*int32)(unsafe.Pointer(bp /* &aRes[0] */ + uintptr(1)*4)) == 1) {
		crt.X__assert_fail(tls, ts+15749 /* "aRes[1]==1" */, ts+9694 /* "testdata/sqlite-..." */, uint32(4293), uintptr(unsafe.Pointer(&__func__75)))
	}
	if !(*(*int32)(unsafe.Pointer(bp /* &aRes[0] */ + uintptr(2)*4)) == 2) {
		crt.X__assert_fail(tls, ts+15760 /* "aRes[2]==2" */, ts+9694 /* "testdata/sqlite-..." */, uint32(4294), uintptr(unsafe.Pointer(&__func__75)))
	}
	if !(*(*int32)(unsafe.Pointer(bp /* &aRes[0] */ + uintptr(4)*4)) == 3) {
		crt.X__assert_fail(tls, ts+15771 /* "aRes[4]==3" */, ts+9694 /* "testdata/sqlite-..." */, uint32(4295), uintptr(unsafe.Pointer(&__func__75)))
	}
	if !(*(*int32)(unsafe.Pointer(bp /* &aRes[0] */ + uintptr(5)*4)) == 4) {
		crt.X__assert_fail(tls, ts+15782 /* "aRes[5]==4" */, ts+9694 /* "testdata/sqlite-..." */, uint32(4296), uintptr(unsafe.Pointer(&__func__75)))
	}

	if ((*sqlite3rbu)(unsafe.Pointer(p)).Frc != 0) && ((*sqlite3rbu)(unsafe.Pointer(p)).Frc != 101) {
		return 5
	} else {
		if !(((*sqlite3rbu)(unsafe.Pointer(p)).Frc != 101) || ((*sqlite3rbu)(unsafe.Pointer(p)).FeStage == 5)) {
			crt.X__assert_fail(tls, ts+15793 /* "p->rc!=101 || p-..." */, ts+9694 /* "testdata/sqlite-..." */, uint32(4301), uintptr(unsafe.Pointer(&__func__75)))
		}
		if !(((((*sqlite3rbu)(unsafe.Pointer(p)).FeStage == 1) || ((*sqlite3rbu)(unsafe.Pointer(p)).FeStage == 2)) || ((*sqlite3rbu)(unsafe.Pointer(p)).FeStage == 4)) || ((*sqlite3rbu)(unsafe.Pointer(p)).FeStage == 5)) {
			crt.X__assert_fail(tls, ts+15820 /* "p->eStage==1 || ..." */, ts+9694 /* "testdata/sqlite-..." */, uint32(4302), uintptr(unsafe.Pointer(&__func__75)))
		}
		return *(*int32)(unsafe.Pointer(bp /* &aRes[0] */ + uintptr((*sqlite3rbu)(unsafe.Pointer(p)).FeStage)*4))
	}
	return int32(0)
}

var __func__75 = *(*[17]int8)(unsafe.Pointer(ts + 15881 /* "sqlite3rbu_state" */)) /* sqlite3rbu.c:4283:36 */

func sqlite3rbu_savestate(tls *crt.TLS, p uintptr) int32 { /* sqlite3rbu.c:4311:5: */
	var rc int32 = (*sqlite3rbu)(unsafe.Pointer(p)).Frc
	if rc == 101 {
		return 0
	}

	if !(((*sqlite3rbu)(unsafe.Pointer(p)).FeStage >= 1) && ((*sqlite3rbu)(unsafe.Pointer(p)).FeStage <= 5)) {
		crt.X__assert_fail(tls, ts+15898 /* "p->eStage>=1 && ..." */, ts+9694 /* "testdata/sqlite-..." */, uint32(4315), uintptr(unsafe.Pointer(&__func__76)))
	}
	if (*sqlite3rbu)(unsafe.Pointer(p)).FeStage == 1 {
		if !(rc != 101) {
			crt.X__assert_fail(tls, ts+15927 /* "rc!=101" */, ts+9694 /* "testdata/sqlite-..." */, uint32(4317), uintptr(unsafe.Pointer(&__func__76)))
		}
		if rc == 0 {
			rc = sqlite3.Xsqlite3_exec(tls, (*sqlite3rbu)(unsafe.Pointer(p)).FdbMain, ts+15071 /* "COMMIT" */, uintptr(0), uintptr(0), uintptr(0))
		}
	}

	// Sync the db file
	if (rc == 0) && ((*sqlite3rbu)(unsafe.Pointer(p)).FeStage == 4) {
		var pDb uintptr = (*rbu_file)(unsafe.Pointer((*sqlite3rbu)(unsafe.Pointer(p)).FpTargetFd)).FpReal
		rc = (*(*func(*crt.TLS, uintptr, int32) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pDb)).FpMethods + 40 /* &.xSync */))))(tls, pDb, 0x00002)
	}

	(*sqlite3rbu)(unsafe.Pointer(p)).Frc = rc
	rbuSaveState(tls, p, (*sqlite3rbu)(unsafe.Pointer(p)).FeStage)
	rc = (*sqlite3rbu)(unsafe.Pointer(p)).Frc

	if (*sqlite3rbu)(unsafe.Pointer(p)).FeStage == 1 {
		if !(rc != 101) {
			crt.X__assert_fail(tls, ts+15927 /* "rc!=101" */, ts+9694 /* "testdata/sqlite-..." */, uint32(4332), uintptr(unsafe.Pointer(&__func__76)))
		}
		if rc == 0 {
			rc = sqlite3.Xsqlite3_exec(tls, (*sqlite3rbu)(unsafe.Pointer(p)).FdbRbu, ts+15071 /* "COMMIT" */, uintptr(0), uintptr(0), uintptr(0))
		}
		if rc == 0 {
			var zBegin uintptr
			if (*sqlite3rbu)(unsafe.Pointer((p))).FzTarget == uintptr(0) {
				zBegin = ts + 15574 /* "BEGIN" */
			} else {
				zBegin = ts + 15602 /* "BEGIN IMMEDIATE" */
			}
			rc = sqlite3.Xsqlite3_exec(tls, (*sqlite3rbu)(unsafe.Pointer(p)).FdbRbu, zBegin, uintptr(0), uintptr(0), uintptr(0))
		}
		if rc == 0 {
			rc = sqlite3.Xsqlite3_exec(tls, (*sqlite3rbu)(unsafe.Pointer(p)).FdbMain, ts+15602 /* "BEGIN IMMEDIATE" */, uintptr(0), uintptr(0), uintptr(0))
		}
	}

	(*sqlite3rbu)(unsafe.Pointer(p)).Frc = rc
	return rc
}

var __func__76 = *(*[21]int8)(unsafe.Pointer(ts + 15935 /* "sqlite3rbu_saves..." */)) /* sqlite3rbu.c:4311:40 */

// *************************************************************************
//
// Beginning of RBU VFS shim methods. The VFS shim modifies the behaviour
// of a standard VFS in the following ways:
//
// 1. Whenever the first page of a main database file is read or
//    written, the value of the change-counter cookie is stored in
//    rbu_file.iCookie. Similarly, the value of the "write-version"
//    database header field is stored in rbu_file.iWriteVer. This ensures
//    that the values are always trustworthy within an open transaction.
//
// 2. Whenever an SQLITE_OPEN_WAL file is opened, the (rbu_file.pWalFd)
//    member variable of the associated database file descriptor is set
//    to point to the new file. A mutex protected linked list of all main
//    db fds opened using a particular RBU VFS is maintained at
//    rbu_vfs.pMain to facilitate this.
//
// 3. Using a new file-control "SQLITE_FCNTL_RBU", a main db rbu_file
//    object can be marked as the target database of an RBU update. This
//    turns on the following extra special behaviour:
//
// 3a. If xAccess() is called to check if there exists a *-wal file
//     associated with an RBU target database currently in RBU_STAGE_OAL
//     stage (preparing the *-oal file), the following special handling
//     applies:
//
//      * if the *-wal file does exist, return SQLITE_CANTOPEN. An RBU
//        target database may not be in wal mode already.
//
//      * if the *-wal file does not exist, set the output parameter to
//        non-zero (to tell SQLite that it does exist) anyway.
//
//     Then, when xOpen() is called to open the *-wal file associated with
//     the RBU target in RBU_STAGE_OAL stage, instead of opening the *-wal
//     file, the rbu vfs opens the corresponding *-oal file instead.
//
// 3b. The *-shm pages returned by xShmMap() for a target db file in
//     RBU_STAGE_OAL mode are actually stored in heap memory. This is to
//     avoid creating a *-shm file on disk. Additionally, xShmLock() calls
//     are no-ops on target database files in RBU_STAGE_OAL mode. This is
//     because assert() statements in some VFS implementations fail if
//     xShmLock() is called before xShmMap().
//
// 3c. If an EXCLUSIVE lock is attempted on a target database file in any
//     mode except RBU_STAGE_DONE (all work completed and checkpointed), it
//     fails with an SQLITE_BUSY error. This is to stop RBU connections
//     from automatically checkpointing a *-wal (or *-oal) file from within
//     sqlite3_close().
//
// 3d. In RBU_STAGE_CAPTURE mode, all xRead() calls on the wal file, and
//     all xWrite() calls on the target database file perform no IO.
//     Instead the frame and page numbers that would be read and written
//     are recorded. Additionally, successful attempts to obtain exclusive
//     xShmLock() WRITER, CHECKPOINTER and READ0 locks on the target
//     database file are recorded. xShmLock() calls to unlock the same
//     locks are no-ops (so that once obtained, these locks are never
//     relinquished). Finally, calls to xSync() on the target database
//     file fail with SQLITE_INTERNAL errors.

func rbuUnlockShm(tls *crt.TLS, p uintptr) { /* sqlite3rbu.c:4404:13: */
	if !(((*rbu_file)(unsafe.Pointer(p)).FopenFlags & 0x00000100) != 0) {
		crt.X__assert_fail(tls, ts+15956 /* "p->openFlags & 0..." */, ts+9694 /* "testdata/sqlite-..." */, uint32(4405), uintptr(unsafe.Pointer(&__func__77)))
	}
	if (*rbu_file)(unsafe.Pointer(p)).FpRbu != 0 {
		var xShmLock uintptr = (*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer((*rbu_file)(unsafe.Pointer(p)).FpReal)).FpMethods)).FxShmLock
		var i int32
		for i = 0; i < 8; i++ {
			if ((u32(int32(1) << i)) & (*sqlite3rbu)(unsafe.Pointer((*rbu_file)(unsafe.Pointer(p)).FpRbu)).FmLock) != 0 {
				(*(*func(*crt.TLS, uintptr, int32, int32, int32) int32)(unsafe.Pointer(&xShmLock)))(tls, (*rbu_file)(unsafe.Pointer(p)).FpReal, i, 1, (1 | 8))
			}
		}
		(*sqlite3rbu)(unsafe.Pointer((*rbu_file)(unsafe.Pointer(p)).FpRbu)).FmLock = u32(0)
	}
}

var __func__77 = *(*[13]int8)(unsafe.Pointer(ts + 15982 /* "rbuUnlockShm" */)) /* sqlite3rbu.c:4404:38 */

//
func rbuUpdateTempSize(tls *crt.TLS, pFd uintptr, nNew sqlite3_int64) int32 { /* sqlite3rbu.c:4420:12: */
	var pRbu uintptr = (*rbu_file)(unsafe.Pointer(pFd)).FpRbu
	var nDiff i64 = (nNew - (*rbu_file)(unsafe.Pointer(pFd)).Fsz)
	*(*i64)(unsafe.Pointer(pRbu + 360 /* &.szTemp */)) += (nDiff)
	(*rbu_file)(unsafe.Pointer(pFd)).Fsz = nNew
	if !((*sqlite3rbu)(unsafe.Pointer(pRbu)).FszTemp >= int64(0)) {
		crt.X__assert_fail(tls, ts+15995 /* "pRbu->szTemp>=0" */, ts+9694 /* "testdata/sqlite-..." */, uint32(4425), uintptr(unsafe.Pointer(&__func__78)))
	}
	if ((*sqlite3rbu)(unsafe.Pointer(pRbu)).FszTempLimit != 0) && ((*sqlite3rbu)(unsafe.Pointer(pRbu)).FszTemp > (*sqlite3rbu)(unsafe.Pointer(pRbu)).FszTempLimit) {
		return 13
	}
	return 0
}

var __func__78 = *(*[18]int8)(unsafe.Pointer(ts + 16011 /* "rbuUpdateTempSiz..." */)) /* sqlite3rbu.c:4420:64 */

// Add an item to the main-db lists, if it is not already present.
//
// There are two main-db lists. One for all file descriptors, and one
// for all file descriptors with rbu_file.pDb!=0. If the argument has
// rbu_file.pDb!=0, then it is assumed to already be present on the
// main list and is only added to the pDb!=0 list.
func rbuMainlistAdd(tls *crt.TLS, p uintptr) { /* sqlite3rbu.c:4438:13: */
	var pRbuVfs uintptr = (*rbu_file)(unsafe.Pointer(p)).FpRbuVfs
	var pIter uintptr
	if !(((*rbu_file)(unsafe.Pointer(p)).FopenFlags & 0x00000100) != 0) {
		crt.X__assert_fail(tls, ts+16029 /* "(p->openFlags & ..." */, ts+9694 /* "testdata/sqlite-..." */, uint32(4441), uintptr(unsafe.Pointer(&__func__79)))
	}
	sqlite3.Xsqlite3_mutex_enter(tls, (*rbu_vfs)(unsafe.Pointer(pRbuVfs)).Fmutex)
	if (*rbu_file)(unsafe.Pointer(p)).FpRbu == uintptr(0) {
		for pIter = (*rbu_vfs)(unsafe.Pointer(pRbuVfs)).FpMain; pIter != 0; pIter = (*rbu_file)(unsafe.Pointer(pIter)).FpMainNext {
		}
		(*rbu_file)(unsafe.Pointer(p)).FpMainNext = (*rbu_vfs)(unsafe.Pointer(pRbuVfs)).FpMain
		(*rbu_vfs)(unsafe.Pointer(pRbuVfs)).FpMain = p
	} else {
		for pIter = (*rbu_vfs)(unsafe.Pointer(pRbuVfs)).FpMainRbu; (pIter != 0) && (pIter != p); pIter = (*rbu_file)(unsafe.Pointer(pIter)).FpMainRbuNext {
		}
		if pIter == uintptr(0) {
			(*rbu_file)(unsafe.Pointer(p)).FpMainRbuNext = (*rbu_vfs)(unsafe.Pointer(pRbuVfs)).FpMainRbu
			(*rbu_vfs)(unsafe.Pointer(pRbuVfs)).FpMainRbu = p
		}
	}
	sqlite3.Xsqlite3_mutex_leave(tls, (*rbu_vfs)(unsafe.Pointer(pRbuVfs)).Fmutex)
}

var __func__79 = *(*[15]int8)(unsafe.Pointer(ts + 16057 /* "rbuMainlistAdd" */)) /* sqlite3rbu.c:4438:40 */

// Remove an item from the main-db lists.
func rbuMainlistRemove(tls *crt.TLS, p uintptr) { /* sqlite3rbu.c:4460:13: */
	var pp uintptr
	sqlite3.Xsqlite3_mutex_enter(tls, (*rbu_vfs)(unsafe.Pointer((*rbu_file)(unsafe.Pointer(p)).FpRbuVfs)).Fmutex)
	for pp = ((*rbu_file)(unsafe.Pointer(p)).FpRbuVfs + 192 /* &.pMain */); (*(*uintptr)(unsafe.Pointer(pp)) != 0) && (*(*uintptr)(unsafe.Pointer(pp)) != p); pp = (*(*uintptr)(unsafe.Pointer(pp)) + 88 /* &.pMainNext */) {
	}
	if *(*uintptr)(unsafe.Pointer(pp)) != 0 {
		*(*uintptr)(unsafe.Pointer(pp)) = (*rbu_file)(unsafe.Pointer(p)).FpMainNext
	}
	(*rbu_file)(unsafe.Pointer(p)).FpMainNext = uintptr(0)
	for pp = ((*rbu_file)(unsafe.Pointer(p)).FpRbuVfs + 200 /* &.pMainRbu */); (*(*uintptr)(unsafe.Pointer(pp)) != 0) && (*(*uintptr)(unsafe.Pointer(pp)) != p); pp = (*(*uintptr)(unsafe.Pointer(pp)) + 96 /* &.pMainRbuNext */) {
	}
	if *(*uintptr)(unsafe.Pointer(pp)) != 0 {
		*(*uintptr)(unsafe.Pointer(pp)) = (*rbu_file)(unsafe.Pointer(p)).FpMainRbuNext
	}
	(*rbu_file)(unsafe.Pointer(p)).FpMainRbuNext = uintptr(0)
	sqlite3.Xsqlite3_mutex_leave(tls, (*rbu_vfs)(unsafe.Pointer((*rbu_file)(unsafe.Pointer(p)).FpRbuVfs)).Fmutex)
}

// Given that zWal points to a buffer containing a wal file name passed to
// either the xOpen() or xAccess() VFS method, search the main-db list for
// a file-handle opened by the same database connection on the corresponding
// database file.
//
// If parameter bRbu is true, only search for file-descriptors with
// rbu_file.pDb!=0.
func rbuFindMaindb(tls *crt.TLS, pRbuVfs uintptr, zWal uintptr, bRbu int32) uintptr { /* sqlite3rbu.c:4481:17: */
	var pDb uintptr
	sqlite3.Xsqlite3_mutex_enter(tls, (*rbu_vfs)(unsafe.Pointer(pRbuVfs)).Fmutex)
	if bRbu != 0 {
		for pDb = (*rbu_vfs)(unsafe.Pointer(pRbuVfs)).FpMainRbu; (pDb != 0) && ((*rbu_file)(unsafe.Pointer(pDb)).FzWal != zWal); pDb = (*rbu_file)(unsafe.Pointer(pDb)).FpMainRbuNext {
		}
	} else {
		for pDb = (*rbu_vfs)(unsafe.Pointer(pRbuVfs)).FpMain; (pDb != 0) && ((*rbu_file)(unsafe.Pointer(pDb)).FzWal != zWal); pDb = (*rbu_file)(unsafe.Pointer(pDb)).FpMainNext {
		}
	}
	sqlite3.Xsqlite3_mutex_leave(tls, (*rbu_vfs)(unsafe.Pointer(pRbuVfs)).Fmutex)
	return pDb
}

// Close an rbu file.
func rbuVfsClose(tls *crt.TLS, pFile uintptr) int32 { /* sqlite3rbu.c:4496:12: */
	var p uintptr = pFile
	var rc int32
	var i int32

	// Free the contents of the apShm[] array. And the array itself.
	for i = 0; i < (*rbu_file)(unsafe.Pointer(p)).FnShm; i++ {
		sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer((*rbu_file)(unsafe.Pointer(p)).FapShm + uintptr(i)*8)))
	}
	sqlite3.Xsqlite3_free(tls, (*rbu_file)(unsafe.Pointer(p)).FapShm)
	(*rbu_file)(unsafe.Pointer(p)).FapShm = uintptr(0)
	sqlite3.Xsqlite3_free(tls, (*rbu_file)(unsafe.Pointer(p)).FzDel)

	if ((*rbu_file)(unsafe.Pointer(p)).FopenFlags & 0x00000100) != 0 {
		rbuMainlistRemove(tls, p)
		rbuUnlockShm(tls, p)
		(*(*func(*crt.TLS, uintptr, int32) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer((*rbu_file)(unsafe.Pointer(p)).FpReal)).FpMethods + 128 /* &.xShmUnmap */))))(tls, (*rbu_file)(unsafe.Pointer(p)).FpReal, 0)
	} else if (((*rbu_file)(unsafe.Pointer(p)).FopenFlags & 0x00000008) != 0) && ((*rbu_file)(unsafe.Pointer(p)).FpRbu != 0) {
		rbuUpdateTempSize(tls, p, int64(0))
	}
	if !(((*rbu_file)(unsafe.Pointer(p)).FpMainNext == uintptr(0)) && ((*rbu_vfs)(unsafe.Pointer((*rbu_file)(unsafe.Pointer(p)).FpRbuVfs)).FpMain != p)) {
		crt.X__assert_fail(tls, ts+16072 /* "p->pMainNext==0 ..." */, ts+9694 /* "testdata/sqlite-..." */, uint32(4517), uintptr(unsafe.Pointer(&__func__80)))
	}

	// Close the underlying file handle
	rc = (*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer((*rbu_file)(unsafe.Pointer(p)).FpReal)).FpMethods + 8 /* &.xClose */))))(tls, (*rbu_file)(unsafe.Pointer(p)).FpReal)
	return rc
}

var __func__80 = *(*[12]int8)(unsafe.Pointer(ts + 16112 /* "rbuVfsClose" */)) /* sqlite3rbu.c:4496:44 */

// Read and return an unsigned 32-bit big-endian integer from the buffer
// passed as the only argument.
func rbuGetU32(tls *crt.TLS, aBuf uintptr) u32 { /* sqlite3rbu.c:4529:12: */
	return ((((u32(*(*u8)(unsafe.Pointer(aBuf + uintptr(0)))) << 24) +
		(u32(*(*u8)(unsafe.Pointer(aBuf + uintptr(1)))) << 16)) +
		(u32(*(*u8)(unsafe.Pointer(aBuf + uintptr(2)))) << 8)) +
		(u32(*(*u8)(unsafe.Pointer(aBuf + uintptr(3))))))
}

// Write an unsigned 32-bit value in big-endian format to the supplied
// buffer.
func rbuPutU32(tls *crt.TLS, aBuf uintptr, iVal u32) { /* sqlite3rbu.c:4540:13: */
	*(*u8)(unsafe.Pointer(aBuf + uintptr(0))) = (u8((iVal >> 24) & u32(0xFF)))
	*(*u8)(unsafe.Pointer(aBuf + uintptr(1))) = (u8((iVal >> 16) & u32(0xFF)))
	*(*u8)(unsafe.Pointer(aBuf + uintptr(2))) = (u8((iVal >> 8) & u32(0xFF)))
	*(*u8)(unsafe.Pointer(aBuf + uintptr(3))) = (u8((iVal >> 0) & u32(0xFF)))
}

func rbuPutU16(tls *crt.TLS, aBuf uintptr, iVal u16) { /* sqlite3rbu.c:4547:13: */
	*(*u8)(unsafe.Pointer(aBuf + uintptr(0))) = (u8((int32(iVal) >> 8) & 0xFF))
	*(*u8)(unsafe.Pointer(aBuf + uintptr(1))) = (u8((int32(iVal) >> 0) & 0xFF))
}

// Read data from an rbuVfs-file.
func rbuVfsRead(tls *crt.TLS, pFile uintptr, zBuf uintptr, iAmt int32, iOfst sqlite_int64) int32 { /* sqlite3rbu.c:4555:12: */
	var p uintptr = pFile
	var pRbu uintptr = (*rbu_file)(unsafe.Pointer(p)).FpRbu
	var rc int32

	if (pRbu != 0) && ((*sqlite3rbu)(unsafe.Pointer(pRbu)).FeStage == 3) {
		if !(((*rbu_file)(unsafe.Pointer(p)).FopenFlags & 0x00080000) != 0) {
			crt.X__assert_fail(tls, ts+16124 /* "p->openFlags & 0..." */, ts+9694 /* "testdata/sqlite-..." */, uint32(4566), uintptr(unsafe.Pointer(&__func__81)))
		}
		rc = rbuCaptureWalRead(tls, (*rbu_file)(unsafe.Pointer(p)).FpRbu, iOfst, iAmt)
	} else {
		if (((pRbu != 0) && ((*sqlite3rbu)(unsafe.Pointer(pRbu)).FeStage == 1)) &&
			(((*rbu_file)(unsafe.Pointer(p)).FopenFlags & 0x00080000) != 0)) &&
			(iOfst >= (*sqlite3rbu)(unsafe.Pointer(pRbu)).FiOalSz) {
			rc = 0
			crt.Xmemset(tls, zBuf, 0, uint64(iAmt))
		} else {
			rc = (*(*func(*crt.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer((*rbu_file)(unsafe.Pointer(p)).FpReal)).FpMethods + 16 /* &.xRead */))))(tls, (*rbu_file)(unsafe.Pointer(p)).FpReal, zBuf, iAmt, iOfst)
			// If this is being called to read the first page of the target
			// database as part of an rbu vacuum operation, synthesize the
			// contents of the first page if it does not yet exist. Otherwise,
			// SQLite will not check for a *-wal file.
			if (((((pRbu != 0) && ((*sqlite3rbu)(unsafe.Pointer((pRbu))).FzTarget == uintptr(0))) &&
				(rc == (10 | (int32(2) << 8)))) && (iOfst == int64(0))) &&
				(((*rbu_file)(unsafe.Pointer(p)).FopenFlags & 0x00000100) != 0)) &&
				((*sqlite3rbu)(unsafe.Pointer(pRbu)).Frc == 0) {
				var pFd uintptr = (*sqlite3rbu)(unsafe.Pointer(pRbu)).FpRbuFd
				rc = (*(*func(*crt.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pFd)).FpMethods + 16 /* &.xRead */))))(tls, pFd, zBuf, iAmt, iOfst)
				if rc == 0 {
					var aBuf uintptr = zBuf
					var iRoot u32
					if rbuGetU32(tls, (aBuf+uintptr(52))) != 0 {
						iRoot = uint32(1)
					} else {
						iRoot = uint32(0)
					}
					rbuPutU32(tls, (aBuf + uintptr(52)), iRoot)                                                                                        // largest root page number
					rbuPutU32(tls, (aBuf + uintptr(36)), uint32(0))                                                                                    // number of free pages
					rbuPutU32(tls, (aBuf + uintptr(32)), uint32(0))                                                                                    // first page on free list trunk
					rbuPutU32(tls, (aBuf + uintptr(28)), uint32(1))                                                                                    // size of db file in pages
					rbuPutU32(tls, (aBuf + uintptr(24)), ((*rbu_file)(unsafe.Pointer((*sqlite3rbu)(unsafe.Pointer(pRbu)).FpRbuFd)).FiCookie + u32(1))) // Change counter

					if iAmt > 100 {
						crt.Xmemset(tls, (aBuf + uintptr(100)), 0, (uint64(iAmt - 100)))
						rbuPutU16(tls, (aBuf + uintptr(105)), (uint16(iAmt & 0xFFFF)))
						*(*u8)(unsafe.Pointer(aBuf + uintptr(100))) = u8(0x0D)
					}
				}
			}
		}
		if ((rc == 0) && (iOfst == int64(0))) && (((*rbu_file)(unsafe.Pointer(p)).FopenFlags & 0x00000100) != 0) {
			// These look like magic numbers. But they are stable, as they are part
			// of the definition of the SQLite file format, which may not change.
			var pBuf uintptr = zBuf
			(*rbu_file)(unsafe.Pointer(p)).FiCookie = rbuGetU32(tls, (pBuf + uintptr(24)))
			(*rbu_file)(unsafe.Pointer(p)).FiWriteVer = *(*u8)(unsafe.Pointer(pBuf + uintptr(19)))
		}
	}
	return rc
}

var __func__81 = *(*[11]int8)(unsafe.Pointer(ts + 16150 /* "rbuVfsRead" */)) /* sqlite3rbu.c:4560:2 */

// Write data to an rbuVfs-file.
func rbuVfsWrite(tls *crt.TLS, pFile uintptr, zBuf uintptr, iAmt int32, iOfst sqlite_int64) int32 { /* sqlite3rbu.c:4621:12: */
	var p uintptr = pFile
	var pRbu uintptr = (*rbu_file)(unsafe.Pointer(p)).FpRbu
	var rc int32

	if (pRbu != 0) && ((*sqlite3rbu)(unsafe.Pointer(pRbu)).FeStage == 3) {
		if !(((*rbu_file)(unsafe.Pointer(p)).FopenFlags & 0x00000100) != 0) {
			crt.X__assert_fail(tls, ts+15956 /* "p->openFlags & 0..." */, ts+9694 /* "testdata/sqlite-..." */, uint32(4632), uintptr(unsafe.Pointer(&__func__82)))
		}
		rc = rbuCaptureDbWrite(tls, (*rbu_file)(unsafe.Pointer(p)).FpRbu, iOfst)
	} else {
		if pRbu != 0 {
			if (((*sqlite3rbu)(unsafe.Pointer(pRbu)).FeStage == 1) &&
				(((*rbu_file)(unsafe.Pointer(p)).FopenFlags & 0x00080000) != 0)) &&
				(iOfst >= (*sqlite3rbu)(unsafe.Pointer(pRbu)).FiOalSz) {
				(*sqlite3rbu)(unsafe.Pointer(pRbu)).FiOalSz = (sqlite_int64(iAmt) + iOfst)
			} else if ((*rbu_file)(unsafe.Pointer(p)).FopenFlags & 0x00000008) != 0 {
				var szNew i64 = (sqlite_int64(iAmt) + iOfst)
				if szNew > (*rbu_file)(unsafe.Pointer(p)).Fsz {
					rc = rbuUpdateTempSize(tls, p, szNew)
					if rc != 0 {
						return rc
					}
				}
			}
		}
		rc = (*(*func(*crt.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer((*rbu_file)(unsafe.Pointer(p)).FpReal)).FpMethods + 24 /* &.xWrite */))))(tls, (*rbu_file)(unsafe.Pointer(p)).FpReal, zBuf, iAmt, iOfst)
		if ((rc == 0) && (iOfst == int64(0))) && (((*rbu_file)(unsafe.Pointer(p)).FopenFlags & 0x00000100) != 0) {
			// These look like magic numbers. But they are stable, as they are part
			// of the definition of the SQLite file format, which may not change.
			var pBuf uintptr = zBuf
			(*rbu_file)(unsafe.Pointer(p)).FiCookie = rbuGetU32(tls, (pBuf + uintptr(24)))
			(*rbu_file)(unsafe.Pointer(p)).FiWriteVer = *(*u8)(unsafe.Pointer(pBuf + uintptr(19)))
		}
	}
	return rc
}

var __func__82 = *(*[12]int8)(unsafe.Pointer(ts + 16161 /* "rbuVfsWrite" */)) /* sqlite3rbu.c:4626:2 */

// Truncate an rbuVfs-file.
func rbuVfsTruncate(tls *crt.TLS, pFile uintptr, size sqlite_int64) int32 { /* sqlite3rbu.c:4664:12: */
	var p uintptr = pFile
	if (((*rbu_file)(unsafe.Pointer(p)).FopenFlags & 0x00000008) != 0) && ((*rbu_file)(unsafe.Pointer(p)).FpRbu != 0) {
		var rc int32 = rbuUpdateTempSize(tls, p, size)
		if rc != 0 {
			return rc
		}
	}
	return (*(*func(*crt.TLS, uintptr, sqlite3_int64) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer((*rbu_file)(unsafe.Pointer(p)).FpReal)).FpMethods + 32 /* &.xTruncate */))))(tls, (*rbu_file)(unsafe.Pointer(p)).FpReal, size)
}

// Sync an rbuVfs-file.
func rbuVfsSync(tls *crt.TLS, pFile uintptr, flags int32) int32 { /* sqlite3rbu.c:4676:12: */
	var p uintptr = pFile
	if ((*rbu_file)(unsafe.Pointer(p)).FpRbu != 0) && ((*sqlite3rbu)(unsafe.Pointer((*rbu_file)(unsafe.Pointer(p)).FpRbu)).FeStage == 3) {
		if ((*rbu_file)(unsafe.Pointer(p)).FopenFlags & 0x00000100) != 0 {
			return 2
		}
		return 0
	}
	return (*(*func(*crt.TLS, uintptr, int32) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer((*rbu_file)(unsafe.Pointer(p)).FpReal)).FpMethods + 40 /* &.xSync */))))(tls, (*rbu_file)(unsafe.Pointer(p)).FpReal, flags)
}

// Return the current file-size of an rbuVfs-file.
func rbuVfsFileSize(tls *crt.TLS, pFile uintptr, pSize uintptr) int32 { /* sqlite3rbu.c:4690:12: */
	var p uintptr = pFile
	var rc int32
	rc = (*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer((*rbu_file)(unsafe.Pointer(p)).FpReal)).FpMethods + 48 /* &.xFileSize */))))(tls, (*rbu_file)(unsafe.Pointer(p)).FpReal, pSize)

	// If this is an RBU vacuum operation and this is the target database,
	// pretend that it has at least one page. Otherwise, SQLite will not
	// check for the existance of a *-wal file. rbuVfsRead() contains
	// similar logic.
	if ((((rc == 0) && (*(*sqlite_int64)(unsafe.Pointer(pSize)) == int64(0))) &&
		((*rbu_file)(unsafe.Pointer(p)).FpRbu != 0)) && ((*sqlite3rbu)(unsafe.Pointer(((*rbu_file)(unsafe.Pointer(p)).FpRbu))).FzTarget == uintptr(0))) &&
		(((*rbu_file)(unsafe.Pointer(p)).FopenFlags & 0x00000100) != 0) {
		*(*sqlite_int64)(unsafe.Pointer(pSize)) = int64(1024)
	}
	return rc
}

// Lock an rbuVfs-file.
func rbuVfsLock(tls *crt.TLS, pFile uintptr, eLock int32) int32 { /* sqlite3rbu.c:4711:12: */
	var p uintptr = pFile
	var pRbu uintptr = (*rbu_file)(unsafe.Pointer(p)).FpRbu
	var rc int32 = 0

	if !(((*rbu_file)(unsafe.Pointer(p)).FopenFlags & (0x00000100 | 0x00000200)) != 0) {
		crt.X__assert_fail(tls, ts+16173 /* "p->openFlags & (..." */, ts+9694 /* "testdata/sqlite-..." */, uint32(4716), uintptr(unsafe.Pointer(&__func__83)))
	}
	if (eLock == 4) &&
		(((*rbu_file)(unsafe.Pointer(p)).FbNolock != 0) || ((pRbu != 0) && ((*sqlite3rbu)(unsafe.Pointer(pRbu)).FeStage != 5))) {
		// Do not allow EXCLUSIVE locks. Preventing SQLite from taking this
		// prevents it from checkpointing the database from sqlite3_close().
		rc = 5
	} else {
		rc = (*(*func(*crt.TLS, uintptr, int32) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer((*rbu_file)(unsafe.Pointer(p)).FpReal)).FpMethods + 56 /* &.xLock */))))(tls, (*rbu_file)(unsafe.Pointer(p)).FpReal, eLock)
	}

	return rc
}

var __func__83 = *(*[11]int8)(unsafe.Pointer(ts + 16212 /* "rbuVfsLock" */)) /* sqlite3rbu.c:4711:54 */

// Unlock an rbuVfs-file.
func rbuVfsUnlock(tls *crt.TLS, pFile uintptr, eLock int32) int32 { /* sqlite3rbu.c:4733:12: */
	var p uintptr = pFile
	return (*(*func(*crt.TLS, uintptr, int32) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer((*rbu_file)(unsafe.Pointer(p)).FpReal)).FpMethods + 64 /* &.xUnlock */))))(tls, (*rbu_file)(unsafe.Pointer(p)).FpReal, eLock)
}

// Check if another file-handle holds a RESERVED lock on an rbuVfs-file.
func rbuVfsCheckReservedLock(tls *crt.TLS, pFile uintptr, pResOut uintptr) int32 { /* sqlite3rbu.c:4741:12: */
	var p uintptr = pFile
	return (*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer((*rbu_file)(unsafe.Pointer(p)).FpReal)).FpMethods + 72 /* &.xCheckReservedLock */))))(tls, (*rbu_file)(unsafe.Pointer(p)).FpReal, pResOut)
}

// File control method. For custom operations on an rbuVfs-file.
func rbuVfsFileControl(tls *crt.TLS, pFile uintptr, op int32, pArg uintptr) int32 { /* sqlite3rbu.c:4749:12: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	var p uintptr = pFile
	var xControl uintptr = (*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer((*rbu_file)(unsafe.Pointer(p)).FpReal)).FpMethods)).FxFileControl
	var rc int32

	if !((((*rbu_file)(unsafe.Pointer(p)).FopenFlags & (0x00000100 | 0x00000200)) != 0) || (((*rbu_file)(unsafe.Pointer(p)).FopenFlags & (0x00000400 | 0x00001000)) != 0)) {
		crt.X__assert_fail(tls, ts+16223 /* "p->openFlags & (..." */, ts+9694 /* "testdata/sqlite-..." */, uint32(4754), uintptr(unsafe.Pointer(&__func__84)))
	}
	if op == 26 {
		var pRbu uintptr = pArg

		// First try to find another RBU vfs lower down in the vfs stack. If
		// one is found, this vfs will operate in pass-through mode. The lower
		// level vfs will do the special RBU handling.
		rc = (*(*func(*crt.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(&xControl)))(tls, (*rbu_file)(unsafe.Pointer(p)).FpReal, op, pArg)

		if rc == 12 {
			// Now search for a zipvfs instance lower down in the VFS stack. If
			// one is found, this is an error.
			*(*uintptr)(unsafe.Pointer(bp + 16 /* dummy */)) = uintptr(0)
			rc = (*(*func(*crt.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(&xControl)))(tls, (*rbu_file)(unsafe.Pointer(p)).FpReal, 25, bp+16 /* &dummy */)
			if rc == 0 {
				rc = 1
				(*sqlite3rbu)(unsafe.Pointer(pRbu)).FzErrmsg = sqlite3.Xsqlite3_mprintf(tls, ts+16304 /* "rbu/zipvfs setup..." */, 0)
			} else if rc == 12 {
				(*sqlite3rbu)(unsafe.Pointer(pRbu)).FpTargetFd = p
				(*rbu_file)(unsafe.Pointer(p)).FpRbu = pRbu
				rbuMainlistAdd(tls, p)
				if (*rbu_file)(unsafe.Pointer(p)).FpWalFd != 0 {
					(*rbu_file)(unsafe.Pointer((*rbu_file)(unsafe.Pointer(p)).FpWalFd)).FpRbu = pRbu
				}
				rc = 0
			}
		}
		return rc
	} else if op == 5149216 {
		var pRbu uintptr = pArg
		(*sqlite3rbu)(unsafe.Pointer(pRbu)).FnRbu++
		(*sqlite3rbu)(unsafe.Pointer(pRbu)).FpRbuFd = p
		(*rbu_file)(unsafe.Pointer(p)).FbNolock = u8(1)
	}

	rc = (*(*func(*crt.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(&xControl)))(tls, (*rbu_file)(unsafe.Pointer(p)).FpReal, op, pArg)
	if (rc == 0) && (op == 12) {
		var pRbuVfs uintptr = (*rbu_file)(unsafe.Pointer(p)).FpRbuVfs
		var zIn uintptr = *(*uintptr)(unsafe.Pointer(pArg))
		var zOut uintptr = sqlite3.Xsqlite3_mprintf(tls, ts+16327 /* "rbu(%s)/%z" */, crt.VaList(bp, (*rbu_vfs)(unsafe.Pointer(pRbuVfs)).Fbase.FzName, zIn))
		*(*uintptr)(unsafe.Pointer(pArg)) = zOut
		if zOut == uintptr(0) {
			rc = 7
		}
	}

	return rc
}

var __func__84 = *(*[18]int8)(unsafe.Pointer(ts + 16338 /* "rbuVfsFileContro..." */)) /* sqlite3rbu.c:4749:70 */

// Return the sector-size in bytes for an rbuVfs-file.
func rbuVfsSectorSize(tls *crt.TLS, pFile uintptr) int32 { /* sqlite3rbu.c:4805:12: */
	var p uintptr = pFile
	return (*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer((*rbu_file)(unsafe.Pointer(p)).FpReal)).FpMethods + 88 /* &.xSectorSize */))))(tls, (*rbu_file)(unsafe.Pointer(p)).FpReal)
}

// Return the device characteristic flags supported by an rbuVfs-file.
func rbuVfsDeviceCharacteristics(tls *crt.TLS, pFile uintptr) int32 { /* sqlite3rbu.c:4813:12: */
	var p uintptr = pFile
	return (*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer((*rbu_file)(unsafe.Pointer(p)).FpReal)).FpMethods + 96 /* &.xDeviceCharacteristics */))))(tls, (*rbu_file)(unsafe.Pointer(p)).FpReal)
}

// Take or release a shared-memory lock.
func rbuVfsShmLock(tls *crt.TLS, pFile uintptr, ofst int32, n int32, flags int32) int32 { /* sqlite3rbu.c:4821:12: */
	var p uintptr = pFile
	var pRbu uintptr = (*rbu_file)(unsafe.Pointer(p)).FpRbu
	var rc int32 = 0

	if !(((*rbu_file)(unsafe.Pointer(p)).FopenFlags & (0x00000100 | 0x00000200)) != 0) {
		crt.X__assert_fail(tls, ts+16173 /* "p->openFlags & (..." */, ts+9694 /* "testdata/sqlite-..." */, uint32(4830), uintptr(unsafe.Pointer(&__func__85)))
	}
	if (pRbu != 0) && (((*sqlite3rbu)(unsafe.Pointer(pRbu)).FeStage == 1) || ((*sqlite3rbu)(unsafe.Pointer(pRbu)).FeStage == 2)) {
		// Magic number 1 is the WAL_CKPT_LOCK lock. Preventing SQLite from
		// taking this lock also prevents any checkpoints from occurring.
		// todo: really, it's not clear why this might occur, as
		// wal_autocheckpoint ought to be turned off.
		if (ofst == 1) && (n == 1) {
			rc = 5
		}
	} else {
		var bCapture int32 = 0
		if (pRbu != 0) && ((*sqlite3rbu)(unsafe.Pointer(pRbu)).FeStage == 3) {
			bCapture = 1
		}

		if (bCapture == 0) || (0 == (flags & 1)) {
			rc = (*(*func(*crt.TLS, uintptr, int32, int32, int32) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer((*rbu_file)(unsafe.Pointer(p)).FpReal)).FpMethods + 112 /* &.xShmLock */))))(tls, (*rbu_file)(unsafe.Pointer(p)).FpReal, ofst, n, flags)
			if (bCapture != 0) && (rc == 0) {
				*(*u32)(unsafe.Pointer(pRbu + 316 /* &.mLock */)) |= (u32(int32(1) << ofst))
			}
		}
	}

	return rc
}

var __func__85 = *(*[14]int8)(unsafe.Pointer(ts + 16356 /* "rbuVfsShmLock" */)) /* sqlite3rbu.c:4821:74 */

// Obtain a pointer to a mapping of a single 32KiB page of the *-shm file.
func rbuVfsShmMap(tls *crt.TLS, pFile uintptr, iRegion int32, szRegion int32, isWrite int32, pp uintptr) int32 { /* sqlite3rbu.c:4857:12: */
	var p uintptr = pFile
	var rc int32 = 0
	var eStage int32 = func() int32 {
		if (*rbu_file)(unsafe.Pointer(p)).FpRbu != 0 {
			return (*sqlite3rbu)(unsafe.Pointer((*rbu_file)(unsafe.Pointer(p)).FpRbu)).FeStage
		}
		return 0
	}()

	// If not in RBU_STAGE_OAL, allow this call to pass through. Or, if this
	// rbu is in the RBU_STAGE_OAL state, use heap memory for *-shm space
	// instead of a file on disk.
	if !(((*rbu_file)(unsafe.Pointer(p)).FopenFlags & (0x00000100 | 0x00000200)) != 0) {
		crt.X__assert_fail(tls, ts+16173 /* "p->openFlags & (..." */, ts+9694 /* "testdata/sqlite-..." */, uint32(4871), uintptr(unsafe.Pointer(&__func__86)))
	}
	if eStage == 1 {
		var nByte sqlite3_int64 = (sqlite3_int64((uint64(iRegion + 1)) * uint64(unsafe.Sizeof(uintptr(0)))))
		var apNew uintptr = sqlite3.Xsqlite3_realloc64(tls, (*rbu_file)(unsafe.Pointer(p)).FapShm, uint64(nByte))

		// This is an RBU connection that uses its own heap memory for the
		// pages of the *-shm file. Since no other process can have run
		// recovery, the connection must request *-shm pages in order
		// from start to finish.
		if !(iRegion == (*rbu_file)(unsafe.Pointer(p)).FnShm) {
			crt.X__assert_fail(tls, ts+16370 /* "iRegion==p->nShm" */, ts+9694 /* "testdata/sqlite-..." */, uint32(4880), uintptr(unsafe.Pointer(&__func__86)))
		}
		if apNew == uintptr(0) {
			rc = 7
		} else {
			crt.Xmemset(tls, (apNew + uintptr((*rbu_file)(unsafe.Pointer(p)).FnShm)*8), 0, (uint64(unsafe.Sizeof(uintptr(0))) * (uint64((1 + iRegion) - (*rbu_file)(unsafe.Pointer(p)).FnShm))))
			(*rbu_file)(unsafe.Pointer(p)).FapShm = apNew
			(*rbu_file)(unsafe.Pointer(p)).FnShm = (iRegion + 1)
		}

		if rc == 0 {
			var pNew uintptr = sqlite3.Xsqlite3_malloc64(tls, uint64(szRegion))
			if pNew == uintptr(0) {
				rc = 7
			} else {
				crt.Xmemset(tls, pNew, 0, uint64(szRegion))
				*(*uintptr)(unsafe.Pointer((*rbu_file)(unsafe.Pointer(p)).FapShm + uintptr(iRegion)*8)) = pNew
			}
		}

		if rc == 0 {
			*(*uintptr)(unsafe.Pointer(pp)) = *(*uintptr)(unsafe.Pointer((*rbu_file)(unsafe.Pointer(p)).FapShm + uintptr(iRegion)*8))
		} else {
			*(*uintptr)(unsafe.Pointer(pp)) = uintptr(0)
		}
	} else {
		if !((*rbu_file)(unsafe.Pointer(p)).FapShm == uintptr(0)) {
			crt.X__assert_fail(tls, ts+16387 /* "p->apShm==0" */, ts+9694 /* "testdata/sqlite-..." */, uint32(4905), uintptr(unsafe.Pointer(&__func__86)))
		}
		rc = (*(*func(*crt.TLS, uintptr, int32, int32, int32, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer((*rbu_file)(unsafe.Pointer(p)).FpReal)).FpMethods + 104 /* &.xShmMap */))))(tls, (*rbu_file)(unsafe.Pointer(p)).FpReal, iRegion, szRegion, isWrite, pp)
	}

	return rc
}

var __func__86 = *(*[13]int8)(unsafe.Pointer(ts + 16399 /* "rbuVfsShmMap" */)) /* sqlite3rbu.c:4863:2 */

// Memory barrier.
func rbuVfsShmBarrier(tls *crt.TLS, pFile uintptr) { /* sqlite3rbu.c:4915:13: */
	var p uintptr = pFile
	(*(*func(*crt.TLS, uintptr))(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer((*rbu_file)(unsafe.Pointer(p)).FpReal)).FpMethods + 120 /* &.xShmBarrier */))))(tls, (*rbu_file)(unsafe.Pointer(p)).FpReal)
}

// The xShmUnmap method.
func rbuVfsShmUnmap(tls *crt.TLS, pFile uintptr, delFlag int32) int32 { /* sqlite3rbu.c:4923:12: */
	var p uintptr = pFile
	var rc int32 = 0
	var eStage int32 = func() int32 {
		if (*rbu_file)(unsafe.Pointer(p)).FpRbu != 0 {
			return (*sqlite3rbu)(unsafe.Pointer((*rbu_file)(unsafe.Pointer(p)).FpRbu)).FeStage
		}
		return 0
	}()

	if !(((*rbu_file)(unsafe.Pointer(p)).FopenFlags & (0x00000100 | 0x00000200)) != 0) {
		crt.X__assert_fail(tls, ts+16173 /* "p->openFlags & (..." */, ts+9694 /* "testdata/sqlite-..." */, uint32(4928), uintptr(unsafe.Pointer(&__func__87)))
	}
	if (eStage == 1) || (eStage == 2) {
	} else {
		// Release the checkpointer and writer locks
		rbuUnlockShm(tls, p)
		rc = (*(*func(*crt.TLS, uintptr, int32) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer((*rbu_file)(unsafe.Pointer(p)).FpReal)).FpMethods + 128 /* &.xShmUnmap */))))(tls, (*rbu_file)(unsafe.Pointer(p)).FpReal, delFlag)
	}
	return rc
}

var __func__87 = *(*[15]int8)(unsafe.Pointer(ts + 16412 /* "rbuVfsShmUnmap" */)) /* sqlite3rbu.c:4923:60 */

// Open an rbu file handle.
func rbuVfsOpen(tls *crt.TLS, pVfs uintptr, zName uintptr, pFile uintptr, flags int32, pOutFlags uintptr) int32 { /* sqlite3rbu.c:4942:12: */
	var pRbuVfs uintptr = pVfs
	var pRealVfs uintptr = (*rbu_vfs)(unsafe.Pointer(pRbuVfs)).FpRealVfs
	var pFd uintptr = pFile
	var rc int32 = 0
	var zOpen uintptr = zName
	var oflags int32 = flags

	crt.Xmemset(tls, pFd, 0, uint64(unsafe.Sizeof(rbu_file{})))
	(*rbu_file)(unsafe.Pointer(pFd)).FpReal = (pFd + uintptr(1)*104)
	(*rbu_file)(unsafe.Pointer(pFd)).FpRbuVfs = pRbuVfs
	(*rbu_file)(unsafe.Pointer(pFd)).FopenFlags = flags
	if zName != 0 {
		if (flags & 0x00000100) != 0 {
			// A main database has just been opened. The following block sets
			// (pFd->zWal) to point to a buffer owned by SQLite that contains
			// the name of the *-wal file this db connection will use. SQLite
			// happens to pass a pointer to this buffer when using xAccess()
			// or xOpen() to operate on the *-wal file.
			(*rbu_file)(unsafe.Pointer(pFd)).FzWal = sqlite3.Xsqlite3_filename_wal(tls, zName)
		} else if (flags & 0x00080000) != 0 {
			var pDb uintptr = rbuFindMaindb(tls, pRbuVfs, zName, 0)
			if pDb != 0 {
				if ((*rbu_file)(unsafe.Pointer(pDb)).FpRbu != 0) && ((*sqlite3rbu)(unsafe.Pointer((*rbu_file)(unsafe.Pointer(pDb)).FpRbu)).FeStage == 1) {
					// This call is to open a *-wal file. Intead, open the *-oal. This
					// code ensures that the string passed to xOpen() is terminated by a
					// pair of '\0' bytes in case the VFS attempts to extract a URI
					// parameter from it.
					var zBase uintptr = zName
					var nCopy size_t
					var zCopy uintptr
					if (*sqlite3rbu)(unsafe.Pointer(((*rbu_file)(unsafe.Pointer(pDb)).FpRbu))).FzTarget == uintptr(0) {
						zBase = sqlite3.Xsqlite3_db_filename(tls, (*sqlite3rbu)(unsafe.Pointer((*rbu_file)(unsafe.Pointer(pDb)).FpRbu)).FdbRbu, ts+354 /* "main" */)
						zBase = sqlite3.Xsqlite3_filename_wal(tls, zBase)
					}
					nCopy = crt.Xstrlen(tls, zBase)
					zCopy = sqlite3.Xsqlite3_malloc64(tls, (uint64(nCopy + uint64(2))))
					if zCopy != 0 {
						crt.Xmemcpy(tls, zCopy, zBase, nCopy)
						*(*int8)(unsafe.Pointer(zCopy + uintptr((nCopy - uint64(3))))) = int8('o')
						*(*int8)(unsafe.Pointer(zCopy + uintptr(nCopy))) = int8(0)
						*(*int8)(unsafe.Pointer(zCopy + uintptr((nCopy + uint64(1))))) = int8(0)
						zOpen = crt.AssignPtrUintptr(pFd+64 /* &.zDel */, zCopy)
					} else {
						rc = 7
					}
					(*rbu_file)(unsafe.Pointer(pFd)).FpRbu = (*rbu_file)(unsafe.Pointer(pDb)).FpRbu
				}
				(*rbu_file)(unsafe.Pointer(pDb)).FpWalFd = pFd
			}
		}
	} else {
		(*rbu_file)(unsafe.Pointer(pFd)).FpRbu = (*rbu_vfs)(unsafe.Pointer(pRbuVfs)).FpRbu
	}

	if ((oflags & 0x00000100) != 0) &&
		(sqlite3.Xsqlite3_uri_boolean(tls, zName, ts+16427 /* "rbu_memory" */, 0) != 0) {
		if !((oflags & 0x00000100) != 0) {
			crt.X__assert_fail(tls, ts+16438 /* "oflags & 0x00000..." */, ts+9694 /* "testdata/sqlite-..." */, uint32(5027), uintptr(unsafe.Pointer(&__func__88)))
		}
		oflags = ((((0x00000200 | 0x00000002) | 0x00000004) | 0x00000010) | 0x00000008)
		zOpen = uintptr(0)
	}

	if rc == 0 {
		rc = (*(*func(*crt.TLS, uintptr, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer((pRealVfs + 40 /* &.xOpen */))))(tls, pRealVfs, zOpen, (*rbu_file)(unsafe.Pointer(pFd)).FpReal, oflags, pOutFlags)
	}
	if (*sqlite3_file)(unsafe.Pointer((*rbu_file)(unsafe.Pointer(pFd)).FpReal)).FpMethods != 0 {
		// The xOpen() operation has succeeded. Set the sqlite3_file.pMethods
		// pointer and, if the file is a main database file, link it into the
		// mutex protected linked list of all such files.
		(*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods = uintptr(unsafe.Pointer(&rbuvfs_io_methods))
		if (flags & 0x00000100) != 0 {
			rbuMainlistAdd(tls, pFd)
		}
	} else {
		sqlite3.Xsqlite3_free(tls, (*rbu_file)(unsafe.Pointer(pFd)).FzDel)
	}

	return rc
}

var __func__88 = *(*[11]int8)(unsafe.Pointer(ts + 16458 /* "rbuVfsOpen" */)) /* sqlite3rbu.c:4948:2 */
var rbuvfs_io_methods = sqlite3_io_methods{FiVersion: 2, FxClose:            // iVersion
0, FxRead:// xClose
0, FxWrite:// xRead
0, FxTruncate:// xWrite
0, FxSync:// xTruncate
0, FxFileSize:// xSync
0, FxLock:// xFileSize
0, FxUnlock:// xLock
0, FxCheckReservedLock:// xUnlock
0, FxFileControl:// xCheckReservedLock
0, FxSectorSize:// xFileControl
0, FxDeviceCharacteristics:// xSectorSize
0, FxShmMap:// xDeviceCharacteristics
0, FxShmLock:// xShmMap
0, FxShmBarrier:// xShmLock
0, FxShmUnmap:// xShmBarrier
0, FxFetch:// xShmUnmap
uintptr(0), FxUnfetch: uintptr(0), // xFetch, xUnfetch
} /* sqlite3rbu.c:4949:29 */

// Delete the file located at zPath.
func rbuVfsDelete(tls *crt.TLS, pVfs uintptr, zPath uintptr, dirSync int32) int32 { /* sqlite3rbu.c:5054:12: */
	var pRealVfs uintptr = (*rbu_vfs)(unsafe.Pointer(pVfs)).FpRealVfs
	return (*(*func(*crt.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer((pRealVfs + 48 /* &.xDelete */))))(tls, pRealVfs, zPath, dirSync)
}

// Test for access permissions. Return true if the requested permission
// is available, or false otherwise.
func rbuVfsAccess(tls *crt.TLS, pVfs uintptr, zPath uintptr, flags int32, pResOut uintptr) int32 { /* sqlite3rbu.c:5063:12: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var pRbuVfs uintptr = pVfs
	var pRealVfs uintptr = (*rbu_vfs)(unsafe.Pointer(pRbuVfs)).FpRealVfs
	var rc int32

	rc = (*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer((pRealVfs + 56 /* &.xAccess */))))(tls, pRealVfs, zPath, flags, pResOut)

	// If this call is to check if a *-wal file associated with an RBU target
	// database connection exists, and the RBU update is in RBU_STAGE_OAL,
	// the following special handling is activated:
	//
	//   a) if the *-wal file does exist, return SQLITE_CANTOPEN. This
	//      ensures that the RBU extension never tries to update a database
	//      in wal mode, even if the first page of the database file has
	//      been damaged.
	//
	//   b) if the *-wal file does not exist, claim that it does anyway,
	//      causing SQLite to call xOpen() to open it. This call will also
	//      be intercepted (see the rbuVfsOpen() function) and the *-oal
	//      file opened instead.
	if (rc == 0) && (flags == 0) {
		var pDb uintptr = rbuFindMaindb(tls, pRbuVfs, zPath, 1)
		if (pDb != 0) && ((*sqlite3rbu)(unsafe.Pointer((*rbu_file)(unsafe.Pointer(pDb)).FpRbu)).FeStage == 1) {
			if !((*rbu_file)(unsafe.Pointer(pDb)).FpRbu != 0) {
				crt.X__assert_fail(tls, ts+16469 /* "pDb->pRbu" */, ts+9694 /* "testdata/sqlite-..." */, uint32(5092), uintptr(unsafe.Pointer(&__func__89)))
			}
			if *(*int32)(unsafe.Pointer(pResOut)) != 0 {
				rc = 14
			} else {
				*(*sqlite3_int64)(unsafe.Pointer(bp /* sz */)) = int64(0)
				rc = rbuVfsFileSize(tls, (pDb /* &.base */), bp /* &sz */)
				*(*int32)(unsafe.Pointer(pResOut)) = (crt.Bool32(*(*sqlite3_int64)(unsafe.Pointer(bp /* sz */)) > int64(0)))
			}
		}
	}

	return rc
}

var __func__89 = *(*[13]int8)(unsafe.Pointer(ts + 16479 /* "rbuVfsAccess" */)) /* sqlite3rbu.c:5068:2 */

// Populate buffer zOut with the full canonical pathname corresponding
// to the pathname in zPath. zOut is guaranteed to point to a buffer
// of at least (DEVSYM_MAX_PATHNAME+1) bytes.
func rbuVfsFullPathname(tls *crt.TLS, pVfs uintptr, zPath uintptr, nOut int32, zOut uintptr) int32 { /* sqlite3rbu.c:5111:12: */
	var pRealVfs uintptr = (*rbu_vfs)(unsafe.Pointer(pVfs)).FpRealVfs
	return (*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer((pRealVfs + 64 /* &.xFullPathname */))))(tls, pRealVfs, zPath, nOut, zOut)
}

// Populate the buffer pointed to by zBufOut with nByte bytes of
// random data.
func rbuVfsRandomness(tls *crt.TLS, pVfs uintptr, nByte int32, zBufOut uintptr) int32 { /* sqlite3rbu.c:5165:12: */
	var pRealVfs uintptr = (*rbu_vfs)(unsafe.Pointer(pVfs)).FpRealVfs
	return (*(*func(*crt.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer((pRealVfs + 104 /* &.xRandomness */))))(tls, pRealVfs, nByte, zBufOut)
}

// Sleep for nMicro microseconds. Return the number of microseconds
// actually slept.
func rbuVfsSleep(tls *crt.TLS, pVfs uintptr, nMicro int32) int32 { /* sqlite3rbu.c:5174:12: */
	var pRealVfs uintptr = (*rbu_vfs)(unsafe.Pointer(pVfs)).FpRealVfs
	return (*(*func(*crt.TLS, uintptr, int32) int32)(unsafe.Pointer((pRealVfs + 112 /* &.xSleep */))))(tls, pRealVfs, nMicro)
}

// Return the current time as a Julian Day number in *pTimeOut.
func rbuVfsCurrentTime(tls *crt.TLS, pVfs uintptr, pTimeOut uintptr) int32 { /* sqlite3rbu.c:5182:12: */
	var pRealVfs uintptr = (*rbu_vfs)(unsafe.Pointer(pVfs)).FpRealVfs
	return (*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer((pRealVfs + 120 /* &.xCurrentTime */))))(tls, pRealVfs, pTimeOut)
}

// No-op.
func rbuVfsGetLastError(tls *crt.TLS, pVfs uintptr, a int32, b uintptr) int32 { /* sqlite3rbu.c:5190:12: */
	return 0
}

// Deregister and destroy an RBU vfs created by an earlier call to
// sqlite3rbu_create_vfs().
func sqlite3rbu_destroy_vfs(tls *crt.TLS, zName uintptr) { /* sqlite3rbu.c:5198:6: */
	var pVfs uintptr = sqlite3.Xsqlite3_vfs_find(tls, zName)
	if (pVfs != 0) && ((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FxOpen == *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, uintptr, int32, uintptr) int32
	}{rbuVfsOpen}))) {
		sqlite3.Xsqlite3_mutex_free(tls, (*rbu_vfs)(unsafe.Pointer(pVfs)).Fmutex)
		sqlite3.Xsqlite3_vfs_unregister(tls, pVfs)
		sqlite3.Xsqlite3_free(tls, pVfs)
	}
}

// Create an RBU VFS named zName that accesses the underlying file-system
// via existing VFS zParent. The new object is registered as a non-default
// VFS with SQLite before returning.
func sqlite3rbu_create_vfs(tls *crt.TLS, zName uintptr, zParent uintptr) int32 { /* sqlite3rbu.c:5212:5: */

	var pNew uintptr = uintptr(0) // Newly allocated VFS
	var rc int32 = 0
	var nName size_t
	var nByte size_t

	nName = crt.Xstrlen(tls, zName)
	nByte = ((uint64(unsafe.Sizeof(rbu_vfs{})) + nName) + uint64(1))
	pNew = sqlite3.Xsqlite3_malloc64(tls, uint64(nByte))
	if pNew == uintptr(0) {
		rc = 7
	} else {
		var pParent uintptr // Parent VFS
		crt.Xmemset(tls, pNew, 0, nByte)
		pParent = sqlite3.Xsqlite3_vfs_find(tls, zParent)
		if pParent == uintptr(0) {
			rc = 12
		} else {
			var zSpace uintptr
			crt.Xmemcpy(tls, (pNew /* &.base */), uintptr(unsafe.Pointer(&vfs_template)), uint64(unsafe.Sizeof(sqlite3_vfs{})))
			(*rbu_vfs)(unsafe.Pointer(pNew)).Fbase.FmxPathname = (*sqlite3_vfs)(unsafe.Pointer(pParent)).FmxPathname
			(*rbu_vfs)(unsafe.Pointer(pNew)).Fbase.FszOsFile = (int32(uint64(unsafe.Sizeof(rbu_file{})) + uint64((*sqlite3_vfs)(unsafe.Pointer(pParent)).FszOsFile)))
			(*rbu_vfs)(unsafe.Pointer(pNew)).FpRealVfs = pParent
			(*rbu_vfs)(unsafe.Pointer(pNew)).Fbase.FzName = crt.AssignUintptr(&zSpace, (pNew + uintptr(1)*208))
			crt.Xmemcpy(tls, zSpace, zName, nName)

			// Allocate the mutex and register the new VFS (not as the default)
			(*rbu_vfs)(unsafe.Pointer(pNew)).Fmutex = sqlite3.Xsqlite3_mutex_alloc(tls, 1)
			if (*rbu_vfs)(unsafe.Pointer(pNew)).Fmutex == uintptr(0) {
				rc = 7
			} else {
				rc = sqlite3.Xsqlite3_vfs_register(tls, (pNew /* &.base */), 0)
			}
		}

		if rc != 0 {
			sqlite3.Xsqlite3_mutex_free(tls, (*rbu_vfs)(unsafe.Pointer(pNew)).Fmutex)
			sqlite3.Xsqlite3_free(tls, pNew)
		}
	}

	return rc
}

var vfs_template = sqlite3_vfs{FiVersion: 1, FszOsFile: // iVersion
0, FmxPathname:// szOsFile
0, FpNext:// mxPathname
uintptr(0), FzName:// pNext
uintptr(0), FpAppData:// zName
uintptr(0), FxOpen:// pAppData
0, FxDelete:// xOpen
0, FxAccess:// xDelete
0, FxFullPathname:// xAccess
0, FxDlOpen:// xFullPathname

uintptr(0), FxDlError: uintptr(0), FxDlSym: uintptr(0), FxDlClose: uintptr(0), FxRandomness: 0, FxSleep: // xRandomness
0, FxCurrentTime:// xSleep
0, FxGetLastError:// xCurrentTime
0, FxCurrentTimeInt64:// xGetLastError
uintptr(0), FxSetSystemCall:// xCurrentTimeInt64 (version 2)
uintptr(0), FxGetSystemCall: uintptr(0), FxNextSystemCall: uintptr(0), // Unimplemented version 3 methods
} /* sqlite3rbu.c:5215:22 */

// Configure the aggregate temp file size limit for this RBU handle.
func sqlite3rbu_temp_size_limit(tls *crt.TLS, pRbu uintptr, n sqlite3_int64) sqlite3_int64 { /* sqlite3rbu.c:5290:15: */
	if n >= int64(0) {
		(*sqlite3rbu)(unsafe.Pointer(pRbu)).FszTempLimit = n
	}
	return (*sqlite3rbu)(unsafe.Pointer(pRbu)).FszTempLimit
}

func sqlite3rbu_temp_size(tls *crt.TLS, pRbu uintptr) sqlite3_int64 { /* sqlite3rbu.c:5297:15: */
	return (*sqlite3rbu)(unsafe.Pointer(pRbu)).FszTemp
}

//************************************************************************

func test_rbu_delta(tls *crt.TLS, pCtx uintptr, nArg int32, apVal uintptr) { /* test_rbu.c:34:6: */
	var interp uintptr = sqlite3.Xsqlite3_user_data(tls, pCtx)
	var pScript uintptr
	var i int32

	pScript = tcl.XTcl_NewObj(tls)
	(*Tcl_Obj)(unsafe.Pointer(pScript)).FrefCount++
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pScript, tcl.XTcl_NewStringObj(tls, ts+16492 /* "rbu_delta" */, -1))
	for i = 0; i < nArg; i++ {
		var pIn uintptr = *(*uintptr)(unsafe.Pointer(apVal + uintptr(i)*8))
		var z uintptr = sqlite3.Xsqlite3_value_text(tls, pIn)
		tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pScript, tcl.XTcl_NewStringObj(tls, z, -1))
	}

	if 0 == tcl.XTcl_EvalObjEx(tls, interp, pScript, 1) {
		var z uintptr = tcl.XTcl_GetStringResult(tls, interp)
		sqlite3.Xsqlite3_result_text(tls, pCtx, z, -1, crt.UintptrFromInt32(-1))
	} else {
		tcl.XTcl_BackgroundError(tls, interp)
	}

	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = pScript
		if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
}

func test_sqlite3rbu_cmd(tls *crt.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_rbu.c:59:26: */
	bp := tls.Alloc(496)
	defer tls.Free(496)

	var ret int32 = 0
	var pRbu uintptr = clientData
	*(*[14]RbuCmd)(unsafe.Pointer(bp + 24 /* aCmd */)) = [14]RbuCmd{
		{FzName: ts + 16502 /* "step" */, FnArg: 2, FzUsage: ts + 792 /* "" */},                   // 0
		{FzName: ts + 16507 /* "close" */, FnArg: 2, FzUsage: ts + 792 /* "" */},                  // 1
		{FzName: ts + 16513 /* "create_rbu_delta" */, FnArg: 2, FzUsage: ts + 792 /* "" */},       // 2
		{FzName: ts + 16530 /* "savestate" */, FnArg: 2, FzUsage: ts + 792 /* "" */},              // 3
		{FzName: ts + 16540 /* "dbMain_eval" */, FnArg: 3, FzUsage: ts + 16552 /* "SQL" */},       // 4
		{FzName: ts + 16556 /* "bp_progress" */, FnArg: 2, FzUsage: ts + 792 /* "" */},            // 5
		{FzName: ts + 16568 /* "db" */, FnArg: 3, FzUsage: ts + 16571 /* "RBU" */},                // 6
		{FzName: ts + 16575 /* "state" */, FnArg: 2, FzUsage: ts + 792 /* "" */},                  // 7
		{FzName: ts + 16581 /* "progress" */, FnArg: 2, FzUsage: ts + 792 /* "" */},               // 8
		{FzName: ts + 16590 /* "close_no_error" */, FnArg: 2, FzUsage: ts + 792 /* "" */},         // 9
		{FzName: ts + 16605 /* "temp_size_limit" */, FnArg: 3, FzUsage: ts + 16621 /* "LIMIT" */}, // 10
		{FzName: ts + 16627 /* "temp_size" */, FnArg: 2, FzUsage: ts + 792 /* "" */},              // 11
		{FzName: ts + 16637 /* "dbRbu_eval" */, FnArg: 3, FzUsage: ts + 16552 /* "SQL" */},        // 12
		{FzName: uintptr(0), FnArg: 0, FzUsage: uintptr(0)},
	}
	// var iCmd int32 at bp+360, 4

	if objc < 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+16648 /* "METHOD" */)
		return 1
	}
	ret = tcl.XTcl_GetIndexFromObjStruct(tls,
		interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)), bp+24 /* &aCmd[0] */, int32(unsafe.Sizeof(RbuCmd{})), ts+16655 /* "method" */, 0, bp+360 /* &iCmd */)
	if ret != 0 {
		return 1
	}
	if objc != (*RbuCmd)(unsafe.Pointer(bp+24 /* &aCmd */ +uintptr(*(*int32)(unsafe.Pointer(bp + 360 /* iCmd */)))*24)).FnArg {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, (*RbuCmd)(unsafe.Pointer(bp+24 /* &aCmd */ +uintptr(*(*int32)(unsafe.Pointer(bp + 360 /* iCmd */)))*24)).FzUsage)
		return 1
	}

	switch *(*int32)(unsafe.Pointer(bp + 360 /* iCmd */)) {
	case 0: /* step */
		{
			var rc int32 = sqlite3rbu_step(tls, pRbu)
			tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3ErrName(tls, rc), -1))
			break
		}

	case 9:
		fallthrough /* close_no_error */
	case 1: /* close */
		{
			*(*uintptr)(unsafe.Pointer(bp + 368 /* zErrmsg */)) = uintptr(0)
			var rc int32
			tcl.XTcl_DeleteCommand(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(0)*8))))
			if *(*int32)(unsafe.Pointer(bp + 360 /* iCmd */)) == 1 {
				rc = sqlite3rbu_close(tls, pRbu, bp+368 /* &zErrmsg */)
			} else {
				rc = sqlite3rbu_close(tls, pRbu, uintptr(0))
			}
			if (rc == 0) || (rc == 101) {
				tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3ErrName(tls, rc), -1))
				if !(*(*uintptr)(unsafe.Pointer(bp + 368 /* zErrmsg */)) == uintptr(0)) {
					crt.X__assert_fail(tls, ts+16662 /* "zErrmsg==0" */, ts+16673 /* "testdata/sqlite-..." */, uint32(121), uintptr(unsafe.Pointer(&__func__90)))
				}
			} else {
				tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3ErrName(tls, rc), -1))
				if *(*uintptr)(unsafe.Pointer(bp + 368 /* zErrmsg */)) != 0 {
					tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+16720 /* " - " */, *(*uintptr)(unsafe.Pointer(bp + 368 /* zErrmsg */)), 0))
					sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(bp + 368 /* zErrmsg */)))
				}
				ret = 1
			}
			break
		}

	case 2: /* create_rbu_delta */
		{
			var db uintptr = sqlite3rbu_db(tls, pRbu, 0)
			var rc int32 = sqlite3.Xsqlite3_create_function(tls,
				db, ts+16492 /* "rbu_delta" */, -1, 1, interp, *(*uintptr)(unsafe.Pointer(&struct {
					f func(*crt.TLS, uintptr, int32, uintptr)
				}{test_rbu_delta})), uintptr(0), uintptr(0))
			tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3ErrName(tls, rc), -1))
			ret = func() int32 {
				if rc == 0 {
					return 0
				}
				return 1
			}()
			break
		}

	case 3: /* savestate */
		{
			var rc int32 = sqlite3rbu_savestate(tls, pRbu)
			tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3ErrName(tls, rc), -1))
			ret = func() int32 {
				if rc == 0 {
					return 0
				}
				return 1
			}()
			break
		}

	case 12:
		fallthrough /* dbRbu_eval */
	case 4: /* dbMain_eval */
		{
			var db uintptr = sqlite3rbu_db(tls, pRbu, (crt.Bool32(*(*int32)(unsafe.Pointer(bp + 360 /* iCmd */)) == 12)))
			var rc int32 = sqlite3.Xsqlite3_exec(tls, db, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8))), uintptr(0), uintptr(0), uintptr(0))
			if rc != 0 {
				tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3_errmsg(tls, db), -1))
				ret = 1
			}
			break
		}

	case 5: /* bp_progress */
		{
			// var one int32 at bp+376, 4

			// var two int32 at bp+380, 4

			var pObj uintptr
			sqlite3rbu_bp_progress(tls, pRbu, bp+376 /* &one */, bp+380 /* &two */)

			pObj = tcl.XTcl_NewObj(tls)
			tcl.XTcl_ListObjAppendElement(tls, interp, pObj, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 376 /* one */))))
			tcl.XTcl_ListObjAppendElement(tls, interp, pObj, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 380 /* two */))))
			tcl.XTcl_SetObjResult(tls, interp, pObj)
			break
		}

	case 6: /* db */
		{
			// var bArg int32 at bp+384, 4

			if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)), bp+384 /* &bArg */) != 0 {
				ret = 1
			} else {
				// var zBuf [50]int8 at bp+388, 50

				var db uintptr = sqlite3rbu_db(tls, pRbu, *(*int32)(unsafe.Pointer(bp + 384 /* bArg */)))
				if sqlite3TestMakePointerStr(tls, interp, bp+388 /* &zBuf[0] */, db) != 0 {
					ret = 1
				} else {
					tcl.XTcl_SetResult(tls, interp, bp+388 /* &zBuf[0] */, uintptr(1))
				}
			}
			break
		}
	case 7: /* state */
		{
			*(*[6]uintptr)(unsafe.Pointer(bp + 440 /* aRes */)) = [6]uintptr{uintptr(0), ts + 16724 /* "oal" */, ts + 16728 /* "move" */, ts + 16733 /* "checkpoint" */, ts + 16744 /* "done" */, ts + 16749 /* "error" */}
			var eState int32 = sqlite3rbu_state(tls, pRbu)
			if !((eState > 0) && (eState <= 5)) {
				crt.X__assert_fail(tls, ts+16755 /* "eState>0 && eSta..." */, ts+16673 /* "testdata/sqlite-..." */, uint32(191), uintptr(unsafe.Pointer(&__func__90)))
			}
			tcl.XTcl_SetResult(tls, interp, *(*uintptr)(unsafe.Pointer(bp + 440 /* &aRes[0] */ + uintptr(eState)*8)), uintptr(0))
			break
		}
	case 8: /* progress */
		{
			var nStep sqlite3_int64 = sqlite3rbu_progress(tls, pRbu)
			tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewWideIntObj(tls, int64(nStep)))
			break
		}

	case 10: /* temp_size_limit */
		{
			// var nLimit sqlite3_int64 at bp+488, 8

			if tcl.XTcl_GetWideIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)), bp+488 /* &nLimit */) != 0 {
				ret = 1
			} else {
				*(*sqlite3_int64)(unsafe.Pointer(bp + 488 /* nLimit */)) = sqlite3rbu_temp_size_limit(tls, pRbu, *(*sqlite3_int64)(unsafe.Pointer(bp + 488 /* nLimit */)))
				tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewWideIntObj(tls, int64(*(*sqlite3_int64)(unsafe.Pointer(bp + 488 /* nLimit */)))))
			}
			break
		}
	case 11: /* temp_size */
		{
			var sz sqlite3_int64 = sqlite3rbu_temp_size(tls, pRbu)
			tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewWideIntObj(tls, int64(sz)))
			break
		}

	default: // seems unlikely
		if !(!(1 != 0)) {
			crt.X__assert_fail(tls, ts+16777 /* "!\"cannot happen\"" */, ts+16673 /* "testdata/sqlite-..." */, uint32(218), uintptr(unsafe.Pointer(&__func__90)))
		}
		break
	}

	return ret
}

type RbuCmd = struct {
	FzName  uintptr
	FnArg   int32
	FzUsage uintptr
}

var __func__90 = *(*[20]int8)(unsafe.Pointer(ts + 16794 /* "test_sqlite3rbu_..." */)) /* test_rbu.c:64:2 */

// Tclcmd: sqlite3rbu CMD <target-db> <rbu-db> ?<state-db>?
func test_sqlite3rbu(tls *crt.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_rbu.c:228:26: */
	var pRbu uintptr = uintptr(0)
	var zCmd uintptr
	var zTarget uintptr
	var zRbu uintptr
	var zStateDb uintptr = uintptr(0)

	if (objc != 4) && (objc != 5) {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+16814 /* "NAME TARGET-DB R..." */)
		return 1
	}
	zCmd = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)))
	zTarget = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)))
	zRbu = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(3)*8)))
	if objc == 5 {
		zStateDb = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(4)*8)))
	}

	pRbu = sqlite3rbu_open(tls, zTarget, zRbu, zStateDb)
	tcl.XTcl_CreateObjCommand(tls, interp, zCmd, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
	}{test_sqlite3rbu_cmd})), pRbu, uintptr(0))
	tcl.XTcl_SetObjResult(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)))
	return 0
}

// Tclcmd: sqlite3rbu_vacuum CMD <target-db> <state-db>
func test_sqlite3rbu_vacuum(tls *crt.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_rbu.c:258:26: */
	var pRbu uintptr = uintptr(0)
	var zCmd uintptr
	var zTarget uintptr
	var zStateDb uintptr = uintptr(0)

	if (objc != 3) && (objc != 4) {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+16847 /* "NAME TARGET-DB ?..." */)
		return 1
	}
	zCmd = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)))
	zTarget = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)))
	if objc == 4 {
		zStateDb = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(3)*8)))
	}
	if (zStateDb != 0) && (int32(*(*int8)(unsafe.Pointer(zStateDb + uintptr(0)))) == 0) {
		zStateDb = uintptr(0)
	}

	pRbu = sqlite3rbu_vacuum(tls, zTarget, zStateDb)
	tcl.XTcl_CreateObjCommand(tls, interp, zCmd, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
	}{test_sqlite3rbu_cmd})), pRbu, uintptr(0))
	tcl.XTcl_SetObjResult(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)))
	return 0
}

// Tclcmd: sqlite3rbu_create_vfs ?-default? NAME PARENT
func test_sqlite3rbu_create_vfs(tls *crt.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_rbu.c:287:26: */
	var zName uintptr
	var zParent uintptr
	var rc int32

	if (objc != 3) && (objc != 4) {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+16873 /* "?-default? NAME ..." */)
		return 1
	}

	zName = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr((objc-2))*8)))
	zParent = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr((objc-1))*8)))
	if int32(*(*int8)(unsafe.Pointer(zParent + uintptr(0)))) == 0 {
		zParent = uintptr(0)
	}

	rc = sqlite3rbu_create_vfs(tls, zName, zParent)
	if rc != 0 {
		tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3ErrName(tls, rc), -1))
		return 1
	} else if objc == 4 {
		var pVfs uintptr = sqlite3.Xsqlite3_vfs_find(tls, zName)
		sqlite3.Xsqlite3_vfs_register(tls, pVfs, 1)
	}

	tcl.XTcl_ResetResult(tls, interp)
	return 0
}

// Tclcmd: sqlite3rbu_destroy_vfs NAME
func test_sqlite3rbu_destroy_vfs(tls *crt.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_rbu.c:322:26: */
	var zName uintptr

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+16896 /* "NAME" */)
		return 1
	}

	zName = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)))
	sqlite3rbu_destroy_vfs(tls, zName)
	return 0
}

// Tclcmd: sqlite3rbu_internal_test
func test_sqlite3rbu_internal_test(tls *crt.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_rbu.c:343:26: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var db uintptr

	if objc != 1 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+792 /* "" */)
		return 1
	}

	db = sqlite3rbu_db(tls, uintptr(0), 0)
	if db != uintptr(0) {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+16901 /* "sqlite3rbu_db(0,..." */, 0))
		return 1
	}

	return 0
}

func SqliteRbu_Init(tls *crt.TLS, interp uintptr) int32 { /* test_rbu.c:365:5: */
	var i int32
	for i = 0; uint64(i) < (uint64(unsafe.Sizeof(aObjCmd)) / uint64(unsafe.Sizeof(struct {
		FzName uintptr
		FxProc uintptr
	}{}))); i++ {
		tcl.XTcl_CreateObjCommand(tls, interp, aObjCmd[i].FzName, aObjCmd[i].FxProc, uintptr(0), uintptr(0))
	}
	return 0
}

var aObjCmd = [5]struct {
	FzName uintptr
	FxProc uintptr
}{
	{FzName: ts + 16924 /* "sqlite3rbu" */, FxProc: 0},
	{FzName: ts + 16935 /* "sqlite3rbu_vacuu..." */, FxProc: 0},
	{FzName: ts + 16953 /* "sqlite3rbu_creat..." */, FxProc: 0},
	{FzName: ts + 16975 /* "sqlite3rbu_destr..." */, FxProc: 0},
	{FzName: ts + 16998 /* "sqlite3rbu_inter..." */, FxProc: 0},
} /* test_rbu.c:369:5 */

// Used to get the current process ID
// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.14 Signal handling <signal.h>

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//   Copyright (C) 2002-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Signal number definitions.  Linux version.
//   Copyright (C) 1995-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// Signal number constants.  Generic template.
//   Copyright (C) 1991-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// Fake signal functions.

// We define here all the signal names listed in POSIX (1003.1-2008);
//   as of 1003.1-2013, no additional signals have been added by POSIX.
//   We also define here signal names that historically exist in every
//   real-world POSIX variant (e.g. SIGWINCH).
//
//   Signals in the 1-15 range are defined with their historical numbers.
//   For other signals, we use the BSD numbers.
//   There are two unallocated signal numbers in the 1-31 range: 7 and 29.
//   Signal number 0 is reserved for use as kill(pid, 0), to test whether
//   a process exists without sending it a signal.

// ISO C99 signals.

// Historical signals specified by POSIX.

// New(er) POSIX signals (1003.1-2008, 1003.1-2013).

// Nonstandard signals found in all modern POSIX systems
//   (including both BSD and Linux).

// Archaic names for compatibility.

// Not all systems support real-time signals.  bits/signum.h indicates
//   that they are supported by overriding __SIGRTMAX to a value greater
//   than __SIGRTMIN.  These constants give the kernel-level hard limits,
//   but some real-time signals may be used internally by glibc.  Do not
//   use these constants in application code; use SIGRTMIN and SIGRTMAX
//   (defined in signal.h) instead.

// Biggest signal number + 1 (including real-time signals).

// Adjustments and additions to the signal number constants for
//   most Linux systems.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//   Copyright (C) 2002-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// An integral type that can be modified atomically, without the
//   possibility of a signal arriving in the middle of the operation.
type sig_atomic_t = int32 /* sig_atomic_t.h:8:24 */

// We need `struct timespec' later on.
// NB: Include guard matches what <linux/time.h> uses.

// Determine the wordsize from the preprocessor defines.

// Both x86-64 and x32 use the 64-bit system call interface.
// bits/types.h -- definitions of __*_t types underlying *_t types.
//   Copyright (C) 2002-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Define __sigval_t.
//   Copyright (C) 1997-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// Type for data associated with a signal.
type sigval = struct {
	_          [0]uint64
	Fsival_int int32
	_          [4]byte
}

// Some fields of siginfo_t have architecture-specific variations.
// Architecture-specific adjustments to siginfo_t.  x86 version.

type siginfo_t = struct {
	Fsi_signo  int32
	Fsi_errno  int32
	Fsi_code   int32
	F__pad0    int32
	F_sifields struct {
		_     [0]uint64
		F_pad [28]int32
	}
} /* siginfo_t.h:124:5 */

// Architectures might also add architecture-specific constants.
//   These are all considered GNU extensions.

// Define __sigval_t.
//   Copyright (C) 1997-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// To avoid sigval_t (not a standard type name) having C++ name
//   mangling depending on whether the selected standard includes union
//   sigval, it should not be defined at all when using a standard for
//   which the sigval name is not reserved; in that case, headers should
//   not include <bits/types/sigval_t.h> and should use only the
//   internal __sigval_t name.

type sigval_t = sigval /* sigval_t.h:16:20 */

// Determine the wordsize from the preprocessor defines.

// Both x86-64 and x32 use the 64-bit system call interface.
// bits/types.h -- definitions of __*_t types underlying *_t types.
//   Copyright (C) 2002-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Define __sigval_t.
//   Copyright (C) 1997-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// Forward declaration.

// Structure to transport application-defined values with signals.
type sigevent_t = sigevent /* sigevent_t.h:42:5 */

// 4.4 BSD uses the name `sig_t' for this.
type sig_t = uintptr /* signal.h:190:24 */

type _fpxreg = struct {
	Fsignificand       [4]uint16
	Fexponent          uint16
	F__glibc_reserved1 [3]uint16
}

type _xmmreg = struct{ Felement [4]uint32 }

type _fpstate = struct {
	Fcwd       uint16
	Fswd       uint16
	Fftw       uint16
	Ffop       uint16
	Frip       uint64
	Frdp       uint64
	Fmxcsr     uint32
	Fmxcr_mask uint32
	F_st       [8]struct {
		Fsignificand       [4]uint16
		Fexponent          uint16
		F__glibc_reserved1 [3]uint16
	}
	F_xmm              [16]struct{ Felement [4]uint32 }
	F__glibc_reserved1 [24]uint32
}

type _xsave_hdr = struct {
	Fxstate_bv         uint64
	F__glibc_reserved1 [2]uint64
	F__glibc_reserved2 [5]uint64
}

type _ymmh_state = struct{ Fymmh_space [64]uint32 }

// Copyright (C) 1989-2018 Free Software Foundation, Inc.
//
//This file is part of GCC.
//
//GCC is free software; you can redistribute it and/or modify
//it under the terms of the GNU General Public License as published by
//the Free Software Foundation; either version 3, or (at your option)
//any later version.
//
//GCC is distributed in the hope that it will be useful,
//but WITHOUT ANY WARRANTY; without even the implied warranty of
//MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//GNU General Public License for more details.
//
//Under Section 7 of GPL version 3, you are granted additional
//permissions described in the GCC Runtime Library Exception, version
//3.1, as published by the Free Software Foundation.
//
//You should have received a copy of the GNU General Public License and
//a copy of the GCC Runtime Library Exception along with this program;
//see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
//<http://www.gnu.org/licenses/>.

// ISO C Standard:  7.17  Common definitions  <stddef.h>

// Any one of these symbols __need_* means that GNU libc
//   wants us just to define one data type.  So don't define
//   the symbols that indicate this file's entire job has been done.

// This avoids lossage on SunOS but only if stdtypes.h comes first.
//   There's no way to win with the other order!  Sun lossage.

// On 4.3bsd-net2, make sure ansi.h is included, so we have
//   one less case to deal with in the following.
// On FreeBSD 5, machine/ansi.h does not exist anymore...

// In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
//   defined if the corresponding type is *not* defined.
//   FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_.
//   NetBSD defines _I386_ANSI_H_ and _X86_64_ANSI_H_ instead of _ANSI_H_

// Sequent's header files use _PTRDIFF_T_ in some conflicting way.
//   Just ignore it.

// On VxWorks, <type/vxTypesBase.h> may have defined macros like
//   _TYPE_size_t which will typedef size_t.  fixincludes patched the
//   vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
//   not defined, and so that defining this macro defines _GCC_SIZE_T.
//   If we find that the macros are still defined at this point, we must
//   invoke them so that the type is defined as expected.

// In case nobody has defined these types, but we aren't running under
//   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
//   __WCHAR_TYPE__ have reasonable values.  This can happen if the
//   parts of GCC is compiled by an older compiler, that actually
//   include gstddef.h, such as collect2.

// Signed type of difference of two pointers.

// Define this type if we are doing the whole job,
//   or if we want this type in particular.

// Unsigned type of `sizeof' something.

// Define this type if we are doing the whole job,
//   or if we want this type in particular.

// Wide character type.
//   Locale-writers should change this as necessary to
//   be big enough to hold unique values not between 0 and 127,
//   and not (wchar_t) -1, for each defined multibyte character.

// Define this type if we are doing the whole job,
//   or if we want this type in particular.

//  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
//    are already defined.
//  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.
//  NetBSD 5 requires the I386_ANSI_H and X86_64_ANSI_H checks here.

// A null pointer constant.

// Define stack_t.  Linux version.
//   Copyright (C) 1998-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// Copyright (C) 1989-2018 Free Software Foundation, Inc.
//
//This file is part of GCC.
//
//GCC is free software; you can redistribute it and/or modify
//it under the terms of the GNU General Public License as published by
//the Free Software Foundation; either version 3, or (at your option)
//any later version.
//
//GCC is distributed in the hope that it will be useful,
//but WITHOUT ANY WARRANTY; without even the implied warranty of
//MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//GNU General Public License for more details.
//
//Under Section 7 of GPL version 3, you are granted additional
//permissions described in the GCC Runtime Library Exception, version
//3.1, as published by the Free Software Foundation.
//
//You should have received a copy of the GNU General Public License and
//a copy of the GCC Runtime Library Exception along with this program;
//see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
//<http://www.gnu.org/licenses/>.

// ISO C Standard:  7.17  Common definitions  <stddef.h>

// Any one of these symbols __need_* means that GNU libc
//   wants us just to define one data type.  So don't define
//   the symbols that indicate this file's entire job has been done.

// This avoids lossage on SunOS but only if stdtypes.h comes first.
//   There's no way to win with the other order!  Sun lossage.

// On 4.3bsd-net2, make sure ansi.h is included, so we have
//   one less case to deal with in the following.
// On FreeBSD 5, machine/ansi.h does not exist anymore...

// In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
//   defined if the corresponding type is *not* defined.
//   FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_.
//   NetBSD defines _I386_ANSI_H_ and _X86_64_ANSI_H_ instead of _ANSI_H_

// Sequent's header files use _PTRDIFF_T_ in some conflicting way.
//   Just ignore it.

// On VxWorks, <type/vxTypesBase.h> may have defined macros like
//   _TYPE_size_t which will typedef size_t.  fixincludes patched the
//   vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
//   not defined, and so that defining this macro defines _GCC_SIZE_T.
//   If we find that the macros are still defined at this point, we must
//   invoke them so that the type is defined as expected.

// In case nobody has defined these types, but we aren't running under
//   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
//   __WCHAR_TYPE__ have reasonable values.  This can happen if the
//   parts of GCC is compiled by an older compiler, that actually
//   include gstddef.h, such as collect2.

// Signed type of difference of two pointers.

// Define this type if we are doing the whole job,
//   or if we want this type in particular.

// Unsigned type of `sizeof' something.

// Define this type if we are doing the whole job,
//   or if we want this type in particular.

// Wide character type.
//   Locale-writers should change this as necessary to
//   be big enough to hold unique values not between 0 and 127,
//   and not (wchar_t) -1, for each defined multibyte character.

// Define this type if we are doing the whole job,
//   or if we want this type in particular.

//  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
//    are already defined.
//  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.
//  NetBSD 5 requires the I386_ANSI_H and X86_64_ANSI_H checks here.

// A null pointer constant.

// Structure describing a signal stack.
type stack_t = struct {
	Fss_sp    uintptr
	Fss_flags int32
	Fss_size  size_t
} /* stack_t.h:31:5 */

// This will define `ucontext_t' and `mcontext_t'.
// Copyright (C) 2001-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//   Copyright (C) 2002-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Define stack_t.  Linux version.
//   Copyright (C) 1998-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// Type for general register.
type greg_t = int64 /* ucontext.h:37:37 */

// Number of general registers.

// Container for all general registers.
type gregset_t = [23]greg_t /* ucontext.h:46:16 */

type _libc_fpxreg = struct {
	Fsignificand       [4]uint16
	Fexponent          uint16
	F__glibc_reserved1 [3]uint16
}

type _libc_xmmreg = struct{ Felement [4]uint32 }

type _libc_fpstate = struct {
	Fcwd       uint16
	Fswd       uint16
	Fftw       uint16
	Ffop       uint16
	Frip       uint64
	Frdp       uint64
	Fmxcsr     uint32
	Fmxcr_mask uint32
	F_st       [8]struct {
		Fsignificand       [4]uint16
		Fexponent          uint16
		F__glibc_reserved1 [3]uint16
	}
	F_xmm              [16]struct{ Felement [4]uint32 }
	F__glibc_reserved1 [24]uint32
}

// Structure to describe FPU registers.
type fpregset_t = uintptr /* ucontext.h:130:30 */

// Context to describe whole processor state.
type mcontext_t = struct {
	Fgregs       gregset_t
	Ffpregs      fpregset_t
	F__reserved1 [8]uint64
} /* ucontext.h:139:3 */

// Userlevel context.
type ucontext_t1 = struct {
	Fuc_flags     uint64
	Fuc_link      uintptr
	Fuc_stack     stack_t
	Fuc_mcontext  mcontext_t
	Fuc_sigmask   sigset_t
	F__fpregs_mem struct {
		Fcwd       uint16
		Fswd       uint16
		Fftw       uint16
		Ffop       uint16
		Frip       uint64
		Frdp       uint64
		Fmxcsr     uint32
		Fmxcr_mask uint32
		F_st       [8]struct {
			Fsignificand       [4]uint16
			Fexponent          uint16
			F__glibc_reserved1 [3]uint16
		}
		F_xmm              [16]struct{ Felement [4]uint32 }
		F__glibc_reserved1 [24]uint32
	}
	F__ssp [4]uint64
}

// Userlevel context.
type ucontext_t = ucontext_t1 /* ucontext.h:151:5 */

// Define some macros helping to catch buffer overflows.

// Windows needs to know which symbols to export.  Unix does not.
// BUILD_sqlite should be undefined for Unix.

// Forward declaration
type SqliteDb = struct {
	Fdb             uintptr
	Finterp         uintptr
	FzBusy          uintptr
	FzCommit        uintptr
	FzTrace         uintptr
	FzTraceV2       uintptr
	FzProfile       uintptr
	FzProgress      uintptr
	FzBindFallback  uintptr
	FzAuth          uintptr
	FdisableAuth    int32
	FzNull          uintptr
	FpFunc          uintptr
	FpUpdateHook    uintptr
	FpPreUpdateHook uintptr
	FpRollbackHook  uintptr
	FpWalHook       uintptr
	FpUnlockNotify  uintptr
	FpCollate       uintptr
	Frc             int32
	FpCollateNeeded uintptr
	FstmtList       uintptr
	FstmtLast       uintptr
	FmaxStmt        int32
	FnStmt          int32
	FpIncrblob      uintptr
	FnStep          int32
	FnSort          int32
	FnIndex         int32
	FnVMStep        int32
	FnTransaction   int32
	FopenFlags      int32
	FbLegacyPrepare int32
	_               [4]byte
} /* tclsqlite.c:91:25 */

// New SQL functions can be created as TCL scripts.  Each such function
// is described by an instance of the following structure.
//
// Variable eType may be set to SQLITE_INTEGER, SQLITE_FLOAT, SQLITE_TEXT,
// SQLITE_BLOB or SQLITE_NULL. If it is SQLITE_NULL, then the implementation
// attempts to determine the type of the result based on the Tcl object.
// If it is SQLITE_TEXT or SQLITE_BLOB, then a text (sqlite3_result_text())
// or blob (sqlite3_result_blob()) is returned. If it is SQLITE_INTEGER
// or SQLITE_FLOAT, then an attempt is made to return an integer or float
// value, falling back to float and then text if this is not possible.
type SqlFunc1 = struct {
	Finterp      uintptr
	FpScript     uintptr
	FpDb         uintptr
	FuseEvalObjv int32
	FeType       int32
	FzName       uintptr
	FpNext       uintptr
}

// New SQL functions can be created as TCL scripts.  Each such function
// is described by an instance of the following structure.
//
// Variable eType may be set to SQLITE_INTEGER, SQLITE_FLOAT, SQLITE_TEXT,
// SQLITE_BLOB or SQLITE_NULL. If it is SQLITE_NULL, then the implementation
// attempts to determine the type of the result based on the Tcl object.
// If it is SQLITE_TEXT or SQLITE_BLOB, then a text (sqlite3_result_text())
// or blob (sqlite3_result_blob()) is returned. If it is SQLITE_INTEGER
// or SQLITE_FLOAT, then an attempt is made to return an integer or float
// value, falling back to float and then text if this is not possible.
type SqlFunc = SqlFunc1 /* tclsqlite.c:105:24 */

// New collation sequences function can be created as TCL scripts.  Each such
// function is described by an instance of the following structure.
type SqlCollate1 = struct {
	Finterp  uintptr
	FzScript uintptr
	FpNext   uintptr
}

// New collation sequences function can be created as TCL scripts.  Each such
// function is described by an instance of the following structure.
type SqlCollate = SqlCollate1 /* tclsqlite.c:120:27 */

// Prepared statements are cached for faster execution.  Each prepared
// statement is described by an instance of the following structure.
type SqlPreparedStmt1 = struct {
	FpNext  uintptr
	FpPrev  uintptr
	FpStmt  uintptr
	FnSql   int32
	FzSql   uintptr
	FnParm  int32
	FapParm uintptr
}

// Prepared statements are cached for faster execution.  Each prepared
// statement is described by an instance of the following structure.
type SqlPreparedStmt = SqlPreparedStmt1 /* tclsqlite.c:131:32 */

type IncrblobChannel1 = struct {
	FpBlob   uintptr
	FpDb     uintptr
	FiSeek   int32
	Fchannel Tcl_Channel
	FpNext   uintptr
	FpPrev   uintptr
}

type IncrblobChannel = IncrblobChannel1 /* tclsqlite.c:142:32 */

// Compute a string length that is limited to what can be stored in
// lower 30 bits of a 32-bit signed integer.
func strlen30(tls *crt.TLS, z uintptr) int32 { /* tclsqlite.c:202:12: */
	var z2 uintptr = z
	for *(*int8)(unsafe.Pointer(z2)) != 0 {
		z2++
	}
	return (0x3fffffff & (int32((int64(z2) - int64(z)) / 1)))
}

// Close all incrblob channels opened using database connection pDb.
// This is called when shutting down the database connection.
func closeIncrblobChannels(tls *crt.TLS, pDb uintptr) { /* tclsqlite.c:214:13: */
	var p uintptr
	var pNext uintptr

	for p = (*SqliteDb)(unsafe.Pointer(pDb)).FpIncrblob; p != 0; p = pNext {
		pNext = (*IncrblobChannel)(unsafe.Pointer(p)).FpNext

		// Note: Calling unregister here call Tcl_Close on the incrblob channel,
		// which deletes the IncrblobChannel structure at *p. So do not
		// call Tcl_Free() here.
		tcl.XTcl_UnregisterChannel(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp, (*IncrblobChannel)(unsafe.Pointer(p)).Fchannel)
	}
}

// Close an incremental blob channel.
func incrblobClose(tls *crt.TLS, instanceData ClientData, interp uintptr) int32 { /* tclsqlite.c:232:26: */
	var p uintptr = instanceData
	var rc int32 = sqlite3.Xsqlite3_blob_close(tls, (*IncrblobChannel)(unsafe.Pointer(p)).FpBlob)
	var db uintptr = (*SqliteDb)(unsafe.Pointer((*IncrblobChannel)(unsafe.Pointer(p)).FpDb)).Fdb

	// Remove the channel from the SqliteDb.pIncrblob list.
	if (*IncrblobChannel)(unsafe.Pointer(p)).FpNext != 0 {
		(*IncrblobChannel)(unsafe.Pointer((*IncrblobChannel)(unsafe.Pointer(p)).FpNext)).FpPrev = (*IncrblobChannel)(unsafe.Pointer(p)).FpPrev
	}
	if (*IncrblobChannel)(unsafe.Pointer(p)).FpPrev != 0 {
		(*IncrblobChannel)(unsafe.Pointer((*IncrblobChannel)(unsafe.Pointer(p)).FpPrev)).FpNext = (*IncrblobChannel)(unsafe.Pointer(p)).FpNext
	}
	if (*SqliteDb)(unsafe.Pointer((*IncrblobChannel)(unsafe.Pointer(p)).FpDb)).FpIncrblob == p {
		(*SqliteDb)(unsafe.Pointer((*IncrblobChannel)(unsafe.Pointer(p)).FpDb)).FpIncrblob = (*IncrblobChannel)(unsafe.Pointer(p)).FpNext
	}

	// Free the IncrblobChannel structure
	tcl.XTcl_Free(tls, p)

	if rc != 0 {
		tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3_errmsg(tls, db), uintptr(1))
		return 1
	}
	return 0
}

// Read data from an incremental blob channel.
func incrblobInput(tls *crt.TLS, instanceData ClientData, buf uintptr, bufSize int32, errorCodePtr uintptr) int32 { /* tclsqlite.c:264:26: */
	var p uintptr = instanceData
	var nRead int32 = bufSize // Number of bytes to read
	var nBlob int32           // Total size of the blob
	var rc int32              // sqlite error code

	nBlob = sqlite3.Xsqlite3_blob_bytes(tls, (*IncrblobChannel)(unsafe.Pointer(p)).FpBlob)
	if ((*IncrblobChannel)(unsafe.Pointer(p)).FiSeek + nRead) > nBlob {
		nRead = (nBlob - (*IncrblobChannel)(unsafe.Pointer(p)).FiSeek)
	}
	if nRead <= 0 {
		return 0
	}

	rc = sqlite3.Xsqlite3_blob_read(tls, (*IncrblobChannel)(unsafe.Pointer(p)).FpBlob, buf, nRead, (*IncrblobChannel)(unsafe.Pointer(p)).FiSeek)
	if rc != 0 {
		*(*int32)(unsafe.Pointer(errorCodePtr)) = rc
		return -1
	}

	*(*int32)(unsafe.Pointer(p + 16 /* &.iSeek */)) += (nRead)
	return nRead
}

// Write data to an incremental blob channel.
func incrblobOutput(tls *crt.TLS, instanceData ClientData, buf uintptr, toWrite int32, errorCodePtr uintptr) int32 { /* tclsqlite.c:296:26: */
	var p uintptr = instanceData
	var nWrite int32 = toWrite // Number of bytes to write
	var nBlob int32            // Total size of the blob
	var rc int32               // sqlite error code

	nBlob = sqlite3.Xsqlite3_blob_bytes(tls, (*IncrblobChannel)(unsafe.Pointer(p)).FpBlob)
	if ((*IncrblobChannel)(unsafe.Pointer(p)).FiSeek + nWrite) > nBlob {
		*(*int32)(unsafe.Pointer(errorCodePtr)) = 22
		return -1
	}
	if nWrite <= 0 {
		return 0
	}

	rc = sqlite3.Xsqlite3_blob_write(tls, (*IncrblobChannel)(unsafe.Pointer(p)).FpBlob, buf, nWrite, (*IncrblobChannel)(unsafe.Pointer(p)).FiSeek)
	if rc != 0 {
		*(*int32)(unsafe.Pointer(errorCodePtr)) = 5
		return -1
	}

	*(*int32)(unsafe.Pointer(p + 16 /* &.iSeek */)) += (nWrite)
	return nWrite
}

// Seek an incremental blob channel.
func incrblobSeek(tls *crt.TLS, instanceData ClientData, offset int64, seekMode int32, errorCodePtr uintptr) int32 { /* tclsqlite.c:329:26: */
	var p uintptr = instanceData

	switch seekMode {
	case 0:
		(*IncrblobChannel)(unsafe.Pointer(p)).FiSeek = int32(offset)
		break
	case 1:
		*(*int32)(unsafe.Pointer(p + 16 /* &.iSeek */)) += int32((offset))
		break
	case 2:
		(*IncrblobChannel)(unsafe.Pointer(p)).FiSeek = (int32(int64(sqlite3.Xsqlite3_blob_bytes(tls, (*IncrblobChannel)(unsafe.Pointer(p)).FpBlob)) + offset))
		break

	default:
		if !(!(1 != 0)) {
			crt.X__assert_fail(tls, ts+17023 /* "!\"Bad seekMode\"" */, ts+17039 /* "testdata/sqlite-..." */, uint32(348), uintptr(unsafe.Pointer(&__func__91)))
		}
	}

	return (*IncrblobChannel)(unsafe.Pointer(p)).FiSeek
}

var __func__91 = *(*[13]int8)(unsafe.Pointer(ts + 17083 /* "incrblobSeek" */)) /* tclsqlite.c:334:2 */

func incrblobWatch(tls *crt.TLS, instanceData ClientData, mode int32) { /* tclsqlite.c:355:27: */
	// NO-OP
}
func incrblobHandle(tls *crt.TLS, instanceData ClientData, dir int32, hPtr uintptr) int32 { /* tclsqlite.c:361:26: */
	return 1
}

var IncrblobChannelType = Tcl_ChannelType{FtypeName: ts + 17096 /* "incrblob" */, Fversion: // typeName
uintptr(0x2), FcloseProc:// version
0, FinputProc:// closeProc
0, FoutputProc:// inputProc
0, FseekProc:// outputProc
0, FsetOptionProc:// seekProc
uintptr(0), FgetOptionProc:// setOptionProc
uintptr(0), FwatchProc:// getOptionProc
0, FgetHandleProc:// watchProc (this is a no-op)
0, Fclose2Proc:// getHandleProc (always returns error)
uintptr(0), FblockModeProc:// close2Proc
uintptr(0), FflushProc:// blockModeProc
uintptr(0), FhandlerProc:// flushProc
uintptr(0), FwideSeekProc:// handlerProc
uintptr(0), // wideSeekProc
} /* tclsqlite.c:369:24 */

// Create a new incrblob channel.
func createIncrblobChannel(tls *crt.TLS, interp uintptr, pDb uintptr, zDb uintptr, zTable uintptr, zColumn uintptr, iRow sqlite_int64, isReadonly int32) int32 { /* tclsqlite.c:390:12: */
	bp := tls.Alloc(80)
	defer tls.Free(80)

	var p uintptr
	var db uintptr = (*SqliteDb)(unsafe.Pointer(pDb)).Fdb
	// var pBlob uintptr at bp+8, 8

	var rc int32
	var flags int32 = ((int32(1) << 1) | (func() int32 {
		if isReadonly != 0 {
			return 0
		}
		return (int32(1) << 2)
	}()))
	// var zChannel [64]int8 at bp+16, 64

	rc = sqlite3.Xsqlite3_blob_open(tls, db, zDb, zTable, zColumn, iRow, crt.BoolInt32(!(isReadonly != 0)), bp+8 /* &pBlob */)
	if rc != 0 {
		tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3_errmsg(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb), uintptr(1))
		return 1
	}

	p = tcl.XTcl_Alloc(tls, uint32(unsafe.Sizeof(IncrblobChannel{})))
	(*IncrblobChannel)(unsafe.Pointer(p)).FiSeek = 0
	(*IncrblobChannel)(unsafe.Pointer(p)).FpBlob = *(*uintptr)(unsafe.Pointer(bp + 8 /* pBlob */))

	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([64]int8{})), bp+16 /* &zChannel[0] */, ts+17105 /* "incrblob_%d" */, crt.VaList(bp, crt.PreIncInt32(&count, 1)))
	(*IncrblobChannel)(unsafe.Pointer(p)).Fchannel = tcl.XTcl_CreateChannel(tls, uintptr(unsafe.Pointer(&IncrblobChannelType)), bp+16 /* &zChannel[0] */, p, flags)
	tcl.XTcl_RegisterChannel(tls, interp, (*IncrblobChannel)(unsafe.Pointer(p)).Fchannel)

	// Link the new channel into the SqliteDb.pIncrblob list.
	(*IncrblobChannel)(unsafe.Pointer(p)).FpNext = (*SqliteDb)(unsafe.Pointer(pDb)).FpIncrblob
	(*IncrblobChannel)(unsafe.Pointer(p)).FpPrev = uintptr(0)
	if (*IncrblobChannel)(unsafe.Pointer(p)).FpNext != 0 {
		(*IncrblobChannel)(unsafe.Pointer((*IncrblobChannel)(unsafe.Pointer(p)).FpNext)).FpPrev = p
	}
	(*SqliteDb)(unsafe.Pointer(pDb)).FpIncrblob = p
	(*IncrblobChannel)(unsafe.Pointer(p)).FpDb = pDb

	tcl.XTcl_SetResult(tls, interp, tcl.XTcl_GetChannelName(tls, (*IncrblobChannel)(unsafe.Pointer(p)).Fchannel), uintptr(1))
	return 0
}

var count int32 = 0 /* tclsqlite.c:406:14 */

// Look at the script prefix in pCmd.  We will be executing this script
// after first appending one or more arguments.  This routine analyzes
// the script to see if it is safe to use Tcl_EvalObjv() on the script
// rather than the more general Tcl_EvalEx().  Tcl_EvalObjv() is much
// faster.
//
// Scripts that are safe to use with Tcl_EvalObjv() consists of a
// command name followed by zero or more arguments with no [...] or $
// or {...} or ; to be seen anywhere.  Most callback scripts consist
// of just a single procedure name and they meet this requirement.
func safeToUseEvalObjv(tls *crt.TLS, interp uintptr, pCmd uintptr) int32 { /* tclsqlite.c:451:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	// We could try to do something with Tcl_Parse().  But we will instead
	// just do a search for forbidden characters.  If any of the forbidden
	// characters appear in pCmd, we will report the string as unsafe.
	var z uintptr
	// var n int32 at bp, 4

	z = tcl.XTcl_GetStringFromObj(tls, pCmd, bp /* &n */)
	for crt.PostDecInt32(&*(*int32)(unsafe.Pointer(bp /* n */)), 1) > 0 {
		var c int32 = int32(*(*int8)(unsafe.Pointer(crt.PostIncUintptr(&z, 1))))
		if ((c == '$') || (c == '[')) || (c == ';') {
			return 0
		}
	}
	return 1
}

// Find an SqlFunc structure with the given name.  Or create a new
// one if an existing one cannot be found.  Return a pointer to the
// structure.
func findSqlFunc(tls *crt.TLS, pDb uintptr, zName uintptr) uintptr { /* tclsqlite.c:471:16: */
	var p uintptr
	var pNew uintptr
	var nName int32 = strlen30(tls, zName)
	pNew = tcl.XTcl_Alloc(tls, (uint32((uint64(unsafe.Sizeof(SqlFunc{})) + uint64(nName)) + uint64(1))))
	(*SqlFunc)(unsafe.Pointer(pNew)).FzName = (pNew + uintptr(1)*48)
	crt.Xmemcpy(tls, (*SqlFunc)(unsafe.Pointer(pNew)).FzName, zName, (uint64(nName + 1)))
	for p = (*SqliteDb)(unsafe.Pointer(pDb)).FpFunc; p != 0; p = (*SqlFunc)(unsafe.Pointer(p)).FpNext {
		if sqlite3.Xsqlite3_stricmp(tls, (*SqlFunc)(unsafe.Pointer(p)).FzName, (*SqlFunc)(unsafe.Pointer(pNew)).FzName) == 0 {
			tcl.XTcl_Free(tls, pNew)
			return p
		}
	}
	(*SqlFunc)(unsafe.Pointer(pNew)).Finterp = (*SqliteDb)(unsafe.Pointer(pDb)).Finterp
	(*SqlFunc)(unsafe.Pointer(pNew)).FpDb = pDb
	(*SqlFunc)(unsafe.Pointer(pNew)).FpScript = uintptr(0)
	(*SqlFunc)(unsafe.Pointer(pNew)).FpNext = (*SqliteDb)(unsafe.Pointer(pDb)).FpFunc
	(*SqliteDb)(unsafe.Pointer(pDb)).FpFunc = pNew
	return pNew
}

// Free a single SqlPreparedStmt object.
func dbFreeStmt(tls *crt.TLS, pStmt uintptr) { /* tclsqlite.c:494:13: */
	if sqlite3.Xsqlite3_sql(tls, (*SqlPreparedStmt)(unsafe.Pointer(pStmt)).FpStmt) == uintptr(0) {
		tcl.XTcl_Free(tls, (*SqlPreparedStmt)(unsafe.Pointer(pStmt)).FzSql)
	}
	sqlite3.Xsqlite3_finalize(tls, (*SqlPreparedStmt)(unsafe.Pointer(pStmt)).FpStmt)
	tcl.XTcl_Free(tls, pStmt)
}

// Finalize and free a list of prepared statements
func flushStmtCache(tls *crt.TLS, pDb uintptr) { /* tclsqlite.c:507:13: */
	var pPreStmt uintptr
	var pNext uintptr

	for pPreStmt = (*SqliteDb)(unsafe.Pointer(pDb)).FstmtList; pPreStmt != 0; pPreStmt = pNext {
		pNext = (*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FpNext
		dbFreeStmt(tls, pPreStmt)
	}
	(*SqliteDb)(unsafe.Pointer(pDb)).FnStmt = 0
	(*SqliteDb)(unsafe.Pointer(pDb)).FstmtLast = uintptr(0)
	(*SqliteDb)(unsafe.Pointer(pDb)).FstmtList = uintptr(0)
}

// TCL calls this procedure when an sqlite3 database command is
// deleted.
func DbDeleteCmd(tls *crt.TLS, db uintptr) { /* tclsqlite.c:524:27: */
	var pDb uintptr = db
	flushStmtCache(tls, pDb)
	closeIncrblobChannels(tls, pDb)
	sqlite3.Xsqlite3_close(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb)
	for (*SqliteDb)(unsafe.Pointer(pDb)).FpFunc != 0 {
		var pFunc uintptr = (*SqliteDb)(unsafe.Pointer(pDb)).FpFunc
		(*SqliteDb)(unsafe.Pointer(pDb)).FpFunc = (*SqlFunc)(unsafe.Pointer(pFunc)).FpNext
		if !((*SqlFunc)(unsafe.Pointer(pFunc)).FpDb == pDb) {
			crt.X__assert_fail(tls, ts+17117 /* "pFunc->pDb==pDb" */, ts+17039 /* "testdata/sqlite-..." */, uint32(532), uintptr(unsafe.Pointer(&__func__92)))
		}
		for ok := true; ok; ok = 0 != 0 {
			var _objPtr uintptr = (*SqlFunc)(unsafe.Pointer(pFunc)).FpScript
			if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
		tcl.XTcl_Free(tls, pFunc)
	}
	for (*SqliteDb)(unsafe.Pointer(pDb)).FpCollate != 0 {
		var pCollate uintptr = (*SqliteDb)(unsafe.Pointer(pDb)).FpCollate
		(*SqliteDb)(unsafe.Pointer(pDb)).FpCollate = (*SqlCollate)(unsafe.Pointer(pCollate)).FpNext
		tcl.XTcl_Free(tls, pCollate)
	}
	if (*SqliteDb)(unsafe.Pointer(pDb)).FzBusy != 0 {
		tcl.XTcl_Free(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzBusy)
	}
	if (*SqliteDb)(unsafe.Pointer(pDb)).FzTrace != 0 {
		tcl.XTcl_Free(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzTrace)
	}
	if (*SqliteDb)(unsafe.Pointer(pDb)).FzTraceV2 != 0 {
		tcl.XTcl_Free(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzTraceV2)
	}
	if (*SqliteDb)(unsafe.Pointer(pDb)).FzProfile != 0 {
		tcl.XTcl_Free(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzProfile)
	}
	if (*SqliteDb)(unsafe.Pointer(pDb)).FzBindFallback != 0 {
		tcl.XTcl_Free(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzBindFallback)
	}
	if (*SqliteDb)(unsafe.Pointer(pDb)).FzAuth != 0 {
		tcl.XTcl_Free(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzAuth)
	}
	if (*SqliteDb)(unsafe.Pointer(pDb)).FzNull != 0 {
		tcl.XTcl_Free(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzNull)
	}
	if (*SqliteDb)(unsafe.Pointer(pDb)).FpUpdateHook != 0 {
		for ok1 := true; ok1; ok1 = 0 != 0 {
			var _objPtr uintptr = (*SqliteDb)(unsafe.Pointer(pDb)).FpUpdateHook
			if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
	}
	if (*SqliteDb)(unsafe.Pointer(pDb)).FpPreUpdateHook != 0 {
		for ok2 := true; ok2; ok2 = 0 != 0 {
			var _objPtr uintptr = (*SqliteDb)(unsafe.Pointer(pDb)).FpPreUpdateHook
			if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
	}
	if (*SqliteDb)(unsafe.Pointer(pDb)).FpRollbackHook != 0 {
		for ok3 := true; ok3; ok3 = 0 != 0 {
			var _objPtr uintptr = (*SqliteDb)(unsafe.Pointer(pDb)).FpRollbackHook
			if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
	}
	if (*SqliteDb)(unsafe.Pointer(pDb)).FpWalHook != 0 {
		for ok4 := true; ok4; ok4 = 0 != 0 {
			var _objPtr uintptr = (*SqliteDb)(unsafe.Pointer(pDb)).FpWalHook
			if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
	}
	if (*SqliteDb)(unsafe.Pointer(pDb)).FpCollateNeeded != 0 {
		for ok5 := true; ok5; ok5 = 0 != 0 {
			var _objPtr uintptr = (*SqliteDb)(unsafe.Pointer(pDb)).FpCollateNeeded
			if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
	}
	tcl.XTcl_Free(tls, pDb)
}

var __func__92 = *(*[12]int8)(unsafe.Pointer(ts + 17133 /* "DbDeleteCmd" */)) /* tclsqlite.c:524:48 */

// This routine is called when a database file is locked while trying
// to execute SQL.
func DbBusyHandler(tls *crt.TLS, cd uintptr, nTries int32) int32 { /* tclsqlite.c:584:12: */
	bp := tls.Alloc(70)
	defer tls.Free(70)

	var pDb uintptr = cd
	var rc int32
	// var zVal [30]int8 at bp+40, 30

	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([30]int8{})), bp+40 /* &zVal[0] */, ts+1647 /* "%d" */, crt.VaList(bp, nTries))
	rc = tcl.XTcl_VarEval(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp, crt.VaList(bp+8, (*SqliteDb)(unsafe.Pointer(pDb)).FzBusy, ts+4435 /* " " */, bp+40 /* &zVal[0] */, uintptr(0)))
	if (rc != 0) || (crt.Xatoi(tls, tcl.XTcl_GetStringResult(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp)) != 0) {
		return 0
	}
	return 1
}

// This routine is called by the SQLite trace handler whenever a new
// block of SQL is executed.  The TCL script in pDb->zTrace is executed.
func DbTraceHandler(tls *crt.TLS, cd uintptr, zSql uintptr) { /* tclsqlite.c:620:13: */
	bp := tls.Alloc(216)
	defer tls.Free(216)

	var pDb uintptr = cd
	// var str Tcl_DString at bp, 216

	tcl.XTcl_DStringInit(tls, bp /* &str */)
	tcl.XTcl_DStringAppend(tls, bp /* &str */, (*SqliteDb)(unsafe.Pointer(pDb)).FzTrace, -1)
	tcl.XTcl_DStringAppendElement(tls, bp /* &str */, zSql)
	tcl.XTcl_Eval(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp, (*Tcl_DString)(unsafe.Pointer(bp /* &str */)).Fstring)
	tcl.XTcl_DStringFree(tls, bp /* &str */)
	tcl.XTcl_ResetResult(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp)
}

// This routine is called by the SQLite trace_v2 handler whenever a new
// supported event is generated.  Unsupported event types are ignored.
// The TCL script in pDb->zTraceV2 is executed, with the arguments for
// the event appended to it (as list elements).
func DbTraceV2Handler(tls *crt.TLS, type1 uint32, cd uintptr, pd uintptr, xd uintptr) int32 { /* tclsqlite.c:640:12: */
	var pDb uintptr = cd
	var pCmd uintptr

	switch type1 {
	case uint32(0x01):
		{
			var pStmt uintptr = pd
			var zSql uintptr = xd

			pCmd = tcl.XTcl_NewStringObj(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzTraceV2, -1)
			(*Tcl_Obj)(unsafe.Pointer(pCmd)).FrefCount++
			tcl.XTcl_ListObjAppendElement(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp, pCmd,
				tcl.XTcl_NewWideIntObj(tls, int64(pStmt)))
			tcl.XTcl_ListObjAppendElement(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp, pCmd,
				tcl.XTcl_NewStringObj(tls, zSql, -1))
			tcl.XTcl_EvalObjEx(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp, pCmd, 0x040000)
			for ok := true; ok; ok = 0 != 0 {
				var _objPtr uintptr = pCmd
				if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
					tcl.XTclFreeObj(tls, _objPtr)
				}
			}
			tcl.XTcl_ResetResult(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp)
			break
		}
	case uint32(0x02):
		{
			var pStmt uintptr = pd
			var ns sqlite3_int64 = *(*sqlite3_int64)(unsafe.Pointer(xd))

			pCmd = tcl.XTcl_NewStringObj(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzTraceV2, -1)
			(*Tcl_Obj)(unsafe.Pointer(pCmd)).FrefCount++
			tcl.XTcl_ListObjAppendElement(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp, pCmd,
				tcl.XTcl_NewWideIntObj(tls, int64(pStmt)))
			tcl.XTcl_ListObjAppendElement(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp, pCmd,
				tcl.XTcl_NewWideIntObj(tls, Tcl_WideInt(ns)))
			tcl.XTcl_EvalObjEx(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp, pCmd, 0x040000)
			for ok1 := true; ok1; ok1 = 0 != 0 {
				var _objPtr uintptr = pCmd
				if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
					tcl.XTclFreeObj(tls, _objPtr)
				}
			}
			tcl.XTcl_ResetResult(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp)
			break
		}
	case uint32(0x04):
		{
			var pStmt uintptr = pd

			pCmd = tcl.XTcl_NewStringObj(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzTraceV2, -1)
			(*Tcl_Obj)(unsafe.Pointer(pCmd)).FrefCount++
			tcl.XTcl_ListObjAppendElement(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp, pCmd,
				tcl.XTcl_NewWideIntObj(tls, int64(pStmt)))
			tcl.XTcl_EvalObjEx(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp, pCmd, 0x040000)
			for ok2 := true; ok2; ok2 = 0 != 0 {
				var _objPtr uintptr = pCmd
				if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
					tcl.XTclFreeObj(tls, _objPtr)
				}
			}
			tcl.XTcl_ResetResult(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp)
			break
		}
	case uint32(0x08):
		{
			var db uintptr = pd

			pCmd = tcl.XTcl_NewStringObj(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzTraceV2, -1)
			(*Tcl_Obj)(unsafe.Pointer(pCmd)).FrefCount++
			tcl.XTcl_ListObjAppendElement(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp, pCmd,
				tcl.XTcl_NewWideIntObj(tls, int64(db)))
			tcl.XTcl_EvalObjEx(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp, pCmd, 0x040000)
			for ok3 := true; ok3; ok3 = 0 != 0 {
				var _objPtr uintptr = pCmd
				if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
					tcl.XTclFreeObj(tls, _objPtr)
				}
			}
			tcl.XTcl_ResetResult(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp)
			break
		}
	}
	return 0
}

// This routine is called by the SQLite profile handler after a statement
// SQL has executed.  The TCL script in pDb->zProfile is evaluated.
func DbProfileHandler(tls *crt.TLS, cd uintptr, zSql uintptr, tm sqlite_uint64) { /* tclsqlite.c:715:13: */
	bp := tls.Alloc(328)
	defer tls.Free(328)

	var pDb uintptr = cd
	// var str Tcl_DString at bp+112, 216

	// var zTm [100]int8 at bp+8, 100

	sqlite3.Xsqlite3_snprintf(tls, (int32(uint64(unsafe.Sizeof([100]int8{})) - uint64(1))), bp+8 /* &zTm[0] */, ts+17145 /* "%lld" */, crt.VaList(bp, tm))
	tcl.XTcl_DStringInit(tls, bp+112 /* &str */)
	tcl.XTcl_DStringAppend(tls, bp+112 /* &str */, (*SqliteDb)(unsafe.Pointer(pDb)).FzProfile, -1)
	tcl.XTcl_DStringAppendElement(tls, bp+112 /* &str */, zSql)
	tcl.XTcl_DStringAppendElement(tls, bp+112 /* &str */, bp+8 /* &zTm[0] */)
	tcl.XTcl_Eval(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp, (*Tcl_DString)(unsafe.Pointer(bp+112 /* &str */)).Fstring)
	tcl.XTcl_DStringFree(tls, bp+112 /* &str */)
	tcl.XTcl_ResetResult(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp)
}

// This routine is called when a transaction is committed.  The
// TCL script in pDb->zCommit is executed.  If it returns non-zero or
// if it throws an exception, the transaction is rolled back instead
// of being committed.
func DbCommitHandler(tls *crt.TLS, cd uintptr) int32 { /* tclsqlite.c:737:12: */
	var pDb uintptr = cd
	var rc int32

	rc = tcl.XTcl_Eval(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp, (*SqliteDb)(unsafe.Pointer(pDb)).FzCommit)
	if (rc != 0) || (crt.Xatoi(tls, tcl.XTcl_GetStringResult(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp)) != 0) {
		return 1
	}
	return 0
}

func DbRollbackHandler(tls *crt.TLS, clientData uintptr) { /* tclsqlite.c:748:13: */
	var pDb uintptr = clientData
	if !((*SqliteDb)(unsafe.Pointer(pDb)).FpRollbackHook != 0) {
		crt.X__assert_fail(tls, ts+17150 /* "pDb->pRollbackHo..." */, ts+17039 /* "testdata/sqlite-..." */, uint32(750), uintptr(unsafe.Pointer(&__func__93)))
	}
	if 0 != tcl.XTcl_EvalObjEx(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp, (*SqliteDb)(unsafe.Pointer(pDb)).FpRollbackHook, 0) {
		tcl.XTcl_BackgroundError(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp)
	}
}

var __func__93 = *(*[18]int8)(unsafe.Pointer(ts + 17169 /* "DbRollbackHandle..." */)) /* tclsqlite.c:748:48 */

// This procedure handles wal_hook callbacks.
func DbWalHandler(tls *crt.TLS, clientData uintptr, db uintptr, zDb uintptr, nEntry int32) int32 { /* tclsqlite.c:759:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	*(*int32)(unsafe.Pointer(bp /* ret */)) = 0
	var p uintptr
	var pDb uintptr = clientData
	var interp uintptr = (*SqliteDb)(unsafe.Pointer(pDb)).Finterp
	if !((*SqliteDb)(unsafe.Pointer(pDb)).FpWalHook != 0) {
		crt.X__assert_fail(tls, ts+17187 /* "pDb->pWalHook" */, ts+17039 /* "testdata/sqlite-..." */, uint32(769), uintptr(unsafe.Pointer(&__func__94)))
	}

	if !(db == (*SqliteDb)(unsafe.Pointer(pDb)).Fdb) {
		crt.X__assert_fail(tls, ts+17201 /* "db==pDb->db" */, ts+17039 /* "testdata/sqlite-..." */, uint32(771), uintptr(unsafe.Pointer(&__func__94)))
	}
	p = tcl.XTcl_DuplicateObj(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FpWalHook)
	(*Tcl_Obj)(unsafe.Pointer(p)).FrefCount++
	tcl.XTcl_ListObjAppendElement(tls, interp, p, tcl.XTcl_NewStringObj(tls, zDb, -1))
	tcl.XTcl_ListObjAppendElement(tls, interp, p, tcl.XTcl_NewIntObj(tls, nEntry))
	if (0 != tcl.XTcl_EvalObjEx(tls, interp, p, 0)) ||
		(0 != tcl.XTcl_GetIntFromObj(tls, interp, tcl.XTcl_GetObjResult(tls, interp), bp /* &ret */)) {
		tcl.XTcl_BackgroundError(tls, interp)
	}
	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = p
		if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}

	return *(*int32)(unsafe.Pointer(bp /* ret */))
}

var __func__94 = *(*[13]int8)(unsafe.Pointer(ts + 17213 /* "DbWalHandler" */)) /* tclsqlite.c:764:2 */

func setTestUnlockNotifyVars(tls *crt.TLS, interp uintptr, iArg int32, nArg int32) { /* tclsqlite.c:787:13: */
	bp := tls.Alloc(80)
	defer tls.Free(80)

	// var zBuf [64]int8 at bp+16, 64

	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([64]int8{})), bp+16 /* &zBuf[0] */, ts+1647 /* "%d" */, crt.VaList(bp, iArg))
	tcl.XTcl_SetVar2(tls, interp, ts+17226 /* "sqlite_unlock_no..." */, uintptr(0), bp+16 /* &zBuf[0] */, 1)
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([64]int8{})), bp+16 /* &zBuf[0] */, ts+1647 /* "%d" */, crt.VaList(bp+8, nArg))
	tcl.XTcl_SetVar2(tls, interp, ts+17251 /* "sqlite_unlock_no..." */, uintptr(0), bp+16 /* &zBuf[0] */, 1)
}

func DbUnlockNotify(tls *crt.TLS, apArg uintptr, nArg int32) { /* tclsqlite.c:799:13: */
	var i int32
	for i = 0; i < nArg; i++ {
		var flags int32 = (0x020000 | 0x040000)
		var pDb uintptr = *(*uintptr)(unsafe.Pointer(apArg + uintptr(i)*8))
		setTestUnlockNotifyVars(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp, i, nArg)
		if !((*SqliteDb)(unsafe.Pointer(pDb)).FpUnlockNotify != 0) {
			crt.X__assert_fail(tls, ts+17281 /* "pDb->pUnlockNoti..." */, ts+17039 /* "testdata/sqlite-..." */, uint32(805), uintptr(unsafe.Pointer(&__func__95)))
		}
		tcl.XTcl_EvalObjEx(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp, (*SqliteDb)(unsafe.Pointer(pDb)).FpUnlockNotify, flags)
		for ok := true; ok; ok = 0 != 0 {
			var _objPtr uintptr = (*SqliteDb)(unsafe.Pointer(pDb)).FpUnlockNotify
			if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
		(*SqliteDb)(unsafe.Pointer(pDb)).FpUnlockNotify = uintptr(0)
	}
}

var __func__95 = *(*[15]int8)(unsafe.Pointer(ts + 17300 /* "DbUnlockNotify" */)) /* tclsqlite.c:799:51 */

func DbUpdateHandler(tls *crt.TLS, p uintptr, op int32, zDb uintptr, zTbl uintptr, rowid sqlite_int64) { /* tclsqlite.c:849:13: */
	var pDb uintptr = p
	var pCmd uintptr

	if !(((9 - 1) / 9) == 0) {
		crt.X__assert_fail(tls, ts+17315 /* "(9-1)/9 == 0" */, ts+17039 /* "testdata/sqlite-..." */, uint32(860), uintptr(unsafe.Pointer(&__func__96)))
	}
	if !(((18 - 1) / 9) == 1) {
		crt.X__assert_fail(tls, ts+17328 /* "(18-1)/9 == 1" */, ts+17039 /* "testdata/sqlite-..." */, uint32(861), uintptr(unsafe.Pointer(&__func__96)))
	}
	if !(((23 - 1) / 9) == 2) {
		crt.X__assert_fail(tls, ts+17342 /* "(23-1)/9 == 2" */, ts+17039 /* "testdata/sqlite-..." */, uint32(862), uintptr(unsafe.Pointer(&__func__96)))
	}

	if !((*SqliteDb)(unsafe.Pointer(pDb)).FpUpdateHook != 0) {
		crt.X__assert_fail(tls, ts+17356 /* "pDb->pUpdateHook" */, ts+17039 /* "testdata/sqlite-..." */, uint32(864), uintptr(unsafe.Pointer(&__func__96)))
	}
	if !(((op == 18) || (op == 23)) || (op == 9)) {
		crt.X__assert_fail(tls, ts+17373 /* "op==18 || op==23..." */, ts+17039 /* "testdata/sqlite-..." */, uint32(865), uintptr(unsafe.Pointer(&__func__96)))
	}

	pCmd = tcl.XTcl_DuplicateObj(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FpUpdateHook)
	(*Tcl_Obj)(unsafe.Pointer(pCmd)).FrefCount++
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pCmd, tcl.XTcl_NewStringObj(tls, azStr[((op-1)/9)], -1))
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pCmd, tcl.XTcl_NewStringObj(tls, zDb, -1))
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pCmd, tcl.XTcl_NewStringObj(tls, zTbl, -1))
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pCmd, tcl.XTcl_NewWideIntObj(tls, int64(rowid)))
	tcl.XTcl_EvalObjEx(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp, pCmd, 0x040000)
	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = pCmd
		if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
}

var __func__96 = *(*[16]int8)(unsafe.Pointer(ts + 17399 /* "DbUpdateHandler" */))                       /* tclsqlite.c:855:2 */
var azStr = [3]uintptr{ts + 17415 /* "DELETE" */, ts + 17422 /* "INSERT" */, ts + 17429 /* "UPDATE" */} /* tclsqlite.c:858:21 */

func tclCollateNeeded(tls *crt.TLS, pCtx uintptr, db uintptr, enc int32, zName uintptr) { /* tclsqlite.c:877:13: */
	var pDb uintptr = pCtx
	var pScript uintptr = tcl.XTcl_DuplicateObj(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FpCollateNeeded)
	(*Tcl_Obj)(unsafe.Pointer(pScript)).FrefCount++
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pScript, tcl.XTcl_NewStringObj(tls, zName, -1))
	tcl.XTcl_EvalObjEx(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp, pScript, 0)
	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = pScript
		if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
}

// This routine is called to evaluate an SQL collation function implemented
// using TCL script.
func tclSqlCollate(tls *crt.TLS, pCtx uintptr, nA int32, zA uintptr, nB int32, zB uintptr) int32 { /* tclsqlite.c:895:12: */
	var p uintptr = pCtx
	var pCmd uintptr

	pCmd = tcl.XTcl_NewStringObj(tls, (*SqlCollate)(unsafe.Pointer(p)).FzScript, -1)
	(*Tcl_Obj)(unsafe.Pointer(pCmd)).FrefCount++
	tcl.XTcl_ListObjAppendElement(tls, (*SqlCollate)(unsafe.Pointer(p)).Finterp, pCmd, tcl.XTcl_NewStringObj(tls, zA, nA))
	tcl.XTcl_ListObjAppendElement(tls, (*SqlCollate)(unsafe.Pointer(p)).Finterp, pCmd, tcl.XTcl_NewStringObj(tls, zB, nB))
	tcl.XTcl_EvalObjEx(tls, (*SqlCollate)(unsafe.Pointer(p)).Finterp, pCmd, 0x040000)
	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = pCmd
		if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	return crt.Xatoi(tls, tcl.XTcl_GetStringResult(tls, (*SqlCollate)(unsafe.Pointer(p)).Finterp))
}

// This routine is called to evaluate an SQL function implemented
// using TCL script.
func tclSqlFunc(tls *crt.TLS, context uintptr, argc int32, argv uintptr) { /* tclsqlite.c:918:13: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	var p uintptr = sqlite3.Xsqlite3_user_data(tls, context)
	var pCmd uintptr
	var i int32
	var rc int32

	if argc == 0 {
		// If there are no arguments to the function, call Tcl_EvalObjEx on the
		// script object directly.  This allows the TCL compiler to generate
		// bytecode for the command on the first invocation and thus make
		// subsequent invocations much faster.
		pCmd = (*SqlFunc)(unsafe.Pointer(p)).FpScript
		(*Tcl_Obj)(unsafe.Pointer(pCmd)).FrefCount++
		rc = tcl.XTcl_EvalObjEx(tls, (*SqlFunc)(unsafe.Pointer(p)).Finterp, pCmd, 0)
		for ok := true; ok; ok = 0 != 0 {
			var _objPtr uintptr = pCmd
			if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
	} else {
		// If there are arguments to the function, make a shallow copy of the
		// script object, lappend the arguments, then evaluate the copy.
		//
		// By "shallow" copy, we mean only the outer list Tcl_Obj is duplicated.
		// The new Tcl_Obj contains pointers to the original list elements.
		// That way, when Tcl_EvalObjv() is run and shimmers the first element
		// of the list to tclCmdNameType, that alternate representation will
		// be preserved and reused on the next invocation.
		// var aArg uintptr at bp+8, 8

		// var nArg int32 at bp, 4

		if tcl.XTcl_ListObjGetElements(tls, (*SqlFunc)(unsafe.Pointer(p)).Finterp, (*SqlFunc)(unsafe.Pointer(p)).FpScript, bp /* &nArg */, bp+8 /* &aArg */) != 0 {
			sqlite3.Xsqlite3_result_error(tls, context, tcl.XTcl_GetStringResult(tls, (*SqlFunc)(unsafe.Pointer(p)).Finterp), -1)
			return
		}
		pCmd = tcl.XTcl_NewListObj(tls, *(*int32)(unsafe.Pointer(bp /* nArg */)), *(*uintptr)(unsafe.Pointer(bp + 8 /* aArg */)))
		(*Tcl_Obj)(unsafe.Pointer(pCmd)).FrefCount++
		for i = 0; i < argc; i++ {
			var pIn uintptr = *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8))
			var pVal uintptr

			// Set pVal to contain the i'th column of this row.
			switch sqlite3.Xsqlite3_value_type(tls, pIn) {
			case 4:
				{
					var bytes int32 = sqlite3.Xsqlite3_value_bytes(tls, pIn)
					pVal = tcl.XTcl_NewByteArrayObj(tls, sqlite3.Xsqlite3_value_blob(tls, pIn), bytes)
					break
				}
				fallthrough
			case 1:
				{
					var v sqlite_int64 = sqlite3.Xsqlite3_value_int64(tls, pIn)
					if (v >= int64(-2147483647)) && (v <= int64(2147483647)) {
						pVal = tcl.XTcl_NewIntObj(tls, int32(v))
					} else {
						pVal = tcl.XTcl_NewWideIntObj(tls, int64(v))
					}
					break
				}
				fallthrough
			case 2:
				{
					var r float64 = sqlite3.Xsqlite3_value_double(tls, pIn)
					pVal = tcl.XTcl_NewDoubleObj(tls, r)
					break
				}
				fallthrough
			case 5:
				{
					pVal = tcl.XTcl_NewStringObj(tls, (*SqliteDb)(unsafe.Pointer((*SqlFunc)(unsafe.Pointer(p)).FpDb)).FzNull, -1)
					break
				}
				fallthrough
			default:
				{
					var bytes int32 = sqlite3.Xsqlite3_value_bytes(tls, pIn)
					pVal = tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3_value_text(tls, pIn), bytes)
					break
				}
			}
			rc = tcl.XTcl_ListObjAppendElement(tls, (*SqlFunc)(unsafe.Pointer(p)).Finterp, pCmd, pVal)
			if rc != 0 {
				for ok1 := true; ok1; ok1 = 0 != 0 {
					var _objPtr uintptr = pCmd
					if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
						tcl.XTclFreeObj(tls, _objPtr)
					}
				}
				sqlite3.Xsqlite3_result_error(tls, context, tcl.XTcl_GetStringResult(tls, (*SqlFunc)(unsafe.Pointer(p)).Finterp), -1)
				return
			}
		}
		if !((*SqlFunc)(unsafe.Pointer(p)).FuseEvalObjv != 0) {
			// Tcl_EvalObjEx() will automatically call Tcl_EvalObjv() if pCmd
			// is a list without a string representation.  To prevent this from
			// happening, make sure pCmd has a valid string representation
			tcl.XTcl_GetString(tls, pCmd)
		}
		rc = tcl.XTcl_EvalObjEx(tls, (*SqlFunc)(unsafe.Pointer(p)).Finterp, pCmd, 0x040000)
		for ok2 := true; ok2; ok2 = 0 != 0 {
			var _objPtr uintptr = pCmd
			if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
	}

	if (rc != 0) && (rc != 2) {
		sqlite3.Xsqlite3_result_error(tls, context, tcl.XTcl_GetStringResult(tls, (*SqlFunc)(unsafe.Pointer(p)).Finterp), -1)
	} else {
		var pVar uintptr = tcl.XTcl_GetObjResult(tls, (*SqlFunc)(unsafe.Pointer(p)).Finterp)
		// var n int32 at bp+16, 4

		var data uintptr
		var zType uintptr = func() uintptr {
			if (*Tcl_Obj)(unsafe.Pointer(pVar)).FtypePtr != 0 {
				return (*Tcl_ObjType)(unsafe.Pointer((*Tcl_Obj)(unsafe.Pointer(pVar)).FtypePtr)).Fname
			}
			return ts + 792 /* "" */
		}()
		var c int8 = *(*int8)(unsafe.Pointer(zType + uintptr(0)))
		var eType int32 = (*SqlFunc)(unsafe.Pointer(p)).FeType

		if eType == 5 {
			if ((int32(c) == 'b') && (crt.Xstrcmp(tls, zType, ts+17436 /* "bytearray" */) == 0)) && ((*Tcl_Obj)(unsafe.Pointer(pVar)).Fbytes == uintptr(0)) {
				// Only return a BLOB type if the Tcl variable is a bytearray and
				// has no string representation.
				eType = 4
			} else if (((int32(c) == 'b') && (crt.Xstrcmp(tls, zType, ts+17446 /* "boolean" */) == 0)) ||
				((int32(c) == 'w') && (crt.Xstrcmp(tls, zType, ts+17454 /* "wideInt" */) == 0))) ||
				((int32(c) == 'i') && (crt.Xstrcmp(tls, zType, ts+17462 /* "int" */) == 0)) {
				eType = 1
			} else if (int32(c) == 'd') && (crt.Xstrcmp(tls, zType, ts+3376 /* "double" */) == 0) {
				eType = 2
			} else {
				eType = 3
			}
		}

		switch eType {
		case 4:
			{
				data = tcl.XTcl_GetByteArrayFromObj(tls, pVar, bp+16 /* &n */)
				sqlite3.Xsqlite3_result_blob(tls, context, data, *(*int32)(unsafe.Pointer(bp + 16 /* n */)), crt.UintptrFromInt32(-1))
				break
			}
			fallthrough
		case 1:
			{
				// var v Tcl_WideInt at bp+24, 8

				if 0 == tcl.XTcl_GetWideIntFromObj(tls, uintptr(0), pVar, bp+24 /* &v */) {
					sqlite3.Xsqlite3_result_int64(tls, context, int64(*(*Tcl_WideInt)(unsafe.Pointer(bp + 24 /* v */))))
					break
				}
				// fall-through
			}
			fallthrough
		case 2:
			{
				// var r float64 at bp+32, 8

				if 0 == tcl.XTcl_GetDoubleFromObj(tls, uintptr(0), pVar, bp+32 /* &r */) {
					sqlite3.Xsqlite3_result_double(tls, context, *(*float64)(unsafe.Pointer(bp + 32 /* r */)))
					break
				}
				// fall-through
			}
			fallthrough
		default:
			{
				data = tcl.XTcl_GetStringFromObj(tls, pVar, bp+16 /* &n */)
				sqlite3.Xsqlite3_result_text(tls, context, data, *(*int32)(unsafe.Pointer(bp + 16 /* n */)), crt.UintptrFromInt32(-1))
				break
			}
		}
	}
}

// This is the authentication function.  It appends the authentication
// type code and the two arguments to zCmd[] then invokes the result
// on the interpreter.  The reply is examined to determine if the
// authentication fails or succeeds.
func auth_callback(tls *crt.TLS, pArg uintptr, code int32, zArg1 uintptr, zArg2 uintptr, zArg3 uintptr, zArg4 uintptr) int32 { /* tclsqlite.c:1069:12: */
	bp := tls.Alloc(216)
	defer tls.Free(216)

	var zCode uintptr
	// var str Tcl_DString at bp, 216

	var rc int32
	var zReply uintptr
	// EVIDENCE-OF: R-38590-62769 The first parameter to the authorizer
	// callback is a copy of the third parameter to the
	// sqlite3_set_authorizer() interface.
	var pDb uintptr = pArg
	if (*SqliteDb)(unsafe.Pointer(pDb)).FdisableAuth != 0 {
		return 0
	}

	// EVIDENCE-OF: R-56518-44310 The second parameter to the callback is an
	// integer action code that specifies the particular action to be
	// authorized.
	switch code {
	case 0:
		zCode = ts + 17466 /* "SQLITE_COPY" */
		break
	case 1:
		zCode = ts + 17478 /* "SQLITE_CREATE_IN..." */
		break
	case 2:
		zCode = ts + 17498 /* "SQLITE_CREATE_TA..." */
		break
	case 3:
		zCode = ts + 17518 /* "SQLITE_CREATE_TE..." */
		break
	case 4:
		zCode = ts + 17543 /* "SQLITE_CREATE_TE..." */
		break
	case 5:
		zCode = ts + 17568 /* "SQLITE_CREATE_TE..." */
		break
	case 6:
		zCode = ts + 17595 /* "SQLITE_CREATE_TE..." */
		break
	case 7:
		zCode = ts + 17619 /* "SQLITE_CREATE_TR..." */
		break
	case 8:
		zCode = ts + 17641 /* "SQLITE_CREATE_VI..." */
		break
	case 9:
		zCode = ts + 17660 /* "SQLITE_DELETE" */
		break
	case 10:
		zCode = ts + 17674 /* "SQLITE_DROP_INDE..." */
		break
	case 11:
		zCode = ts + 17692 /* "SQLITE_DROP_TABL..." */
		break
	case 12:
		zCode = ts + 17710 /* "SQLITE_DROP_TEMP..." */
		break
	case 13:
		zCode = ts + 17733 /* "SQLITE_DROP_TEMP..." */
		break
	case 14:
		zCode = ts + 17756 /* "SQLITE_DROP_TEMP..." */
		break
	case 15:
		zCode = ts + 17781 /* "SQLITE_DROP_TEMP..." */
		break
	case 16:
		zCode = ts + 17803 /* "SQLITE_DROP_TRIG..." */
		break
	case 17:
		zCode = ts + 17823 /* "SQLITE_DROP_VIEW" */
		break
	case 18:
		zCode = ts + 17840 /* "SQLITE_INSERT" */
		break
	case 19:
		zCode = ts + 17854 /* "SQLITE_PRAGMA" */
		break
	case 20:
		zCode = ts + 17868 /* "SQLITE_READ" */
		break
	case 21:
		zCode = ts + 17880 /* "SQLITE_SELECT" */
		break
	case 22:
		zCode = ts + 17894 /* "SQLITE_TRANSACTI..." */
		break
	case 23:
		zCode = ts + 17913 /* "SQLITE_UPDATE" */
		break
	case 24:
		zCode = ts + 17927 /* "SQLITE_ATTACH" */
		break
	case 25:
		zCode = ts + 17941 /* "SQLITE_DETACH" */
		break
	case 26:
		zCode = ts + 17955 /* "SQLITE_ALTER_TAB..." */
		break
	case 27:
		zCode = ts + 17974 /* "SQLITE_REINDEX" */
		break
	case 28:
		zCode = ts + 17989 /* "SQLITE_ANALYZE" */
		break
	case 29:
		zCode = ts + 18004 /* "SQLITE_CREATE_VT..." */
		break
	case 30:
		zCode = ts + 18025 /* "SQLITE_DROP_VTAB..." */
		break
	case 31:
		zCode = ts + 18044 /* "SQLITE_FUNCTION" */
		break
	case 32:
		zCode = ts + 18060 /* "SQLITE_SAVEPOINT" */
		break
	case 33:
		zCode = ts + 18077 /* "SQLITE_RECURSIVE" */
		break
	default:
		zCode = ts + 18094 /* "????" */
		break
	}
	tcl.XTcl_DStringInit(tls, bp /* &str */)
	tcl.XTcl_DStringAppend(tls, bp /* &str */, (*SqliteDb)(unsafe.Pointer(pDb)).FzAuth, -1)
	tcl.XTcl_DStringAppendElement(tls, bp /* &str */, zCode)
	tcl.XTcl_DStringAppendElement(tls, bp /* &str */, func() uintptr {
		if zArg1 != 0 {
			return zArg1
		}
		return ts + 792 /* "" */
	}())
	tcl.XTcl_DStringAppendElement(tls, bp /* &str */, func() uintptr {
		if zArg2 != 0 {
			return zArg2
		}
		return ts + 792 /* "" */
	}())
	tcl.XTcl_DStringAppendElement(tls, bp /* &str */, func() uintptr {
		if zArg3 != 0 {
			return zArg3
		}
		return ts + 792 /* "" */
	}())
	tcl.XTcl_DStringAppendElement(tls, bp /* &str */, func() uintptr {
		if zArg4 != 0 {
			return zArg4
		}
		return ts + 792 /* "" */
	}())
	rc = tcl.XTcl_GlobalEval(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp, (*Tcl_DString)(unsafe.Pointer(bp /* &str */)).Fstring)
	tcl.XTcl_DStringFree(tls, bp /* &str */)
	if rc == 0 {
		zReply = tcl.XTcl_GetStringResult(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp)
	} else {
		zReply = ts + 18099 /* "SQLITE_DENY" */
	}
	if crt.Xstrcmp(tls, zReply, ts+18111 /* "SQLITE_OK" */) == 0 {
		rc = 0
	} else if crt.Xstrcmp(tls, zReply, ts+18099 /* "SQLITE_DENY" */) == 0 {
		rc = 1
	} else if crt.Xstrcmp(tls, zReply, ts+18121 /* "SQLITE_IGNORE" */) == 0 {
		rc = 2
	} else {
		rc = 999
	}
	return rc
}

// This routine reads a line of text from FILE in, stores
// the text in memory obtained from malloc() and returns a pointer
// to the text.  NULL is returned at end of file, or if malloc()
// fails.
//
// The interface is like "readline" but no command-line editing
// is done.
//
// copied from shell.c from '.import' command
func local_getline(tls *crt.TLS, zPrompt uintptr, in uintptr) uintptr { /* tclsqlite.c:1168:13: */
	var zLine uintptr
	var nLine int32
	var n int32

	nLine = 100
	zLine = crt.Xmalloc(tls, uint64(nLine))
	if zLine == uintptr(0) {
		return uintptr(0)
	}
	n = 0
	for 1 != 0 {
		if (n + 100) > nLine {
			nLine = ((nLine * 2) + 100)
			zLine = crt.Xrealloc(tls, zLine, uint64(nLine))
			if zLine == uintptr(0) {
				return uintptr(0)
			}
		}
		if crt.Xfgets(tls, (zLine+uintptr(n)), (nLine-n), in) == uintptr(0) {
			if n == 0 {
				crt.Xfree(tls, zLine)
				return uintptr(0)
			}
			*(*int8)(unsafe.Pointer(zLine + uintptr(n))) = int8(0)
			break
		}
		for *(*int8)(unsafe.Pointer(zLine + uintptr(n))) != 0 {
			n++
		}
		if (n > 0) && (int32(*(*int8)(unsafe.Pointer(zLine + uintptr((n - 1))))) == '\n') {
			n--
			*(*int8)(unsafe.Pointer(zLine + uintptr(n))) = int8(0)
			break
		}
	}
	zLine = crt.Xrealloc(tls, zLine, (uint64(n + 1)))
	return zLine
}

// This function is part of the implementation of the command:
//
//   $db transaction [-deferred|-immediate|-exclusive] SCRIPT
//
// It is invoked after evaluating the script SCRIPT to commit or rollback
// the transaction or savepoint opened by the [transaction] command.
func DbTransPostCmd(tls *crt.TLS, data uintptr, interp uintptr, result int32) int32 { /* tclsqlite.c:1211:26: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var pDb uintptr = *(*ClientData)(unsafe.Pointer(data + uintptr(0)*8))
	var rc int32 = result
	var zEnd uintptr

	(*SqliteDb)(unsafe.Pointer(pDb)).FnTransaction--
	zEnd = azEnd[(((crt.Bool32(rc == 1)) * 2) + (crt.Bool32((*SqliteDb)(unsafe.Pointer(pDb)).FnTransaction == 0)))]

	(*SqliteDb)(unsafe.Pointer(pDb)).FdisableAuth++
	if sqlite3.Xsqlite3_exec(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, zEnd, uintptr(0), uintptr(0), uintptr(0)) != 0 {
		// This is a tricky scenario to handle. The most likely cause of an
		// error is that the exec() above was an attempt to commit the
		// top-level transaction that returned SQLITE_BUSY. Or, less likely,
		// that an IO-error has occurred. In either case, throw a Tcl exception
		// and try to rollback the transaction.
		//
		// But it could also be that the user executed one or more BEGIN,
		// COMMIT, SAVEPOINT, RELEASE or ROLLBACK commands that are confusing
		// this method's logic. Not clear how this would be best handled.
		if rc != 1 {
			tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, sqlite3.Xsqlite3_errmsg(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb), uintptr(0)))
			rc = 1
		}
		sqlite3.Xsqlite3_exec(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, ts+7303 /* "ROLLBACK" */, uintptr(0), uintptr(0), uintptr(0))
	}
	(*SqliteDb)(unsafe.Pointer(pDb)).FdisableAuth--

	return rc
}

var azEnd = [4]uintptr{
	ts + 18135, /* "RELEASE _tcl_tra..." */ // rc==TCL_ERROR, nTransaction!=0
	ts + 15071, /* "COMMIT" */              // rc!=TCL_ERROR, nTransaction==0
	ts + 18160, /* "ROLLBACK TO _tcl..." */
	ts + 7303,  /* "ROLLBACK" */ // rc==TCL_ERROR, nTransaction==0
} /* tclsqlite.c:1216:21 */

// Unless SQLITE_TEST is defined, this function is a simple wrapper around
// sqlite3_prepare_v2(). If SQLITE_TEST is defined, then it uses either
// sqlite3_prepare_v2() or legacy interface sqlite3_prepare(), depending
// on whether or not the [db_use_legacy_prepare] command has been used to
// configure the connection.
func dbPrepare(tls *crt.TLS, pDb uintptr, zSql uintptr, ppStmt uintptr, pzOut uintptr) int32 { /* tclsqlite.c:1259:12: */
	var prepFlags uint32 = uint32(0)
	if (*SqliteDb)(unsafe.Pointer(pDb)).FbLegacyPrepare != 0 {
		return sqlite3.Xsqlite3_prepare(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, zSql, -1, ppStmt, pzOut)
	}
	// If the statement cache is large, use the SQLITE_PREPARE_PERSISTENT
	// flags, which uses less lookaside memory.  But if the cache is small,
	// omit that flag to make full use of lookaside
	if (*SqliteDb)(unsafe.Pointer(pDb)).FmaxStmt > 5 {
		prepFlags = uint32(0x01)
	}

	return sqlite3.Xsqlite3_prepare_v3(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, zSql, -1, prepFlags, ppStmt, pzOut)
}

// Search the cache for a prepared-statement object that implements the
// first SQL statement in the buffer pointed to by parameter zIn. If
// no such prepared-statement can be found, allocate and prepare a new
// one. In either case, bind the current values of the relevant Tcl
// variables to any $var, :var or @var variables in the statement. Before
// returning, set *ppPreStmt to point to the prepared-statement object.
//
// Output parameter *pzOut is set to point to the next SQL statement in
// buffer zIn, or to the '\0' byte at the end of zIn if there is no
// next statement.
//
// If successful, TCL_OK is returned. Otherwise, TCL_ERROR is returned
// and an error message loaded into interpreter pDb->interp.
func dbPrepareAndBind(tls *crt.TLS, pDb uintptr, zIn uintptr, pzOut uintptr, ppPreStmt uintptr) int32 { /* tclsqlite.c:1294:12: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var zSql uintptr = zIn                                   // Pointer to first SQL statement in zIn
	*(*uintptr)(unsafe.Pointer(bp /* pStmt */)) = uintptr(0) // Prepared statement object
	var pPreStmt uintptr                                     // Pointer to cached statement
	var nSql int32                                           // Length of zSql in bytes
	var nVar int32 = 0                                       // Number of variables in statement
	var iParm int32 = 0                                      // Next free entry in apParm
	var c int8
	var i int32
	var needResultReset int32 = 0 // Need to invoke Tcl_ResetResult()
	var rc int32 = 0              // Value to return
	var interp uintptr = (*SqliteDb)(unsafe.Pointer(pDb)).Finterp

	*(*uintptr)(unsafe.Pointer(ppPreStmt)) = uintptr(0)

	// Trim spaces from the start of zSql and calculate the remaining length.
	for ((((int32(crt.AssignInt8(&c, *(*int8)(unsafe.Pointer(zSql + uintptr(0)))))) == ' ') || (int32(c) == '\t')) || (int32(c) == '\r')) || (int32(c) == '\n') {
		zSql++
	}
	nSql = strlen30(tls, zSql)

	for pPreStmt = (*SqliteDb)(unsafe.Pointer(pDb)).FstmtList; pPreStmt != 0; pPreStmt = (*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FpNext {
		var n int32 = (*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FnSql
		if ((nSql >= n) &&
			(crt.Xmemcmp(tls, (*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FzSql, zSql, uint64(n)) == 0)) &&
			((int32(*(*int8)(unsafe.Pointer(zSql + uintptr(n)))) == 0) || (int32(*(*int8)(unsafe.Pointer(zSql + uintptr((n - 1))))) == ';')) {
			*(*uintptr)(unsafe.Pointer(bp /* pStmt */)) = (*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FpStmt
			*(*uintptr)(unsafe.Pointer(pzOut)) = (zSql + uintptr((*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FnSql))

			// When a prepared statement is found, unlink it from the
			// cache list.  It will later be added back to the beginning
			// of the cache list in order to implement LRU replacement.
			if (*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FpPrev != 0 {
				(*SqlPreparedStmt)(unsafe.Pointer((*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FpPrev)).FpNext = (*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FpNext
			} else {
				(*SqliteDb)(unsafe.Pointer(pDb)).FstmtList = (*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FpNext
			}
			if (*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FpNext != 0 {
				(*SqlPreparedStmt)(unsafe.Pointer((*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FpNext)).FpPrev = (*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FpPrev
			} else {
				(*SqliteDb)(unsafe.Pointer(pDb)).FstmtLast = (*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FpPrev
			}
			(*SqliteDb)(unsafe.Pointer(pDb)).FnStmt--
			nVar = sqlite3.Xsqlite3_bind_parameter_count(tls, *(*uintptr)(unsafe.Pointer(bp /* pStmt */)))
			break
		}
	}

	// If no prepared statement was found. Compile the SQL text. Also allocate
	// a new SqlPreparedStmt structure.
	if pPreStmt == uintptr(0) {
		var nByte int32

		if 0 != dbPrepare(tls, pDb, zSql, bp /* &pStmt */, pzOut) {
			tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3_errmsg(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb), -1))
			return 1
		}
		if *(*uintptr)(unsafe.Pointer(bp /* pStmt */)) == uintptr(0) {
			if 0 != sqlite3.Xsqlite3_errcode(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb) {
				// A compile-time error in the statement.
				tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3_errmsg(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb), -1))
				return 1
			} else {
				// The statement was a no-op.  Continue to the next statement
				// in the SQL string.
				return 0
			}
		}

		if !(pPreStmt == uintptr(0)) {
			crt.X__assert_fail(tls, ts+18216 /* "pPreStmt==0" */, ts+17039 /* "testdata/sqlite-..." */, uint32(1369), uintptr(unsafe.Pointer(&__func__97)))
		}
		nVar = sqlite3.Xsqlite3_bind_parameter_count(tls, *(*uintptr)(unsafe.Pointer(bp /* pStmt */)))
		nByte = (int32(uint64(unsafe.Sizeof(SqlPreparedStmt{})) + (uint64(nVar) * uint64(unsafe.Sizeof(uintptr(0))))))
		pPreStmt = tcl.XTcl_Alloc(tls, uint32(nByte))
		crt.Xmemset(tls, pPreStmt, 0, uint64(nByte))

		(*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FpStmt = *(*uintptr)(unsafe.Pointer(bp /* pStmt */))
		(*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FnSql = (int32((int64(*(*uintptr)(unsafe.Pointer(pzOut))) - int64(zSql)) / 1))
		(*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FzSql = sqlite3.Xsqlite3_sql(tls, *(*uintptr)(unsafe.Pointer(bp /* pStmt */)))
		(*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FapParm = (pPreStmt + uintptr(1)*56)
		if (*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FzSql == uintptr(0) {
			var zCopy uintptr = tcl.XTcl_Alloc(tls, (uint32((*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FnSql + 1)))
			crt.Xmemcpy(tls, zCopy, zSql, uint64((*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FnSql))
			*(*int8)(unsafe.Pointer(zCopy + uintptr((*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FnSql))) = int8(0)
			(*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FzSql = zCopy
		}
	}
	if !(pPreStmt != 0) {
		crt.X__assert_fail(tls, ts+18228 /* "pPreStmt" */, ts+17039 /* "testdata/sqlite-..." */, uint32(1388), uintptr(unsafe.Pointer(&__func__97)))
	}
	if !(strlen30(tls, (*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FzSql) == (*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FnSql) {
		crt.X__assert_fail(tls, ts+18237 /* "strlen30(pPreStm..." */, ts+17039 /* "testdata/sqlite-..." */, uint32(1389), uintptr(unsafe.Pointer(&__func__97)))
	}
	if !(0 == crt.Xmemcmp(tls, (*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FzSql, zSql, uint64((*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FnSql))) {
		crt.X__assert_fail(tls, ts+18278 /* "0==memcmp(pPreSt..." */, ts+17039 /* "testdata/sqlite-..." */, uint32(1390), uintptr(unsafe.Pointer(&__func__97)))
	}

	// Bind values to parameters that begin with $ or :
	for i = 1; i <= nVar; i++ {
		var zVar uintptr = sqlite3.Xsqlite3_bind_parameter_name(tls, *(*uintptr)(unsafe.Pointer(bp /* pStmt */)), i)
		if (zVar != uintptr(0)) && (((int32(*(*int8)(unsafe.Pointer(zVar + uintptr(0)))) == '$') || (int32(*(*int8)(unsafe.Pointer(zVar + uintptr(0)))) == ':')) || (int32(*(*int8)(unsafe.Pointer(zVar + uintptr(0)))) == '@')) {
			var pVar uintptr = tcl.XTcl_GetVar2Ex(tls, interp, (zVar + uintptr(1)), uintptr(0), 0)
			if (pVar == uintptr(0)) && ((*SqliteDb)(unsafe.Pointer(pDb)).FzBindFallback != uintptr(0)) {
				var pCmd uintptr
				var rx int32
				pCmd = tcl.XTcl_NewStringObj(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzBindFallback, -1)
				(*Tcl_Obj)(unsafe.Pointer(pCmd)).FrefCount++
				tcl.XTcl_ListObjAppendElement(tls, interp, pCmd, tcl.XTcl_NewStringObj(tls, zVar, -1))
				if needResultReset != 0 {
					tcl.XTcl_ResetResult(tls, interp)
				}
				needResultReset = 1
				rx = tcl.XTcl_EvalObjEx(tls, interp, pCmd, 0x040000)
				for ok := true; ok; ok = 0 != 0 {
					var _objPtr uintptr = pCmd
					if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
						tcl.XTclFreeObj(tls, _objPtr)
					}
				}
				if rx == 0 {
					pVar = tcl.XTcl_GetObjResult(tls, interp)
				} else if rx == 1 {
					rc = 1
					break
				} else {
					pVar = uintptr(0)
				}
			}
			if pVar != 0 {
				// var n int32 at bp+8, 4

				var data uintptr
				var zType uintptr = func() uintptr {
					if (*Tcl_Obj)(unsafe.Pointer(pVar)).FtypePtr != 0 {
						return (*Tcl_ObjType)(unsafe.Pointer((*Tcl_Obj)(unsafe.Pointer(pVar)).FtypePtr)).Fname
					}
					return ts + 792 /* "" */
				}()
				c = *(*int8)(unsafe.Pointer(zType + uintptr(0)))
				if (int32(*(*int8)(unsafe.Pointer(zVar + uintptr(0)))) == '@') || (((int32(c) == 'b') && (crt.Xstrcmp(tls, zType, ts+17436 /* "bytearray" */) == 0)) && ((*Tcl_Obj)(unsafe.Pointer(pVar)).Fbytes == uintptr(0))) {
					// Load a BLOB type if the Tcl variable is a bytearray and
					// it has no string representation or the host
					// parameter name begins with "@".
					data = tcl.XTcl_GetByteArrayFromObj(tls, pVar, bp+8 /* &n */)
					sqlite3.Xsqlite3_bind_blob(tls, *(*uintptr)(unsafe.Pointer(bp /* pStmt */)), i, data, *(*int32)(unsafe.Pointer(bp + 8 /* n */)), uintptr(0))
					(*Tcl_Obj)(unsafe.Pointer(pVar)).FrefCount++
					*(*uintptr)(unsafe.Pointer((*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FapParm + uintptr(crt.PostIncInt32(&iParm, 1))*8)) = pVar
				} else if (int32(c) == 'b') && (crt.Xstrcmp(tls, zType, ts+17446 /* "boolean" */) == 0) {
					tcl.XTcl_GetIntFromObj(tls, interp, pVar, bp+8 /* &n */)
					sqlite3.Xsqlite3_bind_int(tls, *(*uintptr)(unsafe.Pointer(bp /* pStmt */)), i, *(*int32)(unsafe.Pointer(bp + 8 /* n */)))
				} else if (int32(c) == 'd') && (crt.Xstrcmp(tls, zType, ts+3376 /* "double" */) == 0) {
					// var r float64 at bp+16, 8

					tcl.XTcl_GetDoubleFromObj(tls, interp, pVar, bp+16 /* &r */)
					sqlite3.Xsqlite3_bind_double(tls, *(*uintptr)(unsafe.Pointer(bp /* pStmt */)), i, *(*float64)(unsafe.Pointer(bp + 16 /* r */)))
				} else if ((int32(c) == 'w') && (crt.Xstrcmp(tls, zType, ts+17454 /* "wideInt" */) == 0)) || ((int32(c) == 'i') && (crt.Xstrcmp(tls, zType, ts+17462 /* "int" */) == 0)) {
					// var v Tcl_WideInt at bp+24, 8

					tcl.XTcl_GetWideIntFromObj(tls, interp, pVar, bp+24 /* &v */)
					sqlite3.Xsqlite3_bind_int64(tls, *(*uintptr)(unsafe.Pointer(bp /* pStmt */)), i, int64(*(*Tcl_WideInt)(unsafe.Pointer(bp + 24 /* v */))))
				} else {
					data = tcl.XTcl_GetStringFromObj(tls, pVar, bp+8 /* &n */)
					sqlite3.Xsqlite3_bind_text(tls, *(*uintptr)(unsafe.Pointer(bp /* pStmt */)), i, data, *(*int32)(unsafe.Pointer(bp + 8 /* n */)), uintptr(0))
					(*Tcl_Obj)(unsafe.Pointer(pVar)).FrefCount++
					*(*uintptr)(unsafe.Pointer((*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FapParm + uintptr(crt.PostIncInt32(&iParm, 1))*8)) = pVar
				}
			} else {
				sqlite3.Xsqlite3_bind_null(tls, *(*uintptr)(unsafe.Pointer(bp /* pStmt */)), i)
			}
			if needResultReset != 0 {
				tcl.XTcl_ResetResult(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp)
			}
		}
	}
	(*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FnParm = iParm
	*(*uintptr)(unsafe.Pointer(ppPreStmt)) = pPreStmt
	if (needResultReset != 0) && (rc == 0) {
		tcl.XTcl_ResetResult(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp)
	}

	return rc
}

var __func__97 = *(*[17]int8)(unsafe.Pointer(ts + 18326 /* "dbPrepareAndBind" */)) /* tclsqlite.c:1299:2 */

// Release a statement reference obtained by calling dbPrepareAndBind().
// There should be exactly one call to this function for each call to
// dbPrepareAndBind().
//
// If the discard parameter is non-zero, then the statement is deleted
// immediately. Otherwise it is added to the LRU list and may be returned
// by a subsequent call to dbPrepareAndBind().
func dbReleaseStmt(tls *crt.TLS, pDb uintptr, pPreStmt uintptr, discard int32) { /* tclsqlite.c:1470:13: */
	var i int32

	// Free the bound string and blob parameters
	for i = 0; i < (*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FnParm; i++ {
		for ok := true; ok; ok = 0 != 0 {
			var _objPtr uintptr = *(*uintptr)(unsafe.Pointer((*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FapParm + uintptr(i)*8))
			if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
	}
	(*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FnParm = 0

	if ((*SqliteDb)(unsafe.Pointer(pDb)).FmaxStmt <= 0) || (discard != 0) {
		// If the cache is turned off, deallocated the statement
		dbFreeStmt(tls, pPreStmt)
	} else {
		// Add the prepared statement to the beginning of the cache list.
		(*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FpNext = (*SqliteDb)(unsafe.Pointer(pDb)).FstmtList
		(*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FpPrev = uintptr(0)
		if (*SqliteDb)(unsafe.Pointer(pDb)).FstmtList != 0 {
			(*SqlPreparedStmt)(unsafe.Pointer((*SqliteDb)(unsafe.Pointer(pDb)).FstmtList)).FpPrev = pPreStmt
		}
		(*SqliteDb)(unsafe.Pointer(pDb)).FstmtList = pPreStmt
		if (*SqliteDb)(unsafe.Pointer(pDb)).FstmtLast == uintptr(0) {
			if !((*SqliteDb)(unsafe.Pointer(pDb)).FnStmt == 0) {
				crt.X__assert_fail(tls, ts+18343 /* "pDb->nStmt==0" */, ts+17039 /* "testdata/sqlite-..." */, uint32(1495), uintptr(unsafe.Pointer(&__func__98)))
			}
			(*SqliteDb)(unsafe.Pointer(pDb)).FstmtLast = pPreStmt
		} else {
			if !((*SqliteDb)(unsafe.Pointer(pDb)).FnStmt > 0) {
				crt.X__assert_fail(tls, ts+18357 /* "pDb->nStmt>0" */, ts+17039 /* "testdata/sqlite-..." */, uint32(1498), uintptr(unsafe.Pointer(&__func__98)))
			}
		}
		(*SqliteDb)(unsafe.Pointer(pDb)).FnStmt++

		// If we have too many statement in cache, remove the surplus from
		// the end of the cache list.
		for (*SqliteDb)(unsafe.Pointer(pDb)).FnStmt > (*SqliteDb)(unsafe.Pointer(pDb)).FmaxStmt {
			var pLast uintptr = (*SqliteDb)(unsafe.Pointer(pDb)).FstmtLast
			(*SqliteDb)(unsafe.Pointer(pDb)).FstmtLast = (*SqlPreparedStmt)(unsafe.Pointer(pLast)).FpPrev
			(*SqlPreparedStmt)(unsafe.Pointer((*SqliteDb)(unsafe.Pointer(pDb)).FstmtLast)).FpNext = uintptr(0)
			(*SqliteDb)(unsafe.Pointer(pDb)).FnStmt--
			dbFreeStmt(tls, pLast)
		}
	}
}

var __func__98 = *(*[14]int8)(unsafe.Pointer(ts + 18370 /* "dbReleaseStmt" */)) /* tclsqlite.c:1474:2 */

// Structure used with dbEvalXXX() functions:
//
//   dbEvalInit()
//   dbEvalStep()
//   dbEvalFinalize()
//   dbEvalRowInfo()
//   dbEvalColumnValue()
type DbEvalContext1 = struct {
	FpDb       uintptr
	FpSql      uintptr
	FzSql      uintptr
	FpPreStmt  uintptr
	FnCol      int32
	FevalFlags int32
	FpArray    uintptr
	FapColName uintptr
}

// Structure used with dbEvalXXX() functions:
//
//   dbEvalInit()
//   dbEvalStep()
//   dbEvalFinalize()
//   dbEvalRowInfo()
//   dbEvalColumnValue()
type DbEvalContext = DbEvalContext1 /* tclsqlite.c:1523:30 */

// Release any cache of column names currently held as part of
// the DbEvalContext structure passed as the first argument.
func dbReleaseColumnNames(tls *crt.TLS, p uintptr) { /* tclsqlite.c:1541:13: */
	if (*DbEvalContext)(unsafe.Pointer(p)).FapColName != 0 {
		var i int32
		for i = 0; i < (*DbEvalContext)(unsafe.Pointer(p)).FnCol; i++ {
			for ok := true; ok; ok = 0 != 0 {
				var _objPtr uintptr = *(*uintptr)(unsafe.Pointer((*DbEvalContext)(unsafe.Pointer(p)).FapColName + uintptr(i)*8))
				if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
					tcl.XTclFreeObj(tls, _objPtr)
				}
			}
		}
		tcl.XTcl_Free(tls, (*DbEvalContext)(unsafe.Pointer(p)).FapColName)
		(*DbEvalContext)(unsafe.Pointer(p)).FapColName = uintptr(0)
	}
	(*DbEvalContext)(unsafe.Pointer(p)).FnCol = 0
}

// Initialize a DbEvalContext structure.
//
// If pArray is not NULL, then it contains the name of a Tcl array
// variable. The "*" member of this array is set to a list containing
// the names of the columns returned by the statement as part of each
// call to dbEvalStep(), in order from left to right. e.g. if the names
// of the returned columns are a, b and c, it does the equivalent of the
// tcl command:
//
//     set ${pArray}(*) {a b c}
func dbEvalInit(tls *crt.TLS, p uintptr, pDb uintptr, pSql uintptr, pArray uintptr, evalFlags int32) { /* tclsqlite.c:1565:13: */
	crt.Xmemset(tls, p, 0, uint64(unsafe.Sizeof(DbEvalContext{})))
	(*DbEvalContext)(unsafe.Pointer(p)).FpDb = pDb
	(*DbEvalContext)(unsafe.Pointer(p)).FzSql = tcl.XTcl_GetString(tls, pSql)
	(*DbEvalContext)(unsafe.Pointer(p)).FpSql = pSql
	(*Tcl_Obj)(unsafe.Pointer(pSql)).FrefCount++
	if pArray != 0 {
		(*DbEvalContext)(unsafe.Pointer(p)).FpArray = pArray
		(*Tcl_Obj)(unsafe.Pointer(pArray)).FrefCount++
	}
	(*DbEvalContext)(unsafe.Pointer(p)).FevalFlags = evalFlags
}

// Obtain information about the row that the DbEvalContext passed as the
// first argument currently points to.
func dbEvalRowInfo(tls *crt.TLS, p uintptr, pnCol uintptr, papColName uintptr) { /* tclsqlite.c:1588:13: */
	// Compute column names
	if uintptr(0) == (*DbEvalContext)(unsafe.Pointer(p)).FapColName {
		var pStmt uintptr = (*SqlPreparedStmt)(unsafe.Pointer((*DbEvalContext)(unsafe.Pointer(p)).FpPreStmt)).FpStmt
		var i int32                        // Iterator variable
		var nCol int32                     // Number of columns returned by pStmt
		var apColName uintptr = uintptr(0) // Array of column names

		(*DbEvalContext)(unsafe.Pointer(p)).FnCol = crt.AssignInt32(&nCol, sqlite3.Xsqlite3_column_count(tls, pStmt))
		if (nCol > 0) && ((papColName != 0) || ((*DbEvalContext)(unsafe.Pointer(p)).FpArray != 0)) {
			apColName = tcl.XTcl_Alloc(tls, (uint32(uint64(unsafe.Sizeof(uintptr(0))) * uint64(nCol))))
			for i = 0; i < nCol; i++ {
				*(*uintptr)(unsafe.Pointer(apColName + uintptr(i)*8)) = tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3_column_name(tls, pStmt, i), -1)
				(*Tcl_Obj)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(apColName + uintptr(i)*8)))).FrefCount++
			}
			(*DbEvalContext)(unsafe.Pointer(p)).FapColName = apColName
		}

		// If results are being stored in an array variable, then create
		// the array(*) entry for that array
		if (*DbEvalContext)(unsafe.Pointer(p)).FpArray != 0 {
			var interp uintptr = (*SqliteDb)(unsafe.Pointer((*DbEvalContext)(unsafe.Pointer(p)).FpDb)).Finterp
			var pColList uintptr = tcl.XTcl_NewObj(tls)
			var pStar uintptr = tcl.XTcl_NewStringObj(tls, ts+3237 /* "*" */, -1)

			for i = 0; i < nCol; i++ {
				tcl.XTcl_ListObjAppendElement(tls, interp, pColList, *(*uintptr)(unsafe.Pointer(apColName + uintptr(i)*8)))
			}
			(*Tcl_Obj)(unsafe.Pointer(pStar)).FrefCount++
			tcl.XTcl_ObjSetVar2(tls, interp, (*DbEvalContext)(unsafe.Pointer(p)).FpArray, pStar, pColList, 0)
			for ok := true; ok; ok = 0 != 0 {
				var _objPtr uintptr = pStar
				if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
					tcl.XTclFreeObj(tls, _objPtr)
				}
			}
		}
	}

	if papColName != 0 {
		*(*uintptr)(unsafe.Pointer(papColName)) = (*DbEvalContext)(unsafe.Pointer(p)).FapColName
	}
	if pnCol != 0 {
		*(*int32)(unsafe.Pointer(pnCol)) = (*DbEvalContext)(unsafe.Pointer(p)).FnCol
	}
}

// Return one of TCL_OK, TCL_BREAK or TCL_ERROR. If TCL_ERROR is
// returned, then an error message is stored in the interpreter before
// returning.
//
// A return value of TCL_OK means there is a row of data available. The
// data may be accessed using dbEvalRowInfo() and dbEvalColumnValue(). This
// is analogous to a return of SQLITE_ROW from sqlite3_step(). If TCL_BREAK
// is returned, then the SQL script has finished executing and there are
// no further rows available. This is similar to SQLITE_DONE.
func dbEvalStep(tls *crt.TLS, p uintptr) int32 { /* tclsqlite.c:1646:12: */
	var zPrevSql uintptr = uintptr(0) // Previous value of p->zSql

	for (*(*int8)(unsafe.Pointer((*DbEvalContext)(unsafe.Pointer(p)).FzSql + uintptr(0))) != 0) || ((*DbEvalContext)(unsafe.Pointer(p)).FpPreStmt != 0) {
		var rc int32
		if (*DbEvalContext)(unsafe.Pointer(p)).FpPreStmt == uintptr(0) {
			zPrevSql = func() uintptr {
				if (*DbEvalContext)(unsafe.Pointer(p)).FzSql == zPrevSql {
					return uintptr(0)
				}
				return (*DbEvalContext)(unsafe.Pointer(p)).FzSql
			}()
			rc = dbPrepareAndBind(tls, (*DbEvalContext)(unsafe.Pointer(p)).FpDb, (*DbEvalContext)(unsafe.Pointer(p)).FzSql, (p + 16 /* &.zSql */), (p + 24 /* &.pPreStmt */))
			if rc != 0 {
				return rc
			}
		} else {
			var rcs int32
			var pDb uintptr = (*DbEvalContext)(unsafe.Pointer(p)).FpDb
			var pPreStmt uintptr = (*DbEvalContext)(unsafe.Pointer(p)).FpPreStmt
			var pStmt uintptr = (*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FpStmt

			rcs = sqlite3.Xsqlite3_step(tls, pStmt)
			if rcs == 100 {
				return 0
			}
			if (*DbEvalContext)(unsafe.Pointer(p)).FpArray != 0 {
				dbEvalRowInfo(tls, p, uintptr(0), uintptr(0))
			}
			rcs = sqlite3.Xsqlite3_reset(tls, pStmt)

			(*SqliteDb)(unsafe.Pointer(pDb)).FnStep = sqlite3.Xsqlite3_stmt_status(tls, pStmt, 1, 1)
			(*SqliteDb)(unsafe.Pointer(pDb)).FnSort = sqlite3.Xsqlite3_stmt_status(tls, pStmt, 2, 1)
			(*SqliteDb)(unsafe.Pointer(pDb)).FnIndex = sqlite3.Xsqlite3_stmt_status(tls, pStmt, 3, 1)
			(*SqliteDb)(unsafe.Pointer(pDb)).FnVMStep = sqlite3.Xsqlite3_stmt_status(tls, pStmt, 4, 1)
			dbReleaseColumnNames(tls, p)
			(*DbEvalContext)(unsafe.Pointer(p)).FpPreStmt = uintptr(0)

			if rcs != 0 {
				// If a run-time error occurs, report the error and stop reading
				// the SQL.
				dbReleaseStmt(tls, pDb, pPreStmt, 1)
				if (((*SqliteDb)(unsafe.Pointer((*DbEvalContext)(unsafe.Pointer(p)).FpDb)).FbLegacyPrepare != 0) && (rcs == 17)) && (zPrevSql != 0) {
					// If the runtime error was an SQLITE_SCHEMA, and the database
					// handle is configured to use the legacy sqlite3_prepare()
					// interface, retry prepare()/step() on the same SQL statement.
					// This only happens once. If there is a second SQLITE_SCHEMA
					// error, the error will be returned to the caller.
					(*DbEvalContext)(unsafe.Pointer(p)).FzSql = zPrevSql
					continue
				}
				tcl.XTcl_SetObjResult(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp,
					tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3_errmsg(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb), -1))
				return 1
			} else {
				dbReleaseStmt(tls, pDb, pPreStmt, 0)
			}
		}
	}

	// Finished
	return 3
}

// Free all resources currently held by the DbEvalContext structure passed
// as the first argument. There should be exactly one call to this function
// for each call to dbEvalInit().
func dbEvalFinalize(tls *crt.TLS, p uintptr) { /* tclsqlite.c:1710:13: */
	if (*DbEvalContext)(unsafe.Pointer(p)).FpPreStmt != 0 {
		sqlite3.Xsqlite3_reset(tls, (*SqlPreparedStmt)(unsafe.Pointer((*DbEvalContext)(unsafe.Pointer(p)).FpPreStmt)).FpStmt)
		dbReleaseStmt(tls, (*DbEvalContext)(unsafe.Pointer(p)).FpDb, (*DbEvalContext)(unsafe.Pointer(p)).FpPreStmt, 0)
		(*DbEvalContext)(unsafe.Pointer(p)).FpPreStmt = uintptr(0)
	}
	if (*DbEvalContext)(unsafe.Pointer(p)).FpArray != 0 {
		for ok := true; ok; ok = 0 != 0 {
			var _objPtr uintptr = (*DbEvalContext)(unsafe.Pointer(p)).FpArray
			if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
		(*DbEvalContext)(unsafe.Pointer(p)).FpArray = uintptr(0)
	}
	for ok1 := true; ok1; ok1 = 0 != 0 {
		var _objPtr uintptr = (*DbEvalContext)(unsafe.Pointer(p)).FpSql
		if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	dbReleaseColumnNames(tls, p)
}

// Return a pointer to a Tcl_Obj structure with ref-count 0 that contains
// the value for the iCol'th column of the row currently pointed to by
// the DbEvalContext structure passed as the first argument.
func dbEvalColumnValue(tls *crt.TLS, p uintptr, iCol int32) uintptr { /* tclsqlite.c:1729:16: */
	var pStmt uintptr = (*SqlPreparedStmt)(unsafe.Pointer((*DbEvalContext)(unsafe.Pointer(p)).FpPreStmt)).FpStmt
	switch sqlite3.Xsqlite3_column_type(tls, pStmt, iCol) {
	case 4:
		{
			var bytes int32 = sqlite3.Xsqlite3_column_bytes(tls, pStmt, iCol)
			var zBlob uintptr = sqlite3.Xsqlite3_column_blob(tls, pStmt, iCol)
			if !(zBlob != 0) {
				bytes = 0
			}
			return tcl.XTcl_NewByteArrayObj(tls, zBlob, bytes)
		}
	case 1:
		{
			var v sqlite_int64 = sqlite3.Xsqlite3_column_int64(tls, pStmt, iCol)
			if (v >= int64(-2147483647)) && (v <= int64(2147483647)) {
				return tcl.XTcl_NewIntObj(tls, int32(v))
			} else {
				return tcl.XTcl_NewWideIntObj(tls, int64(v))
			}
		}
		fallthrough
	case 2:
		{
			return tcl.XTcl_NewDoubleObj(tls, sqlite3.Xsqlite3_column_double(tls, pStmt, iCol))
		}
	case 5:
		{
			return tcl.XTcl_NewStringObj(tls, (*SqliteDb)(unsafe.Pointer((*DbEvalContext)(unsafe.Pointer(p)).FpDb)).FzNull, -1)
		}
	}

	return tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3_column_text(tls, pStmt, iCol), -1)
}

// If using Tcl version 8.6 or greater, use the NR functions to avoid
// recursive evalution of scripts by the [db eval] and [db trans]
// commands. Even if the headers used while compiling the extension
// are 8.6 or newer, the code still tests the Tcl version at runtime.
// This allows stubs-enabled builds to be used with older Tcl libraries.
func DbUseNre(tls *crt.TLS) int32 { /* tclsqlite.c:1766:12: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// var major int32 at bp, 4

	// var minor int32 at bp+4, 4

	tcl.XTcl_GetVersion(tls, bp /* &major */, bp+4 /* &minor */, uintptr(0), uintptr(0))
	return (crt.Bool32(((*(*int32)(unsafe.Pointer(bp /* major */)) == 8) && (*(*int32)(unsafe.Pointer(bp + 4 /* minor */)) >= 6)) || (*(*int32)(unsafe.Pointer(bp /* major */)) > 8)))
}

// This function is part of the implementation of the command:
//
//   $db eval SQL ?ARRAYNAME? SCRIPT
func DbEvalNextCmd(tls *crt.TLS, data uintptr, interp uintptr, result int32) int32 { /* tclsqlite.c:1793:26: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var rc int32 = result // Return code

	// The first element of the data[] array is a pointer to a DbEvalContext
	// structure allocated using Tcl_Alloc(). The second element of data[]
	// is a pointer to a Tcl_Obj containing the script to run for each row
	// returned by the queries encapsulated in data[0].
	var p uintptr = *(*ClientData)(unsafe.Pointer(data + uintptr(0)*8))
	var pScript uintptr = *(*ClientData)(unsafe.Pointer(data + uintptr(1)*8))
	var pArray uintptr = (*DbEvalContext)(unsafe.Pointer(p)).FpArray

	for ((rc == 0) || (rc == 4)) && (0 == (crt.AssignInt32(&rc, dbEvalStep(tls, p)))) {
		var i int32
		// var nCol int32 at bp, 4

		// var apColName uintptr at bp+8, 8

		dbEvalRowInfo(tls, p, bp /* &nCol */, bp+8 /* &apColName */)
		for i = 0; i < *(*int32)(unsafe.Pointer(bp /* nCol */)); i++ {
			if pArray == uintptr(0) {
				tcl.XTcl_ObjSetVar2(tls, interp, *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8 /* apColName */)) + uintptr(i)*8)), uintptr(0), dbEvalColumnValue(tls, p, i), 0)
			} else if (((*DbEvalContext)(unsafe.Pointer(p)).FevalFlags & 0x00001) != 0) &&
				(sqlite3.Xsqlite3_column_type(tls, (*SqlPreparedStmt)(unsafe.Pointer((*DbEvalContext)(unsafe.Pointer(p)).FpPreStmt)).FpStmt, i) == 5) {
				tcl.XTcl_UnsetVar2(tls, interp, tcl.XTcl_GetString(tls, pArray),
					tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8 /* apColName */)) + uintptr(i)*8))), 0)
			} else {
				tcl.XTcl_ObjSetVar2(tls, interp, pArray, *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8 /* apColName */)) + uintptr(i)*8)), dbEvalColumnValue(tls, p, i), 0)
			}
		}

		// The required interpreter variables are now populated with the data
		// from the current row. If using NRE, schedule callbacks to evaluate
		// script pScript, then to invoke this function again to fetch the next
		// row (or clean up if there is no next row or the script throws an
		// exception). After scheduling the callbacks, return control to the
		// caller.
		//
		// If not using NRE, evaluate pScript directly and continue with the
		// next iteration of this while(...) loop.
		if DbUseNre(tls) != 0 {
			tcl.XTcl_NRAddCallback(tls, interp, *(*uintptr)(unsafe.Pointer(&struct {
				f func(*crt.TLS, uintptr, uintptr, int32) int32
			}{DbEvalNextCmd})), p, pScript, uintptr(0), uintptr(0))
			return tcl.XTcl_NREvalObj(tls, interp, pScript, 0)
		} else {
			rc = tcl.XTcl_EvalObjEx(tls, interp, pScript, 0)
		}
	}

	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = pScript
		if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	dbEvalFinalize(tls, p)
	tcl.XTcl_Free(tls, p)

	if (rc == 0) || (rc == 3) {
		tcl.XTcl_ResetResult(tls, interp)
		rc = 0
	}
	return rc
}

// This function is used by the implementations of the following database
// handle sub-commands:
//
//   $db update_hook ?SCRIPT?
//   $db wal_hook ?SCRIPT?
//   $db commit_hook ?SCRIPT?
//   $db preupdate hook ?SCRIPT?
func DbHookCmd(tls *crt.TLS, interp uintptr, pDb uintptr, pArg uintptr, ppHook uintptr) { /* tclsqlite.c:1863:13: */
	var db uintptr = (*SqliteDb)(unsafe.Pointer(pDb)).Fdb

	if *(*uintptr)(unsafe.Pointer(ppHook)) != 0 {
		tcl.XTcl_SetObjResult(tls, interp, *(*uintptr)(unsafe.Pointer(ppHook)))
		if pArg != 0 {
			for ok := true; ok; ok = 0 != 0 {
				var _objPtr uintptr = *(*uintptr)(unsafe.Pointer(ppHook))
				if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
					tcl.XTclFreeObj(tls, _objPtr)
				}
			}
			*(*uintptr)(unsafe.Pointer(ppHook)) = uintptr(0)
		}
	}
	if pArg != 0 {
		if !(!(int32(*(*uintptr)(unsafe.Pointer(ppHook))) != 0)) {
			crt.X__assert_fail(tls, ts+18384 /* "!(*ppHook)" */, ts+17039 /* "testdata/sqlite-..." */, uint32(1879), uintptr(unsafe.Pointer(&__func__99)))
		}
		if tcl.XTcl_GetCharLength(tls, pArg) > 0 {
			*(*uintptr)(unsafe.Pointer(ppHook)) = pArg
			(*Tcl_Obj)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(ppHook)))).FrefCount++
		}
	}

	sqlite3.Xsqlite3_update_hook(tls, db, func() uintptr {
		if (*SqliteDb)(unsafe.Pointer(pDb)).FpUpdateHook != 0 {
			return *(*uintptr)(unsafe.Pointer(&struct {
				f func(*crt.TLS, uintptr, int32, uintptr, uintptr, sqlite_int64)
			}{DbUpdateHandler}))
		}
		return uintptr(0)
	}(), pDb)
	sqlite3.Xsqlite3_rollback_hook(tls, db, func() uintptr {
		if (*SqliteDb)(unsafe.Pointer(pDb)).FpRollbackHook != 0 {
			return *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, uintptr) }{DbRollbackHandler}))
		}
		return uintptr(0)
	}(), pDb)
	sqlite3.Xsqlite3_wal_hook(tls, db, func() uintptr {
		if (*SqliteDb)(unsafe.Pointer(pDb)).FpWalHook != 0 {
			return *(*uintptr)(unsafe.Pointer(&struct {
				f func(*crt.TLS, uintptr, uintptr, uintptr, int32) int32
			}{DbWalHandler}))
		}
		return uintptr(0)
	}(), pDb)
}

var __func__99 = *(*[10]int8)(unsafe.Pointer(ts + 18395 /* "DbHookCmd" */)) /* tclsqlite.c:1868:2 */

// The "sqlite" command below creates a new Tcl command for each
// connection it opens to an SQLite database.  This routine is invoked
// whenever one of those connection-specific commands is executed
// in Tcl.  For example, if you run Tcl code like this:
//
//       sqlite3 db1  "my_database"
//       db1 close
//
// The first command opens a connection to the "my_database" database
// and calls that connection "db1".  The second command causes this
// subroutine to be invoked.
func DbObjCmd(tls *crt.TLS, cd uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* tclsqlite.c:1907:26: */
	bp := tls.Alloc(1516)
	defer tls.Free(1516)
	*(*uintptr)(unsafe.Pointer(bp + 1408)) = cd

	var pDb uintptr = *(*uintptr)(unsafe.Pointer(bp + 1408 /* cd */))
	// var choice int32 at bp+992, 4

	var rc int32 = 0
	const ( /* tclsqlite.c:1932:3: */
		DB_AUTHORIZER            = 0
		DB_BACKUP                = 1
		DB_BIND_FALLBACK         = 2
		DB_BUSY                  = 3
		DB_CACHE                 = 4
		DB_CHANGES               = 5
		DB_CLOSE                 = 6
		DB_COLLATE               = 7
		DB_COLLATION_NEEDED      = 8
		DB_COMMIT_HOOK           = 9
		DB_COMPLETE              = 10
		DB_CONFIG                = 11
		DB_COPY                  = 12
		DB_DESERIALIZE           = 13
		DB_ENABLE_LOAD_EXTENSION = 14
		DB_ERRORCODE             = 15
		DB_EVAL                  = 16
		DB_EXISTS                = 17
		DB_FUNCTION              = 18
		DB_INCRBLOB              = 19
		DB_INTERRUPT             = 20
		DB_LAST_INSERT_ROWID     = 21
		DB_NULLVALUE             = 22
		DB_ONECOLUMN             = 23
		DB_PREUPDATE             = 24
		DB_PROFILE               = 25
		DB_PROGRESS              = 26
		DB_REKEY                 = 27
		DB_RESTORE               = 28
		DB_ROLLBACK_HOOK         = 29
		DB_SERIALIZE             = 30
		DB_STATUS                = 31
		DB_TIMEOUT               = 32
		DB_TOTAL_CHANGES         = 33
		DB_TRACE                 = 34
		DB_TRACE_V2              = 35
		DB_TRANSACTION           = 36
		DB_UNLOCK_NOTIFY         = 37
		DB_UPDATE_HOOK           = 38
		DB_VERSION               = 39
		DB_WAL_HOOK              = 40
	)
	// don't leave trailing commas on DB_enum, it confuses the AIX xlc compiler

	if objc < 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+2306 /* "SUBCOMMAND ..." */)
		return 1
	}
	if tcl.XTcl_GetIndexFromObjStruct(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)), uintptr(unsafe.Pointer(&DB_strs)), int32(unsafe.Sizeof(uintptr(0))), ts+18405 /* "option" */, 0, bp+992 /* &choice */) != 0 {
		return 1
	}

	switch uint32(*(*int32)(unsafe.Pointer(bp + 992 /* choice */))) {

	// $db authorizer ?CALLBACK?
	//
	// Invoke the given callback to authorize each SQL operation as it is
	// compiled.  5 arguments are appended to the callback before it is
	// invoked:
	//
	//   (1) The authorization type (ex: SQLITE_CREATE_TABLE, SQLITE_INSERT, ...)
	//   (2) First descriptive name (depends on authorization type)
	//   (3) Second descriptive name
	//   (4) Name of the database (ex: "main", "temp")
	//   (5) Name of trigger that is doing the access
	//
	// The callback should return on of the following strings: SQLITE_OK,
	// SQLITE_IGNORE, or SQLITE_DENY.  Any other return value is an error.
	//
	// If this method is invoked with no arguments, the current authorization
	// callback string is returned.
	case DB_AUTHORIZER:
		{
			if objc > 3 {
				tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+18412 /* "?CALLBACK?" */)
				return 1
			} else if objc == 2 {
				if (*SqliteDb)(unsafe.Pointer(pDb)).FzAuth != 0 {
					tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, (*SqliteDb)(unsafe.Pointer(pDb)).FzAuth, uintptr(0)))
				}
			} else {
				var zAuth uintptr
				// var len int32 at bp+996, 4

				if (*SqliteDb)(unsafe.Pointer(pDb)).FzAuth != 0 {
					tcl.XTcl_Free(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzAuth)
				}
				zAuth = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)), bp+996 /* &len */)
				if (zAuth != 0) && (*(*int32)(unsafe.Pointer(bp + 996 /* len */)) > 0) {
					(*SqliteDb)(unsafe.Pointer(pDb)).FzAuth = tcl.XTcl_Alloc(tls, (uint32(*(*int32)(unsafe.Pointer(bp + 996 /* len */)) + 1)))
					crt.Xmemcpy(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzAuth, zAuth, (uint64(*(*int32)(unsafe.Pointer(bp + 996 /* len */)) + 1)))
				} else {
					(*SqliteDb)(unsafe.Pointer(pDb)).FzAuth = uintptr(0)
				}
				if (*SqliteDb)(unsafe.Pointer(pDb)).FzAuth != 0 {
					(*SqliteDb)(unsafe.Pointer(pDb)).Finterp = interp
					sqlite3.Xsqlite3_set_authorizer(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, *(*uintptr)(unsafe.Pointer(&struct {
						f func(*crt.TLS, uintptr, int32, uintptr, uintptr, uintptr, uintptr) int32
					}{auth_callback})), pDb)
				} else {
					sqlite3.Xsqlite3_set_authorizer(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, uintptr(0), uintptr(0))
				}
			}
			break
		}

	// $db backup ?DATABASE? FILENAME
	//
	// Open or create a database file named FILENAME.  Transfer the
	// content of local database DATABASE (default: "main") into the
	// FILENAME database.
	case DB_BACKUP:
		{
			var zDestFile uintptr
			var zSrcDb uintptr
			// var pDest uintptr at bp+1000, 8

			var pBackup uintptr

			if objc == 3 {
				zSrcDb = ts + 354 /* "main" */
				zDestFile = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)))
			} else if objc == 4 {
				zSrcDb = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)))
				zDestFile = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(3)*8)))
			} else {
				tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+18423 /* "?DATABASE? FILEN..." */)
				return 1
			}
			rc = sqlite3.Xsqlite3_open_v2(tls, zDestFile, bp+1000, /* &pDest */
				((0x00000002 | 0x00000004) | (*SqliteDb)(unsafe.Pointer(pDb)).FopenFlags), uintptr(0))
			if rc != 0 {
				tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+16, ts+18443, /* "cannot open targ..." */
					sqlite3.Xsqlite3_errmsg(tls, *(*uintptr)(unsafe.Pointer(bp + 1000 /* pDest */))), uintptr(0)))
				sqlite3.Xsqlite3_close(tls, *(*uintptr)(unsafe.Pointer(bp + 1000 /* pDest */)))
				return 1
			}
			pBackup = sqlite3.Xsqlite3_backup_init(tls, *(*uintptr)(unsafe.Pointer(bp + 1000 /* pDest */)), ts+354 /* "main" */, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, zSrcDb)
			if pBackup == uintptr(0) {
				tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+40, ts+18473, /* "backup failed: " */
					sqlite3.Xsqlite3_errmsg(tls, *(*uintptr)(unsafe.Pointer(bp + 1000 /* pDest */))), uintptr(0)))
				sqlite3.Xsqlite3_close(tls, *(*uintptr)(unsafe.Pointer(bp + 1000 /* pDest */)))
				return 1
			}
			for (crt.AssignInt32(&rc, sqlite3.Xsqlite3_backup_step(tls, pBackup, 100))) == 0 {
			}
			sqlite3.Xsqlite3_backup_finish(tls, pBackup)
			if rc == 101 {
				rc = 0
			} else {
				tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+64, ts+18473, /* "backup failed: " */
					sqlite3.Xsqlite3_errmsg(tls, *(*uintptr)(unsafe.Pointer(bp + 1000 /* pDest */))), uintptr(0)))
				rc = 1
			}
			sqlite3.Xsqlite3_close(tls, *(*uintptr)(unsafe.Pointer(bp + 1000 /* pDest */)))
			break
		}

	// $db bind_fallback ?CALLBACK?
	//
	// When resolving bind parameters in an SQL statement, if the parameter
	// cannot be associated with a TCL variable then invoke CALLBACK with a
	// single argument that is the name of the parameter and use the return
	// value of the CALLBACK as the binding.  If CALLBACK returns something
	// other than TCL_OK or TCL_ERROR then bind a NULL.
	//
	// If CALLBACK is an empty string, then revert to the default behavior
	// which is to set the binding to NULL.
	//
	// If CALLBACK returns an error, that causes the statement execution to
	// abort.  Hence, to configure a connection so that it throws an error
	// on an attempt to bind an unknown variable, do something like this:
	//
	//     proc bind_error {name} {error "no such variable: $name"}
	//     db bind_fallback bind_error
	case DB_BIND_FALLBACK:
		{
			if objc > 3 {
				tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+18412 /* "?CALLBACK?" */)
				return 1
			} else if objc == 2 {
				if (*SqliteDb)(unsafe.Pointer(pDb)).FzBindFallback != 0 {
					tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+88, (*SqliteDb)(unsafe.Pointer(pDb)).FzBindFallback, uintptr(0)))
				}
			} else {
				var zCallback uintptr
				// var len int32 at bp+1008, 4

				if (*SqliteDb)(unsafe.Pointer(pDb)).FzBindFallback != 0 {
					tcl.XTcl_Free(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzBindFallback)
				}
				zCallback = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)), bp+1008 /* &len */)
				if (zCallback != 0) && (*(*int32)(unsafe.Pointer(bp + 1008 /* len */)) > 0) {
					(*SqliteDb)(unsafe.Pointer(pDb)).FzBindFallback = tcl.XTcl_Alloc(tls, (uint32(*(*int32)(unsafe.Pointer(bp + 1008 /* len */)) + 1)))
					crt.Xmemcpy(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzBindFallback, zCallback, (uint64(*(*int32)(unsafe.Pointer(bp + 1008 /* len */)) + 1)))
				} else {
					(*SqliteDb)(unsafe.Pointer(pDb)).FzBindFallback = uintptr(0)
				}
			}
			break
		}

	// $db busy ?CALLBACK?
	//
	// Invoke the given callback if an SQL statement attempts to open
	// a locked database file.
	case DB_BUSY:
		{
			if objc > 3 {
				tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+18489 /* "CALLBACK" */)
				return 1
			} else if objc == 2 {
				if (*SqliteDb)(unsafe.Pointer(pDb)).FzBusy != 0 {
					tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+104, (*SqliteDb)(unsafe.Pointer(pDb)).FzBusy, uintptr(0)))
				}
			} else {
				var zBusy uintptr
				// var len int32 at bp+1012, 4

				if (*SqliteDb)(unsafe.Pointer(pDb)).FzBusy != 0 {
					tcl.XTcl_Free(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzBusy)
				}
				zBusy = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)), bp+1012 /* &len */)
				if (zBusy != 0) && (*(*int32)(unsafe.Pointer(bp + 1012 /* len */)) > 0) {
					(*SqliteDb)(unsafe.Pointer(pDb)).FzBusy = tcl.XTcl_Alloc(tls, (uint32(*(*int32)(unsafe.Pointer(bp + 1012 /* len */)) + 1)))
					crt.Xmemcpy(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzBusy, zBusy, (uint64(*(*int32)(unsafe.Pointer(bp + 1012 /* len */)) + 1)))
				} else {
					(*SqliteDb)(unsafe.Pointer(pDb)).FzBusy = uintptr(0)
				}
				if (*SqliteDb)(unsafe.Pointer(pDb)).FzBusy != 0 {
					(*SqliteDb)(unsafe.Pointer(pDb)).Finterp = interp
					sqlite3.Xsqlite3_busy_handler(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, *(*uintptr)(unsafe.Pointer(&struct {
						f func(*crt.TLS, uintptr, int32) int32
					}{DbBusyHandler})), pDb)
				} else {
					sqlite3.Xsqlite3_busy_handler(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, uintptr(0), uintptr(0))
				}
			}
			break
		}

	// $db cache flush
	//     $db cache size n
	//
	// Flush the prepared statement cache, or set the maximum number of
	// cached statements.
	case DB_CACHE:
		{
			var subCmd uintptr
			// var n int32 at bp+1016, 4

			if objc <= 2 {
				tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+18498 /* "cache option ?ar..." */)
				return 1
			}
			subCmd = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)), uintptr(0))
			if (int32(*(*int8)(unsafe.Pointer(subCmd))) == 'f') && (crt.Xstrcmp(tls, subCmd, ts+18517 /* "flush" */) == 0) {
				if objc != 3 {
					tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+18517 /* "flush" */)
					return 1
				} else {
					flushStmtCache(tls, pDb)
				}
			} else if (int32(*(*int8)(unsafe.Pointer(subCmd))) == 's') && (crt.Xstrcmp(tls, subCmd, ts+18523 /* "size" */) == 0) {
				if objc != 4 {
					tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+18528 /* "size n" */)
					return 1
				} else {
					if 1 == tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(3)*8)), bp+1016 /* &n */) {
						tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+120, ts+18535, /* "cannot convert \"" */
							tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(3)*8)), uintptr(0)), ts+18552 /* "\" to integer" */, uintptr(0)))
						return 1
					} else {
						if *(*int32)(unsafe.Pointer(bp + 1016 /* n */)) < 0 {
							flushStmtCache(tls, pDb)
							*(*int32)(unsafe.Pointer(bp + 1016 /* n */)) = 0
						} else if *(*int32)(unsafe.Pointer(bp + 1016 /* n */)) > 100 {
							*(*int32)(unsafe.Pointer(bp + 1016 /* n */)) = 100
						}
						(*SqliteDb)(unsafe.Pointer(pDb)).FmaxStmt = *(*int32)(unsafe.Pointer(bp + 1016 /* n */))
					}
				}
			} else {
				tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+152, ts+18565, /* "bad option \"" */
					tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)), uintptr(0)), ts+18578, /* "\": must be flush..." */
					uintptr(0)))
				return 1
			}
			break
		}

	// $db changes
	//
	// Return the number of rows that were modified, inserted, or deleted by
	// the most recent INSERT, UPDATE or DELETE statement, not including
	// any changes made by trigger programs.
	case DB_CHANGES:
		{
			var pResult uintptr
			if objc != 2 {
				tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+792 /* "" */)
				return 1
			}
			pResult = tcl.XTcl_GetObjResult(tls, interp)
			tcl.XTcl_SetIntObj(tls, pResult, sqlite3.Xsqlite3_changes(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb))
			break
		}

	// $db close
	//
	// Shutdown the database
	case DB_CLOSE:
		{
			tcl.XTcl_DeleteCommand(tls, interp, tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(0)*8)), uintptr(0)))
			break
		}

	//     $db collate NAME SCRIPT
	//
	// Create a new SQL collation function called NAME.  Whenever
	// that function is called, invoke SCRIPT to evaluate the function.
	case DB_COLLATE:
		{
			var pCollate uintptr
			var zName uintptr
			var zScript uintptr
			// var nScript int32 at bp+1020, 4

			if objc != 4 {
				tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+18603 /* "NAME SCRIPT" */)
				return 1
			}
			zName = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)), uintptr(0))
			zScript = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(3)*8)), bp+1020 /* &nScript */)
			pCollate = tcl.XTcl_Alloc(tls, (uint32((uint64(unsafe.Sizeof(SqlCollate{})) + uint64(*(*int32)(unsafe.Pointer(bp + 1020 /* nScript */)))) + uint64(1))))
			if pCollate == uintptr(0) {
				return 1
			}
			(*SqlCollate)(unsafe.Pointer(pCollate)).Finterp = interp
			(*SqlCollate)(unsafe.Pointer(pCollate)).FpNext = (*SqliteDb)(unsafe.Pointer(pDb)).FpCollate
			(*SqlCollate)(unsafe.Pointer(pCollate)).FzScript = (pCollate + uintptr(1)*24)
			(*SqliteDb)(unsafe.Pointer(pDb)).FpCollate = pCollate
			crt.Xmemcpy(tls, (*SqlCollate)(unsafe.Pointer(pCollate)).FzScript, zScript, (uint64(*(*int32)(unsafe.Pointer(bp + 1020 /* nScript */)) + 1)))
			if sqlite3.Xsqlite3_create_collation(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, zName, 1,
				pCollate, *(*uintptr)(unsafe.Pointer(&struct {
					f func(*crt.TLS, uintptr, int32, uintptr, int32, uintptr) int32
				}{tclSqlCollate}))) != 0 {
				tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3_errmsg(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb), uintptr(1))
				return 1
			}
			break
		}

	//     $db collation_needed SCRIPT
	//
	// Create a new SQL collation function called NAME.  Whenever
	// that function is called, invoke SCRIPT to evaluate the function.
	case DB_COLLATION_NEEDED:
		{
			if objc != 3 {
				tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+18615 /* "SCRIPT" */)
				return 1
			}
			if (*SqliteDb)(unsafe.Pointer(pDb)).FpCollateNeeded != 0 {
				for ok := true; ok; ok = 0 != 0 {
					var _objPtr uintptr = (*SqliteDb)(unsafe.Pointer(pDb)).FpCollateNeeded
					if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
						tcl.XTclFreeObj(tls, _objPtr)
					}
				}
			}
			(*SqliteDb)(unsafe.Pointer(pDb)).FpCollateNeeded = tcl.XTcl_DuplicateObj(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)))
			(*Tcl_Obj)(unsafe.Pointer((*SqliteDb)(unsafe.Pointer(pDb)).FpCollateNeeded)).FrefCount++
			sqlite3.Xsqlite3_collation_needed(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, pDb, *(*uintptr)(unsafe.Pointer(&struct {
				f func(*crt.TLS, uintptr, uintptr, int32, uintptr)
			}{tclCollateNeeded})))
			break
		}

	// $db commit_hook ?CALLBACK?
	//
	// Invoke the given callback just before committing every SQL transaction.
	// If the callback throws an exception or returns non-zero, then the
	// transaction is aborted.  If CALLBACK is an empty string, the callback
	// is disabled.
	case DB_COMMIT_HOOK:
		{
			if objc > 3 {
				tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+18412 /* "?CALLBACK?" */)
				return 1
			} else if objc == 2 {
				if (*SqliteDb)(unsafe.Pointer(pDb)).FzCommit != 0 {
					tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+184, (*SqliteDb)(unsafe.Pointer(pDb)).FzCommit, uintptr(0)))
				}
			} else {
				var zCommit uintptr
				// var len int32 at bp+1024, 4

				if (*SqliteDb)(unsafe.Pointer(pDb)).FzCommit != 0 {
					tcl.XTcl_Free(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzCommit)
				}
				zCommit = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)), bp+1024 /* &len */)
				if (zCommit != 0) && (*(*int32)(unsafe.Pointer(bp + 1024 /* len */)) > 0) {
					(*SqliteDb)(unsafe.Pointer(pDb)).FzCommit = tcl.XTcl_Alloc(tls, (uint32(*(*int32)(unsafe.Pointer(bp + 1024 /* len */)) + 1)))
					crt.Xmemcpy(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzCommit, zCommit, (uint64(*(*int32)(unsafe.Pointer(bp + 1024 /* len */)) + 1)))
				} else {
					(*SqliteDb)(unsafe.Pointer(pDb)).FzCommit = uintptr(0)
				}
				if (*SqliteDb)(unsafe.Pointer(pDb)).FzCommit != 0 {
					(*SqliteDb)(unsafe.Pointer(pDb)).Finterp = interp
					sqlite3.Xsqlite3_commit_hook(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, uintptr) int32 }{DbCommitHandler})), pDb)
				} else {
					sqlite3.Xsqlite3_commit_hook(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, uintptr(0), uintptr(0))
				}
			}
			break
		}

	// $db complete SQL
	//
	// Return TRUE if SQL is a complete SQL statement.  Return FALSE if
	// additional lines of input are needed.  This is similar to the
	// built-in "info complete" command of Tcl.
	case DB_COMPLETE:
		{
			var pResult uintptr
			var isComplete int32
			if objc != 3 {
				tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+16552 /* "SQL" */)
				return 1
			}
			isComplete = sqlite3.Xsqlite3_complete(tls, tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)), uintptr(0)))
			pResult = tcl.XTcl_GetObjResult(tls, interp)
			tcl.XTcl_SetIntObj(tls, pResult, (crt.Bool32((isComplete) != 0)))
			break
		}

	// $db config ?OPTION? ?BOOLEAN?
	//
	// Configure the database connection using the sqlite3_db_config()
	// interface.
	case DB_CONFIG:
		{
			var pResult uintptr
			var ii int32
			if objc > 4 {
				tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+18622 /* "?OPTION? ?BOOLEA..." */)
				return 1
			}
			if objc == 2 {
				// With no arguments, list all configuration options and with the
				// current value
				pResult = tcl.XTcl_NewListObj(tls, 0, uintptr(0))
				for ii = 0; uint64(ii) < (uint64(unsafe.Sizeof(aDbConfig)) / uint64(unsafe.Sizeof(DbConfigChoices{}))); ii++ {
					*(*int32)(unsafe.Pointer(bp + 1028 /* v */)) = 0
					sqlite3.Xsqlite3_db_config(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, aDbConfig[ii].Fop, crt.VaList(bp+200, -1, bp+1028 /* &v */))
					tcl.XTcl_ListObjAppendElement(tls, interp, pResult,
						tcl.XTcl_NewStringObj(tls, aDbConfig[ii].FzName, -1))
					tcl.XTcl_ListObjAppendElement(tls, interp, pResult,
						tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 1028 /* v */))))
				}
			} else {
				var zOpt uintptr = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)))
				*(*int32)(unsafe.Pointer(bp + 1032 /* onoff */)) = -1
				*(*int32)(unsafe.Pointer(bp + 1036 /* v */)) = 0
				if int32(*(*int8)(unsafe.Pointer(zOpt + uintptr(0)))) == '-' {
					zOpt++
				}
				for ii = 0; uint64(ii) < (uint64(unsafe.Sizeof(aDbConfig)) / uint64(unsafe.Sizeof(DbConfigChoices{}))); ii++ {
					if crt.Xstrcmp(tls, aDbConfig[ii].FzName, zOpt) == 0 {
						break
					}
				}
				if uint64(ii) >= (uint64(unsafe.Sizeof(aDbConfig)) / uint64(unsafe.Sizeof(DbConfigChoices{}))) {
					tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+216, ts+18641 /* "unknown config o..." */, zOpt,
						ts+18666 /* "\"" */, uintptr(0)))
					return 1
				}
				if objc == 4 {
					if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(3)*8)), bp+1032 /* &onoff */) != 0 {
						return 1
					}
				}
				sqlite3.Xsqlite3_db_config(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, aDbConfig[ii].Fop, crt.VaList(bp+248, *(*int32)(unsafe.Pointer(bp + 1032 /* onoff */)), bp+1036 /* &v */))
				pResult = tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 1036 /* v */)))
			}
			tcl.XTcl_SetObjResult(tls, interp, pResult)
			break
		}

	// $db copy conflict-algorithm table filename ?SEPARATOR? ?NULLINDICATOR?
	//
	// Copy data into table from filename, optionally using SEPARATOR
	// as column separators.  If a column contains a null string, or the
	// value of NULLINDICATOR, a NULL is inserted for the column.
	// conflict-algorithm is one of the sqlite conflict algorithms:
	//    rollback, abort, fail, ignore, replace
	// On success, return the number of lines processed, not necessarily same
	// as 'db changes' due to conflict-algorithm selected.
	//
	// This code is basically an implementation/enhancement of
	// the sqlite3 shell.c ".import" command.
	//
	// This command usage is equivalent to the sqlite2.x COPY statement,
	// which imports file data into a table using the PostgreSQL COPY file format:
	//   $db copy $conflit_algo $table_name $filename \t \\N
	case DB_COPY:
		{
			var zTable uintptr    // Insert data into this table
			var zFile uintptr     // The file from which to extract data
			var zConflict uintptr // The conflict algorithm to use
			// var pStmt uintptr at bp+1040, 8
			// A statement
			var nCol int32  // Number of columns in the table
			var nByte int32 // Number of bytes in an SQL string
			var i int32
			var j int32          // Loop counters
			var nSep int32       // Number of bytes in zSep[]
			var nNull int32      // Number of bytes in zNull[]
			var zSql uintptr     // An SQL statement
			var zLine uintptr    // A single line of input from the file
			var azCol uintptr    // zLine[] broken up into columns
			var zCommit uintptr  // How to commit changes
			var in uintptr       // The input file
			var lineno int32 = 0 // Line number of input file
			// var zLineNum [80]int8 at bp+1048, 80
			// Line number print buffer
			var pResult uintptr // interp result

			var zSep uintptr
			var zNull uintptr
			if (objc < 5) || (objc > 7) {
				tcl.XTcl_WrongNumArgs(tls, interp, 2, objv,
					ts+18668 /* "CONFLICT-ALGORIT..." */)
				return 1
			}
			if objc >= 6 {
				zSep = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(5)*8)), uintptr(0))
			} else {
				zSep = ts + 18730 /* "\t" */
			}
			if objc >= 7 {
				zNull = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(6)*8)), uintptr(0))
			} else {
				zNull = ts + 792 /* "" */
			}
			zConflict = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)), uintptr(0))
			zTable = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(3)*8)), uintptr(0))
			zFile = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(4)*8)), uintptr(0))
			nSep = strlen30(tls, zSep)
			nNull = strlen30(tls, zNull)
			if nSep == 0 {
				tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+264, ts+18732, /* "Error: non-null ..." */
					uintptr(0)))
				return 1
			}
			if ((((crt.Xstrcmp(tls, zConflict, ts+18776 /* "rollback" */) != 0) && (crt.Xstrcmp(tls, zConflict, ts+18785 /* "abort" */) != 0)) && (crt.Xstrcmp(tls, zConflict, ts+18791 /* "fail" */) != 0)) && (crt.Xstrcmp(tls, zConflict, ts+18796 /* "ignore" */) != 0)) && (crt.Xstrcmp(tls, zConflict, ts+18803 /* "replace" */) != 0) {
				tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+280, ts+18811 /* "Error: \"" */, zConflict,

					ts+18820 /* "\", conflict-algo..." */, uintptr(0)))
				return 1
			}
			zSql = sqlite3.Xsqlite3_mprintf(tls, ts+10713 /* "SELECT * FROM '%..." */, crt.VaList(bp+312, zTable))
			if zSql == uintptr(0) {
				tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+320, ts+18900 /* "Error: no such t..." */, zTable, uintptr(0)))
				return 1
			}
			nByte = strlen30(tls, zSql)
			rc = sqlite3.Xsqlite3_prepare(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, zSql, -1, bp+1040 /* &pStmt */, uintptr(0))
			sqlite3.Xsqlite3_free(tls, zSql)
			if rc != 0 {
				tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+344, ts+18923 /* "Error: " */, sqlite3.Xsqlite3_errmsg(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb), uintptr(0)))
				nCol = 0
			} else {
				nCol = sqlite3.Xsqlite3_column_count(tls, *(*uintptr)(unsafe.Pointer(bp + 1040 /* pStmt */)))
			}
			sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 1040 /* pStmt */)))
			if nCol == 0 {
				return 1
			}
			zSql = crt.Xmalloc(tls, (uint64((nByte + 50) + (nCol * 2))))
			if zSql == uintptr(0) {
				tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+368, ts+18931 /* "Error: can't mal..." */, uintptr(0)))
				return 1
			}
			sqlite3.Xsqlite3_snprintf(tls, (nByte + 50), zSql, ts+18953, /* "INSERT OR %q INT..." */
				crt.VaList(bp+384, zConflict, zTable))
			j = strlen30(tls, zSql)
			for i = 1; i < nCol; i++ {
				*(*int8)(unsafe.Pointer(zSql + uintptr(crt.PostIncInt32(&j, 1)))) = int8(',')
				*(*int8)(unsafe.Pointer(zSql + uintptr(crt.PostIncInt32(&j, 1)))) = int8('?')
			}
			*(*int8)(unsafe.Pointer(zSql + uintptr(crt.PostIncInt32(&j, 1)))) = int8(')')
			*(*int8)(unsafe.Pointer(zSql + uintptr(j))) = int8(0)
			rc = sqlite3.Xsqlite3_prepare(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, zSql, -1, bp+1040 /* &pStmt */, uintptr(0))
			crt.Xfree(tls, zSql)
			if rc != 0 {
				tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+400, ts+18923 /* "Error: " */, sqlite3.Xsqlite3_errmsg(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb), uintptr(0)))
				sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 1040 /* pStmt */)))
				return 1
			}
			in = crt.Xfopen(tls, zFile, ts+3756 /* "rb" */)
			if in == uintptr(0) {
				tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+424, ts+18985 /* "Error: cannot op..." */, zFile, uintptr(0)))
				sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 1040 /* pStmt */)))
				return 1
			}
			azCol = crt.Xmalloc(tls, (uint64(unsafe.Sizeof(uintptr(0))) * (uint64(nCol + 1))))
			if azCol == uintptr(0) {
				tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+448, ts+18931 /* "Error: can't mal..." */, uintptr(0)))
				crt.Xfclose(tls, in)
				return 1
			}
			sqlite3.Xsqlite3_exec(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, ts+15574 /* "BEGIN" */, uintptr(0), uintptr(0), uintptr(0))
			zCommit = ts + 15071 /* "COMMIT" */
			for (crt.AssignUintptr(&zLine, local_getline(tls, uintptr(0), in))) != uintptr(0) {
				var z uintptr
				lineno++
				*(*uintptr)(unsafe.Pointer(azCol + uintptr(0)*8)) = zLine
				i = 0
				z = zLine
				for ; *(*int8)(unsafe.Pointer(z)) != 0; z++ {
					if (int32(*(*int8)(unsafe.Pointer(z))) == int32(*(*int8)(unsafe.Pointer(zSep + uintptr(0))))) && (crt.Xstrncmp(tls, z, zSep, uint64(nSep)) == 0) {
						*(*int8)(unsafe.Pointer(z)) = int8(0)
						i++
						if i < nCol {
							*(*uintptr)(unsafe.Pointer(azCol + uintptr(i)*8)) = (z + uintptr(nSep))
							z += (uintptr(nSep - 1))
						}
					}
				}
				if (i + 1) != nCol {
					var zErr uintptr
					var nErr int32 = (strlen30(tls, zFile) + 200)
					zErr = crt.Xmalloc(tls, uint64(nErr))
					if zErr != 0 {
						sqlite3.Xsqlite3_snprintf(tls, nErr, zErr,
							ts+19011, /* "Error: %s line %..." */
							crt.VaList(bp+464, zFile, lineno, nCol, (i+1)))
						tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+496, zErr, uintptr(0)))
						crt.Xfree(tls, zErr)
					}
					zCommit = ts + 7303 /* "ROLLBACK" */
					break
				}
				for i = 0; i < nCol; i++ {
					// check for null data, if so, bind as null
					if ((nNull > 0) && (crt.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(azCol + uintptr(i)*8)), zNull) == 0)) ||
						(strlen30(tls, *(*uintptr)(unsafe.Pointer(azCol + uintptr(i)*8))) == 0) {
						sqlite3.Xsqlite3_bind_null(tls, *(*uintptr)(unsafe.Pointer(bp + 1040 /* pStmt */)), (i + 1))
					} else {
						sqlite3.Xsqlite3_bind_text(tls, *(*uintptr)(unsafe.Pointer(bp + 1040 /* pStmt */)), (i + 1), *(*uintptr)(unsafe.Pointer(azCol + uintptr(i)*8)), -1, uintptr(0))
					}
				}
				sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 1040 /* pStmt */)))
				rc = sqlite3.Xsqlite3_reset(tls, *(*uintptr)(unsafe.Pointer(bp + 1040 /* pStmt */)))
				crt.Xfree(tls, zLine)
				if rc != 0 {
					tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+512, ts+18923 /* "Error: " */, sqlite3.Xsqlite3_errmsg(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb), uintptr(0)))
					zCommit = ts + 7303 /* "ROLLBACK" */
					break
				}
			}
			crt.Xfree(tls, azCol)
			crt.Xfclose(tls, in)
			sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 1040 /* pStmt */)))
			sqlite3.Xsqlite3_exec(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, zCommit, uintptr(0), uintptr(0), uintptr(0))

			if int32(*(*int8)(unsafe.Pointer(zCommit + uintptr(0)))) == 'C' {
				// success, set result as number of lines processed
				pResult = tcl.XTcl_GetObjResult(tls, interp)
				tcl.XTcl_SetIntObj(tls, pResult, lineno)
				rc = 0
			} else {
				// failure, append lineno where failed
				sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([80]int8{})), bp+1048 /* &zLineNum[0] */, ts+1647 /* "%d" */, crt.VaList(bp+536, lineno))
				tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+544, ts+19071 /* ", failed while p..." */, bp+1048, /* &zLineNum[0] */
					uintptr(0)))
				rc = 1
			}
			break
		}

	//     $db deserialize ?-maxsize N? ?-readonly BOOL? ?DATABASE? VALUE
	//
	// Reopen DATABASE (default "main") using the content in $VALUE
	case DB_DESERIALIZE:
		{
			tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+568, ts+19104, /* "MEMDB not availa..." */
				uintptr(0)))
			rc = 1
			break
		}

	//    $db enable_load_extension BOOLEAN
	//
	// Turn the extension loading feature on or off.  It if off by
	// default.
	case DB_ENABLE_LOAD_EXTENSION:
		{
			tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+584, ts+19138, /* "extension loadin..." */
				uintptr(0)))
			return 1
		}

	//    $db errorcode
	//
	// Return the numeric error code that was returned by the most recent
	// call to sqlite3_exec().
	case DB_ERRORCODE:
		{
			tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, sqlite3.Xsqlite3_errcode(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb)))
			break
		}

	//    $db exists $sql
	//    $db onecolumn $sql
	//
	// The onecolumn method is the equivalent of:
	//     lindex [$db eval $sql] 0
	case DB_EXISTS:
		fallthrough
	case DB_ONECOLUMN:
		{
			var pResult uintptr = uintptr(0)
			// var sEval DbEvalContext at bp+1128, 56

			if objc != 3 {
				tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+16552 /* "SQL" */)
				return 1
			}

			dbEvalInit(tls, bp+1128 /* &sEval */, pDb, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)), uintptr(0), 0)
			rc = dbEvalStep(tls, bp+1128 /* &sEval */)
			if *(*int32)(unsafe.Pointer(bp + 992 /* choice */)) == DB_ONECOLUMN {
				if rc == 0 {
					pResult = dbEvalColumnValue(tls, bp+1128 /* &sEval */, 0)
				} else if rc == 3 {
					tcl.XTcl_ResetResult(tls, interp)
				}
			} else if (rc == 3) || (rc == 0) {
				pResult = tcl.XTcl_NewIntObj(tls, (crt.Bool32((crt.Bool32(rc == 0)) != 0)))
			}
			dbEvalFinalize(tls, bp+1128 /* &sEval */)
			if pResult != 0 {
				tcl.XTcl_SetObjResult(tls, interp, pResult)
			}

			if rc == 3 {
				rc = 0
			}
			break
		}

	//    $db eval ?options? $sql ?array? ?{  ...code... }?
	//
	// The SQL statement in $sql is evaluated.  For each row, the values are
	// placed in elements of the array named "array" and ...code... is executed.
	// If "array" and "code" are omitted, then no callback is every invoked.
	// If "array" is an empty string, then the values are placed in variables
	// that have the same name as the fields extracted by the query.
	case DB_EVAL:
		{
			var evalFlags int32 = 0
			var zOpt uintptr
			for ((objc > 3) && ((crt.AssignUintptr(&zOpt, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8))))) != uintptr(0))) && (int32(*(*int8)(unsafe.Pointer(zOpt + uintptr(0)))) == '-') {
				if crt.Xstrcmp(tls, zOpt, ts+19186 /* "-withoutnulls" */) == 0 {
					evalFlags = evalFlags | (0x00001)
				} else {
					tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+600, ts+19200 /* "unknown option: ..." */, zOpt, ts+18666 /* "\"" */, uintptr(0)))
					return 1
				}
				objc--
				objv += 8
			}
			if (objc < 3) || (objc > 5) {
				tcl.XTcl_WrongNumArgs(tls, interp, 2, objv,
					ts+19218 /* "?OPTIONS? SQL ?A..." */)
				return 1
			}

			if objc == 3 {
				// var sEval DbEvalContext at bp+1184, 56

				var pRet uintptr = tcl.XTcl_NewObj(tls)
				(*Tcl_Obj)(unsafe.Pointer(pRet)).FrefCount++
				dbEvalInit(tls, bp+1184 /* &sEval */, pDb, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)), uintptr(0), 0)
				for 0 == (crt.AssignInt32(&rc, dbEvalStep(tls, bp+1184 /* &sEval */))) {
					var i int32
					// var nCol int32 at bp+1240, 4

					dbEvalRowInfo(tls, bp+1184 /* &sEval */, bp+1240 /* &nCol */, uintptr(0))
					for i = 0; i < *(*int32)(unsafe.Pointer(bp + 1240 /* nCol */)); i++ {
						tcl.XTcl_ListObjAppendElement(tls, interp, pRet, dbEvalColumnValue(tls, bp+1184 /* &sEval */, i))
					}
				}
				dbEvalFinalize(tls, bp+1184 /* &sEval */)
				if rc == 3 {
					tcl.XTcl_SetObjResult(tls, interp, pRet)
					rc = 0
				}
				for ok1 := true; ok1; ok1 = 0 != 0 {
					var _objPtr uintptr = pRet
					if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
						tcl.XTclFreeObj(tls, _objPtr)
					}
				}
			} else {
				// var cd2 [2]ClientData at bp+1248, 16

				var p uintptr
				var pArray uintptr = uintptr(0)
				var pScript uintptr

				if (objc >= 5) && (*(*int8)(unsafe.Pointer(tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(3)*8))))) != 0) {
					pArray = *(*uintptr)(unsafe.Pointer(objv + uintptr(3)*8))
				}
				pScript = *(*uintptr)(unsafe.Pointer(objv + uintptr((objc-1))*8))
				(*Tcl_Obj)(unsafe.Pointer(pScript)).FrefCount++

				p = tcl.XTcl_Alloc(tls, uint32(unsafe.Sizeof(DbEvalContext{})))
				dbEvalInit(tls, p, pDb, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)), pArray, evalFlags)

				*(*ClientData)(unsafe.Pointer(bp + 1248 /* &cd2[0] */ + uintptr(0)*8)) = p
				*(*ClientData)(unsafe.Pointer(bp + 1248 /* &cd2[0] */ + uintptr(1)*8)) = pScript
				rc = DbEvalNextCmd(tls, bp+1248 /* &cd2[0] */, interp, 0)
			}
			break
		}

	//     $db function NAME [OPTIONS] SCRIPT
	//
	// Create a new SQL function called NAME.  Whenever that function is
	// called, invoke SCRIPT to evaluate the function.
	//
	// Options:
	//         --argcount N           Function has exactly N arguments
	//         --deterministic        The function is pure
	//         --directonly           Prohibit use inside triggers and views
	//         --innocuous            Has no side effects or information leaks
	//         --returntype TYPE      Specify the return type of the function
	case DB_FUNCTION:
		{
			var flags int32 = 1
			var pFunc uintptr
			var pScript uintptr
			var zName uintptr
			*(*int32)(unsafe.Pointer(bp + 1264 /* nArg */)) = -1
			var i int32
			*(*int32)(unsafe.Pointer(bp + 1320 /* eType */)) = 5
			if objc < 4 {
				tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+19254 /* "NAME ?SWITCHES? ..." */)
				return 1
			}
			for i = 3; i < (objc - 1); i++ {
				var z uintptr = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(i)*8)))
				var n int32 = strlen30(tls, z)
				if (n > 1) && (crt.Xstrncmp(tls, z, ts+19277 /* "-argcount" */, uint64(n)) == 0) {
					if i == (objc - 2) {
						tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+632, ts+19287 /* "option requires ..." */, z, uintptr(0)))
						return 1
					}
					if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr((i+1))*8)), bp+1264 /* &nArg */) != 0 {
						return 1
					}
					if *(*int32)(unsafe.Pointer(bp + 1264 /* nArg */)) < 0 {
						tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+656, ts+19317, /* "number of argume..." */
							uintptr(0)))
						return 1
					}
					i++
				} else if (n > 1) && (crt.Xstrncmp(tls, z, ts+19358 /* "-deterministic" */, uint64(n)) == 0) {
					flags = flags | (0x000000800)
				} else if (n > 1) && (crt.Xstrncmp(tls, z, ts+19373 /* "-directonly" */, uint64(n)) == 0) {
					flags = flags | (0x000080000)
				} else if (n > 1) && (crt.Xstrncmp(tls, z, ts+19385 /* "-innocuous" */, uint64(n)) == 0) {
					flags = flags | (0x000200000)
				} else if (n > 1) && (crt.Xstrncmp(tls, z, ts+19396 /* "-returntype" */, uint64(n)) == 0) {
					*(*[6]uintptr)(unsafe.Pointer(bp + 1272 /* azType */)) = [6]uintptr{ts + 8373 /* "integer" */, ts + 19408 /* "real" */, ts + 19413 /* "text" */, ts + 19418 /* "blob" */, ts + 19423 /* "any" */, uintptr(0)}
					if !(((1 == 1) && (2 == 2)) && (3 == 3)) {
						crt.X__assert_fail(tls, ts+19427 /* "1==1 && 2==2 && ..." */, ts+17039 /* "testdata/sqlite-..." */, uint32(2865), uintptr(unsafe.Pointer(&__func__100)))
					}
					if !((4 == 4) && (5 == 5)) {
						crt.X__assert_fail(tls, ts+19448 /* "4==4 && 5==5" */, ts+17039 /* "testdata/sqlite-..." */, uint32(2866), uintptr(unsafe.Pointer(&__func__100)))
					}
					if i == (objc - 2) {
						tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+672, ts+19287 /* "option requires ..." */, z, uintptr(0)))
						return 1
					}
					i++
					if tcl.XTcl_GetIndexFromObjStruct(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(i)*8)), bp+1272 /* &azType[0] */, int32(unsafe.Sizeof(uintptr(0))), ts+19461 /* "type" */, 0, bp+1320 /* &eType */) != 0 {
						return 1
					}
					*(*int32)(unsafe.Pointer(bp + 1320 /* eType */))++
				} else {
					tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+696, ts+18565 /* "bad option \"" */, z,

						ts+19466 /* "\": must be -argc..." */, uintptr(0)))
					return 1
				}
			}

			pScript = *(*uintptr)(unsafe.Pointer(objv + uintptr((objc-1))*8))
			zName = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)), uintptr(0))
			pFunc = findSqlFunc(tls, pDb, zName)
			if pFunc == uintptr(0) {
				return 1
			}
			if (*SqlFunc)(unsafe.Pointer(pFunc)).FpScript != 0 {
				for ok2 := true; ok2; ok2 = 0 != 0 {
					var _objPtr uintptr = (*SqlFunc)(unsafe.Pointer(pFunc)).FpScript
					if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
						tcl.XTclFreeObj(tls, _objPtr)
					}
				}
			}
			(*SqlFunc)(unsafe.Pointer(pFunc)).FpScript = pScript
			(*Tcl_Obj)(unsafe.Pointer(pScript)).FrefCount++
			(*SqlFunc)(unsafe.Pointer(pFunc)).FuseEvalObjv = safeToUseEvalObjv(tls, interp, pScript)
			(*SqlFunc)(unsafe.Pointer(pFunc)).FeType = *(*int32)(unsafe.Pointer(bp + 1320 /* eType */))
			rc = sqlite3.Xsqlite3_create_function(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, zName, *(*int32)(unsafe.Pointer(bp + 1264 /* nArg */)), flags,
				pFunc, *(*uintptr)(unsafe.Pointer(&struct {
					f func(*crt.TLS, uintptr, int32, uintptr)
				}{tclSqlFunc})), uintptr(0), uintptr(0))
			if rc != 0 {
				rc = 1
				tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3_errmsg(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb), uintptr(1))
			}
			break
		}

	//     $db incrblob ?-readonly? ?DB? TABLE COLUMN ROWID
	case DB_INCRBLOB:
		{
			var isReadonly int32 = 0
			var zDb uintptr = ts + 354 /* "main" */
			var zTable uintptr
			var zColumn uintptr
			// var iRow Tcl_WideInt at bp+1328, 8

			// Check for the -readonly option
			if (objc > 3) && (crt.Xstrcmp(tls, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8))), ts+19544 /* "-readonly" */) == 0) {
				isReadonly = 1
			}

			if (objc != (5 + isReadonly)) && (objc != (6 + isReadonly)) {
				tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+19554 /* "?-readonly? ?DB?..." */)
				return 1
			}

			if objc == (6 + isReadonly) {
				zDb = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)))
			}
			zTable = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr((objc-3))*8)))
			zColumn = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr((objc-2))*8)))
			rc = tcl.XTcl_GetWideIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr((objc-1))*8)), bp+1328 /* &iRow */)

			if rc == 0 {
				rc = createIncrblobChannel(tls,
					interp, pDb, zDb, zTable, zColumn, sqlite3_int64(*(*Tcl_WideInt)(unsafe.Pointer(bp + 1328 /* iRow */))), isReadonly)
			}
			break
		}

	//     $db interrupt
	//
	// Interrupt the execution of the inner-most SQL interpreter.  This
	// causes the SQL statement to return an error of SQLITE_INTERRUPT.
	case DB_INTERRUPT:
		{
			sqlite3.Xsqlite3_interrupt(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb)
			break
		}

	//     $db nullvalue ?STRING?
	//
	// Change text used when a NULL comes back from the database. If ?STRING?
	// is not present, then the current string used for NULL is returned.
	// If STRING is present, then STRING is returned.
	//
	case DB_NULLVALUE:
		{
			if (objc != 2) && (objc != 3) {
				tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+19590 /* "NULLVALUE" */)
				return 1
			}
			if objc == 3 {
				// var len int32 at bp+1336, 4

				var zNull uintptr = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)), bp+1336 /* &len */)
				if (*SqliteDb)(unsafe.Pointer(pDb)).FzNull != 0 {
					tcl.XTcl_Free(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzNull)
				}
				if (zNull != 0) && (*(*int32)(unsafe.Pointer(bp + 1336 /* len */)) > 0) {
					(*SqliteDb)(unsafe.Pointer(pDb)).FzNull = tcl.XTcl_Alloc(tls, (uint32(*(*int32)(unsafe.Pointer(bp + 1336 /* len */)) + 1)))
					crt.Xmemcpy(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzNull, zNull, uint64(*(*int32)(unsafe.Pointer(bp + 1336 /* len */))))
					*(*int8)(unsafe.Pointer((*SqliteDb)(unsafe.Pointer(pDb)).FzNull + uintptr(*(*int32)(unsafe.Pointer(bp + 1336 /* len */))))) = int8(0)
				} else {
					(*SqliteDb)(unsafe.Pointer(pDb)).FzNull = uintptr(0)
				}
			}
			tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzNull, -1))
			break
		}

	//     $db last_insert_rowid
	//
	// Return an integer which is the ROWID for the most recent insert.
	case DB_LAST_INSERT_ROWID:
		{
			var pResult uintptr
			var rowid Tcl_WideInt
			if objc != 2 {
				tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+792 /* "" */)
				return 1
			}
			rowid = Tcl_WideInt(sqlite3.Xsqlite3_last_insert_rowid(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb))
			pResult = tcl.XTcl_GetObjResult(tls, interp)
			tcl.XTcl_SetWideIntObj(tls, pResult, rowid)
			break
		}

	// The DB_ONECOLUMN method is implemented together with DB_EXISTS.

	// $db progress ?N CALLBACK?
	//
	// Invoke the given callback every N virtual machine opcodes while executing
	// queries.
	case DB_PROGRESS:
		{
			if objc == 2 {
				if (*SqliteDb)(unsafe.Pointer(pDb)).FzProgress != 0 {
					tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+728, (*SqliteDb)(unsafe.Pointer(pDb)).FzProgress, uintptr(0)))
				}
			} else if objc == 4 {
				var zProgress uintptr
				// var len int32 at bp+1344, 4

				// var N int32 at bp+1340, 4

				if 0 != tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)), bp+1340 /* &N */) {
					return 1
				}

				if (*SqliteDb)(unsafe.Pointer(pDb)).FzProgress != 0 {
					tcl.XTcl_Free(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzProgress)
				}
				zProgress = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(3)*8)), bp+1344 /* &len */)
				if (zProgress != 0) && (*(*int32)(unsafe.Pointer(bp + 1344 /* len */)) > 0) {
					(*SqliteDb)(unsafe.Pointer(pDb)).FzProgress = tcl.XTcl_Alloc(tls, (uint32(*(*int32)(unsafe.Pointer(bp + 1344 /* len */)) + 1)))
					crt.Xmemcpy(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzProgress, zProgress, (uint64(*(*int32)(unsafe.Pointer(bp + 1344 /* len */)) + 1)))
				} else {
					(*SqliteDb)(unsafe.Pointer(pDb)).FzProgress = uintptr(0)
				}
			} else {
				tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+19600 /* "N CALLBACK" */)
				return 1
			}
			break
		}

	// $db profile ?CALLBACK?
	//
	// Make arrangements to invoke the CALLBACK routine after each SQL statement
	// that has run.  The text of the SQL and the amount of elapse time are
	// appended to CALLBACK before the script is run.
	case DB_PROFILE:
		{
			if objc > 3 {
				tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+18412 /* "?CALLBACK?" */)
				return 1
			} else if objc == 2 {
				if (*SqliteDb)(unsafe.Pointer(pDb)).FzProfile != 0 {
					tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+744, (*SqliteDb)(unsafe.Pointer(pDb)).FzProfile, uintptr(0)))
				}
			} else {
				var zProfile uintptr
				// var len int32 at bp+1348, 4

				if (*SqliteDb)(unsafe.Pointer(pDb)).FzProfile != 0 {
					tcl.XTcl_Free(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzProfile)
				}
				zProfile = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)), bp+1348 /* &len */)
				if (zProfile != 0) && (*(*int32)(unsafe.Pointer(bp + 1348 /* len */)) > 0) {
					(*SqliteDb)(unsafe.Pointer(pDb)).FzProfile = tcl.XTcl_Alloc(tls, (uint32(*(*int32)(unsafe.Pointer(bp + 1348 /* len */)) + 1)))
					crt.Xmemcpy(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzProfile, zProfile, (uint64(*(*int32)(unsafe.Pointer(bp + 1348 /* len */)) + 1)))
				} else {
					(*SqliteDb)(unsafe.Pointer(pDb)).FzProfile = uintptr(0)
				}
				if (*SqliteDb)(unsafe.Pointer(pDb)).FzProfile != 0 {
					(*SqliteDb)(unsafe.Pointer(pDb)).Finterp = interp
					sqlite3.Xsqlite3_profile(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, *(*uintptr)(unsafe.Pointer(&struct {
						f func(*crt.TLS, uintptr, uintptr, sqlite_uint64)
					}{DbProfileHandler})), pDb)
				} else {
					sqlite3.Xsqlite3_profile(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, uintptr(0), uintptr(0))
				}
			}
			break
		}

	//     $db rekey KEY
	//
	// Change the encryption key on the currently open database.
	case DB_REKEY:
		{
			if objc != 3 {
				tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+19611 /* "KEY" */)
				return 1
			}
			break
		}

	// $db restore ?DATABASE? FILENAME
	//
	// Open a database file named FILENAME.  Transfer the content
	// of FILENAME into the local database DATABASE (default: "main").
	case DB_RESTORE:
		{
			var zSrcFile uintptr
			var zDestDb uintptr
			// var pSrc uintptr at bp+1352, 8

			var pBackup uintptr
			var nTimeout int32 = 0

			if objc == 3 {
				zDestDb = ts + 354 /* "main" */
				zSrcFile = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)))
			} else if objc == 4 {
				zDestDb = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)))
				zSrcFile = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(3)*8)))
			} else {
				tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+18423 /* "?DATABASE? FILEN..." */)
				return 1
			}
			rc = sqlite3.Xsqlite3_open_v2(tls, zSrcFile, bp+1352, /* &pSrc */
				(0x00000001 | (*SqliteDb)(unsafe.Pointer(pDb)).FopenFlags), uintptr(0))
			if rc != 0 {
				tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+760, ts+19615, /* "cannot open sour..." */
					sqlite3.Xsqlite3_errmsg(tls, *(*uintptr)(unsafe.Pointer(bp + 1352 /* pSrc */))), uintptr(0)))
				sqlite3.Xsqlite3_close(tls, *(*uintptr)(unsafe.Pointer(bp + 1352 /* pSrc */)))
				return 1
			}
			pBackup = sqlite3.Xsqlite3_backup_init(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, zDestDb, *(*uintptr)(unsafe.Pointer(bp + 1352 /* pSrc */)), ts+354 /* "main" */)
			if pBackup == uintptr(0) {
				tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+784, ts+19645, /* "restore failed: " */
					sqlite3.Xsqlite3_errmsg(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb), uintptr(0)))
				sqlite3.Xsqlite3_close(tls, *(*uintptr)(unsafe.Pointer(bp + 1352 /* pSrc */)))
				return 1
			}
			for ((crt.AssignInt32(&rc, sqlite3.Xsqlite3_backup_step(tls, pBackup, 100))) == 0) ||
				(rc == 5) {
				if rc == 5 {
					if crt.PostIncInt32(&nTimeout, 1) >= 3 {
						break
					}
					sqlite3.Xsqlite3_sleep(tls, 100)
				}
			}
			sqlite3.Xsqlite3_backup_finish(tls, pBackup)
			if rc == 101 {
				rc = 0
			} else if (rc == 5) || (rc == 6) {
				tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+808, ts+19662, /* "restore failed: ..." */
					uintptr(0)))
				rc = 1
			} else {
				tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+824, ts+19645, /* "restore failed: " */
					sqlite3.Xsqlite3_errmsg(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb), uintptr(0)))
				rc = 1
			}
			sqlite3.Xsqlite3_close(tls, *(*uintptr)(unsafe.Pointer(bp + 1352 /* pSrc */)))
			break
		}

	//     $db serialize ?DATABASE?
	//
	// Return a serialization of a database.
	case DB_SERIALIZE:
		{
			tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+848, ts+19104, /* "MEMDB not availa..." */
				uintptr(0)))
			rc = 1
			break
		}

	//     $db status (step|sort|autoindex|vmstep)
	//
	// Display SQLITE_STMTSTATUS_FULLSCAN_STEP or
	// SQLITE_STMTSTATUS_SORT for the most recent eval.
	case DB_STATUS:
		{
			var v int32
			var zOp uintptr
			if objc != 3 {
				tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+19699 /* "(step|sort|autoi..." */)
				return 1
			}
			zOp = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)))
			if crt.Xstrcmp(tls, zOp, ts+16502 /* "step" */) == 0 {
				v = (*SqliteDb)(unsafe.Pointer(pDb)).FnStep
			} else if crt.Xstrcmp(tls, zOp, ts+19721 /* "sort" */) == 0 {
				v = (*SqliteDb)(unsafe.Pointer(pDb)).FnSort
			} else if crt.Xstrcmp(tls, zOp, ts+19726 /* "autoindex" */) == 0 {
				v = (*SqliteDb)(unsafe.Pointer(pDb)).FnIndex
			} else if crt.Xstrcmp(tls, zOp, ts+19736 /* "vmstep" */) == 0 {
				v = (*SqliteDb)(unsafe.Pointer(pDb)).FnVMStep
			} else {
				tcl.XTcl_AppendResult(tls, interp,
					crt.VaList(bp+864, ts+19743, /* "bad argument: sh..." */
						uintptr(0)))
				return 1
			}
			tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, v))
			break
		}

	//     $db timeout MILLESECONDS
	//
	// Delay for the number of milliseconds specified when a file is locked.
	case DB_TIMEOUT:
		{
			// var ms int32 at bp+1360, 4

			if objc != 3 {
				tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+19799 /* "MILLISECONDS" */)
				return 1
			}
			if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)), bp+1360 /* &ms */) != 0 {
				return 1
			}
			sqlite3.Xsqlite3_busy_timeout(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, *(*int32)(unsafe.Pointer(bp + 1360 /* ms */)))
			break
		}

	//     $db total_changes
	//
	// Return the number of rows that were modified, inserted, or deleted
	// since the database handle was created.
	case DB_TOTAL_CHANGES:
		{
			var pResult uintptr
			if objc != 2 {
				tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+792 /* "" */)
				return 1
			}
			pResult = tcl.XTcl_GetObjResult(tls, interp)
			tcl.XTcl_SetIntObj(tls, pResult, sqlite3.Xsqlite3_total_changes(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb))
			break
		}

	// $db trace ?CALLBACK?
	//
	// Make arrangements to invoke the CALLBACK routine for each SQL statement
	// that is executed.  The text of the SQL is appended to CALLBACK before
	// it is executed.
	case DB_TRACE:
		{
			if objc > 3 {
				tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+18412 /* "?CALLBACK?" */)
				return 1
			} else if objc == 2 {
				if (*SqliteDb)(unsafe.Pointer(pDb)).FzTrace != 0 {
					tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+880, (*SqliteDb)(unsafe.Pointer(pDb)).FzTrace, uintptr(0)))
				}
			} else {
				var zTrace uintptr
				// var len int32 at bp+1364, 4

				if (*SqliteDb)(unsafe.Pointer(pDb)).FzTrace != 0 {
					tcl.XTcl_Free(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzTrace)
				}
				zTrace = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)), bp+1364 /* &len */)
				if (zTrace != 0) && (*(*int32)(unsafe.Pointer(bp + 1364 /* len */)) > 0) {
					(*SqliteDb)(unsafe.Pointer(pDb)).FzTrace = tcl.XTcl_Alloc(tls, (uint32(*(*int32)(unsafe.Pointer(bp + 1364 /* len */)) + 1)))
					crt.Xmemcpy(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzTrace, zTrace, (uint64(*(*int32)(unsafe.Pointer(bp + 1364 /* len */)) + 1)))
				} else {
					(*SqliteDb)(unsafe.Pointer(pDb)).FzTrace = uintptr(0)
				}
				if (*SqliteDb)(unsafe.Pointer(pDb)).FzTrace != 0 {
					(*SqliteDb)(unsafe.Pointer(pDb)).Finterp = interp
					sqlite3.Xsqlite3_trace(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, *(*uintptr)(unsafe.Pointer(&struct {
						f func(*crt.TLS, uintptr, uintptr)
					}{DbTraceHandler})), pDb)
				} else {
					sqlite3.Xsqlite3_trace(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, uintptr(0), uintptr(0))
				}
			}
			break
		}

	// $db trace_v2 ?CALLBACK? ?MASK?
	//
	// Make arrangements to invoke the CALLBACK routine for each trace event
	// matching the mask that is generated.  The parameters are appended to
	// CALLBACK before it is executed.
	case DB_TRACE_V2:
		{
			if objc > 4 {
				tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+19812 /* "?CALLBACK? ?MASK..." */)
				return 1
			} else if objc == 2 {
				if (*SqliteDb)(unsafe.Pointer(pDb)).FzTraceV2 != 0 {
					tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+896, (*SqliteDb)(unsafe.Pointer(pDb)).FzTraceV2, uintptr(0)))
				}
			} else {
				var zTraceV2 uintptr
				// var len int32 at bp+1368, 4

				var wMask Tcl_WideInt = int64(0)
				if objc == 4 {
					const ( /* tclsqlite.c:3324:9: */
						TTYPE_STMT    = 0
						TTYPE_PROFILE = 1
						TTYPE_ROW     = 2
						TTYPE_CLOSE   = 3
					)
					var i int32
					if 0 != tcl.XTcl_ListObjLength(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(3)*8)), bp+1368 /* &len */) {
						return 1
					}
					for i = 0; i < *(*int32)(unsafe.Pointer(bp + 1368 /* len */)); i++ {
						// var pObj uintptr at bp+1376, 8

						// var ttype int32 at bp+1384, 4

						if 0 != tcl.XTcl_ListObjIndex(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(3)*8)), i, bp+1376 /* &pObj */) {
							return 1
						}
						if tcl.XTcl_GetIndexFromObjStruct(tls, interp, *(*uintptr)(unsafe.Pointer(bp + 1376 /* pObj */)), uintptr(unsafe.Pointer(&TTYPE_strs)), int32(unsafe.Sizeof(uintptr(0))), ts+19830 /* "trace type" */, 0, bp+1384 /* &ttype */) != 0 {
							// var wType Tcl_WideInt at bp+1392, 8

							var pError uintptr = tcl.XTcl_DuplicateObj(tls, tcl.XTcl_GetObjResult(tls, interp))
							(*Tcl_Obj)(unsafe.Pointer(pError)).FrefCount++
							if 0 == tcl.XTcl_GetWideIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(bp + 1376 /* pObj */)), bp+1392 /* &wType */) {
								for ok3 := true; ok3; ok3 = 0 != 0 {
									var _objPtr uintptr = pError
									if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
										tcl.XTclFreeObj(tls, _objPtr)
									}
								}
								wMask = wMask | (*(*Tcl_WideInt)(unsafe.Pointer(bp + 1392 /* wType */)))
							} else {
								tcl.XTcl_SetObjResult(tls, interp, pError)
								for ok4 := true; ok4; ok4 = 0 != 0 {
									var _objPtr uintptr = pError
									if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
										tcl.XTclFreeObj(tls, _objPtr)
									}
								}
								return 1
							}
						} else {
							switch uint32(*(*int32)(unsafe.Pointer(bp + 1384 /* ttype */))) {
							case TTYPE_STMT:
								wMask = wMask | (int64(0x01))
								break
								fallthrough
							case TTYPE_PROFILE:
								wMask = wMask | (int64(0x02))
								break
								fallthrough
							case TTYPE_ROW:
								wMask = wMask | (int64(0x04))
								break
								fallthrough
							case TTYPE_CLOSE:
								wMask = wMask | (int64(0x08))
								break
							}
						}
					}
				} else {
					wMask = int64(0x01)
				}
				if (*SqliteDb)(unsafe.Pointer(pDb)).FzTraceV2 != 0 {
					tcl.XTcl_Free(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzTraceV2)
				}
				zTraceV2 = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)), bp+1368 /* &len */)
				if (zTraceV2 != 0) && (*(*int32)(unsafe.Pointer(bp + 1368 /* len */)) > 0) {
					(*SqliteDb)(unsafe.Pointer(pDb)).FzTraceV2 = tcl.XTcl_Alloc(tls, (uint32(*(*int32)(unsafe.Pointer(bp + 1368 /* len */)) + 1)))
					crt.Xmemcpy(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzTraceV2, zTraceV2, (uint64(*(*int32)(unsafe.Pointer(bp + 1368 /* len */)) + 1)))
				} else {
					(*SqliteDb)(unsafe.Pointer(pDb)).FzTraceV2 = uintptr(0)
				}
				if (*SqliteDb)(unsafe.Pointer(pDb)).FzTraceV2 != 0 {
					(*SqliteDb)(unsafe.Pointer(pDb)).Finterp = interp
					sqlite3.Xsqlite3_trace_v2(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, uint32(wMask), *(*uintptr)(unsafe.Pointer(&struct {
						f func(*crt.TLS, uint32, uintptr, uintptr, uintptr) int32
					}{DbTraceV2Handler})), pDb)
				} else {
					sqlite3.Xsqlite3_trace_v2(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, uint32(0), uintptr(0), uintptr(0))
				}
			}
			break
		}

	// $db transaction [-deferred|-immediate|-exclusive] SCRIPT
	//
	// Start a new transaction (if we are not already in the midst of a
	// transaction) and execute the TCL script SCRIPT.  After SCRIPT
	// completes, either commit the transaction or roll it back if SCRIPT
	// throws an exception.  Or if no new transation was started, do nothing.
	// pass the exception on up the stack.
	//
	// This command was inspired by Dave Thomas's talk on Ruby at the
	// 2005 O'Reilly Open Source Convention (OSCON).
	case DB_TRANSACTION:
		{
			var pScript uintptr
			var zBegin uintptr = ts + 19841 /* "SAVEPOINT _tcl_t..." */
			if (objc != 3) && (objc != 4) {
				tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+19868 /* "[TYPE] SCRIPT" */)
				return 1
			}

			if ((*SqliteDb)(unsafe.Pointer(pDb)).FnTransaction == 0) && (objc == 4) {
				const ( /* tclsqlite.c:3407:7: */
					TTYPE_DEFERRED  = 0
					TTYPE_EXCLUSIVE = 1
					TTYPE_IMMEDIATE = 2
				)
				// var ttype int32 at bp+1400, 4

				if tcl.XTcl_GetIndexFromObjStruct(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)), uintptr(unsafe.Pointer(&TTYPE_strs1)), int32(unsafe.Sizeof(uintptr(0))), ts+19882 /* "transaction type" */, 0, bp+1400 /* &ttype */) != 0 {
					return 1
				}
				switch uint32(*(*int32)(unsafe.Pointer(bp + 1400 /* ttype */))) {
				case TTYPE_DEFERRED: /* no-op */
					break
					fallthrough
				case TTYPE_EXCLUSIVE:
					zBegin = ts + 19899 /* "BEGIN EXCLUSIVE" */
					break
					fallthrough
				case TTYPE_IMMEDIATE:
					zBegin = ts + 15602 /* "BEGIN IMMEDIATE" */
					break
				}
			}
			pScript = *(*uintptr)(unsafe.Pointer(objv + uintptr((objc-1))*8))

			// Run the SQLite BEGIN command to open a transaction or savepoint.
			(*SqliteDb)(unsafe.Pointer(pDb)).FdisableAuth++
			rc = sqlite3.Xsqlite3_exec(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, zBegin, uintptr(0), uintptr(0), uintptr(0))
			(*SqliteDb)(unsafe.Pointer(pDb)).FdisableAuth--
			if rc != 0 {
				tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+912, sqlite3.Xsqlite3_errmsg(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb), uintptr(0)))
				return 1
			}
			(*SqliteDb)(unsafe.Pointer(pDb)).FnTransaction++

			// If using NRE, schedule a callback to invoke the script pScript, then
			// a second callback to commit (or rollback) the transaction or savepoint
			// opened above. If not using NRE, evaluate the script directly, then
			// call function DbTransPostCmd() to commit (or rollback) the transaction
			// or savepoint.
			if DbUseNre(tls) != 0 {
				tcl.XTcl_NRAddCallback(tls, interp, *(*uintptr)(unsafe.Pointer(&struct {
					f func(*crt.TLS, uintptr, uintptr, int32) int32
				}{DbTransPostCmd})), *(*uintptr)(unsafe.Pointer(bp + 1408 /* cd */)), uintptr(0), uintptr(0), uintptr(0))
				tcl.XTcl_NREvalObj(tls, interp, pScript, 0)
			} else {
				rc = DbTransPostCmd(tls, bp+1408 /* &cd */, interp, tcl.XTcl_EvalObjEx(tls, interp, pScript, 0))
			}
			break
		}

	//    $db unlock_notify ?script?
	case DB_UNLOCK_NOTIFY:
		{
			if (objc != 2) && (objc != 3) {
				tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+19915 /* "?SCRIPT?" */)
				rc = 1
			} else {
				var xNotify uintptr = uintptr(0)
				var pNotifyArg uintptr = uintptr(0)

				if (*SqliteDb)(unsafe.Pointer(pDb)).FpUnlockNotify != 0 {
					for ok5 := true; ok5; ok5 = 0 != 0 {
						var _objPtr uintptr = (*SqliteDb)(unsafe.Pointer(pDb)).FpUnlockNotify
						if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
							tcl.XTclFreeObj(tls, _objPtr)
						}
					}
					(*SqliteDb)(unsafe.Pointer(pDb)).FpUnlockNotify = uintptr(0)
				}

				if objc == 3 {
					xNotify = *(*uintptr)(unsafe.Pointer(&struct {
						f func(*crt.TLS, uintptr, int32)
					}{DbUnlockNotify}))
					pNotifyArg = pDb
					(*SqliteDb)(unsafe.Pointer(pDb)).FpUnlockNotify = *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8))
					(*Tcl_Obj)(unsafe.Pointer((*SqliteDb)(unsafe.Pointer(pDb)).FpUnlockNotify)).FrefCount++
				}

				if sqlite3.Xsqlite3_unlock_notify(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, xNotify, pNotifyArg) != 0 {
					tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+928, sqlite3.Xsqlite3_errmsg(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb), uintptr(0)))
					rc = 1
				}
			}
			break
		}

	//    $db preupdate_hook count
	//    $db preupdate_hook hook ?SCRIPT?
	//    $db preupdate_hook new INDEX
	//    $db preupdate_hook old INDEX
	case DB_PREUPDATE:
		{
			tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+944, ts+19924, /* "preupdate_hook w..." */
				uintptr(0)))
			rc = 1
			break
		}

	//    $db wal_hook ?script?
	//    $db update_hook ?script?
	//    $db rollback_hook ?script?
	case DB_WAL_HOOK:
		fallthrough
	case DB_UPDATE_HOOK:
		fallthrough
	case DB_ROLLBACK_HOOK:
		{
			// set ppHook to point at pUpdateHook or pRollbackHook, depending on
			// whether [$db update_hook] or [$db rollback_hook] was invoked.
			var ppHook uintptr = uintptr(0)
			if *(*int32)(unsafe.Pointer(bp + 992 /* choice */)) == DB_WAL_HOOK {
				ppHook = (pDb + 128 /* &.pWalHook */)
			}
			if *(*int32)(unsafe.Pointer(bp + 992 /* choice */)) == DB_UPDATE_HOOK {
				ppHook = (pDb + 104 /* &.pUpdateHook */)
			}
			if *(*int32)(unsafe.Pointer(bp + 992 /* choice */)) == DB_ROLLBACK_HOOK {
				ppHook = (pDb + 120 /* &.pRollbackHook */)
			}
			if objc > 3 {
				tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+19915 /* "?SCRIPT?" */)
				return 1
			}

			DbHookCmd(tls, interp, pDb, func() uintptr {
				if objc == 3 {
					return *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8))
				}
				return uintptr(0)
			}(), ppHook)
			break
		}

	// $db version
	//
	// Return the version string for this database.
	case DB_VERSION:
		{
			var i int32
			for i = 2; i < objc; i++ {
				var zArg uintptr = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(i)*8)))
				// Optional arguments to $db version are used for testing purpose
				// $db version -use-legacy-prepare BOOLEAN
				//
				// Turn the use of legacy sqlite3_prepare() on or off.
				if (crt.Xstrcmp(tls, zArg, ts+19967 /* "-use-legacy-prep..." */) == 0) && ((i + 1) < objc) {
					i++
					if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(i)*8)), (pDb+224 /* &.bLegacyPrepare */)) != 0 {
						return 1
					}
				} else

				// $db version -last-stmt-ptr
				//
				// Return a string which is a hex encoding of the pointer to the
				// most recent sqlite3_stmt in the statement cache.
				if crt.Xstrcmp(tls, zArg, ts+19987 /* "-last-stmt-ptr" */) == 0 {
					// var zBuf [100]int8 at bp+1416, 100

					sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([100]int8{})), bp+1416 /* &zBuf[0] */, ts+20002, /* "%p" */
						crt.VaList(bp+960, func() uintptr {
							if (*SqliteDb)(unsafe.Pointer(pDb)).FstmtList != 0 {
								return (*SqlPreparedStmt)(unsafe.Pointer((*SqliteDb)(unsafe.Pointer(pDb)).FstmtList)).FpStmt
							}
							return uintptr(0)
						}()))
					tcl.XTcl_SetResult(tls, interp, bp+1416 /* &zBuf[0] */, uintptr(1))
				} else {
					tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+968, ts+20005 /* "unknown argument..." */, zArg, uintptr(0)))
					return 1
				}
			}
			if i == 2 {
				tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3_libversion(tls), uintptr(0))
			}
			break
		}
	} // End of the SWITCH statement
	return rc
}

type DbConfigChoices = struct {
	FzName uintptr
	Fop    int32
	_      [4]byte
}

var __func__100 = *(*[9]int8)(unsafe.Pointer(ts + 20024 /* "DbObjCmd" */)) /* tclsqlite.c:1912:2 */
var DB_strs = [42]uintptr{
	ts + 20033 /* "authorizer" */, ts + 20044 /* "backup" */, ts + 20051, /* "bind_fallback" */
	ts + 20065 /* "busy" */, ts + 20070 /* "cache" */, ts + 20076, /* "changes" */
	ts + 16507 /* "close" */, ts + 20084 /* "collate" */, ts + 20092, /* "collation_needed" */
	ts + 20109 /* "commit_hook" */, ts + 20121 /* "complete" */, ts + 20130, /* "config" */
	ts + 20137 /* "copy" */, ts + 20142 /* "deserialize" */, ts + 20154, /* "enable_load_exte..." */
	ts + 20176 /* "errorcode" */, ts + 4437 /* "eval" */, ts + 20186, /* "exists" */
	ts + 20193 /* "function" */, ts + 17096 /* "incrblob" */, ts + 20202, /* "interrupt" */
	ts + 20212 /* "last_insert_rowi..." */, ts + 20230 /* "nullvalue" */, ts + 20240, /* "onecolumn" */
	ts + 20250 /* "preupdate" */, ts + 20260 /* "profile" */, ts + 16581, /* "progress" */
	ts + 20268 /* "rekey" */, ts + 20274 /* "restore" */, ts + 20282, /* "rollback_hook" */
	ts + 20296 /* "serialize" */, ts + 20306 /* "status" */, ts + 20313, /* "timeout" */
	ts + 20321 /* "total_changes" */, ts + 20335 /* "trace" */, ts + 20341, /* "trace_v2" */
	ts + 20350 /* "transaction" */, ts + 20362 /* "unlock_notify" */, ts + 20376, /* "update_hook" */
	ts + 20388 /* "version" */, ts + 20396 /* "wal_hook" */, uintptr(0),
} /* tclsqlite.c:1916:21 */
var aDbConfig = [16]DbConfigChoices{
	{FzName: ts + 20405 /* "defensive" */, Fop: 1010},
	{FzName: ts + 20415 /* "dqs_ddl" */, Fop: 1014},
	{FzName: ts + 20423 /* "dqs_dml" */, Fop: 1013},
	{FzName: ts + 20431 /* "enable_fkey" */, Fop: 1002},
	{FzName: ts + 20443 /* "enable_qpsg" */, Fop: 1007},
	{FzName: ts + 20455 /* "enable_trigger" */, Fop: 1003},
	{FzName: ts + 20470 /* "enable_view" */, Fop: 1015},
	{FzName: ts + 20482 /* "fts3_tokenizer" */, Fop: 1004},
	{FzName: ts + 20497 /* "legacy_alter_tab..." */, Fop: 1012},
	{FzName: ts + 20516 /* "legacy_file_form..." */, Fop: 1016},
	{FzName: ts + 20535 /* "load_extension" */, Fop: 1005},
	{FzName: ts + 20550 /* "no_ckpt_on_close" */, Fop: 1006},
	{FzName: ts + 20567 /* "reset_database" */, Fop: 1009},
	{FzName: ts + 20582 /* "trigger_eqp" */, Fop: 1008},
	{FzName: ts + 20594 /* "trusted_schema" */, Fop: 1017},
	{FzName: ts + 20609 /* "writable_schema" */, Fop: 1011},
} /* tclsqlite.c:2343:7 */
var TTYPE_strs = [5]uintptr{
	ts + 20625 /* "statement" */, ts + 20260 /* "profile" */, ts + 20635 /* "row" */, ts + 16507 /* "close" */, uintptr(0),
} /* tclsqlite.c:3321:27 */
var TTYPE_strs1 = [4]uintptr{
	ts + 20639 /* "deferred" */, ts + 20648 /* "exclusive" */, ts + 20658 /* "immediate" */, uintptr(0),
} /* tclsqlite.c:3404:25 */

// Adaptor that provides an objCmd interface to the NRE-enabled
// interface implementation.
func DbObjCmdAdaptor(tls *crt.TLS, cd uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* tclsqlite.c:3647:26: */
	return tcl.XTcl_NRCallObjProc(tls, interp, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{DbObjCmd})), cd, objc, objv)
}

// Issue the usage message when the "sqlite3" command arguments are
// incorrect.
func sqliteCmdUsage(tls *crt.TLS, interp uintptr, objv uintptr) int32 { /* tclsqlite.c:3661:12: */
	tcl.XTcl_WrongNumArgs(tls, interp, 1, objv,

		ts+20668 /* "HANDLE ?FILENAME..." */)
	return 1
}

//   sqlite3 DBNAME FILENAME ?-vfs VFSNAME? ?-key KEY? ?-readonly BOOLEAN?
//                           ?-create BOOLEAN? ?-nomutex BOOLEAN?
//                           ?-nofollow BOOLEAN?
//
// This is the main Tcl command.  When the "sqlite" Tcl command is
// invoked, this routine runs to process that command.
//
// The first argument, DBNAME, is an arbitrary name for a new
// database connection.  This command creates a new command named
// DBNAME that is used to control that connection.  The database
// connection is deleted when the DBNAME command is deleted.
//
// The second argument is the name of the database file.
//
func DbMain(tls *crt.TLS, cd uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* tclsqlite.c:3689:26: */
	bp := tls.Alloc(336)
	defer tls.Free(336)

	var p uintptr
	var zArg uintptr
	var zErrMsg uintptr
	var i int32
	var zFile uintptr = uintptr(0)
	var zVfs uintptr = uintptr(0)
	var flags int32
	*(*int32)(unsafe.Pointer(bp + 112 /* bTranslateFileName */)) = 1
	// var translatedFilename Tcl_DString at bp+120, 216

	var rc int32

	// In normal use, each TCL interpreter runs in a single thread.  So
	// by default, we can turn off mutexing on SQLite database connections.
	// However, for testing purposes it is useful to have mutexes turned
	// on.  So, by default, mutexes default off.  But if compiled with
	// SQLITE_TCL_DEFAULT_FULLMUTEX then mutexes default on.
	flags = ((0x00000002 | 0x00000004) | 0x00008000)

	if objc == 1 {
		return sqliteCmdUsage(tls, interp, objv)
	}
	if objc == 2 {
		zArg = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)), uintptr(0))
		if crt.Xstrcmp(tls, zArg, ts+20814 /* "-version" */) == 0 {
			tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, sqlite3.Xsqlite3_libversion(tls), uintptr(0)))
			return 0
		}
		if crt.Xstrcmp(tls, zArg, ts+20823 /* "-sourceid" */) == 0 {
			tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+16, sqlite3.Xsqlite3_sourceid(tls), uintptr(0)))
			return 0
		}
		if crt.Xstrcmp(tls, zArg, ts+20833 /* "-has-codec" */) == 0 {
			tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+32, ts+8293 /* "0" */, uintptr(0)))
			return 0
		}
		if int32(*(*int8)(unsafe.Pointer(zArg + uintptr(0)))) == '-' {
			return sqliteCmdUsage(tls, interp, objv)
		}
	}
	for i = 2; i < objc; i++ {
		zArg = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(i)*8)))
		if int32(*(*int8)(unsafe.Pointer(zArg + uintptr(0)))) != '-' {
			if zFile != uintptr(0) {
				return sqliteCmdUsage(tls, interp, objv)
			}
			zFile = zArg
			continue
		}
		if i == (objc - 1) {
			return sqliteCmdUsage(tls, interp, objv)
		}
		i++
		if crt.Xstrcmp(tls, zArg, ts+20844 /* "-key" */) == 0 {
		} else if crt.Xstrcmp(tls, zArg, ts+20849 /* "-vfs" */) == 0 {
			zVfs = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(i)*8)))
		} else if crt.Xstrcmp(tls, zArg, ts+19544 /* "-readonly" */) == 0 {
			// var b int32 at bp+88, 4

			if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(i)*8)), bp+88 /* &b */) != 0 {
				return 1
			}
			if *(*int32)(unsafe.Pointer(bp + 88 /* b */)) != 0 {
				flags = flags & (^int32(crt.Int32FromInt32((0x00000002 | 0x00000004))))
				flags = flags | (0x00000001)
			} else {
				flags = flags & (^int32(crt.Int32FromInt32(0x00000001)))
				flags = flags | (0x00000002)
			}
		} else if crt.Xstrcmp(tls, zArg, ts+20854 /* "-create" */) == 0 {
			// var b int32 at bp+92, 4

			if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(i)*8)), bp+92 /* &b */) != 0 {
				return 1
			}
			if (*(*int32)(unsafe.Pointer(bp + 92 /* b */)) != 0) && ((flags & 0x00000001) == 0) {
				flags = flags | (0x00000004)
			} else {
				flags = flags & (^int32(crt.Int32FromInt32(0x00000004)))
			}
		} else if crt.Xstrcmp(tls, zArg, ts+20862 /* "-nofollow" */) == 0 {
			// var b int32 at bp+96, 4

			if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(i)*8)), bp+96 /* &b */) != 0 {
				return 1
			}
			if *(*int32)(unsafe.Pointer(bp + 96 /* b */)) != 0 {
				flags = flags | (0x01000000)
			} else {
				flags = flags & (^int32(crt.Int32FromInt32(0x01000000)))
			}
		} else if crt.Xstrcmp(tls, zArg, ts+20872 /* "-nomutex" */) == 0 {
			// var b int32 at bp+100, 4

			if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(i)*8)), bp+100 /* &b */) != 0 {
				return 1
			}
			if *(*int32)(unsafe.Pointer(bp + 100 /* b */)) != 0 {
				flags = flags | (0x00008000)
				flags = flags & (^int32(crt.Int32FromInt32(0x00010000)))
			} else {
				flags = flags & (^int32(crt.Int32FromInt32(0x00008000)))
			}
		} else if crt.Xstrcmp(tls, zArg, ts+20881 /* "-fullmutex" */) == 0 {
			// var b int32 at bp+104, 4

			if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(i)*8)), bp+104 /* &b */) != 0 {
				return 1
			}
			if *(*int32)(unsafe.Pointer(bp + 104 /* b */)) != 0 {
				flags = flags | (0x00010000)
				flags = flags & (^int32(crt.Int32FromInt32(0x00008000)))
			} else {
				flags = flags & (^int32(crt.Int32FromInt32(0x00010000)))
			}
		} else if crt.Xstrcmp(tls, zArg, ts+20892 /* "-uri" */) == 0 {
			// var b int32 at bp+108, 4

			if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(i)*8)), bp+108 /* &b */) != 0 {
				return 1
			}
			if *(*int32)(unsafe.Pointer(bp + 108 /* b */)) != 0 {
				flags = flags | (0x00000040)
			} else {
				flags = flags & (^int32(crt.Int32FromInt32(0x00000040)))
			}
		} else if crt.Xstrcmp(tls, zArg, ts+20897 /* "-translatefilena..." */) == 0 {
			if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(i)*8)), bp+112 /* &bTranslateFileName */) != 0 {
				return 1
			}
		} else {
			tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+48, ts+20916 /* "unknown option: " */, zArg, uintptr(0)))
			return 1
		}
	}
	zErrMsg = uintptr(0)
	p = tcl.XTcl_Alloc(tls, uint32(unsafe.Sizeof(SqliteDb{})))
	crt.Xmemset(tls, p, 0, uint64(unsafe.Sizeof(SqliteDb{})))
	if zFile == uintptr(0) {
		zFile = ts + 792 /* "" */
	}
	if *(*int32)(unsafe.Pointer(bp + 112 /* bTranslateFileName */)) != 0 {
		zFile = tcl.XTcl_TranslateFileName(tls, interp, zFile, bp+120 /* &translatedFilename */)
	}
	rc = sqlite3.Xsqlite3_open_v2(tls, zFile, (p /* &.db */), flags, zVfs)
	if *(*int32)(unsafe.Pointer(bp + 112 /* bTranslateFileName */)) != 0 {
		tcl.XTcl_DStringFree(tls, bp+120 /* &translatedFilename */)
	}
	if (*SqliteDb)(unsafe.Pointer(p)).Fdb != 0 {
		if 0 != sqlite3.Xsqlite3_errcode(tls, (*SqliteDb)(unsafe.Pointer(p)).Fdb) {
			zErrMsg = sqlite3.Xsqlite3_mprintf(tls, ts+130 /* "%s" */, crt.VaList(bp+72, sqlite3.Xsqlite3_errmsg(tls, (*SqliteDb)(unsafe.Pointer(p)).Fdb)))
			sqlite3.Xsqlite3_close(tls, (*SqliteDb)(unsafe.Pointer(p)).Fdb)
			(*SqliteDb)(unsafe.Pointer(p)).Fdb = uintptr(0)
		}
	} else {
		zErrMsg = sqlite3.Xsqlite3_mprintf(tls, ts+130 /* "%s" */, crt.VaList(bp+80, sqlite3.Xsqlite3_errstr(tls, rc)))
	}
	if (*SqliteDb)(unsafe.Pointer(p)).Fdb == uintptr(0) {
		tcl.XTcl_SetResult(tls, interp, zErrMsg, uintptr(1))
		tcl.XTcl_Free(tls, p)
		sqlite3.Xsqlite3_free(tls, zErrMsg)
		return 1
	}
	(*SqliteDb)(unsafe.Pointer(p)).FmaxStmt = 10
	(*SqliteDb)(unsafe.Pointer(p)).FopenFlags = (flags & 0x00000040)
	(*SqliteDb)(unsafe.Pointer(p)).Finterp = interp
	zArg = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)), uintptr(0))
	if DbUseNre(tls) != 0 {
		tcl.XTcl_NRCreateCommand(tls, interp, zArg, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
		}{DbObjCmdAdaptor})), *(*uintptr)(unsafe.Pointer(&struct {
			f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
		}{DbObjCmd})),
			p, *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, uintptr) }{DbDeleteCmd})))
	} else {
		tcl.XTcl_CreateObjCommand(tls, interp, zArg, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
		}{DbObjCmd})), p, *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, uintptr) }{DbDeleteCmd})))
	}
	return 0
}

// Provide a dummy Tcl_InitStubs if we are using this as a static
// library.

// Make sure we have a PACKAGE_VERSION macro defined.  This will be
// defined automatically by the TEA makefile.  But other makefiles
// do not define it.

// Initialize this module.
//
// This Tcl module contains only a single new Tcl command named "sqlite".
// (Hence there is no namespace.  There is no point in using a namespace
// if the extension only supplies one new name!)  The "sqlite" command is
// used to open a new SQLite database.  See the DbMain() routine above
// for additional information.
//
// The EXTERN macros are required by TCL in order to work on windows.
func Sqlite3_Init(tls *crt.TLS, interp uintptr) int32 { /* tclsqlite.c:3877:12: */
	var rc int32
	if 1 != 0 {
		rc = 0
	} else {
		rc = 1
	}
	if rc == 0 {
		tcl.XTcl_CreateObjCommand(tls, interp, ts+20933 /* "sqlite3" */, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
		}{DbMain})), uintptr(0), uintptr(0))
		// The "sqlite" alias is undocumented.  It is here only to support
		// legacy scripts.  All new scripts should use only the "sqlite3"
		// command.
		tcl.XTcl_CreateObjCommand(tls, interp, ts+20941 /* "sqlite" */, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
		}{DbMain})), uintptr(0), uintptr(0))
		rc = tcl.XTcl_PkgProvideEx(tls, interp, ts+20933 /* "sqlite3" */, ts+20948 /* "3.32.3" */, uintptr(0))
	}
	return rc
}
func Tclsqlite3_Init(tls *crt.TLS, interp uintptr) int32 { /* tclsqlite.c:3891:12: */
	return Sqlite3_Init(tls, interp)
}
func Sqlite3_Unload(tls *crt.TLS, interp uintptr, flags int32) int32 { /* tclsqlite.c:3892:12: */
	return 0
}
func Tclsqlite3_Unload(tls *crt.TLS, interp uintptr, flags int32) int32 { /* tclsqlite.c:3893:12: */
	return 0
}

// Because it accesses the file-system and uses persistent state, SQLite
// is not considered appropriate for safe interpreters.  Hence, we cause
// the _SafeInit() interfaces return TCL_ERROR.
func Sqlite3_SafeInit(tls *crt.TLS, interp uintptr) int32 { /* tclsqlite.c:3899:12: */ return 1 }
func Sqlite3_SafeUnload(tls *crt.TLS, interp uintptr, flags int32) int32 { /* tclsqlite.c:3900:12: */
	return 1
}

func Sqlite_Init(tls *crt.TLS, interp uintptr) int32 { /* tclsqlite.c:3905:5: */
	return Sqlite3_Init(tls, interp)
}
func Tclsqlite_Init(tls *crt.TLS, interp uintptr) int32 { /* tclsqlite.c:3906:5: */
	return Sqlite3_Init(tls, interp)
}
func Sqlite_Unload(tls *crt.TLS, interp uintptr, flags int32) int32 { /* tclsqlite.c:3907:5: */
	return 0
}
func Tclsqlite_Unload(tls *crt.TLS, interp uintptr, flags int32) int32 { /* tclsqlite.c:3908:5: */
	return 0
}

// If the TCLSH macro is defined, add code to make a stand-alone program.

// This is the main routine for an ordinary TCL shell.  If there are
// are arguments, run the first argument as a script.  Otherwise,
// read TCL commands from standard input
func tclsh_main_loop(tls *crt.TLS) uintptr { /* tclsqlite.c:3920:19: */
	return uintptr(unsafe.Pointer(&zMainloop))
}

var zMainloop = *(*[431]int8)(unsafe.Pointer(ts + 20955 /* "if {[llength $ar..." */)) /* tclsqlite.c:3921:21 */

func main(tls *crt.TLS, argc int32, argv uintptr) int32 { /* tclsqlite.c:3953:18: */
	bp := tls.Alloc(64)
	defer tls.Free(64)

	var interp uintptr
	var i int32
	var zScript uintptr = uintptr(0)
	// var zArgc [32]int8 at bp+32, 32

	if crt.Xgetenv(tls, ts+21386 /* "SQLITE_DEBUG_BRE..." */) != 0 {
		if (crt.Xisatty(tls, 0) != 0) && (crt.Xisatty(tls, 2) != 0) {
			crt.Xfprintf(tls, crt.Xstderr,
				ts+21405, /* "attach debugger ..." */
				crt.VaList(bp, crt.Xgetpid(tls)))
			crt.Xfgetc(tls, crt.Xstdin)
		} else {
			crt.Xraise(tls, 5)
		}
	}

	// Call sqlite3_shutdown() once before doing anything else. This is to
	// test that sqlite3_shutdown() can be safely called by a process before
	// sqlite3_initialize() is.
	sqlite3.Xsqlite3_shutdown(tls)

	tcl.XTcl_FindExecutable(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)))
	tcl.XTcl_SetSystemEncoding(tls, uintptr(0), ts+21467 /* "utf-8" */)
	interp = tcl.XTcl_CreateInterp(tls)
	Sqlite3_Init(tls, interp)

	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([32]int8{})), bp+32 /* &zArgc[0] */, ts+1647 /* "%d" */, crt.VaList(bp+8, (argc-1)))
	tcl.XTcl_SetVar2(tls, interp, ts+21473 /* "argc" */, uintptr(0), bp+32 /* &zArgc[0] */, 1)
	tcl.XTcl_SetVar2(tls, interp, ts+21478 /* "argv0" */, uintptr(0), *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)), 1)
	tcl.XTcl_SetVar2(tls, interp, ts+21484 /* "argv" */, uintptr(0), ts+792 /* "" */, 1)
	for i = 1; i < argc; i++ {
		tcl.XTcl_SetVar2(tls, interp, ts+21484 /* "argv" */, uintptr(0), *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8)), ((1 | 8) | 4))
	}
	zScript = sqlite3TestInit(tls, interp)
	if zScript == uintptr(0) {
		zScript = tclsh_main_loop(tls)
	}
	if tcl.XTcl_GlobalEval(tls, interp, zScript) != 0 {
		var zInfo uintptr = tcl.XTcl_GetVar2(tls, interp, ts+21489 /* "errorInfo" */, uintptr(0), 1)
		if zInfo == uintptr(0) {
			zInfo = tcl.XTcl_GetStringResult(tls, interp)
		}
		crt.Xfprintf(tls, crt.Xstderr, ts+21499 /* "%s: %s\n" */, crt.VaList(bp+16, *(*uintptr)(unsafe.Pointer(argv)), zInfo))
		return 1
	}
	return 0
}

// CAPI3REF: Database Connection Handle
// KEYWORDS: {database connection} {database connections}
//
// Each open SQLite database is represented by a pointer to an instance of
// the opaque structure named "sqlite3".  It is useful to think of an sqlite3
// pointer as an object.  The [sqlite3_open()], [sqlite3_open16()], and
// [sqlite3_open_v2()] interfaces are its constructors, and [sqlite3_close()]
// and [sqlite3_close_v2()] are its destructors.  There are many other
// interfaces (such as
// [sqlite3_prepare_v2()], [sqlite3_create_function()], and
// [sqlite3_busy_timeout()] to name but three) that are methods on an
// sqlite3 object.
type sqlite31 = sqlite32 /* sqlite3.h:249:24 */

// CAPI3REF: Dynamically Typed Value Object
// KEYWORDS: {protected sqlite3_value} {unprotected sqlite3_value}
//
// SQLite uses the sqlite3_value object to represent all values
// that can be stored in a database table. SQLite uses dynamic typing
// for the values it stores.  ^Values stored in sqlite3_value objects
// can be integers, floating point values, strings, BLOBs, or NULL.
//
// An sqlite3_value object may be either "protected" or "unprotected".
// Some interfaces require a protected sqlite3_value.  Other interfaces
// will accept either a protected or an unprotected sqlite3_value.
// Every interface that accepts sqlite3_value arguments specifies
// whether or not it requires a protected sqlite3_value.  The
// [sqlite3_value_dup()] interface can be used to construct a new
// protected sqlite3_value from an unprotected sqlite3_value.
//
// The terms "protected" and "unprotected" refer to whether or not
// a mutex is held.  An internal mutex is held for a protected
// sqlite3_value object but no mutex is held for an unprotected
// sqlite3_value object.  If SQLite is compiled to be single-threaded
// (with [SQLITE_THREADSAFE=0] and with [sqlite3_threadsafe()] returning 0)
// or if SQLite is run in one of reduced mutex modes
// [SQLITE_CONFIG_SINGLETHREAD] or [SQLITE_CONFIG_MULTITHREAD]
// then there is no distinction between protected and unprotected
// sqlite3_value objects and they can be used interchangeably.  However,
// for maximum code portability it is recommended that applications
// still make the distinction between protected and unprotected
// sqlite3_value objects even when not strictly required.
//
// ^The sqlite3_value objects that are passed as parameters into the
// implementation of [application-defined SQL functions] are protected.
// ^The sqlite3_value object returned by
// [sqlite3_column_value()] is unprotected.
// Unprotected sqlite3_value objects may only be used as arguments
// to [sqlite3_result_value()], [sqlite3_bind_value()], and
// [sqlite3_value_dup()].
// The [sqlite3_value_blob | sqlite3_value_type()] family of
// interfaces require protected sqlite3_value objects.
type sqlite3_value = sqlite3_value1 /* sqlite3.h:4242:30 */

// CAPI3REF: SQL Function Context Object
//
// The context in which an SQL function executes is stored in an
// sqlite3_context object.  ^A pointer to an sqlite3_context object
// is always first parameter to [application-defined SQL functions].
// The application-defined SQL function implementation will pass this
// pointer through into calls to [sqlite3_result_int | sqlite3_result()],
// [sqlite3_aggregate_context()], [sqlite3_user_data()],
// [sqlite3_context_db_handle()], [sqlite3_get_auxdata()],
// and/or [sqlite3_set_auxdata()].
type sqlite3_context = sqlite3_context1 /* sqlite3.h:4256:32 */

// CAPI3REF: Dynamic String Object
// KEYWORDS: {dynamic string}
//
// An instance of the sqlite3_str object contains a dynamically-sized
// string under construction.
//
// The lifecycle of an sqlite3_str object is as follows:
// <ol>
// <li> ^The sqlite3_str object is created using [sqlite3_str_new()].
// <li> ^Text is appended to the sqlite3_str object using various
// methods, such as [sqlite3_str_appendf()].
// <li> ^The sqlite3_str object is destroyed and the string it created
// is returned using the [sqlite3_str_finish()] interface.
// </ol>
type sqlite3_str = sqlite3_str1 /* sqlite3.h:7778:28 */

// Is the sqlite3ErrName() function needed in the build?  Currently,
// it is needed by "mutex_w32.c" (when debugging), "os_win.c" (when
// OSTRACE is enabled), and by several "test*.c" files (which are
// compiled using SQLITE_TEST).

// SQLITE_ENABLE_EXPLAIN_COMMENTS is incompatible with SQLITE_OMIT_EXPLAIN

// Return true (non-zero) if the input is an integer that is too large
// to fit in 32-bits.  This macro is used inside of various testcase()
// macros to verify that we have tested SQLite for large-file support.

// The macro unlikely() is a hint that surrounds a boolean
// expression that is usually false.  Macro likely() surrounds
// a boolean expression that is usually true.  These hints could,
// in theory, be used by the compiler to generate better code, but
// currently they are just comments for human readers.

// 2001 September 22
//
// The author disclaims copyright to this source code.  In place of
// a legal notice, here is a blessing:
//
//    May you do good and not evil.
//    May you find forgiveness for yourself and forgive others.
//    May you share freely, never taking more than you give.
//
//
// This is the header file for the generic hash-table implementation
// used in SQLite.

// Forward declarations of structures.
type Hash1 = struct {
	Fhtsize uint32
	Fcount  uint32
	Ffirst  uintptr
	Fht     uintptr
}

// Is the sqlite3ErrName() function needed in the build?  Currently,
// it is needed by "mutex_w32.c" (when debugging), "os_win.c" (when
// OSTRACE is enabled), and by several "test*.c" files (which are
// compiled using SQLITE_TEST).

// SQLITE_ENABLE_EXPLAIN_COMMENTS is incompatible with SQLITE_OMIT_EXPLAIN

// Return true (non-zero) if the input is an integer that is too large
// to fit in 32-bits.  This macro is used inside of various testcase()
// macros to verify that we have tested SQLite for large-file support.

// The macro unlikely() is a hint that surrounds a boolean
// expression that is usually false.  Macro likely() surrounds
// a boolean expression that is usually true.  These hints could,
// in theory, be used by the compiler to generate better code, but
// currently they are just comments for human readers.

// 2001 September 22
//
// The author disclaims copyright to this source code.  In place of
// a legal notice, here is a blessing:
//
//    May you do good and not evil.
//    May you find forgiveness for yourself and forgive others.
//    May you share freely, never taking more than you give.
//
//
// This is the header file for the generic hash-table implementation
// used in SQLite.

// Forward declarations of structures.
type Hash = Hash1 /* hash.h:19:21 */
type HashElem1 = struct {
	Fnext uintptr
	Fprev uintptr
	Fdata uintptr
	FpKey uintptr
}

type HashElem = HashElem1 /* hash.h:20:25 */

// A complete hash table is an instance of the following structure.
// The internals of this structure are intended to be opaque -- client
// code should not attempt to access or modify the fields of this structure
// directly.  Change this structure only by using the routines below.
// However, some of the "procedures" and "functions" for modifying and
// accessing this structure are really macros, so we can't really make
// this structure opaque.
//
// All elements of the hash table are on a single doubly-linked list.
// Hash.first points to the head of this list.
//
// There are Hash.htsize buckets.  Each bucket points to a spot in
// the global doubly-linked list.  The contents of the bucket are the
// element pointed to plus the next _ht.count-1 elements in the list.
//
// Hash.htsize and Hash.ht may be zero.  In that case lookup is done
// by a linear search of the global list.  For small tables, the
// Hash.ht table is never allocated because if there are few elements
// in the table, it is faster to do a linear search than to manage
// the hash table.
type _ht = struct {
	Fcount uint32
	Fchain uintptr
}

type off64_t = int64        /* stdio.h:70:19 */
type fpos64_t = _G_fpos64_t /* stdio.h:89:20 */
type ino64_t = uint64       /* types.h:54:19 */ // Type to count file system inodes.

type blkcnt64_t = int64    /* types.h:236:22 */ // Type to count number of disk blocks.
type fsblkcnt64_t = uint64 /* types.h:237:24 */ // Type to count file system blocks.
type fsfilcnt64_t = uint64 /* types.h:238:24 */

// If this symbol has done its job, get rid of it.

// Unsigned type of `sizeof' something.

// Define this type if we are doing the whole job,
//   or if we want this type in particular.

// Wide character type.
//   Locale-writers should change this as necessary to
//   be big enough to hold unique values not between 0 and 127,
//   and not (wchar_t) -1, for each defined multibyte character.

// Define this type if we are doing the whole job,
//   or if we want this type in particular.

//  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
//    are already defined.
//  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.
//  NetBSD 5 requires the I386_ANSI_H and X86_64_ANSI_H checks here.

// A null pointer constant.

// Offset of member MEMBER in a struct of type TYPE.

// Type whose alignment is supported in every context and is at least
//   as great as that of any standard type not using alignment
//   specifiers.
type max_align_t = struct {
	F__max_align_ll int64
	F__max_align_ld float64
}                /* stddef.h:437:3 */     // 2-byte unsigned integer
type i16 = int16 /* sqliteInt.h:773:20 */ // 1-byte unsigned integer
type i8 = int8   /* sqliteInt.h:775:19 */ // 1-byte signed integer

// SQLITE_MAX_U32 is a u64 constant that is the maximum u64 value
// that can be stored in a u32 without loss of data.  The value
// is 0x00000000ffffffff.  But because of quirks of some compilers, we
// have to specify the value in the less intuitive manner shown:

// The datatype used to store estimates of the number of rows in a
// table or index.  This is an unsigned integer type.  For 99.9% of
// the world, a 32-bit integer is sufficient.  But a 64-bit integer
// can be used at compile-time if desired.
type tRowcnt = u32 /* sqliteInt.h:794:14 */ // 32-bit is the default

// Estimated quantities used for query planning are stored as 16-bit
// logarithms.  For quantity X, the value stored is 10*log2(X).  This
// gives a possible range of values of approximately 1.0e986 to 1e-986.
// But the allowed values are "grainy".  Not every value is representable.
// For example, quantities 16 and 17 are both represented by a LogEst
// of 40.  However, since LogEst quantities are suppose to be estimates,
// not exact values, this imprecision is not a problem.
//
// "LogEst" is short for "Logarithmic Estimate".
//
// Examples:
//      1 -> 0              20 -> 43          10000 -> 132
//      2 -> 10             25 -> 46          25000 -> 146
//      3 -> 16            100 -> 66        1000000 -> 199
//      4 -> 20           1000 -> 99        1048576 -> 200
//     10 -> 33           1024 -> 100    4294967296 -> 320
//
// The LogEst can be negative to indicate fractional values.
// Examples:
//
//    0.5 -> -10           0.1 -> -33        0.0625 -> -40
type LogEst = int16 /* sqliteInt.h:820:20 */

// Set the SQLITE_PTRSIZE macro to the number of bytes in a pointer

// The uptr type is an unsigned integer large enough to hold a pointer
type uptr = u64 /* sqliteInt.h:844:15 */

// The SQLITE_WITHIN(P,S,E) macro checks to see if pointer P points to
// something between S (inclusive) and E (exclusive).
//
// In other words, S is a buffer and E is a pointer to the first byte after
// the end of buffer S.  This macro returns true if P points to something
// contained within the buffer S.

// Macros to determine whether the machine is big or little endian,
// and whether or not that determination is run-time or compile-time.
//
// For best performance, an attempt is made to guess at the byte-order
// using C-preprocessor macros.  If that is unsuccessful, or if
// -DSQLITE_BYTEORDER=0 is set, then byte-order is determined
// at run-time.

// Constants for the largest and smallest possible 64-bit signed integers.
// These macros are designed to work correctly on both 32-bit and 64-bit
// compilers.

// Round up a number to the next larger multiple of 8.  This is used
// to force 8-byte alignment on 64-bit architectures.

// Round down to the nearest multiple of 8

// Assert that the pointer X is aligned to an 8-byte boundary.  This
// macro is used only within assert() to verify that the code gets
// all alignment restrictions correct.
//
// Except, if SQLITE_4_BYTE_ALIGNED_MALLOC is defined, then the
// underlying malloc() implementation might return us 4-byte aligned
// pointers.  In that case, only verify 4-byte alignment.

// Disable MMAP on platforms where it is known to not work

// Default maximum size of memory used by memory-mapped I/O in the VFS

// The default MMAP_SIZE is zero on all platforms.  Or, even if a larger
// default MMAP_SIZE is specified at compile-time, make sure that it does
// not exceed the maximum mmap size.

// SELECTTRACE_ENABLED will be either 1 or 0 depending on whether or not
// the Select query generator tracing logic is turned on.

// An instance of the following structure is used to store the busy-handler
// callback for a given sqlite handle.
//
// The sqlite.busyHandler member of the sqlite struct contains the busy
// callback for the database handle. Each pager opened via the sqlite
// handle is passed a pointer to sqlite.busyHandler. The busy-handler
// callback is currently invoked only from within pager.c.
type BusyHandler1 = struct {
	FxBusyHandler uintptr
	FpBusyArg     uintptr
	FnBusy        int32
	_             [4]byte
}

// The SQLITE_WITHIN(P,S,E) macro checks to see if pointer P points to
// something between S (inclusive) and E (exclusive).
//
// In other words, S is a buffer and E is a pointer to the first byte after
// the end of buffer S.  This macro returns true if P points to something
// contained within the buffer S.

// Macros to determine whether the machine is big or little endian,
// and whether or not that determination is run-time or compile-time.
//
// For best performance, an attempt is made to guess at the byte-order
// using C-preprocessor macros.  If that is unsuccessful, or if
// -DSQLITE_BYTEORDER=0 is set, then byte-order is determined
// at run-time.

// Constants for the largest and smallest possible 64-bit signed integers.
// These macros are designed to work correctly on both 32-bit and 64-bit
// compilers.

// Round up a number to the next larger multiple of 8.  This is used
// to force 8-byte alignment on 64-bit architectures.

// Round down to the nearest multiple of 8

// Assert that the pointer X is aligned to an 8-byte boundary.  This
// macro is used only within assert() to verify that the code gets
// all alignment restrictions correct.
//
// Except, if SQLITE_4_BYTE_ALIGNED_MALLOC is defined, then the
// underlying malloc() implementation might return us 4-byte aligned
// pointers.  In that case, only verify 4-byte alignment.

// Disable MMAP on platforms where it is known to not work

// Default maximum size of memory used by memory-mapped I/O in the VFS

// The default MMAP_SIZE is zero on all platforms.  Or, even if a larger
// default MMAP_SIZE is specified at compile-time, make sure that it does
// not exceed the maximum mmap size.

// SELECTTRACE_ENABLED will be either 1 or 0 depending on whether or not
// the Select query generator tracing logic is turned on.

// An instance of the following structure is used to store the busy-handler
// callback for a given sqlite handle.
//
// The sqlite.busyHandler member of the sqlite struct contains the busy
// callback for the database handle. Each pager opened via the sqlite
// handle is passed a pointer to sqlite.busyHandler. The busy-handler
// callback is currently invoked only from within pager.c.
type BusyHandler = BusyHandler1 /* sqliteInt.h:992:28 */

// Name of the master database table.  The master database table
// is a special table that holds the names and attributes of all
// user tables and indices.

// The root-page of the master database table.

// The name of the schema table.

// A convenience macro that returns the number of elements in
// an array.

// Determine if the argument is a power of two

// The following value as a destructor means to use sqlite3DbFree().
// The sqlite3DbFree() routine requires two parameters instead of the
// one parameter that destructors normally want.  So we have to introduce
// this magic value that the code knows to handle differently.  Any
// pointer will work here as long as it is distinct from SQLITE_STATIC
// and SQLITE_TRANSIENT.

// When SQLITE_OMIT_WSD is defined, it means that the target platform does
// not support Writable Static Data (WSD) such as global and static variables.
// All variables must either be on the stack or dynamically allocated from
// the heap.  When WSD is unsupported, the variable declarations scattered
// throughout the SQLite code must become constants instead.  The SQLITE_WSD
// macro is used for this purpose.  And instead of referencing the variable
// directly, we use its constant as a key to lookup the run-time allocated
// buffer that holds real variable.  The constant is also the initializer
// for the run-time allocated buffer.
//
// In the usual case where WSD is supported, the SQLITE_WSD and GLOBAL
// macros become no-ops and have zero performance impact.

// The following macros are used to suppress compiler warnings and to
// make it clear to human readers when a function parameter is deliberately
// left unused within the body of a function. This usually happens when
// a function is called via a function pointer. For example the
// implementation of an SQL aggregate step callback may not use the
// parameter indicating the number of arguments passed to the aggregate,
// if it knows that this is enforced elsewhere.
//
// When a function parameter is not used at all within the body of a function,
// it is generally named "NotUsed" or "NotUsed2" to make things even clearer.
// However, these macros may also be used to suppress warnings related to
// parameters that may or may not be used depending on compilation options.
// For example those parameters only used in assert() statements. In these
// cases the parameters are named as per the usual conventions.

// Forward references to structures
type AggInfo1 = struct {
	FdirectMode     u8
	FuseSortingIdx  u8
	FsortingIdx     int32
	FsortingIdxPTab int32
	FnSortingColumn int32
	FmnReg          int32
	FmxReg          int32
	FpGroupBy       uintptr
	FaCol           uintptr
	FnColumn        int32
	FnAccumulator   int32
	FaFunc          uintptr
	FnFunc          int32
	FpNext          uintptr
}

// Name of the master database table.  The master database table
// is a special table that holds the names and attributes of all
// user tables and indices.

// The root-page of the master database table.

// The name of the schema table.

// A convenience macro that returns the number of elements in
// an array.

// Determine if the argument is a power of two

// The following value as a destructor means to use sqlite3DbFree().
// The sqlite3DbFree() routine requires two parameters instead of the
// one parameter that destructors normally want.  So we have to introduce
// this magic value that the code knows to handle differently.  Any
// pointer will work here as long as it is distinct from SQLITE_STATIC
// and SQLITE_TRANSIENT.

// When SQLITE_OMIT_WSD is defined, it means that the target platform does
// not support Writable Static Data (WSD) such as global and static variables.
// All variables must either be on the stack or dynamically allocated from
// the heap.  When WSD is unsupported, the variable declarations scattered
// throughout the SQLite code must become constants instead.  The SQLITE_WSD
// macro is used for this purpose.  And instead of referencing the variable
// directly, we use its constant as a key to lookup the run-time allocated
// buffer that holds real variable.  The constant is also the initializer
// for the run-time allocated buffer.
//
// In the usual case where WSD is supported, the SQLITE_WSD and GLOBAL
// macros become no-ops and have zero performance impact.

// The following macros are used to suppress compiler warnings and to
// make it clear to human readers when a function parameter is deliberately
// left unused within the body of a function. This usually happens when
// a function is called via a function pointer. For example the
// implementation of an SQL aggregate step callback may not use the
// parameter indicating the number of arguments passed to the aggregate,
// if it knows that this is enforced elsewhere.
//
// When a function parameter is not used at all within the body of a function,
// it is generally named "NotUsed" or "NotUsed2" to make things even clearer.
// However, these macros may also be used to suppress warnings related to
// parameters that may or may not be used depending on compilation options.
// For example those parameters only used in assert() statements. In these
// cases the parameters are named as per the usual conventions.

// Forward references to structures
type AggInfo = AggInfo1 /* sqliteInt.h:1086:24 */
type AuthContext1 = struct {
	FzAuthContext uintptr
	FpParse       uintptr
}

type AuthContext = AuthContext1 /* sqliteInt.h:1087:28 */
type AutoincInfo1 = struct {
	FpNext  uintptr
	FpTab   uintptr
	FiDb    int32
	FregCtr int32
}

type AutoincInfo = AutoincInfo1 /* sqliteInt.h:1088:28 */
type CollSeq1 = struct {
	FzName uintptr
	Fenc   u8
	FpUser uintptr
	FxCmp  uintptr
	FxDel  uintptr
}

type CollSeq = CollSeq1 /* sqliteInt.h:1090:24 */
type Column1 = struct {
	FzName    uintptr
	FpDflt    uintptr
	FzColl    uintptr
	FnotNull  u8
	Faffinity int8
	FszEst    u8
	FhName    u8
	FcolFlags u16
	_         [2]byte
}

type Column = Column1 /* sqliteInt.h:1091:23 */
type Db1 = struct {
	FzDbSName     uintptr
	FpBt          uintptr
	Fsafety_level u8
	FbSyncSet     u8
	FpSchema      uintptr
}

type Db = Db1 /* sqliteInt.h:1092:19 */
type Schema1 = struct {
	Fschema_cookie int32
	FiGeneration   int32
	FtblHash       Hash
	FidxHash       Hash
	FtrigHash      Hash
	FfkeyHash      Hash
	FpSeqTab       uintptr
	Ffile_format   u8
	Fenc           u8
	FschemaFlags   u16
	Fcache_size    int32
}

type Schema = Schema1 /* sqliteInt.h:1093:23 */
type Expr1 = struct {
	Fop              u8
	FaffExpr         int8
	Fop2             u8
	Fflags           u32
	Fu               struct{ FzToken uintptr }
	FpLeft           uintptr
	FpRight          uintptr
	Fx               struct{ FpList uintptr }
	FiTable          int32
	FiColumn         ynVar
	FiAgg            i16
	FiRightJoinTable i16
	FpAggInfo        uintptr
	Fy               struct{ FpTab uintptr }
}

type Expr = Expr1 /* sqliteInt.h:1094:21 */
type ExprList1 = struct {
	FnExpr int32
	Fa     [1]struct {
		FpExpr     uintptr
		FzEName    uintptr
		FsortFlags u8
		_          [3]byte
		FeEName    uint8 /* unsigned eEName: 2, unsigned done: 1, unsigned reusable: 1, unsigned bSorterRef: 1, unsigned bNulls: 1 */
		Fu         struct {
			_  [0]uint32
			Fx struct {
				FiOrderByCol u16
				FiAlias      u16
			}
		}
		_ [4]byte
	}
}

type ExprList = ExprList1 /* sqliteInt.h:1095:25 */
type FKey1 = struct {
	FpFrom      uintptr
	FpNextFrom  uintptr
	FzTo        uintptr
	FpNextTo    uintptr
	FpPrevTo    uintptr
	FnCol       int32
	FisDeferred u8
	FaAction    [2]u8
	FapTrigger  [2]uintptr
	FaCol       [1]struct {
		FiFrom int32
		FzCol  uintptr
	}
}

type FKey = FKey1 /* sqliteInt.h:1096:21 */
type FuncDestructor1 = struct {
	FnRef      int32
	FxDestroy  uintptr
	FpUserData uintptr
}

type FuncDestructor = FuncDestructor1 /* sqliteInt.h:1097:31 */
type FuncDef1 = struct {
	FnArg      i8
	FfuncFlags u32
	FpUserData uintptr
	FpNext     uintptr
	FxSFunc    uintptr
	FxFinalize uintptr
	FxValue    uintptr
	FxInverse  uintptr
	FzName     uintptr
	Fu         struct{ FpHash uintptr }
}

type FuncDef = FuncDef1 /* sqliteInt.h:1098:24 */
type FuncDefHash1 = struct{ Fa [23]uintptr }

type FuncDefHash = FuncDefHash1 /* sqliteInt.h:1099:28 */
type IdList1 = struct {
	Fa   uintptr
	FnId int32
	_    [4]byte
}

type IdList = IdList1 /* sqliteInt.h:1100:23 */
type Index1 = struct {
	FzName         uintptr
	FaiColumn      uintptr
	FaiRowLogEst   uintptr
	FpTable        uintptr
	FzColAff       uintptr
	FpNext         uintptr
	FpSchema       uintptr
	FaSortOrder    uintptr
	FazColl        uintptr
	FpPartIdxWhere uintptr
	FaColExpr      uintptr
	Ftnum          int32
	FszIdxRow      LogEst
	FnKeyCol       u16
	FnColumn       u16
	FonError       u8
	FidxType       uint16 /* unsigned idxType: 2, unsigned bUnordered: 1, unsigned uniqNotNull: 1, unsigned isResized: 1, unsigned isCovering: 1, unsigned noSkipScan: 1, unsigned hasStat1: 1, unsigned bNoQuery: 1, unsigned bAscKeyBug: 1, unsigned bHasVCol: 1 */
	FcolNotIdxed   Bitmask
}

type Index = Index1 /* sqliteInt.h:1101:22 */
type IndexSample1 = struct {
	Fp     uintptr
	Fn     int32
	FanEq  uintptr
	FanLt  uintptr
	FanDLt uintptr
}

type IndexSample = IndexSample1 /* sqliteInt.h:1102:28 */
type KeyInfo1 = struct {
	FnRef       u32
	Fenc        u8
	FnKeyField  u16
	FnAllField  u16
	Fdb         uintptr
	FaSortFlags uintptr
	FaColl      [1]uintptr
}

type KeyInfo = KeyInfo1 /* sqliteInt.h:1104:24 */
type Lookaside1 = struct {
	FbDisable   u32
	Fsz         u16
	FszTrue     u16
	FbMalloced  u8
	FnSlot      u32
	FanStat     [3]u32
	FpInit      uintptr
	FpFree      uintptr
	FpSmallInit uintptr
	FpSmallFree uintptr
	FpMiddle    uintptr
	FpStart     uintptr
	FpEnd       uintptr
}

type Lookaside = Lookaside1 /* sqliteInt.h:1105:26 */
type LookasideSlot1 = struct{ FpNext uintptr }

type LookasideSlot = LookasideSlot1 /* sqliteInt.h:1106:30 */
type Module1 = struct {
	FpModule    uintptr
	FzName      uintptr
	FnRefModule int32
	FpAux       uintptr
	FxDestroy   uintptr
	FpEpoTab    uintptr
}

type Module = Module1 /* sqliteInt.h:1107:23 */
type NameContext1 = struct {
	FpParse     uintptr
	FpSrcList   uintptr
	FuNC        struct{ FpEList uintptr }
	FpNext      uintptr
	FnRef       int32
	FnErr       int32
	FncFlags    int32
	FpWinSelect uintptr
}

type NameContext = NameContext1 /* sqliteInt.h:1108:28 */
type Parse1 = struct {
	Fdb               uintptr
	FzErrMsg          uintptr
	FpVdbe            uintptr
	Frc               int32
	FcolNamesSet      u8
	FcheckSchema      u8
	Fnested           u8
	FnTempReg         u8
	FisMultiWrite     u8
	FmayAbort         u8
	FhasCompound      u8
	FokConstFactor    u8
	FdisableLookaside u8
	FdisableVtab      u8
	FnRangeReg        int32
	FiRangeReg        int32
	FnErr             int32
	FnTab             int32
	FnMem             int32
	FszOpAlloc        int32
	FiSelfTab         int32
	FnLabel           int32
	FnLabelAlloc      int32
	FaLabel           uintptr
	FpConstExpr       uintptr
	FconstraintName   Token
	FwriteMask        yDbMask
	FcookieMask       yDbMask
	FregRowid         int32
	FregRoot          int32
	FnMaxArg          int32
	FnSelect          int32
	FnTableLock       int32
	FaTableLock       uintptr
	FpAinc            uintptr
	FpToplevel        uintptr
	FpTriggerTab      uintptr
	FpParentParse     uintptr
	FpAggList         uintptr
	FaddrCrTab        int32
	FnQueryLoop       u32
	Foldmask          u32
	Fnewmask          u32
	FeTriggerOp       u8
	FeOrconf          u8
	FdisableTriggers  u8
	FaTempReg         [8]int32
	FsNameToken       Token
	FsLastToken       Token
	FnVar             ynVar
	FiPkSortOrder     u8
	Fexplain          u8
	FeParseMode       u8
	FnVtabLock        int32
	FnHeight          int32
	FaddrExplain      int32
	FpVList           uintptr
	FpReprepare       uintptr
	FzTail            uintptr
	FpNewTable        uintptr
	FpNewIndex        uintptr
	FpNewTrigger      uintptr
	FzAuthContext     uintptr
	FsArg             Token
	FapVtabLock       uintptr
	FpZombieTab       uintptr
	FpTriggerPrg      uintptr
	FpWith            uintptr
	FpWithToFree      uintptr
	FpRename          uintptr
}

type Parse = Parse1 /* sqliteInt.h:1109:22 */
type PreUpdate1 = struct {
	Fv            uintptr
	FpCsr         uintptr
	Fop           int32
	FaRecord      uintptr
	Fkeyinfo      KeyInfo
	FpUnpacked    uintptr
	FpNewUnpacked uintptr
	FiNewReg      int32
	FiKey1        i64
	FiKey2        i64
	FaNew         uintptr
	FpTab         uintptr
	FpPk          uintptr
}

type PreUpdate = PreUpdate1 /* sqliteInt.h:1110:26 */
type PrintfArguments1 = struct {
	FnArg  int32
	FnUsed int32
	FapArg uintptr
}

type PrintfArguments = PrintfArguments1 /* sqliteInt.h:1111:32 */
type Savepoint1 = struct {
	FzName            uintptr
	FnDeferredCons    i64
	FnDeferredImmCons i64
	FpNext            uintptr
}

type Savepoint = Savepoint1 /* sqliteInt.h:1114:26 */
type Select1 = struct {
	Fop           u8
	FnSelectRow   LogEst
	FselFlags     u32
	FiLimit       int32
	FiOffset      int32
	FselId        u32
	FaddrOpenEphm [2]int32
	FpEList       uintptr
	FpSrc         uintptr
	FpWhere       uintptr
	FpGroupBy     uintptr
	FpHaving      uintptr
	FpOrderBy     uintptr
	FpPrior       uintptr
	FpNext        uintptr
	FpLimit       uintptr
	FpWith        uintptr
	FpWin         uintptr
	FpWinDefn     uintptr
}

type Select = Select1 /* sqliteInt.h:1115:23 */
type SelectDest1 = struct {
	FeDest    u8
	FiSDParm  int32
	FiSdst    int32
	FnSdst    int32
	FzAffSdst uintptr
	FpOrderBy uintptr
}

type SelectDest = SelectDest1 /* sqliteInt.h:1117:27 */
type SrcList1 = struct {
	FnSrc   int32
	FnAlloc u32
	Fa      [1]struct {
		FpSchema     uintptr
		FzDatabase   uintptr
		FzName       uintptr
		FzAlias      uintptr
		FpTab        uintptr
		FpSelect     uintptr
		FaddrFillSub int32
		FregReturn   int32
		FregResult   int32
		Ffg          struct {
			_           [0]uint32
			Fjointype   u8
			_           [3]byte
			FnotIndexed uint8 /* unsigned notIndexed: 1, unsigned isIndexedBy: 1, unsigned isTabFunc: 1, unsigned isCorrelated: 1, unsigned viaCoroutine: 1, unsigned isRecursive: 1, unsigned fromDDL: 1 */
			_           [3]byte
		}
		FiCursor  int32
		FpOn      uintptr
		FpUsing   uintptr
		FcolUsed  Bitmask
		Fu1       struct{ FzIndexedBy uintptr }
		FpIBIndex uintptr
	}
}

type SrcList = SrcList1      /* sqliteInt.h:1118:24 */
type StrAccum = sqlite3_str1 /* sqliteInt.h:1119:28 */ // Internal alias for sqlite3_str
type Table1 = struct {
	FzName        uintptr
	FaCol         uintptr
	FpIndex       uintptr
	FpSelect      uintptr
	FpFKey        uintptr
	FzColAff      uintptr
	FpCheck       uintptr
	Ftnum         int32
	FnTabRef      u32
	FtabFlags     u32
	FiPKey        i16
	FnCol         i16
	FnNVCol       i16
	FnRowLogEst   LogEst
	FszTabRow     LogEst
	FkeyConf      u8
	FaddColOffset int32
	FnModuleArg   int32
	FazModuleArg  uintptr
	FpVTable      uintptr
	FpTrigger     uintptr
	FpSchema      uintptr
	FpNextZombie  uintptr
}

// Internal alias for sqlite3_str
type Table = Table1 /* sqliteInt.h:1120:22 */
type Token1 = struct {
	Fz uintptr
	Fn uint32
	_  [4]byte
}

type Token = Token1 /* sqliteInt.h:1122:22 */
type Trigger1 = struct {
	FzName      uintptr
	Ftable      uintptr
	Fop         u8
	Ftr_tm      u8
	FpWhen      uintptr
	FpColumns   uintptr
	FpSchema    uintptr
	FpTabSchema uintptr
	Fstep_list  uintptr
	FpNext      uintptr
}

type Trigger = Trigger1 /* sqliteInt.h:1124:24 */
type TriggerPrg1 = struct {
	FpTrigger uintptr
	FpNext    uintptr
	FpProgram uintptr
	Forconf   int32
	FaColmask [2]u32
	_         [4]byte
}

type TriggerPrg = TriggerPrg1 /* sqliteInt.h:1125:27 */
type TriggerStep1 = struct {
	Fop        u8
	Forconf    u8
	FpTrig     uintptr
	FpSelect   uintptr
	FzTarget   uintptr
	FpWhere    uintptr
	FpExprList uintptr
	FpIdList   uintptr
	FpUpsert   uintptr
	FzSpan     uintptr
	FpNext     uintptr
	FpLast     uintptr
}

type TriggerStep = TriggerStep1 /* sqliteInt.h:1126:28 */
type UnpackedRecord1 = struct {
	FpKeyInfo   uintptr
	FaMem       uintptr
	FnField     u16
	Fdefault_rc i8
	FerrCode    u8
	Fr1         i8
	Fr2         i8
	FeqSeen     u8
	_           [1]byte
}

type UnpackedRecord = UnpackedRecord1 /* sqliteInt.h:1127:31 */
type Upsert1 = struct {
	FpUpsertTarget      uintptr
	FpUpsertTargetWhere uintptr
	FpUpsertSet         uintptr
	FpUpsertWhere       uintptr
	FpUpsertIdx         uintptr
	FpUpsertSrc         uintptr
	FregData            int32
	FiDataCur           int32
	FiIdxCur            int32
	_                   [4]byte
}

type Upsert = Upsert1 /* sqliteInt.h:1128:23 */
type VTable1 = struct {
	Fdb          uintptr
	FpMod        uintptr
	FpVtab       uintptr
	FnRef        int32
	FbConstraint u8
	FeVtabRisk   u8
	FiSavepoint  int32
	FpNext       uintptr
}

type VTable = VTable1 /* sqliteInt.h:1129:23 */
type Walker1 = struct {
	FpParse           uintptr
	FxExprCallback    uintptr
	FxSelectCallback  uintptr
	FxSelectCallback2 uintptr
	FwalkerDepth      int32
	FeCode            u16
	Fu                struct{ FpNC uintptr }
}

type Walker = Walker1 /* sqliteInt.h:1131:23 */
type Window1 = struct {
	FzName          uintptr
	FzBase          uintptr
	FpPartition     uintptr
	FpOrderBy       uintptr
	FeFrmType       u8
	FeStart         u8
	FeEnd           u8
	FbImplicitFrame u8
	FeExclude       u8
	FpStart         uintptr
	FpEnd           uintptr
	FppThis         uintptr
	FpNextWin       uintptr
	FpFilter        uintptr
	FpFunc          uintptr
	FiEphCsr        int32
	FregAccum       int32
	FregResult      int32
	FcsrApp         int32
	FregApp         int32
	FregPart        int32
	FpOwner         uintptr
	FnBufferCol     int32
	FiArgCol        int32
	FregOne         int32
	FregStartRowid  int32
	FregEndRowid    int32
	FbExprArgs      u8
	_               [3]byte
}

type Window = Window1 /* sqliteInt.h:1133:23 */
type With1 = struct {
	FnCte   int32
	FpOuter uintptr
	Fa      [1]struct {
		FzName   uintptr
		FpCols   uintptr
		FpSelect uintptr
		FzCteErr uintptr
	}
}

type With = With1 /* sqliteInt.h:1134:21 */

// The bitmask datatype defined below is used for various optimizations.
//
// Changing this from a 64-bit to a 32-bit type limits the number of
// tables in a join to 32 instead of 64.  But it also reduces the size
// of the library by 738 bytes on ix86.
type Bitmask = u64 /* sqliteInt.h:1147:15 */

// The number of bits in a Bitmask.  "BMS" means "BitMask Size".

// A bit in a Bitmask

// A VList object records a mapping between parameters/variables/wildcards
// in the SQL statement (such as $abc, @pqr, or :xyz) and the integer
// variable number associated with that parameter.  See the format description
// on the sqlite3VListAdd() routine for more information.  A VList is really
// just an array of integers.
type VList = int32 /* sqliteInt.h:1169:13 */

// Defer sourcing vdbe.h and btree.h until after the "u8" and
// "BusyHandler" typedefs. vdbe.h also requires a few of the opaque
// pointer types (i.e. FuncDef) defined above.
// 2001 September 15
//
// The author disclaims copyright to this source code.  In place of
// a legal notice, here is a blessing:
//
//    May you do good and not evil.
//    May you find forgiveness for yourself and forgive others.
//    May you share freely, never taking more than you give.
//
//
// This header file defines the interface that the sqlite B-Tree file
// subsystem.  See comments in the source code for a detailed description
// of what each interface routine does.

// TODO: This definition is just included so other modules compile. It
// needs to be revisited.

// If defined as non-zero, auto-vacuum is enabled by default. Otherwise
// it must be turned on for each database using "PRAGMA auto_vacuum = 1".

// Forward declarations of structure
type Btree1 = struct {
	Fdb             uintptr
	FpBt            uintptr
	FinTrans        u8
	Fsharable       u8
	Flocked         u8
	FhasIncrblobCur u8
	FwantToLock     int32
	FnBackup        int32
	FiDataVersion   u32
	FpNext          uintptr
	FpPrev          uintptr
	Flock           BtLock
}

type BtCursor1 = struct {
	FeState        u8
	FcurFlags      u8
	FcurPagerFlags u8
	Fhints         u8
	FskipNext      int32
	FpBtree        uintptr
	FaOverflow     uintptr
	FpKey          uintptr
	FpBt           uintptr
	FpNext         uintptr
	Finfo          CellInfo
	FnKey          i64
	FpgnoRoot      Pgno
	FiPage         i8
	FcurIntKey     u8
	Fix            u16
	FaiIdx         [19]u16
	FpKeyInfo      uintptr
	FpPage         uintptr
	FapPage        [19]uintptr
}

type BtShared1 = struct {
	FpPager          uintptr
	Fdb              uintptr
	FpCursor         uintptr
	FpPage1          uintptr
	FopenFlags       u8
	FautoVacuum      u8
	FincrVacuum      u8
	FbDoTruncate     u8
	FinTransaction   u8
	Fmax1bytePayload u8
	FnReserveWanted  u8
	FbtsFlags        u16
	FmaxLocal        u16
	FminLocal        u16
	FmaxLeaf         u16
	FminLeaf         u16
	FpageSize        u32
	FusableSize      u32
	FnTransaction    int32
	FnPage           u32
	FpSchema         uintptr
	FxFreeSchema     uintptr
	Fmutex           uintptr
	FpHasContent     uintptr
	FnRef            int32
	FpNext           uintptr
	FpLock           uintptr
	FpWriter         uintptr
	FpTmpSpace       uintptr
}

type BtreePayload1 = struct {
	FpKey  uintptr
	FnKey  sqlite3_int64
	FpData uintptr
	FaMem  uintptr
	FnMem  u16
	FnData int32
	FnZero int32
	_      [4]byte
}

type BtreePayload = BtreePayload1 /* btree.h:42:29 */

// 2001 September 15
//
// The author disclaims copyright to this source code.  In place of
// a legal notice, here is a blessing:
//
//    May you do good and not evil.
//    May you find forgiveness for yourself and forgive others.
//    May you share freely, never taking more than you give.
//
//
// Header file for the Virtual DataBase Engine (VDBE)
//
// This header defines the interface to the virtual database engine
// or VDBE.  The VDBE implements an abstract machine that runs a
// simple program to access and modify the underlying database.
// Define ISO C stdio on top of C++ iostreams.
//   Copyright (C) 1991-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.19 Input/output	<stdio.h>

// A single VDBE is an opaque structure named "Vdbe".  Only routines
// in the source file sqliteVdbe.c are allowed to see the insides
// of this structure.
type Vdbe1 = struct {
	Fdb                 uintptr
	FpPrev              uintptr
	FpNext              uintptr
	FpParse             uintptr
	FnVar               ynVar
	Fmagic              u32
	FnMem               int32
	FnCursor            int32
	FcacheCtr           u32
	Fpc                 int32
	Frc                 int32
	FnChange            int32
	FiStatement         int32
	FiCurrentTime       i64
	FnFkConstraint      i64
	FnStmtDefCons       i64
	FnStmtDefImmCons    i64
	FaMem               uintptr
	FapArg              uintptr
	FapCsr              uintptr
	FaVar               uintptr
	FaOp                uintptr
	FnOp                int32
	FnOpAlloc           int32
	FaColName           uintptr
	FpResultSet         uintptr
	FzErrMsg            uintptr
	FpVList             uintptr
	FstartTime          i64
	FnResColumn         u16
	FerrorAction        u8
	FminWriteFileFormat u8
	FprepFlags          u8
	FdoingRerun         u8
	_                   [2]byte
	Fexpired            uint16 /* bft expired: 2, bft explain: 2, bft changeCntOn: 1, bft runOnlyOnce: 1, bft usesStmtJournal: 1, bft readOnly: 1, bft bIsReader: 1 */
	FbtreeMask          yDbMask
	FlockMask           yDbMask
	FaCounter           [7]u32
	FzSql               uintptr
	FpFree              uintptr
	FpFrame             uintptr
	FpDelFrame          uintptr
	FnFrame             int32
	Fexpmask            u32
	FpProgram           uintptr
	FpAuxData           uintptr
}

// 2001 September 15
//
// The author disclaims copyright to this source code.  In place of
// a legal notice, here is a blessing:
//
//    May you do good and not evil.
//    May you find forgiveness for yourself and forgive others.
//    May you share freely, never taking more than you give.
//
//
// Header file for the Virtual DataBase Engine (VDBE)
//
// This header defines the interface to the virtual database engine
// or VDBE.  The VDBE implements an abstract machine that runs a
// simple program to access and modify the underlying database.
// Define ISO C stdio on top of C++ iostreams.
//   Copyright (C) 1991-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.19 Input/output	<stdio.h>

// A single VDBE is an opaque structure named "Vdbe".  Only routines
// in the source file sqliteVdbe.c are allowed to see the insides
// of this structure.
type Vdbe = Vdbe1 /* vdbe.h:27:21 */

// The names of the following types declared in vdbeInt.h are required
// for the VdbeOp definition.
type Mem = sqlite3_value1 /* vdbe.h:33:30 */
type SubProgram1 = struct {
	FaOp   uintptr
	FnOp   int32
	FnMem  int32
	FnCsr  int32
	FaOnce uintptr
	Ftoken uintptr
	FpNext uintptr
}

type SubProgram = SubProgram1 /* vdbe.h:34:27 */

// A single instruction of the virtual machine has an opcode
// and as many as three operands.  The instruction is recorded
// as an instance of the following structure:
type VdbeOp1 = struct {
	Fopcode u8
	Fp4type int8
	Fp5     u16
	Fp1     int32
	Fp2     int32
	Fp3     int32
	Fp4     struct {
		_  [0]uint64
		Fi int32
		_  [4]byte
	}
}

// A single instruction of the virtual machine has an opcode
// and as many as three operands.  The instruction is recorded
// as an instance of the following structure:
type p4union = struct {
	_  [0]uint64
	Fi int32
	_  [4]byte
}

type VdbeOp = VdbeOp1 /* vdbe.h:80:23 */

// A smaller version of VdbeOp used for the VdbeAddOpList() function because
// it takes up less space.
type VdbeOpList1 = struct {
	Fopcode u8
	Fp1     int8
	Fp2     int8
	Fp3     int8
}

type VdbeOpList = VdbeOpList1 /* vdbe.h:106:27 */

type RecordCompare = uintptr /* vdbe.h:286:13 */

// Use SQLITE_ENABLE_COMMENTS to enable generation of extra comments on
// each VDBE opcode.
//
// Use the SQLITE_ENABLE_MODULE_COMMENTS macro to see some extra no-op
// comments in VDBE programs that show key decision points in the code
// generator.

// The VdbeCoverage macros are used to set a coverage testing point
// for VDBE branch instructions.  The coverage testing points are line
// numbers in the sqlite3.c source file.  VDBE branch coverage testing
// only works with an amalagmation build.  That's ok since a VDBE branch
// coverage build designed for testing the test suite only.  No application
// should ever ship with VDBE branch coverage measuring turned on.
//
//    VdbeCoverage(v)                  // Mark the previously coded instruction
//                                     // as a branch
//
//    VdbeCoverageIf(v, conditional)   // Mark previous if conditional true
//
//    VdbeCoverageAlwaysTaken(v)       // Previous branch is always taken
//
//    VdbeCoverageNeverTaken(v)        // Previous branch is never taken
//
//    VdbeCoverageNeverNull(v)         // Previous three-way branch is only
//                                     // taken on the first two ways.  The
//                                     // NULL option is not possible
//
//    VdbeCoverageEqNe(v)              // Previous OP_Jump is only interested
//                                     // in distingishing equal and not-equal.
//
// Every VDBE branch operation must be tagged with one of the macros above.
// If not, then when "make test" is run with -DSQLITE_VDBE_COVERAGE and
// -DSQLITE_DEBUG then an ALWAYS() will fail in the vdbeTakeBranch()
// routine in vdbe.c, alerting the developer to the missed tag.
//
// During testing, the test application will invoke
// sqlite3_test_control(SQLITE_TESTCTRL_VDBE_COVERAGE,...) to set a callback
// routine that is invoked as each bytecode branch is taken.  The callback
// contains the sqlite3.c source line number ov the VdbeCoverage macro and
// flags to indicate whether or not the branch was taken.  The test application
// is responsible for keeping track of this and reporting byte-code branches
// that are never taken.
//
// See the VdbeBranchTaken() macro and vdbeTakeBranch() function in the
// vdbe.c source file for additional information.

// 2001 September 15
//
// The author disclaims copyright to this source code.  In place of
// a legal notice, here is a blessing:
//
//    May you do good and not evil.
//    May you find forgiveness for yourself and forgive others.
//    May you share freely, never taking more than you give.
//
//
// This header file defines the interface that the sqlite page cache
// subsystem.  The page cache subsystem reads and writes a file a page
// at a time and provides a journal for rollback.

// Default maximum size for persistent journal files. A negative
// value means no limit. This value may be overridden using the
// sqlite3PagerJournalSizeLimit() API. See also "PRAGMA journal_size_limit".

// The type used to represent a page number.  The first page in a file
// is called page 1.  0 is used to represent "not a page".
type Pgno = u32 /* pager.h:33:13 */

// Handle type for pages.
type PgHdr1 = struct {
	FpPage      uintptr
	FpData      uintptr
	FpExtra     uintptr
	FpCache     uintptr
	FpDirty     uintptr
	FpPager     uintptr
	Fpgno       Pgno
	Fflags      u16
	FnRef       i16
	FpDirtyNext uintptr
	FpDirtyPrev uintptr
}

// Handle type for pages.
type DbPage = PgHdr1 /* pager.h:43:22 */

// 2008 August 05
//
// The author disclaims copyright to this source code.  In place of
// a legal notice, here is a blessing:
//
//    May you do good and not evil.
//    May you find forgiveness for yourself and forgive others.
//    May you share freely, never taking more than you give.
//
//
// This header file defines the interface that the sqlite page cache
// subsystem.

type PgHdr = PgHdr1 /* pcache.h:18:22 */

// typedef for the authorization callback function.
type sqlite3_xauth = uintptr /* sqliteInt.h:1415:15 */

// This is an extra SQLITE_TRACE macro that indicates "legacy" tracing
// in the style of sqlite3_trace()

// Each database connection is an instance of the following structure.
type sqlite3InitInfo = struct {
	FnewTnum       int32
	FiDb           u8
	Fbusy          u8
	_              [2]byte
	ForphanTrigger uint8 /* unsigned orphanTrigger: 1, unsigned imposterTable: 1, unsigned reopenMemdb: 1 */
	FazInit        uintptr
}

// Allowed values for Table.tabFlags.
//
// TF_OOOHidden applies to tables or view that have hidden columns that are
// followed by non-hidden columns.  Example:  "CREATE VIRTUAL TABLE x USING
// vtab1(a HIDDEN, b);".  Since "b" is a non-hidden column but "a" is hidden,
// the TF_OOOHidden attribute would apply in this case.  Such tables require
// special handling during INSERT processing. The "OOO" means "Out Of Order".
//
// Constraints:
//
//         TF_HasVirtual == COLFLAG_Virtual
//         TF_HasStored  == COLFLAG_Stored

// Test to see whether or not a table is a virtual table.  This is
// done as a macro so that it will be optimized out when virtual
// table support is omitted from the build.

// Macros to determine if a column is hidden.  IsOrdinaryHiddenColumn()
// only works for non-virtual tables (ordinary tables and views) and is
// always false unless SQLITE_ENABLE_HIDDEN_COLUMNS is defined.  The
// IsHiddenColumn() macro is general purpose.

// Does the table have a rowid

// Each foreign key constraint is an instance of the following structure.
//
// A foreign key is associated with two tables.  The "from" table is
// the table that contains the REFERENCES clause that creates the foreign
// key.  The "to" table is the table that is named in the REFERENCES clause.
// Consider this example:
//
//     CREATE TABLE ex1(
//       a INTEGER PRIMARY KEY,
//       b INTEGER CONSTRAINT fk1 REFERENCES ex2(x)
//     );
//
// For foreign key "fk1", the from-table is "ex1" and the to-table is "ex2".
// Equivalent names:
//
//     from-table == child-table
//       to-table == parent-table
//
// Each REFERENCES clause generates an instance of the following structure
// which is attached to the from-table.  The to-table need not exist when
// the from-table is created.  The existence of the to-table is not checked.
//
// The list of all parents for child Table X is held at X.pFKey.
//
// A list of all children for a table named Z (which might not even exist)
// is held in Schema.fkeyHash with a hash key of Z.
type sColMap = struct {
	FiFrom int32
	FzCol  uintptr
}

// An instance of this structure contains information needed to generate
// code for a SELECT that contains aggregate functions.
//
// If Expr.op==TK_AGG_COLUMN or TK_AGG_FUNCTION then Expr.pAggInfo is a
// pointer to this structure.  The Expr.iAgg field is the index in
// AggInfo.aCol[] or AggInfo.aFunc[] of information needed to generate
// code for that node.
//
// AggInfo.pGroupBy and AggInfo.aFunc.pExpr point to fields within the
// original Select structure that describes the SELECT statement.  These
// fields do not need to be freed when deallocating the AggInfo structure.
type AggInfo_col = struct {
	FpTab          uintptr
	FpExpr         uintptr
	FiTable        int32
	FiMem          int32
	FiColumn       i16
	FiSorterColumn i16
	_              [4]byte
}

// An instance of this structure contains information needed to generate
// code for a SELECT that contains aggregate functions.
//
// If Expr.op==TK_AGG_COLUMN or TK_AGG_FUNCTION then Expr.pAggInfo is a
// pointer to this structure.  The Expr.iAgg field is the index in
// AggInfo.aCol[] or AggInfo.aFunc[] of information needed to generate
// code for that node.
//
// AggInfo.pGroupBy and AggInfo.aFunc.pExpr point to fields within the
// original Select structure that describes the SELECT statement.  These
// fields do not need to be freed when deallocating the AggInfo structure.
type AggInfo_func = struct {
	FpExpr     uintptr
	FpFunc     uintptr
	FiMem      int32
	FiDistinct int32
}

// Value for AggInfo.iAggMagic when the structure is valid

// The datatype ynVar is a signed integer, either 16-bit or 32-bit.
// Usually it is 16-bits.  But if SQLITE_MAX_VARIABLE_NUMBER is greater
// than 32767 we have to make it 32-bit.  16-bit is preferred because
// it uses less memory in the Expr object, which is a big memory user
// in systems with lots of prepared statements.  And few applications
// need more than about 10 or 20 variables.  But some extreme users want
// to have prepared statements with over 32766 variables, and for them
// the option is available (at compile-time).
type ynVar = i16 /* sqliteInt.h:2548:13 */

// The following are the meanings of bits in the Expr.flags field.
// Value restrictions:
//
//          EP_Agg == NC_HasAgg == SF_HasAgg
//          EP_Win == NC_HasWin
//  0x020000 // available for reuse
//   0x80000000 // Available

// The EP_Propagate mask is a set of properties that automatically propagate
// upwards into parent nodes.

// These macros can be used to test, set, or clear bits in the
// Expr.flags field.

// Flags for use with Expr.vvaFlags

// The ExprSetVVAProperty() macro is used for Verification, Validation,
// and Accreditation only.  It works like ExprSetProperty() during VVA
// processes but is a no-op for delivery.

// Macros to determine the number of bytes required by a normal Expr
// struct, an Expr struct with the EP_Reduced flag set in Expr.flags
// and an Expr struct with the EP_TokenOnly flag set.

// Flags passed to the sqlite3ExprDup() function. See the header comment
// above sqlite3ExprDup() for details.

// True if the expression passed as an argument was a function with
// an OVER() clause (a window function).

// A list of expressions.  Each expression may optionally have a
// name.  An expr/name combination can be used in several ways, such
// as the list of "expr AS ID" fields following a "SELECT" or in the
// list of "ID = expr" items in an UPDATE.  A list of expressions can
// also be used as the argument to a function, in which case the a.zName
// field is not used.
//
// In order to try to keep memory usage down, the Expr.a.zEName field
// is used for multiple purposes:
//
//     eEName          Usage
//    ----------       -------------------------
//    ENAME_NAME       (1) the AS of result set column
//                     (2) COLUMN= of an UPDATE
//
//    ENAME_TAB        DB.TABLE.NAME used to resolve names
//                     of subqueries
//
//    ENAME_SPAN       Text of the original result set
//                     expression.
type ExprList_item = struct {
	FpExpr     uintptr
	FzEName    uintptr
	FsortFlags u8
	_          [3]byte
	FeEName    uint8 /* unsigned eEName: 2, unsigned done: 1, unsigned reusable: 1, unsigned bSorterRef: 1, unsigned bNulls: 1 */
	Fu         struct {
		_  [0]uint32
		Fx struct {
			FiOrderByCol u16
			FiAlias      u16
		}
	}
	_ [4]byte
}

// Allowed values for Expr.a.eEName

// An instance of this structure can hold a simple list of identifiers,
// such as the list "a,b,c" in the following statements:
//
//      INSERT INTO t(a,b,c) VALUES ...;
//      CREATE INDEX idx ON t(a,b,c);
//      CREATE TRIGGER trig BEFORE UPDATE ON t(a,b,c) ...;
//
// The IdList.a.idx field is used when the IdList represents the list of
// column names after a table name in an INSERT statement.  In the statement
//
//     INSERT INTO t(a,b,c) ...
//
// If "a" is the k-th column of table "t", then IdList.a[0].idx==k.
type IdList_item = struct {
	FzName uintptr
	Fidx   int32
	_      [4]byte
}

// The following structure describes the FROM clause of a SELECT statement.
// Each table or subquery in the FROM clause is a separate element of
// the SrcList.a[] array.
//
// With the addition of multiple database support, the following structure
// can also be used to describe a particular table such as the table that
// is modified by an INSERT, DELETE, or UPDATE statement.  In standard SQL,
// such a table must be a simple name: ID.  But in SQLite, the table can
// now be identified by a database name, a dot, then the table name: ID.ID.
//
// The jointype starts out showing the join type between the current table
// and the next table on the list.  The parser builds the list this way.
// But sqlite3SrcListShiftJoinType() later shifts the jointypes so that each
// jointype expresses the join between the table and the previous table.
//
// In the colUsed field, the high-order bit (bit 63) is set if the table
// contains more than 63 columns and the 64-th or later column is used.
type SrcList_item = struct {
	FpSchema     uintptr
	FzDatabase   uintptr
	FzName       uintptr
	FzAlias      uintptr
	FpTab        uintptr
	FpSelect     uintptr
	FaddrFillSub int32
	FregReturn   int32
	FregResult   int32
	Ffg          struct {
		_           [0]uint32
		Fjointype   u8
		_           [3]byte
		FnotIndexed uint8 /* unsigned notIndexed: 1, unsigned isIndexedBy: 1, unsigned isTabFunc: 1, unsigned isCorrelated: 1, unsigned viaCoroutine: 1, unsigned isRecursive: 1, unsigned fromDDL: 1 */
		_           [3]byte
	}
	FiCursor  int32
	FpOn      uintptr
	FpUsing   uintptr
	FcolUsed  Bitmask
	Fu1       struct{ FzIndexedBy uintptr }
	FpIBIndex uintptr
}

// The yDbMask datatype for the bitmask of all attached databases.
type yDbMask = uint32 /* sqliteInt.h:3268:24 */

// The following structure contains information used by the sqliteFix...
// routines as they walk the parse tree to make database references
// explicit.
type DbFixer1 = struct {
	FpParse  uintptr
	FpSchema uintptr
	FbTemp   u8
	FzDb     uintptr
	FzType   uintptr
	FpName   uintptr
}

// The following structure contains information used by the sqliteFix...
// routines as they walk the parse tree to make database references
// explicit.
type DbFixer = DbFixer1 /* sqliteInt.h:3568:24 */

// A pointer to this structure is used to communicate information
// from sqlite3Init and OP_ParseSchema into the sqlite3InitCallback.
type InitData = struct {
	Fdb         uintptr
	FpzErrMsg   uintptr
	FiDb        int32
	Frc         int32
	FmInitFlags u32
	FnInitRow   u32
} /* sqliteInt.h:3609:3 */

// Allowed values for mInitFlags

// Structure containing global configuration data for the SQLite library.
//
// This structure also contains some state information.
type Sqlite3Config = struct {
	FbMemstat            int32
	FbCoreMutex          u8
	FbFullMutex          u8
	FbOpenUri            u8
	FbUseCis             u8
	FbSmallMalloc        u8
	FbExtraSchemaChecks  u8
	FmxStrlen            int32
	FneverCorrupt        int32
	FszLookaside         int32
	FnLookaside          int32
	FnStmtSpill          int32
	Fm                   sqlite3_mem_methods
	Fmutex               sqlite3_mutex_methods
	Fpcache2             sqlite3_pcache_methods2
	FpHeap               uintptr
	FnHeap               int32
	FmnReq               int32
	FmxReq               int32
	FszMmap              sqlite3_int64
	FmxMmap              sqlite3_int64
	FpPage               uintptr
	FszPage              int32
	FnPage               int32
	FmxParserStack       int32
	FsharedCacheEnabled  int32
	FszPma               u32
	FisInit              int32
	FinProgress          int32
	FisMutexInit         int32
	FisMallocInit        int32
	FisPCacheInit        int32
	FnRefInitMutex       int32
	FpInitMutex          uintptr
	FxLog                uintptr
	FpLogArg             uintptr
	FxTestCallback       uintptr
	FbLocaltimeFault     int32
	FiOnceResetThreshold int32
	FszSorterRef         u32
	FiPrngSeed           uint32
}

// Return code from the parse-tree walking primitives and their
// callbacks.

// An instance of this structure represents a set of one or more CTEs
// (common table expressions) created by a single WITH clause.
type Cte = struct {
	FzName   uintptr
	FpCols   uintptr
	FpSelect uintptr
	FzCteErr uintptr
}

// 2003 September 6
//
// The author disclaims copyright to this source code.  In place of
// a legal notice, here is a blessing:
//
//    May you do good and not evil.
//    May you find forgiveness for yourself and forgive others.
//    May you share freely, never taking more than you give.
//
//
// This is the header file for information that is private to the
// VDBE.  This information used to all be at the top of the single
// source code file "vdbe.c".  When that file became too big (over
// 6000 lines long) it was split up into several smaller files and
// this header information was factored out.

// The maximum number of times that a statement will try to reparse
// itself before giving up and returning SQLITE_SCHEMA.

// VDBE_DISPLAY_P4 is true or false depending on whether or not the
// "explain" P4 display logic is enabled.

// SQL is translated into a sequence of instructions to be
// executed by a virtual machine.  Each instruction is an instance
// of the following structure.
type Op = VdbeOp1 /* vdbeInt.h:46:23 */

// Boolean values
type Bool = uint32 /* vdbeInt.h:51:18 */

// Elements of the linked list at Vdbe.pAuxData
type AuxData1 = struct {
	FiAuxOp     int32
	FiAuxArg    int32
	FpAux       uintptr
	FxDeleteAux uintptr
	FpNextAux   uintptr
}

// Elements of the linked list at Vdbe.pAuxData
type AuxData = AuxData1 /* vdbeInt.h:57:24 */

// Types of VDBE cursors

// A VdbeCursor is an superclass (a wrapper) for various cursor objects:
//
//      * A b-tree cursor
//          -  In the main database or in an ephemeral database
//          -  On either an index or a table
//      * A sorter
//      * A virtual table
//      * A one-row "pseudotable" stored in a single register
type VdbeCursor1 = struct {
	FeCurType       u8
	FiDb            i8
	FnullRow        u8
	FdeferredMoveto u8
	FisTable        u8
	_               [3]byte
	FisEphemeral    uint8 /* Bool isEphemeral: 1, Bool useRandomRowid: 1, Bool isOrdered: 1, Bool seekHit: 1 */
	FpBtx           uintptr
	FseqCount       i64
	FaAltMap        uintptr
	FcacheStatus    u32
	FseekResult     int32
	FpAltCursor     uintptr
	Fuc             struct{ FpCursor uintptr }
	FpKeyInfo       uintptr
	FiHdrOffset     u32
	FpgnoRoot       Pgno
	FnField         i16
	FnHdrParsed     u16
	FmovetoTarget   i64
	FaOffset        uintptr
	FaRow           uintptr
	FpayloadSize    u32
	FszRow          u32
	FaType          [1]u32
	_               [4]byte
}

// Types of VDBE cursors

// A VdbeCursor is an superclass (a wrapper) for various cursor objects:
//
//      * A b-tree cursor
//          -  In the main database or in an ephemeral database
//          -  On either an index or a table
//      * A sorter
//      * A virtual table
//      * A one-row "pseudotable" stored in a single register
type VdbeCursor = VdbeCursor1 /* vdbeInt.h:75:27 */

// A value for VdbeCursor.cacheStatus that means the cache is always invalid.

// When a sub-program is executed (OP_Program), a structure of this type
// is allocated to store the current value of the program counter, as
// well as the current memory cell array and various other frame specific
// values stored in the Vdbe struct. When the sub-program is finished,
// these values are copied back to the Vdbe from the VdbeFrame structure,
// restoring the state of the VM to as it was before the sub-program
// began executing.
//
// The memory for a VdbeFrame object is allocated and managed by a memory
// cell in the parent (calling) frame. When the memory cell is deleted or
// overwritten, the VdbeFrame object is not freed immediately. Instead, it
// is linked into the Vdbe.pDelFrame list. The contents of the Vdbe.pDelFrame
// list is deleted when the VM is reset in VdbeHalt(). The reason for doing
// this instead of deleting the VdbeFrame immediately is to avoid recursive
// calls to sqlite3VdbeMemRelease() when the memory cells belonging to the
// child frame are released.
//
// The currently executing frame is stored in Vdbe.pFrame. Vdbe.pFrame is
// set to NULL if the currently executing frame is the main program.
type VdbeFrame1 = struct {
	Fv         uintptr
	FpParent   uintptr
	FaOp       uintptr
	FanExec    uintptr
	FaMem      uintptr
	FapCsr     uintptr
	FaOnce     uintptr
	Ftoken     uintptr
	FlastRowid i64
	FpAuxData  uintptr
	FnCursor   int32
	Fpc        int32
	FnOp       int32
	FnMem      int32
	FnChildMem int32
	FnChildCsr int32
	FnChange   int32
	FnDbChange int32
}

// A value for VdbeCursor.cacheStatus that means the cache is always invalid.

// When a sub-program is executed (OP_Program), a structure of this type
// is allocated to store the current value of the program counter, as
// well as the current memory cell array and various other frame specific
// values stored in the Vdbe struct. When the sub-program is finished,
// these values are copied back to the Vdbe from the VdbeFrame structure,
// restoring the state of the VM to as it was before the sub-program
// began executing.
//
// The memory for a VdbeFrame object is allocated and managed by a memory
// cell in the parent (calling) frame. When the memory cell is deleted or
// overwritten, the VdbeFrame object is not freed immediately. Instead, it
// is linked into the Vdbe.pDelFrame list. The contents of the Vdbe.pDelFrame
// list is deleted when the VM is reset in VdbeHalt(). The reason for doing
// this instead of deleting the VdbeFrame immediately is to avoid recursive
// calls to sqlite3VdbeMemRelease() when the memory cells belonging to the
// child frame are released.
//
// The currently executing frame is stored in Vdbe.pFrame. Vdbe.pFrame is
// set to NULL if the currently executing frame is the main program.
type VdbeFrame = VdbeFrame1 /* vdbeInt.h:161:26 */

// Magic number for sanity checking on VdbeFrame objects

// Return a pointer to the array of registers allocated for use
// by a VdbeFrame.

// Internally, the vdbe manipulates nearly all SQL values as Mem
// structures. Each Mem struct may cache multiple representations (string,
// integer etc.) of the same value.
type MemValue = struct{ Fr float64 }

// A bitfield type for use inside of structures.  Always follow with :N where
// N is the number of bits.
type bft = uint32 /* vdbeInt.h:344:18 */ // Bit Field Type

// The ScanStatus object holds a single value for the
// sqlite3_stmt_scanstatus() interface.
type ScanStatus1 = struct {
	FaddrExplain int32
	FaddrLoop    int32
	FaddrVisit   int32
	FiSelectID   int32
	FnEst        LogEst
	FzName       uintptr
}

// Bit Field Type

// The ScanStatus object holds a single value for the
// sqlite3_stmt_scanstatus() interface.
type ScanStatus = ScanStatus1 /* vdbeInt.h:349:27 */

// The DblquoteStr object holds the text of a double-quoted
// string for a prepared statement.  A linked list of these objects
// is constructed during statement parsing and is held on Vdbe.pDblStr.
// When computing a normalized SQL statement for an SQL statement, that
// list is consulted for each double-quoted identifier to see if the
// identifier should really be a string literal.
type DblquoteStr1 = struct {
	FpNextStr uintptr
	Fz        [8]int8
}

// The DblquoteStr object holds the text of a double-quoted
// string for a prepared statement.  A linked list of these objects
// is constructed during statement parsing and is held on Vdbe.pDblStr.
// When computing a normalized SQL statement for an SQL statement, that
// list is consulted for each double-quoted identifier to see if the
// identifier should really be a string literal.
type DblquoteStr = DblquoteStr1 /* vdbeInt.h:366:28 */

// Convert text generated by the "%p" conversion format back into
// a pointer.
func testHexToInt(tls *crt.TLS, h int32) int32 { /* test1.c:44:12: */
	if (h >= '0') && (h <= '9') {
		return (h - '0')
	} else if (h >= 'a') && (h <= 'f') {
		return ((h - 'a') + 10)
	} else {

		return ((h - 'A') + 10)
	}
	return int32(0)
}
func sqlite3TestTextToPtr(tls *crt.TLS, z uintptr) uintptr { /* test1.c:54:6: */
	bp := tls.Alloc(20)
	defer tls.Free(20)

	// var p uintptr at bp, 8

	// var v u64 at bp+8, 8

	// var v2 u32 at bp+16, 4

	if (int32(*(*int8)(unsafe.Pointer(z + uintptr(0)))) == '0') && (int32(*(*int8)(unsafe.Pointer(z + uintptr(1)))) == 'x') {
		z += uintptr(2)
	}
	*(*u64)(unsafe.Pointer(bp + 8 /* v */)) = uint64(0)
	for *(*int8)(unsafe.Pointer(z)) != 0 {
		*(*u64)(unsafe.Pointer(bp + 8 /* v */)) = ((*(*u64)(unsafe.Pointer(bp + 8 /* v */)) << 4) + u64(testHexToInt(tls, int32(*(*int8)(unsafe.Pointer(z))))))
		z++
	}
	if uint64(unsafe.Sizeof(uintptr(0))) == uint64(unsafe.Sizeof(u64(0))) {
		crt.Xmemcpy(tls, bp /* &p */, bp+8 /* &v */, uint64(unsafe.Sizeof(uintptr(0))))
	} else {

		*(*u32)(unsafe.Pointer(bp + 16 /* v2 */)) = u32(*(*u64)(unsafe.Pointer(bp + 8 /* v */)))
		crt.Xmemcpy(tls, bp /* &p */, bp+16 /* &v2 */, uint64(unsafe.Sizeof(uintptr(0))))
	}
	return *(*uintptr)(unsafe.Pointer(bp /* p */))
}

// A TCL command that returns the address of the sqlite* pointer
// for an sqlite connection instance.  Bad things happen if the
// input is not an sqlite connection.
func get_sqlite_pointer(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:82:26: */
	bp := tls.Alloc(212)
	defer tls.Free(212)

	var p uintptr
	// var cmdInfo Tcl_CmdInfo at bp+48, 64

	// var zBuf [100]int8 at bp+112, 100

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+21507 /* "SQLITE-CONNECTIO..." */)
		return 1
	}
	if !(tcl.XTcl_GetCommandInfo(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), bp+48 /* &cmdInfo */) != 0) {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21525, /* "command not foun..." */
			tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), uintptr(0)))
		return 1
	}
	p = (*Tcl_CmdInfo)(unsafe.Pointer(bp + 48 /* &cmdInfo */)).FobjClientData
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([100]int8{})), bp+112 /* &zBuf[0] */, ts+20002 /* "%p" */, crt.VaList(bp+24, (*struct{ Fdb uintptr })(unsafe.Pointer(p)).Fdb))
	tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+32, bp+112 /* &zBuf[0] */, 0))
	return 0
}

// Decode a pointer to an sqlite3 object.
func getDbPointer(tls *crt.TLS, interp uintptr, zA uintptr, ppDb uintptr) int32 { /* test1.c:109:5: */
	bp := tls.Alloc(64)
	defer tls.Free(64)

	var p uintptr
	// var cmdInfo Tcl_CmdInfo at bp, 64

	if tcl.XTcl_GetCommandInfo(tls, interp, zA, bp /* &cmdInfo */) != 0 {
		p = (*Tcl_CmdInfo)(unsafe.Pointer(bp /* &cmdInfo */)).FobjClientData
		*(*uintptr)(unsafe.Pointer(ppDb)) = (*struct{ Fdb uintptr })(unsafe.Pointer(p)).Fdb
	} else {
		*(*uintptr)(unsafe.Pointer(ppDb)) = sqlite3TestTextToPtr(tls, zA)
	}
	return 0
}

// Convert an sqlite3_stmt* into an sqlite3*.  This depends on the
// fact that the sqlite3* is the first field in the Vdbe structure.

// Check a return value to make sure it agrees with the results
// from sqlite3_errcode.
func sqlite3TestErrCode(tls *crt.TLS, interp uintptr, db uintptr, rc int32) int32 { /* test1.c:144:5: */
	bp := tls.Alloc(248)
	defer tls.Free(248)

	if (((sqlite3.Xsqlite3_threadsafe(tls) == 0) && (rc != 21)) && (rc != 0)) &&
		(sqlite3.Xsqlite3_errcode(tls, db) != rc) {
		// var zBuf [200]int8 at bp+48, 200

		var r2 int32 = sqlite3.Xsqlite3_errcode(tls, db)
		sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([200]int8{})), bp+48, /* &zBuf[0] */
			ts+21545, /* "error code %s (%..." */
			crt.VaList(bp, sqlite3.Xsqlite3ErrName(tls, rc), rc, sqlite3.Xsqlite3ErrName(tls, r2), r2))
		tcl.XTcl_ResetResult(tls, interp)
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+32, bp+48 /* &zBuf[0] */, 0))
		return 1
	}
	return 0
}

// Decode a pointer to an sqlite3_stmt object.
func getStmtPointer(tls *crt.TLS, interp uintptr, zArg uintptr, ppStmt uintptr) int32 { /* test1.c:162:12: */
	*(*uintptr)(unsafe.Pointer(ppStmt)) = sqlite3TestTextToPtr(tls, zArg)
	return 0
}

// Generate a text representation of a pointer that can be understood
// by the getDbPointer and getVmPointer routines above.
//
// The problem is, on some machines (Solaris) if you do a printf with
// "%p" you cannot turn around and do a scanf with the same "%p" and
// get your pointer back.  You have to prepend a "0x" before it will
// work.  Or at least that is what is reported to me (drh).  But this
// behavior varies from machine to machine.  The solution used her is
// to test the string right after it is generated to see if it can be
// understood by scanf, and if not, try prepending an "0x" to see if
// that helps.  If nothing works, a fatal error is generated.
func sqlite3TestMakePointerStr(tls *crt.TLS, interp uintptr, zPtr uintptr, p uintptr) int32 { /* test1.c:184:5: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	sqlite3.Xsqlite3_snprintf(tls, 100, zPtr, ts+20002 /* "%p" */, crt.VaList(bp, p))
	return 0
}

// The callback routine for sqlite3_exec_printf().
func exec_printf_cb(tls *crt.TLS, pArg uintptr, argc int32, argv uintptr, name uintptr) int32 { /* test1.c:192:12: */
	var str uintptr = pArg
	var i int32

	if ((*Tcl_DString)(unsafe.Pointer(str)).Flength) == 0 {
		for i = 0; i < argc; i++ {
			tcl.XTcl_DStringAppendElement(tls, str, func() uintptr {
				if *(*uintptr)(unsafe.Pointer(name + uintptr(i)*8)) != 0 {
					return *(*uintptr)(unsafe.Pointer(name + uintptr(i)*8))
				}
				return ts + 5494 /* "NULL" */
			}())
		}
	}
	for i = 0; i < argc; i++ {
		tcl.XTcl_DStringAppendElement(tls, str, func() uintptr {
			if *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8)) != 0 {
				return *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8))
			}
			return ts + 5494 /* "NULL" */
		}())
	}
	return 0
}

// The I/O tracing callback.

// Usage:  io_trace FILENAME
//
// Turn I/O tracing on or off.  If FILENAME is not an empty string,
// I/O tracing begins going into FILENAME. If FILENAME is an empty
// string, I/O tracing is turned off.
func test_io_trace(tls *crt.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:228:26: */
	return 0
}

// Usage:  clang_sanitize_address
//
// Returns true if the program was compiled using clang with the
// -fsanitize=address switch on the command line. False otherwise.
//
// Also return true if the OMIT_MISUSE environment variable exists.
func clang_sanitize_address(tls *crt.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:269:26: */
	var res int32 = 0
	if (res == 0) && (crt.Xgetenv(tls, ts+21603 /* "OMIT_MISUSE" */) != uintptr(0)) {
		res = 1
	}
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, res))
	return 0
}

// Usage:  sqlite3_exec_printf  DB  FORMAT  STRING
//
// Invoke the sqlite3_exec_printf() interface using the open database
// DB.  The SQL is the string FORMAT.  The format string should contain
// one %s or %q.  STRING is the value inserted into %s or %q.
func test_exec_printf(tls *crt.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:296:26: */
	bp := tls.Alloc(310)
	defer tls.Free(310)

	// var db uintptr at bp+48, 8

	// var str Tcl_DString at bp+56, 216

	var rc int32
	*(*uintptr)(unsafe.Pointer(bp + 272 /* zErr */)) = uintptr(0)
	var zSql uintptr
	// var zBuf [30]int8 at bp+280, 30

	if argc != 4 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
			ts+21641 /* " DB FORMAT STRIN..." */, 0))
		return 1
	}
	if getDbPointer(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), bp+48 /* &db */) != 0 {
		return 1
	}
	tcl.XTcl_DStringInit(tls, bp+56 /* &str */)
	zSql = sqlite3.Xsqlite3_mprintf(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8)), crt.VaList(bp+32, *(*uintptr)(unsafe.Pointer(argv + uintptr(3)*8))))
	rc = sqlite3.Xsqlite3_exec(tls, *(*uintptr)(unsafe.Pointer(bp + 48 /* db */)), zSql, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, int32, uintptr, uintptr) int32
	}{exec_printf_cb})), bp+56 /* &str */, bp+272 /* &zErr */)
	sqlite3.Xsqlite3_free(tls, zSql)
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([30]int8{})), bp+280 /* &zBuf[0] */, ts+1647 /* "%d" */, crt.VaList(bp+40, rc))
	tcl.XTcl_AppendElement(tls, interp, bp+280 /* &zBuf[0] */)
	tcl.XTcl_AppendElement(tls, interp, func() uintptr {
		if rc == 0 {
			return (*Tcl_DString)(unsafe.Pointer(bp + 56 /* &str */)).Fstring
		}
		return *(*uintptr)(unsafe.Pointer(bp + 272 /* zErr */))
	}())
	tcl.XTcl_DStringFree(tls, bp+56 /* &str */)
	if *(*uintptr)(unsafe.Pointer(bp + 272 /* zErr */)) != 0 {
		sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(bp + 272 /* zErr */)))
	}
	if sqlite3TestErrCode(tls, interp, *(*uintptr)(unsafe.Pointer(bp + 48 /* db */)), rc) != 0 {
		return 1
	}
	return 0
}

// Usage:  sqlite3_exec_hex  DB  HEX
//
// Invoke the sqlite3_exec() on a string that is obtained by translating
// HEX into ASCII.  Most characters are translated as is.  %HH becomes
// a hex character.
func test_exec_hex(tls *crt.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:334:26: */
	bp := tls.Alloc(806)
	defer tls.Free(806)

	// var db uintptr at bp+40, 8

	// var str Tcl_DString at bp+552, 216

	var rc int32
	var i int32
	var j int32
	*(*uintptr)(unsafe.Pointer(bp + 768 /* zErr */)) = uintptr(0)
	var zHex uintptr
	// var zSql [501]int8 at bp+48, 501

	// var zBuf [30]int8 at bp+776, 30

	if argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
			ts+21659 /* " DB HEX" */, 0))
		return 1
	}
	if getDbPointer(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), bp+40 /* &db */) != 0 {
		return 1
	}
	zHex = *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8))
	i = crt.AssignInt32(&j, 0)
__1:
	if !((uint64(i) < (uint64(unsafe.Sizeof([501]int8{})) - uint64(1))) && (*(*int8)(unsafe.Pointer(zHex + uintptr(j))) != 0)) {
		goto __3
	}
	{
		if ((int32(*(*int8)(unsafe.Pointer(zHex + uintptr(j)))) == '%') && (*(*int8)(unsafe.Pointer(zHex + uintptr((j + 2)))) != 0)) && (*(*int8)(unsafe.Pointer(zHex + uintptr((j + 2)))) != 0) {
			*(*int8)(unsafe.Pointer(bp + 48 /* &zSql[0] */ + uintptr(i))) = (int8((testHexToInt(tls, int32(*(*int8)(unsafe.Pointer(zHex + uintptr((j + 1)))))) << 4) + testHexToInt(tls, int32(*(*int8)(unsafe.Pointer(zHex + uintptr((j + 2))))))))
			j = j + (2)
		} else {
			*(*int8)(unsafe.Pointer(bp + 48 /* &zSql[0] */ + uintptr(i))) = *(*int8)(unsafe.Pointer(zHex + uintptr(j)))
		}
	}
	goto __2
__2:
	i++
	j++
	goto __1
	goto __3
__3:
	;
	*(*int8)(unsafe.Pointer(bp + 48 /* &zSql[0] */ + uintptr(i))) = int8(0)
	tcl.XTcl_DStringInit(tls, bp+552 /* &str */)
	rc = sqlite3.Xsqlite3_exec(tls, *(*uintptr)(unsafe.Pointer(bp + 40 /* db */)), bp+48 /* &zSql[0] */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, int32, uintptr, uintptr) int32
	}{exec_printf_cb})), bp+552 /* &str */, bp+768 /* &zErr */)
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([30]int8{})), bp+776 /* &zBuf[0] */, ts+1647 /* "%d" */, crt.VaList(bp+32, rc))
	tcl.XTcl_AppendElement(tls, interp, bp+776 /* &zBuf[0] */)
	tcl.XTcl_AppendElement(tls, interp, func() uintptr {
		if rc == 0 {
			return (*Tcl_DString)(unsafe.Pointer(bp + 552 /* &str */)).Fstring
		}
		return *(*uintptr)(unsafe.Pointer(bp + 768 /* zErr */))
	}())
	tcl.XTcl_DStringFree(tls, bp+552 /* &str */)
	if *(*uintptr)(unsafe.Pointer(bp + 768 /* zErr */)) != 0 {
		sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(bp + 768 /* zErr */)))
	}
	if sqlite3TestErrCode(tls, interp, *(*uintptr)(unsafe.Pointer(bp + 40 /* db */)), rc) != 0 {
		return 1
	}
	return 0
}

// Usage:  db_enter DB
//         db_leave DB
//
// Enter or leave the mutex on a database connection.
func db_enter(tls *crt.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:380:26: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	// var db uintptr at bp+32, 8

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
			ts+21667 /* " DB" */, 0))
		return 1
	}
	if getDbPointer(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), bp+32 /* &db */) != 0 {
		return 1
	}
	sqlite3.Xsqlite3_mutex_enter(tls, (*sqlite31)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32 /* db */)))).Fmutex)
	return 0
}
func db_leave(tls *crt.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:396:26: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	// var db uintptr at bp+32, 8

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
			ts+21667 /* " DB" */, 0))
		return 1
	}
	if getDbPointer(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), bp+32 /* &db */) != 0 {
		return 1
	}
	sqlite3.Xsqlite3_mutex_leave(tls, (*sqlite31)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32 /* db */)))).Fmutex)
	return 0
}

// Usage:  sqlite3_exec  DB  SQL
//
// Invoke the sqlite3_exec interface using the open database DB
func test_exec(tls *crt.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:418:26: */
	bp := tls.Alloc(310)
	defer tls.Free(310)

	// var db uintptr at bp+48, 8

	// var str Tcl_DString at bp+56, 216

	var rc int32
	*(*uintptr)(unsafe.Pointer(bp + 272 /* zErr */)) = uintptr(0)
	var zSql uintptr
	var i int32
	var j int32
	// var zBuf [30]int8 at bp+280, 30

	if argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
			ts+21671 /* " DB SQL" */, 0))
		return 1
	}
	if getDbPointer(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), bp+48 /* &db */) != 0 {
		return 1
	}
	tcl.XTcl_DStringInit(tls, bp+56 /* &str */)
	zSql = sqlite3.Xsqlite3_mprintf(tls, ts+130 /* "%s" */, crt.VaList(bp+32, *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8))))
	for i = crt.AssignInt32(&j, 0); *(*int8)(unsafe.Pointer(zSql + uintptr(i))) != 0; {
		if int32(*(*int8)(unsafe.Pointer(zSql + uintptr(i)))) == '%' {
			*(*int8)(unsafe.Pointer(zSql + uintptr(crt.PostIncInt32(&j, 1)))) = (int8((testHexToInt(tls, int32(*(*int8)(unsafe.Pointer(zSql + uintptr((i + 1)))))) << 4) + testHexToInt(tls, int32(*(*int8)(unsafe.Pointer(zSql + uintptr((i + 2))))))))
			i = i + (3)
		} else {
			*(*int8)(unsafe.Pointer(zSql + uintptr(crt.PostIncInt32(&j, 1)))) = *(*int8)(unsafe.Pointer(zSql + uintptr(crt.PostIncInt32(&i, 1))))
		}
	}
	*(*int8)(unsafe.Pointer(zSql + uintptr(j))) = int8(0)
	rc = sqlite3.Xsqlite3_exec(tls, *(*uintptr)(unsafe.Pointer(bp + 48 /* db */)), zSql, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, int32, uintptr, uintptr) int32
	}{exec_printf_cb})), bp+56 /* &str */, bp+272 /* &zErr */)
	sqlite3.Xsqlite3_free(tls, zSql)
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([30]int8{})), bp+280 /* &zBuf[0] */, ts+1647 /* "%d" */, crt.VaList(bp+40, rc))
	tcl.XTcl_AppendElement(tls, interp, bp+280 /* &zBuf[0] */)
	tcl.XTcl_AppendElement(tls, interp, func() uintptr {
		if rc == 0 {
			return (*Tcl_DString)(unsafe.Pointer(bp + 56 /* &str */)).Fstring
		}
		return *(*uintptr)(unsafe.Pointer(bp + 272 /* zErr */))
	}())
	tcl.XTcl_DStringFree(tls, bp+56 /* &str */)
	if *(*uintptr)(unsafe.Pointer(bp + 272 /* zErr */)) != 0 {
		sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(bp + 272 /* zErr */)))
	}
	if sqlite3TestErrCode(tls, interp, *(*uintptr)(unsafe.Pointer(bp + 48 /* db */)), rc) != 0 {
		return 1
	}
	return 0
}

// Usage:  sqlite3_exec_nr  DB  SQL
//
// Invoke the sqlite3_exec interface using the open database DB.  Discard
// all results
func test_exec_nr(tls *crt.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:465:26: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	// var db uintptr at bp+32, 8

	var rc int32
	*(*uintptr)(unsafe.Pointer(bp + 40 /* zErr */)) = uintptr(0)
	if argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
			ts+21671 /* " DB SQL" */, 0))
		return 1
	}
	if getDbPointer(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), bp+32 /* &db */) != 0 {
		return 1
	}
	rc = sqlite3.Xsqlite3_exec(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* db */)), *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8)), uintptr(0), uintptr(0), bp+40 /* &zErr */)
	if sqlite3TestErrCode(tls, interp, *(*uintptr)(unsafe.Pointer(bp + 32 /* db */)), rc) != 0 {
		return 1
	}
	return 0
}

// Usage:  sqlite3_mprintf_z_test  SEPARATOR  ARG0  ARG1 ...
//
// Test the %z format of sqlite_mprintf().  Use multiple mprintf() calls to
// concatenate arg0 through argn using separator as the separator.
// Return the result.
func test_mprintf_z(tls *crt.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:492:26: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	var zResult uintptr = uintptr(0)
	var i int32

	for i = 2; (i < argc) && ((i == 2) || (zResult != 0)); i++ {
		zResult = sqlite3.Xsqlite3_mprintf(tls, ts+11257 /* "%z%s%s" */, crt.VaList(bp, zResult, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8))))
	}
	tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+24, zResult, 0))
	sqlite3.Xsqlite3_free(tls, zResult)
	return 0
}

// Usage:  sqlite3_mprintf_n_test  STRING
//
// Test the %n format of sqlite_mprintf().  Return the length of the
// input string.
func test_mprintf_n(tls *crt.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:515:26: */
	bp := tls.Alloc(20)
	defer tls.Free(20)

	var zStr uintptr
	*(*int32)(unsafe.Pointer(bp + 16 /* n */)) = 0
	zStr = sqlite3.Xsqlite3_mprintf(tls, ts+21679 /* "%s%n" */, crt.VaList(bp, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), bp+16 /* &n */))
	sqlite3.Xsqlite3_free(tls, zStr)
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 16 /* n */))))
	return 0
}

// Usage:  sqlite3_snprintf_int  SIZE FORMAT  INT
//
// Test the of sqlite3_snprintf() routine.  SIZE is the size of the
// output buffer in bytes.  The maximum size is 100.  FORMAT is the
// format string.  INT is a single integer argument.  The FORMAT
// string must require no more than this one integer argument.  If
// You pass in a format string that requires more than one argument,
// bad things will happen.
func test_snprintf_int(tls *crt.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:539:26: */
	bp := tls.Alloc(124)
	defer tls.Free(124)

	// var zStr [100]int8 at bp+24, 100

	var n int32 = crt.Xatoi(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)))
	var zFormat uintptr = *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8))
	var a1 int32 = crt.Xatoi(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(3)*8)))
	if uint64(n) > uint64(unsafe.Sizeof([100]int8{})) {
		n = int32(unsafe.Sizeof([100]int8{}))
	}
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([100]int8{})), bp+24 /* &zStr[0] */, ts+21684 /* "abcdefghijklmnop..." */, 0)
	sqlite3.Xsqlite3_snprintf(tls, n, bp+24 /* &zStr[0] */, zFormat, crt.VaList(bp, a1))
	tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+8, bp+24 /* &zStr[0] */, 0))
	return 0
}

// Usage:  sqlite3_get_table_printf  DB  FORMAT  STRING  ?--no-counts?
//
// Invoke the sqlite3_get_table_printf() interface using the open database
// DB.  The SQL is the string FORMAT.  The format string should contain
// one %s or %q.  STRING is the value inserted into %s or %q.
func test_get_table_printf(tls *crt.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:565:26: */
	bp := tls.Alloc(350)
	defer tls.Free(350)

	// var db uintptr at bp+72, 8

	// var str Tcl_DString at bp+80, 216

	var rc int32
	*(*uintptr)(unsafe.Pointer(bp + 304 /* zErr */)) = uintptr(0)
	*(*int32)(unsafe.Pointer(bp + 312 /* nRow */)) = 0
	*(*int32)(unsafe.Pointer(bp + 316 /* nCol */)) = 0
	// var aResult uintptr at bp+296, 8

	var i int32
	// var zBuf [30]int8 at bp+320, 30

	var zSql uintptr
	*(*int32)(unsafe.Pointer(bp + 64 /* resCount */)) = -1
	if argc == 5 {
		if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(4)*8)), bp+64 /* &resCount */) != 0 {
			return 1
		}
	}
	if (argc != 4) && (argc != 5) {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
			ts+21711 /* " DB FORMAT STRIN..." */, 0))
		return 1
	}
	if getDbPointer(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), bp+72 /* &db */) != 0 {
		return 1
	}
	tcl.XTcl_DStringInit(tls, bp+80 /* &str */)
	zSql = sqlite3.Xsqlite3_mprintf(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8)), crt.VaList(bp+32, *(*uintptr)(unsafe.Pointer(argv + uintptr(3)*8))))
	if argc == 5 {
		rc = sqlite3.Xsqlite3_get_table(tls, *(*uintptr)(unsafe.Pointer(bp + 72 /* db */)), zSql, bp+296 /* &aResult */, uintptr(0), uintptr(0), bp+304 /* &zErr */)
	} else {
		rc = sqlite3.Xsqlite3_get_table(tls, *(*uintptr)(unsafe.Pointer(bp + 72 /* db */)), zSql, bp+296 /* &aResult */, bp+312 /* &nRow */, bp+316 /* &nCol */, bp+304 /* &zErr */)
		*(*int32)(unsafe.Pointer(bp + 64 /* resCount */)) = ((*(*int32)(unsafe.Pointer(bp + 312 /* nRow */)) + 1) * *(*int32)(unsafe.Pointer(bp + 316 /* nCol */)))
	}
	sqlite3.Xsqlite3_free(tls, zSql)
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([30]int8{})), bp+320 /* &zBuf[0] */, ts+1647 /* "%d" */, crt.VaList(bp+40, rc))
	tcl.XTcl_AppendElement(tls, interp, bp+320 /* &zBuf[0] */)
	if rc == 0 {
		if argc == 4 {
			sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([30]int8{})), bp+320 /* &zBuf[0] */, ts+1647 /* "%d" */, crt.VaList(bp+48, *(*int32)(unsafe.Pointer(bp + 312 /* nRow */))))
			tcl.XTcl_AppendElement(tls, interp, bp+320 /* &zBuf[0] */)
			sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([30]int8{})), bp+320 /* &zBuf[0] */, ts+1647 /* "%d" */, crt.VaList(bp+56, *(*int32)(unsafe.Pointer(bp + 316 /* nCol */))))
			tcl.XTcl_AppendElement(tls, interp, bp+320 /* &zBuf[0] */)
		}
		for i = 0; i < *(*int32)(unsafe.Pointer(bp + 64 /* resCount */)); i++ {
			tcl.XTcl_AppendElement(tls, interp, func() uintptr {
				if *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 296 /* aResult */)) + uintptr(i)*8)) != 0 {
					return *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 296 /* aResult */)) + uintptr(i)*8))
				}
				return ts + 5494 /* "NULL" */
			}())
		}
	} else {
		tcl.XTcl_AppendElement(tls, interp, *(*uintptr)(unsafe.Pointer(bp + 304 /* zErr */)))
	}
	sqlite3.Xsqlite3_free_table(tls, *(*uintptr)(unsafe.Pointer(bp + 296 /* aResult */)))
	if *(*uintptr)(unsafe.Pointer(bp + 304 /* zErr */)) != 0 {
		sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(bp + 304 /* zErr */)))
	}
	if sqlite3TestErrCode(tls, interp, *(*uintptr)(unsafe.Pointer(bp + 72 /* db */)), rc) != 0 {
		return 1
	}
	return 0
}

// Usage:  sqlite3_last_insert_rowid DB
//
// Returns the integer ROWID of the most recent insert.
func test_last_rowid(tls *crt.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:628:26: */
	bp := tls.Alloc(94)
	defer tls.Free(94)

	// var db uintptr at bp+56, 8

	// var zBuf [30]int8 at bp+64, 30

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)), ts+21737 /* " DB\"" */, 0))
		return 1
	}
	if getDbPointer(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), bp+56 /* &db */) != 0 {
		return 1
	}
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([30]int8{})), bp+64 /* &zBuf[0] */, ts+17145 /* "%lld" */, crt.VaList(bp+32, sqlite3.Xsqlite3_last_insert_rowid(tls, *(*uintptr)(unsafe.Pointer(bp + 56 /* db */)))))
	tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+40, bp+64 /* &zBuf[0] */, 0))
	return 0
}

// Usage:  sqlite3_key DB KEY
//
// Set the codec key.
func test_key(tls *crt.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:652:26: */
	return 0
}

// Usage:  sqlite3_rekey DB KEY
//
// Change the codec key.
func test_rekey(tls *crt.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:666:26: */
	return 0
}

// Usage:  sqlite3_close DB
//
// Closes the database opened by sqlite3_open.
func sqlite_test_close(tls *crt.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:680:26: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	// var db uintptr at bp+32, 8

	var rc int32
	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
			ts+21742 /* " FILENAME\"" */, 0))
		return 1
	}
	if getDbPointer(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), bp+32 /* &db */) != 0 {
		return 1
	}
	rc = sqlite3.Xsqlite3_close(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* db */)))
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))
	return 0
}

// Usage:  sqlite3_close_v2 DB
//
// Closes the database opened by sqlite3_open.
func sqlite_test_close_v2(tls *crt.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:704:26: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	// var db uintptr at bp+32, 8

	var rc int32
	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
			ts+21742 /* " FILENAME\"" */, 0))
		return 1
	}
	if getDbPointer(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), bp+32 /* &db */) != 0 {
		return 1
	}
	rc = sqlite3.Xsqlite3_close_v2(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* db */)))
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))
	return 0
}

// Implementation of the x_coalesce() function.
// Return the first argument non-NULL argument.
func t1_ifnullFunc(tls *crt.TLS, context uintptr, argc int32, argv uintptr) { /* test1.c:727:13: */
	var i int32
	for i = 0; i < argc; i++ {
		if 5 != sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8))) {
			var n int32 = sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8)))
			sqlite3.Xsqlite3_result_text(tls, context, sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8))),
				n, crt.UintptrFromInt32(-1))
			break
		}
	}
}

// These are test functions.    hex8() interprets its argument as
// UTF8 and returns a hex encoding.  hex16le() interprets its argument
// as UTF16le and returns a hex encoding.
func hex8Func(tls *crt.TLS, p uintptr, argc int32, argv uintptr) { /* test1.c:748:13: */
	bp := tls.Alloc(208)
	defer tls.Free(208)

	var z uintptr
	var i int32
	// var zBuf [200]int8 at bp+8, 200

	z = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)))
	for i = 0; (uint64(i) < ((uint64(unsafe.Sizeof([200]int8{})) / uint64(2)) - uint64(2))) && (*(*uint8)(unsafe.Pointer(z + uintptr(i))) != 0); i++ {
		sqlite3.Xsqlite3_snprintf(tls, (int32(uint64(unsafe.Sizeof([200]int8{})) - (uint64(i * 2)))), (bp + 8 /* &zBuf */ + uintptr((i * 2))), ts+21753 /* "%02x" */, crt.VaList(bp, int32(*(*uint8)(unsafe.Pointer(z + uintptr(i))))))
	}
	*(*int8)(unsafe.Pointer(bp + 8 /* &zBuf[0] */ + uintptr((i * 2)))) = int8(0)
	sqlite3.Xsqlite3_result_text(tls, p, bp+8 /* zBuf */, -1, crt.UintptrFromInt32(-1))
}

// A structure into which to accumulate text.
type dstr = struct {
	FnAlloc int32
	FnUsed  int32
	Fz      uintptr
}

// Append text to a dstr
func dstrAppend(tls *crt.TLS, p uintptr, z uintptr, divider int32) { /* test1.c:785:13: */
	var n int32 = int32(crt.Xstrlen(tls, z))
	if (((*dstr)(unsafe.Pointer(p)).FnUsed + n) + 2) > (*dstr)(unsafe.Pointer(p)).FnAlloc {
		var zNew uintptr
		(*dstr)(unsafe.Pointer(p)).FnAlloc = ((((*dstr)(unsafe.Pointer(p)).FnAlloc * 2) + n) + 200)
		zNew = sqlite3.Xsqlite3_realloc(tls, (*dstr)(unsafe.Pointer(p)).Fz, (*dstr)(unsafe.Pointer(p)).FnAlloc)
		if zNew == uintptr(0) {
			sqlite3.Xsqlite3_free(tls, (*dstr)(unsafe.Pointer(p)).Fz)
			crt.Xmemset(tls, p, 0, uint64(unsafe.Sizeof(dstr{})))
			return
		}
		(*dstr)(unsafe.Pointer(p)).Fz = zNew
	}
	if (divider != 0) && ((*dstr)(unsafe.Pointer(p)).FnUsed > 0) {
		*(*int8)(unsafe.Pointer((*dstr)(unsafe.Pointer(p)).Fz + uintptr(crt.PostIncInt32(&(*dstr)(unsafe.Pointer(p)).FnUsed, 1)))) = int8(divider)
	}
	crt.Xmemcpy(tls, ((*dstr)(unsafe.Pointer(p)).Fz + uintptr((*dstr)(unsafe.Pointer(p)).FnUsed)), z, (uint64(n + 1)))
	*(*int32)(unsafe.Pointer(p + 4 /* &.nUsed */)) += (n)
}

// Invoked for each callback from sqlite3ExecFunc
func execFuncCallback(tls *crt.TLS, pData uintptr, argc int32, argv uintptr, NotUsed uintptr) int32 { /* test1.c:808:12: */
	var p uintptr = pData
	var i int32
	for i = 0; i < argc; i++ {
		if *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8)) == uintptr(0) {
			dstrAppend(tls, p, ts+5494 /* "NULL" */, ' ')
		} else {
			dstrAppend(tls, p, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8)), ' ')
		}
	}
	return 0
}

// Implementation of the x_sqlite_exec() function.  This function takes
// a single argument and attempts to execute that argument as SQL code.
// This is illegal and should set the SQLITE_MISUSE flag on the database.
//
// 2004-Jan-07:  We have changed this to make it legal to call sqlite3_exec()
// from within a function call.
//
// This routine simulates the effect of having two threads attempt to
// use the same database at the same time.
func sqlite3ExecFunc(tls *crt.TLS, context uintptr, argc int32, argv uintptr) { /* test1.c:832:13: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	// var x dstr at bp, 16

	crt.Xmemset(tls, bp /* &x */, 0, uint64(unsafe.Sizeof(dstr{})))
	sqlite3.Xsqlite3_exec(tls, sqlite3.Xsqlite3_user_data(tls, context),
		sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8))),
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*crt.TLS, uintptr, int32, uintptr, uintptr) int32
		}{execFuncCallback})), bp /* &x */, uintptr(0))
	sqlite3.Xsqlite3_result_text(tls, context, (*dstr)(unsafe.Pointer(bp /* &x */)).Fz, (*dstr)(unsafe.Pointer(bp /* &x */)).FnUsed, crt.UintptrFromInt32(-1))
	sqlite3.Xsqlite3_free(tls, (*dstr)(unsafe.Pointer(bp /* &x */)).Fz)
}

// Implementation of tkt2213func(), a scalar function that takes exactly
// one argument. It has two interesting features:
//
// * It calls sqlite3_value_text() 3 times on the argument sqlite3_value*.
//   If the three pointers returned are not the same an SQL error is raised.
//
// * Otherwise it returns a copy of the text representation of its
//   argument in such a way as the VDBE representation is a Mem* cell
//   with the MEM_Term flag clear.
//
// Ticket #2213 can therefore be tested by evaluating the following
// SQL expression:
//
//   tkt2213func(tkt2213func('a string'));
func tkt2213Function(tls *crt.TLS, context uintptr, argc int32, argv uintptr) { /* test1.c:862:13: */
	var nText int32
	var zText1 uintptr
	var zText2 uintptr
	var zText3 uintptr

	nText = sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)))
	zText1 = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)))
	zText2 = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)))
	zText3 = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)))

	if (zText1 != zText2) || (zText2 != zText3) {
		sqlite3.Xsqlite3_result_error(tls, context, ts+21758 /* "tkt2213 is not f..." */, -1)
	} else {
		var zCopy uintptr = sqlite3.Xsqlite3_malloc(tls, nText)
		crt.Xmemcpy(tls, zCopy, zText1, uint64(nText))
		sqlite3.Xsqlite3_result_text(tls, context, zCopy, nText, *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, uintptr) }{sqlite3.Xsqlite3_free})))
	}
}

// The following SQL function takes 4 arguments.  The 2nd and
// 4th argument must be one of these strings:  'text', 'text16',
// or 'blob' corresponding to API functions
//
//      sqlite3_value_text()
//      sqlite3_value_text16()
//      sqlite3_value_blob()
//
// The third argument is a string, either 'bytes' or 'bytes16' or 'noop',
// corresponding to APIs:
//
//      sqlite3_value_bytes()
//      sqlite3_value_bytes16()
//      noop
//
// The APIs designated by the 2nd through 4th arguments are applied
// to the first argument in order.  If the pointers returned by the
// second and fourth are different, this routine returns 1.  Otherwise,
// this routine returns 0.
//
// This function is used to test to see when returned pointers from
// the _text(), _text16() and _blob() APIs become invalidated.
func ptrChngFunction(tls *crt.TLS, context uintptr, argc int32, argv uintptr) { /* test1.c:910:13: */
	var p1 uintptr
	var p2 uintptr
	var zCmd uintptr
	if argc != 4 {
		return
	}
	zCmd = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)))
	if zCmd == uintptr(0) {
		return
	}
	if crt.Xstrcmp(tls, zCmd, ts+19413 /* "text" */) == 0 {
		p1 = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)))
	} else if crt.Xstrcmp(tls, zCmd, ts+19418 /* "blob" */) == 0 {
		p1 = sqlite3.Xsqlite3_value_blob(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)))
	} else {
		return
	}
	zCmd = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8)))
	if zCmd == uintptr(0) {
		return
	}
	if crt.Xstrcmp(tls, zCmd, ts+21779 /* "bytes" */) == 0 {
		sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)))
	} else if crt.Xstrcmp(tls, zCmd, ts+21785 /* "noop" */) == 0 {
	} else {
		return
	}
	zCmd = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(3)*8)))
	if zCmd == uintptr(0) {
		return
	}
	if crt.Xstrcmp(tls, zCmd, ts+19413 /* "text" */) == 0 {
		p2 = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)))
	} else if crt.Xstrcmp(tls, zCmd, ts+19418 /* "blob" */) == 0 {
		p2 = sqlite3.Xsqlite3_value_blob(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)))
	} else {
		return
	}
	sqlite3.Xsqlite3_result_int(tls, context, (crt.Bool32(p1 != p2)))
}

// This SQL function returns a different answer each time it is called, even if
// the arguments are the same.
func nondeterministicFunction(tls *crt.TLS, context uintptr, argc int32, argv uintptr) { /* test1.c:964:13: */
	sqlite3.Xsqlite3_result_int(tls, context, crt.PostIncInt32(&cnt, 1))
}

var cnt int32 = 0 /* test1.c:969:14 */

// This SQL function returns the integer value of its argument as a MEM_IntReal
// value.
func intrealFunction(tls *crt.TLS, context uintptr, argc int32, argv uintptr) { /* test1.c:977:13: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var v sqlite3_int64 = sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)))
	sqlite3.Xsqlite3_result_int64(tls, context, v)
	sqlite3.Xsqlite3_test_control(tls, 27, crt.VaList(bp, context))
}

// Usage:  sqlite3_create_function DB
//
// Call the sqlite3_create_function API on the given database in order
// to create a function named "x_coalesce".  This function does the same thing
// as the "coalesce" function.  This function also registers an SQL function
// named "x_sqlite_exec" that invokes sqlite3_exec().  Invoking sqlite3_exec()
// in this way is illegal recursion and should raise an SQLITE_MISUSE error.
// The effect is similar to trying to use the same database connection from
// two threads at the same time.
//
// The original motivation for this routine was to be able to call the
// sqlite3_create_function function while a query is in progress in order
// to test the SQLITE_MISUSE detection logic.
func test_create_function(tls *crt.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:1002:26: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	var rc int32
	// var db uintptr at bp+32, 8

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
			ts+21737 /* " DB\"" */, 0))
		return 1
	}
	if getDbPointer(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), bp+32 /* &db */) != 0 {
		return 1
	}
	rc = sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* db */)), ts+21790 /* "x_coalesce" */, -1, 1, uintptr(0),
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*crt.TLS, uintptr, int32, uintptr)
		}{t1_ifnullFunc})), uintptr(0), uintptr(0))
	if rc == 0 {
		rc = sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* db */)), ts+21801 /* "hex8" */, 1, (1 | 0x000000800),
			uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
				f func(*crt.TLS, uintptr, int32, uintptr)
			}{hex8Func})), uintptr(0), uintptr(0))
	}
	if rc == 0 {
		rc = sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* db */)), ts+21806 /* "tkt2213func" */, 1, 5, uintptr(0),
			*(*uintptr)(unsafe.Pointer(&struct {
				f func(*crt.TLS, uintptr, int32, uintptr)
			}{tkt2213Function})), uintptr(0), uintptr(0))
	}
	if rc == 0 {
		rc = sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* db */)), ts+21818 /* "pointer_change" */, 4, 5, uintptr(0),
			*(*uintptr)(unsafe.Pointer(&struct {
				f func(*crt.TLS, uintptr, int32, uintptr)
			}{ptrChngFunction})), uintptr(0), uintptr(0))
	}

	// Functions counter1() and counter2() have the same implementation - they
	// both return an ascending integer with each call.  But counter1() is marked
	// as non-deterministic and counter2() is marked as deterministic.
	if rc == 0 {
		rc = sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* db */)), ts+21833 /* "counter1" */, -1, 1,
			uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
				f func(*crt.TLS, uintptr, int32, uintptr)
			}{nondeterministicFunction})), uintptr(0), uintptr(0))
	}
	if rc == 0 {
		rc = sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* db */)), ts+21842 /* "counter2" */, -1, (1 | 0x000000800),
			uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
				f func(*crt.TLS, uintptr, int32, uintptr)
			}{nondeterministicFunction})), uintptr(0), uintptr(0))
	}

	// The intreal() function converts its argument to an integer and returns
	// it as a MEM_IntReal.
	if rc == 0 {
		rc = sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* db */)), ts+21851 /* "intreal" */, 1, 1,
			uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
				f func(*crt.TLS, uintptr, int32, uintptr)
			}{intrealFunction})), uintptr(0), uintptr(0))
	}

	if sqlite3TestErrCode(tls, interp, *(*uintptr)(unsafe.Pointer(bp + 32 /* db */)), rc) != 0 {
		return 1
	}
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))
	return 0
}

// Usage:  sqlite3_drop_modules DB ?NAME ...?
//
// Invoke the sqlite3_drop_modules(D,L) interface on database
// connection DB, in order to drop all modules except those named in
// the argument.
func test_drop_modules(tls *crt.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:1092:26: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	// var db uintptr at bp+32, 8

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
			ts+21737 /* " DB\"" */, 0))
		return 1
	}
	if getDbPointer(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), bp+32 /* &db */) != 0 {
		return 1
	}
	sqlite3.Xsqlite3_drop_modules(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* db */)), func() uintptr {
		if argc > 2 {
			return (argv + uintptr(2)*8)
		}
		return uintptr(0)
	}())
	return 0
}

// Routines to implement the x_count() aggregate function.
//
// x_count() counts the number of non-null arguments.  But there are
// some twists for testing purposes.
//
// If the argument to x_count() is 40 then a UTF-8 error is reported
// on the step function.  If x_count(41) is seen, then a UTF-16 error
// is reported on the step function.  If the total count is 42, then
// a UTF-8 error is reported on the finalize function.
type t1CountCtx1 = struct{ Fn int32 }

// Routines to implement the x_count() aggregate function.
//
// x_count() counts the number of non-null arguments.  But there are
// some twists for testing purposes.
//
// If the argument to x_count() is 40 then a UTF-8 error is reported
// on the step function.  If x_count(41) is seen, then a UTF-16 error
// is reported on the step function.  If the total count is 42, then
// a UTF-8 error is reported on the finalize function.
type t1CountCtx = t1CountCtx1 /* test1.c:1123:27 */
func t1CountStep(tls *crt.TLS, context uintptr, argc int32, argv uintptr) { /* test1.c:1127:13: */
	var p uintptr
	p = sqlite3.Xsqlite3_aggregate_context(tls, context, int32(unsafe.Sizeof(t1CountCtx{})))
	if ((argc == 0) || (5 != sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8))))) && (p != 0) {
		(*t1CountCtx)(unsafe.Pointer(p)).Fn++
	}
	if argc > 0 {
		var v int32 = sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)))
		if v == 40 {
			sqlite3.Xsqlite3_result_error(tls, context, ts+21859 /* "value of 40 hand..." */, -1)
		}
	}
}
func t1CountFinalize(tls *crt.TLS, context uintptr) { /* test1.c:1149:13: */
	var p uintptr
	p = sqlite3.Xsqlite3_aggregate_context(tls, context, int32(unsafe.Sizeof(t1CountCtx{})))
	if p != 0 {
		if (*t1CountCtx)(unsafe.Pointer(p)).Fn == 42 {
			sqlite3.Xsqlite3_result_error(tls, context, ts+21889 /* "x_count totals t..." */, -1)
		} else {
			sqlite3.Xsqlite3_result_int(tls, context, func() int32 {
				if p != 0 {
					return (*t1CountCtx)(unsafe.Pointer(p)).Fn
				}
				return 0
			}())
		}
	}
}

func legacyCountStep(tls *crt.TLS, context uintptr, argc int32, argv uintptr) { /* test1.c:1162:13: */
	// no-op
}

func legacyCountFinalize(tls *crt.TLS, context uintptr) { /* test1.c:1170:13: */
	sqlite3.Xsqlite3_result_int(tls, context, sqlite3.Xsqlite3_aggregate_count(tls, context))
}

// Usage:  sqlite3_create_aggregate DB
//
// Call the sqlite3_create_function API on the given database in order
// to create a function named "x_count".  This function is similar
// to the built-in count() function, with a few special quirks
// for testing the sqlite3_result_error() APIs.
//
// The original motivation for this routine was to be able to call the
// sqlite3_create_aggregate function while a query is in progress in order
// to test the SQLITE_MISUSE detection logic.  See misuse.test.
//
// This routine was later extended to test the use of sqlite3_result_error()
// within aggregate functions.
//
// Later: It is now also extended to register the aggregate function
// "legacy_count()" with the supplied database handle. This is used
// to test the deprecated sqlite3_aggregate_count() API.
func test_create_aggregate(tls *crt.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:1194:26: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	// var db uintptr at bp+32, 8

	var rc int32
	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
			ts+21742 /* " FILENAME\"" */, 0))
		return 1
	}
	if getDbPointer(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), bp+32 /* &db */) != 0 {
		return 1
	}
	rc = sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* db */)), ts+21910 /* "x_count" */, 0, 1, uintptr(0), uintptr(0),
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*crt.TLS, uintptr, int32, uintptr)
		}{t1CountStep})), *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, uintptr) }{t1CountFinalize})))
	if rc == 0 {
		rc = sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* db */)), ts+21910 /* "x_count" */, 1, 1, uintptr(0), uintptr(0),
			*(*uintptr)(unsafe.Pointer(&struct {
				f func(*crt.TLS, uintptr, int32, uintptr)
			}{t1CountStep})), *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, uintptr) }{t1CountFinalize})))
	}
	if rc == 0 {
		rc = sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* db */)), ts+21918 /* "legacy_count" */, 0, 5, uintptr(0), uintptr(0),
			*(*uintptr)(unsafe.Pointer(&struct {
				f func(*crt.TLS, uintptr, int32, uintptr)
			}{legacyCountStep})), *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, uintptr) }{legacyCountFinalize})))
	}
	if sqlite3TestErrCode(tls, interp, *(*uintptr)(unsafe.Pointer(bp + 32 /* db */)), rc) != 0 {
		return 1
	}
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))
	return 0
}

// Usage:  printf TEXT
//
// Send output to printf.  Use this rather than puts to merge the output
// in the correct sequence with debugging printfs inserted into C code.
// Puts uses a separate buffer and debugging statements will be out of
// sequence if it is used.
func test_printf(tls *crt.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:1235:26: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
			ts+21931 /* " TEXT\"" */, 0))
		return 1
	}
	crt.Xprintf(tls, ts+597 /* "%s\n" */, crt.VaList(bp+32, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8))))
	return 0
}

// Usage:  sqlite3_mprintf_int FORMAT INTEGER INTEGER INTEGER
//
// Call mprintf with three integer arguments
func sqlite3_mprintf_int(tls *crt.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:1257:26: */
	bp := tls.Alloc(84)
	defer tls.Free(84)

	// var a [3]int32 at bp+72, 12

	var i int32
	var z uintptr
	if argc != 5 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
			ts+21938 /* " FORMAT INT INT ..." */, 0))
		return 1
	}
	for i = 2; i < 5; i++ {
		if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8)), (bp+72 /* &a */ +uintptr((i-2))*4)) != 0 {
			return 1
		}
	}
	z = sqlite3.Xsqlite3_mprintf(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), crt.VaList(bp+32, *(*int32)(unsafe.Pointer(bp + 72 /* &a[0] */ + uintptr(0)*4)), *(*int32)(unsafe.Pointer(bp + 72 /* &a[0] */ + uintptr(1)*4)), *(*int32)(unsafe.Pointer(bp + 72 /* &a[0] */ + uintptr(2)*4))))
	tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+56, z, 0))
	sqlite3.Xsqlite3_free(tls, z)
	return 0
}

// Usage:  sqlite3_mprintf_int64 FORMAT INTEGER INTEGER INTEGER
//
// Call mprintf with three 64-bit integer arguments
func sqlite3_mprintf_int64(tls *crt.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:1284:26: */
	bp := tls.Alloc(112)
	defer tls.Free(112)

	var i int32
	// var a [3]sqlite_int64 at bp+88, 24

	var z uintptr
	if argc != 5 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
			ts+21938 /* " FORMAT INT INT ..." */, 0))
		return 1
	}
	for i = 2; i < 5; i++ {
		if sqlite3.Xsqlite3Atoi64(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8)), (bp+88 /* &a */ +uintptr((i-2))*8), sqlite3.Xsqlite3Strlen30(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8))), uint8(1)) != 0 {
			tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+32, ts+21959 /* "argument is not ..." */, 0))
			return 1
		}
	}
	z = sqlite3.Xsqlite3_mprintf(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), crt.VaList(bp+48, *(*sqlite_int64)(unsafe.Pointer(bp + 88 /* &a[0] */ + uintptr(0)*8)), *(*sqlite_int64)(unsafe.Pointer(bp + 88 /* &a[0] */ + uintptr(1)*8)), *(*sqlite_int64)(unsafe.Pointer(bp + 88 /* &a[0] */ + uintptr(2)*8))))
	tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+72, z, 0))
	sqlite3.Xsqlite3_free(tls, z)
	return 0
}

// Usage:  sqlite3_mprintf_long FORMAT INTEGER INTEGER INTEGER
//
// Call mprintf with three long integer arguments.   This might be the
// same as sqlite3_mprintf_int or sqlite3_mprintf_int64, depending on
// platform.
func sqlite3_mprintf_long(tls *crt.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:1317:26: */
	bp := tls.Alloc(112)
	defer tls.Free(112)

	var i int32
	// var a [3]int64 at bp+88, 24

	// var b [3]int32 at bp+72, 12

	var z uintptr
	if argc != 5 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
			ts+21938 /* " FORMAT INT INT ..." */, 0))
		return 1
	}
	for i = 2; i < 5; i++ {
		if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8)), (bp+72 /* &b */ +uintptr((i-2))*4)) != 0 {
			return 1
		}
		*(*int64)(unsafe.Pointer(bp + 88 /* &a[0] */ + uintptr((i-2))*8)) = int64(*(*int32)(unsafe.Pointer(bp + 72 /* &b[0] */ + uintptr((i-2))*4)))
		*(*int64)(unsafe.Pointer(bp + 88 /* &a */ + uintptr((i-2))*8)) &= int64(((u64((uint64(1))) << (uint64(unsafe.Sizeof(int32(0))) * uint64(8))) - uint64(1)))
	}
	z = sqlite3.Xsqlite3_mprintf(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), crt.VaList(bp+32, *(*int64)(unsafe.Pointer(bp + 88 /* &a[0] */ + uintptr(0)*8)), *(*int64)(unsafe.Pointer(bp + 88 /* &a[0] */ + uintptr(1)*8)), *(*int64)(unsafe.Pointer(bp + 88 /* &a[0] */ + uintptr(2)*8))))
	tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+56, z, 0))
	sqlite3.Xsqlite3_free(tls, z)
	return 0
}

// Usage:  sqlite3_mprintf_str FORMAT INTEGER INTEGER STRING
//
// Call mprintf with two integer arguments and one string argument
func sqlite3_mprintf_str(tls *crt.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:1348:26: */
	bp := tls.Alloc(84)
	defer tls.Free(84)

	// var a [3]int32 at bp+72, 12

	var i int32
	var z uintptr
	if (argc < 4) || (argc > 5) {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
			ts+21998 /* " FORMAT INT INT ..." */, 0))
		return 1
	}
	for i = 2; i < 4; i++ {
		if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8)), (bp+72 /* &a */ +uintptr((i-2))*4)) != 0 {
			return 1
		}
	}
	z = sqlite3.Xsqlite3_mprintf(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), crt.VaList(bp+32, *(*int32)(unsafe.Pointer(bp + 72 /* &a[0] */ + uintptr(0)*4)), *(*int32)(unsafe.Pointer(bp + 72 /* &a[0] */ + uintptr(1)*4)), func() uintptr {
		if argc > 4 {
			return *(*uintptr)(unsafe.Pointer(argv + uintptr(4)*8))
		}
		return uintptr(0)
	}()))
	tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+56, z, 0))
	sqlite3.Xsqlite3_free(tls, z)
	return 0
}

// Usage:  sqlite3_snprintf_str INTEGER FORMAT INTEGER INTEGER STRING
//
// Call mprintf with two integer arguments and one string argument
func sqlite3_snprintf_str(tls *crt.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:1375:26: */
	bp := tls.Alloc(104)
	defer tls.Free(104)

	// var a [3]int32 at bp+92, 12

	var i int32
	// var n int32 at bp+88, 4

	var z uintptr
	if (argc < 5) || (argc > 6) {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
			ts+22024 /* " INT FORMAT INT ..." */, 0))
		return 1
	}
	if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), bp+88 /* &n */) != 0 {
		return 1
	}
	if *(*int32)(unsafe.Pointer(bp + 88 /* n */)) < 0 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+32, ts+22054 /* "N must be non-ne..." */, 0))
		return 1
	}
	for i = 3; i < 5; i++ {
		if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8)), (bp+92 /* &a */ +uintptr((i-3))*4)) != 0 {
			return 1
		}
	}
	z = sqlite3.Xsqlite3_malloc(tls, (*(*int32)(unsafe.Pointer(bp + 88 /* n */)) + 1))
	sqlite3.Xsqlite3_snprintf(tls, *(*int32)(unsafe.Pointer(bp + 88 /* n */)), z, *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8)), crt.VaList(bp+48, *(*int32)(unsafe.Pointer(bp + 92 /* &a[0] */ + uintptr(0)*4)), *(*int32)(unsafe.Pointer(bp + 92 /* &a[0] */ + uintptr(1)*4)), func() uintptr {
		if argc > 4 {
			return *(*uintptr)(unsafe.Pointer(argv + uintptr(5)*8))
		}
		return uintptr(0)
	}()))
	tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+72, z, 0))
	sqlite3.Xsqlite3_free(tls, z)
	return 0
}

// Usage:  sqlite3_mprintf_double FORMAT INTEGER INTEGER DOUBLE
//
// Call mprintf with two integer arguments and one double argument
func sqlite3_mprintf_double(tls *crt.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:1409:26: */
	bp := tls.Alloc(96)
	defer tls.Free(96)

	// var a [3]int32 at bp+72, 12

	var i int32
	// var r float64 at bp+88, 8

	var z uintptr
	if argc != 5 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
			ts+22077 /* " FORMAT INT INT ..." */, 0))
		return 1
	}
	for i = 2; i < 4; i++ {
		if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8)), (bp+72 /* &a */ +uintptr((i-2))*4)) != 0 {
			return 1
		}
	}
	if tcl.XTcl_GetDouble(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(4)*8)), bp+88 /* &r */) != 0 {
		return 1
	}
	z = sqlite3.Xsqlite3_mprintf(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), crt.VaList(bp+32, *(*int32)(unsafe.Pointer(bp + 72 /* &a[0] */ + uintptr(0)*4)), *(*int32)(unsafe.Pointer(bp + 72 /* &a[0] */ + uintptr(1)*4)), *(*float64)(unsafe.Pointer(bp + 88 /* r */))))
	tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+56, z, 0))
	sqlite3.Xsqlite3_free(tls, z)
	return 0
}

// Usage:  sqlite3_mprintf_scaled FORMAT DOUBLE DOUBLE
//
// Call mprintf with a single double argument which is the product of the
// two arguments given above.  This is used to generate overflow and underflow
// doubles to test that they are converted properly.
func sqlite3_mprintf_scaled(tls *crt.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:1440:26: */
	bp := tls.Alloc(72)
	defer tls.Free(72)

	var i int32
	// var r [2]float64 at bp+56, 16

	var z uintptr
	if argc != 4 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
			ts+22101 /* " FORMAT DOUBLE D..." */, 0))
		return 1
	}
	for i = 2; i < 4; i++ {
		if tcl.XTcl_GetDouble(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8)), (bp+56 /* &r */ +uintptr((i-2))*8)) != 0 {
			return 1
		}
	}
	z = sqlite3.Xsqlite3_mprintf(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), crt.VaList(bp+32, (*(*float64)(unsafe.Pointer(bp + 56 /* &r[0] */ + uintptr(0)*8))**(*float64)(unsafe.Pointer(bp + 56 /* &r[0] */ + uintptr(1)*8)))))
	tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+40, z, 0))
	sqlite3.Xsqlite3_free(tls, z)
	return 0
}

// Usage:  sqlite3_mprintf_stronly FORMAT STRING
//
// Call mprintf with a single double argument which is the product of the
// two arguments given above.  This is used to generate overflow and underflow
// doubles to test that they are converted properly.
func sqlite3_mprintf_stronly(tls *crt.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:1470:26: */
	bp := tls.Alloc(56)
	defer tls.Free(56)

	var z uintptr
	if argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
			ts+22124 /* " FORMAT STRING\"" */, 0))
		return 1
	}
	z = sqlite3.Xsqlite3_mprintf(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), crt.VaList(bp+32, *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8))))
	tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+40, z, 0))
	sqlite3.Xsqlite3_free(tls, z)
	return 0
}

// Usage:  sqlite3_mprintf_hexdouble FORMAT HEX
//
// Call mprintf with a single double argument which is derived from the
// hexadecimal encoding of an IEEE double.
func sqlite3_mprintf_hexdouble(tls *crt.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:1494:26: */
	bp := tls.Alloc(112)
	defer tls.Free(112)

	var z uintptr
	// var r float64 at bp+96, 8

	// var x1 uint32 at bp+92, 4

	// var x2 uint32 at bp+88, 4

	// var d sqlite_uint64 at bp+104, 8

	if argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
			ts+22124 /* " FORMAT STRING\"" */, 0))
		return 1
	}
	if crt.X__isoc99_sscanf(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8)), ts+22140 /* "%08x%08x" */, crt.VaList(bp+32, bp+88 /* &x2 */, bp+92 /* &x1 */)) != 2 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+48, ts+22149 /* "2nd argument sho..." */, 0))
		return 1
	}
	*(*sqlite_uint64)(unsafe.Pointer(bp + 104 /* d */)) = sqlite_uint64(*(*uint32)(unsafe.Pointer(bp + 88 /* x2 */)))
	*(*sqlite_uint64)(unsafe.Pointer(bp + 104 /* d */)) = ((*(*sqlite_uint64)(unsafe.Pointer(bp + 104 /* d */)) << 32) + sqlite_uint64(*(*uint32)(unsafe.Pointer(bp + 92 /* x1 */))))
	crt.Xmemcpy(tls, bp+96 /* &r */, bp+104 /* &d */, uint64(unsafe.Sizeof(float64(0))))
	z = sqlite3.Xsqlite3_mprintf(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), crt.VaList(bp+64, *(*float64)(unsafe.Pointer(bp + 96 /* r */))))
	tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+72, z, 0))
	sqlite3.Xsqlite3_free(tls, z)
	return 0
}

// Usage: sqlite3_enable_shared_cache ?BOOLEAN?
//
func test_enable_shared(tls *crt.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:1527:26: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var rc int32
	// var enable int32 at bp, 4

	var ret int32 = 0

	if (objc != 2) && (objc != 1) {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+22193 /* "?BOOLEAN?" */)
		return 1
	}
	ret = sqlite3.Xsqlite3Config.FsharedCacheEnabled

	if objc == 2 {
		if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)), bp /* &enable */) != 0 {
			return 1
		}
		rc = sqlite3.Xsqlite3_enable_shared_cache(tls, *(*int32)(unsafe.Pointer(bp /* enable */)))
		if rc != 0 {
			tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrStr(tls, rc), uintptr(0))
			return 1
		}
	}
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, (crt.Bool32((ret) != 0))))
	return 0
}

// Usage: sqlite3_extended_result_codes   DB    BOOLEAN
//
func test_extended_result_codes(tls *crt.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:1564:26: */
	bp := tls.Alloc(12)
	defer tls.Free(12)

	// var enable int32 at bp+8, 4

	// var db uintptr at bp, 8

	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+22203 /* "DB BOOLEAN" */)
		return 1
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), bp /* &db */) != 0 {
		return 1
	}
	if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)), bp+8 /* &enable */) != 0 {
		return 1
	}
	sqlite3.Xsqlite3_extended_result_codes(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), *(*int32)(unsafe.Pointer(bp + 8 /* enable */)))
	return 0
}

// Usage: sqlite3_libversion_number
//
func test_libversion_number(tls *crt.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:1587:26: */
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, sqlite3.Xsqlite3_libversion_number(tls)))
	return 0
}

// Usage: sqlite3_table_column_metadata DB dbname tblname colname
//
func test_table_column_metadata(tls *crt.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:1601:26: */
	bp := tls.Alloc(52)
	defer tls.Free(52)

	// var db uintptr at bp+16, 8

	var zDb uintptr
	var zTbl uintptr
	var zCol uintptr
	var rc int32
	var pRet uintptr
	// var zDatatype uintptr at bp+24, 8

	// var zCollseq uintptr at bp+32, 8

	// var notnull int32 at bp+40, 4

	// var primarykey int32 at bp+44, 4

	// var autoincrement int32 at bp+48, 4

	if (objc != 5) && (objc != 4) {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+22214 /* "DB dbname tblnam..." */)
		return 1
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), bp+16 /* &db */) != 0 {
		return 1
	}
	zDb = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)))
	zTbl = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(3)*8)))
	if objc == 5 {
		zCol = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(4)*8)))
	} else {
		zCol = uintptr(0)
	}

	if crt.Xstrlen(tls, zDb) == uint64(0) {
		zDb = uintptr(0)
	}

	rc = sqlite3.Xsqlite3_table_column_metadata(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* db */)), zDb, zTbl, zCol,
		bp+24 /* &zDatatype */, bp+32 /* &zCollseq */, bp+40 /* &notnull */, bp+44 /* &primarykey */, bp+48 /* &autoincrement */)

	if rc != 0 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, sqlite3.Xsqlite3_errmsg(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* db */))), 0))
		return 1
	}

	pRet = tcl.XTcl_NewObj(tls)
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pRet, tcl.XTcl_NewStringObj(tls, *(*uintptr)(unsafe.Pointer(bp + 24 /* zDatatype */)), -1))
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pRet, tcl.XTcl_NewStringObj(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* zCollseq */)), -1))
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pRet, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 40 /* notnull */))))
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pRet, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 44 /* primarykey */))))
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pRet, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 48 /* autoincrement */))))
	tcl.XTcl_SetObjResult(tls, interp, pRet)

	return 0
}

func blobHandleFromObj(tls *crt.TLS, interp uintptr, pObj uintptr, ppBlob uintptr) int32 { /* test1.c:1652:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var z uintptr
	// var n int32 at bp, 4

	z = tcl.XTcl_GetStringFromObj(tls, pObj, bp /* &n */)
	if *(*int32)(unsafe.Pointer(bp /* n */)) == 0 {
		*(*uintptr)(unsafe.Pointer(ppBlob)) = uintptr(0)
	} else {
		// var notUsed int32 at bp+4, 4

		var channel Tcl_Channel
		var instanceData ClientData

		channel = tcl.XTcl_GetChannel(tls, interp, z, bp+4 /* &notUsed */)
		if !(channel != 0) {
			return 1
		}

		tcl.XTcl_Flush(tls, channel)
		tcl.XTcl_Seek(tls, channel, int64(0), 0)

		instanceData = tcl.XTcl_GetChannelInstanceData(tls, channel)
		*(*uintptr)(unsafe.Pointer(ppBlob)) = *(*uintptr)(unsafe.Pointer(instanceData))
	}

	return 0
}

func test_blob_reopen(tls *crt.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:1681:26: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	// var iRowid Tcl_WideInt at bp+8, 8

	// var pBlob uintptr at bp, 8

	var rc int32

	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+22240 /* "CHANNEL ROWID" */)
		return 1
	}

	if blobHandleFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)), bp /* &pBlob */) != 0 {
		return 1
	}
	if tcl.XTcl_GetWideIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)), bp+8 /* &iRowid */) != 0 {
		return 1
	}

	rc = sqlite3.Xsqlite3_blob_reopen(tls, *(*uintptr)(unsafe.Pointer(bp /* pBlob */)), int64(*(*Tcl_WideInt)(unsafe.Pointer(bp + 8 /* iRowid */))))
	if rc != 0 {
		tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(1))
	}

	return func() int32 {
		if rc == 0 {
			return 0
		}
		return 1
	}()
}

// Usage: sqlite3_create_collation_v2 DB-HANDLE NAME CMP-PROC DEL-PROC
//
//   This Tcl proc is used for testing the experimental
//   sqlite3_create_collation_v2() interface.
type TestCollationX1 = struct {
	Finterp uintptr
	FpCmp   uintptr
	FpDel   uintptr
}

type TestCollationX = TestCollationX1 /* test1.c:1720:31 */
func testCreateCollationDel(tls *crt.TLS, pCtx uintptr) { /* test1.c:1721:13: */
	var p uintptr = pCtx

	var rc int32 = tcl.XTcl_EvalObjEx(tls, (*TestCollationX)(unsafe.Pointer(p)).Finterp, (*TestCollationX)(unsafe.Pointer(p)).FpDel, (0x040000 | 0x020000))
	if rc != 0 {
		tcl.XTcl_BackgroundError(tls, (*TestCollationX)(unsafe.Pointer(p)).Finterp)
	}

	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = (*TestCollationX)(unsafe.Pointer(p)).FpCmp
		if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	for ok1 := true; ok1; ok1 = 0 != 0 {
		var _objPtr uintptr = (*TestCollationX)(unsafe.Pointer(p)).FpDel
		if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	sqlite3.Xsqlite3_free(tls, p)
}
func testCreateCollationCmp(tls *crt.TLS, pCtx uintptr, nLeft int32, zLeft uintptr, nRight int32, zRight uintptr) int32 { /* test1.c:1733:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var p uintptr = pCtx
	var pScript uintptr = tcl.XTcl_DuplicateObj(tls, (*TestCollationX)(unsafe.Pointer(p)).FpCmp)
	*(*int32)(unsafe.Pointer(bp /* iRes */)) = 0

	(*Tcl_Obj)(unsafe.Pointer(pScript)).FrefCount++
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pScript, tcl.XTcl_NewStringObj(tls, zLeft, nLeft))
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pScript, tcl.XTcl_NewStringObj(tls, zRight, nRight))

	if (0 != tcl.XTcl_EvalObjEx(tls, (*TestCollationX)(unsafe.Pointer(p)).Finterp, pScript, (0x040000|0x020000))) ||
		(0 != tcl.XTcl_GetIntFromObj(tls, (*TestCollationX)(unsafe.Pointer(p)).Finterp, tcl.XTcl_GetObjResult(tls, (*TestCollationX)(unsafe.Pointer(p)).Finterp), bp /* &iRes */)) {
		tcl.XTcl_BackgroundError(tls, (*TestCollationX)(unsafe.Pointer(p)).Finterp)
	}
	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = pScript
		if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}

	return *(*int32)(unsafe.Pointer(bp /* iRes */))
}
func test_create_collation_v2(tls *crt.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:1757:26: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	var p uintptr
	// var db uintptr at bp+16, 8

	var rc int32

	if objc != 5 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+22254 /* "DB-HANDLE NAME C..." */)
		return 1
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), bp+16 /* &db */) != 0 {
		return 1
	}

	p = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(TestCollationX{})))
	(*TestCollationX)(unsafe.Pointer(p)).FpCmp = *(*uintptr)(unsafe.Pointer(objv + uintptr(3)*8))
	(*TestCollationX)(unsafe.Pointer(p)).FpDel = *(*uintptr)(unsafe.Pointer(objv + uintptr(4)*8))
	(*TestCollationX)(unsafe.Pointer(p)).Finterp = interp
	(*Tcl_Obj)(unsafe.Pointer((*TestCollationX)(unsafe.Pointer(p)).FpCmp)).FrefCount++
	(*Tcl_Obj)(unsafe.Pointer((*TestCollationX)(unsafe.Pointer(p)).FpDel)).FrefCount++

	rc = sqlite3.Xsqlite3_create_collation_v2(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* db */)), tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8))), 16,
		p, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*crt.TLS, uintptr, int32, uintptr, int32, uintptr) int32
		}{testCreateCollationCmp})), *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, uintptr) }{testCreateCollationDel})))
	if rc != 21 {
		tcl.XTcl_AppendResult(tls, interp,
			crt.VaList(bp, ts+22287 /* "sqlite3_create_c..." */, uintptr(0)))
		return 1
	}
	rc = sqlite3.Xsqlite3_create_collation_v2(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* db */)), tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8))), 1,
		p, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*crt.TLS, uintptr, int32, uintptr, int32, uintptr) int32
		}{testCreateCollationCmp})), *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, uintptr) }{testCreateCollationDel})))
	return 0
}

// USAGE: sqlite3_create_function_v2 DB NAME NARG ENC ?SWITCHES?
//
// Available switches are:
//
//   -func    SCRIPT
//   -step    SCRIPT
//   -final   SCRIPT
//   -destroy SCRIPT
type CreateFunctionV21 = struct {
	Finterp   uintptr
	FpFunc    uintptr
	FpStep    uintptr
	FpFinal   uintptr
	FpDestroy uintptr
}

// USAGE: sqlite3_create_function_v2 DB NAME NARG ENC ?SWITCHES?
//
// Available switches are:
//
//   -func    SCRIPT
//   -step    SCRIPT
//   -final   SCRIPT
//   -destroy SCRIPT
type CreateFunctionV2 = CreateFunctionV21 /* test1.c:1804:33 */
func cf2Func(tls *crt.TLS, ctx uintptr, nArg int32, aArg uintptr) { /* test1.c:1812:13: */
}
func cf2Step(tls *crt.TLS, ctx uintptr, nArg int32, aArg uintptr) { /* test1.c:1814:13: */
}
func cf2Final(tls *crt.TLS, ctx uintptr) { /* test1.c:1816:13: */
}
func cf2Destroy(tls *crt.TLS, pUser uintptr) { /* test1.c:1818:13: */
	var p uintptr = pUser

	if ((*CreateFunctionV2)(unsafe.Pointer(p)).Finterp != 0) && ((*CreateFunctionV2)(unsafe.Pointer(p)).FpDestroy != 0) {
		var rc int32 = tcl.XTcl_EvalObjEx(tls, (*CreateFunctionV2)(unsafe.Pointer(p)).Finterp, (*CreateFunctionV2)(unsafe.Pointer(p)).FpDestroy, 0)
		if rc != 0 {
			tcl.XTcl_BackgroundError(tls, (*CreateFunctionV2)(unsafe.Pointer(p)).Finterp)
		}
	}

	if (*CreateFunctionV2)(unsafe.Pointer(p)).FpFunc != 0 {
		for ok := true; ok; ok = 0 != 0 {
			var _objPtr uintptr = (*CreateFunctionV2)(unsafe.Pointer(p)).FpFunc
			if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
	}
	if (*CreateFunctionV2)(unsafe.Pointer(p)).FpStep != 0 {
		for ok1 := true; ok1; ok1 = 0 != 0 {
			var _objPtr uintptr = (*CreateFunctionV2)(unsafe.Pointer(p)).FpStep
			if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
	}
	if (*CreateFunctionV2)(unsafe.Pointer(p)).FpFinal != 0 {
		for ok2 := true; ok2; ok2 = 0 != 0 {
			var _objPtr uintptr = (*CreateFunctionV2)(unsafe.Pointer(p)).FpFinal
			if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
	}
	if (*CreateFunctionV2)(unsafe.Pointer(p)).FpDestroy != 0 {
		for ok3 := true; ok3; ok3 = 0 != 0 {
			var _objPtr uintptr = (*CreateFunctionV2)(unsafe.Pointer(p)).FpDestroy
			if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
	}
	sqlite3.Xsqlite3_free(tls, p)
}
func test_create_function_v2(tls *crt.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:1832:26: */
	bp := tls.Alloc(180)
	defer tls.Free(180)

	// var db uintptr at bp+16, 8

	var zFunc uintptr
	// var nArg int32 at bp+24, 4

	// var enc int32 at bp+128, 4

	var p uintptr
	var i int32
	var rc int32

	*(*[6]EncTable)(unsafe.Pointer(bp + 32 /* aEnc */)) = [6]EncTable{
		{FzEnc: ts + 22352 /* "utf8" */, Fenc: 1},
		{FzEnc: ts + 22357 /* "utf16" */, Fenc: 4},
		{FzEnc: ts + 22363 /* "utf16le" */, Fenc: 2},
		{FzEnc: ts + 22371 /* "utf16be" */, Fenc: 3},
		{FzEnc: ts + 19423 /* "any" */, Fenc: 5},
		{FzEnc: ts + 8293 /* "0" */, Fenc: 0},
	}

	if (objc < 5) || ((objc % 2) == 0) {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+22379 /* "DB NAME NARG ENC..." */)
		return 1
	}

	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), bp+16 /* &db */) != 0 {
		return 1
	}
	zFunc = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)))
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(3)*8)), bp+24 /* &nArg */) != 0 {
		return 1
	}
	if tcl.XTcl_GetIndexFromObjStruct(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(4)*8)), bp+32 /* &aEnc[0] */, int32(unsafe.Sizeof(EncTable{})),
		ts+22408 /* "encoding" */, 0, bp+128 /* &enc */) != 0 {
		return 1
	}
	*(*int32)(unsafe.Pointer(bp + 128 /* enc */)) = (*EncTable)(unsafe.Pointer(bp + 32 /* &aEnc */ + uintptr(*(*int32)(unsafe.Pointer(bp + 128 /* enc */)))*16)).Fenc

	p = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(CreateFunctionV2{})))

	crt.Xmemset(tls, p, 0, uint64(unsafe.Sizeof(CreateFunctionV2{})))
	(*CreateFunctionV2)(unsafe.Pointer(p)).Finterp = interp

	for i = 5; i < objc; i = i + (2) {
		// var iSwitch int32 at bp+176, 4

		*(*[5]uintptr)(unsafe.Pointer(bp + 136 /* azSwitch */)) = [5]uintptr{ts + 22417 /* "-func" */, ts + 22423 /* "-step" */, ts + 22429 /* "-final" */, ts + 22436 /* "-destroy" */, uintptr(0)}
		if tcl.XTcl_GetIndexFromObjStruct(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(i)*8)), bp+136 /* &azSwitch[0] */, int32(unsafe.Sizeof(uintptr(0))), ts+22445 /* "switch" */, 0, bp+176 /* &iSwitch */) != 0 {
			sqlite3.Xsqlite3_free(tls, p)
			return 1
		}

		switch *(*int32)(unsafe.Pointer(bp + 176 /* iSwitch */)) {
		case 0:
			(*CreateFunctionV2)(unsafe.Pointer(p)).FpFunc = *(*uintptr)(unsafe.Pointer(objv + uintptr((i+1))*8))
			break
		case 1:
			(*CreateFunctionV2)(unsafe.Pointer(p)).FpStep = *(*uintptr)(unsafe.Pointer(objv + uintptr((i+1))*8))
			break
		case 2:
			(*CreateFunctionV2)(unsafe.Pointer(p)).FpFinal = *(*uintptr)(unsafe.Pointer(objv + uintptr((i+1))*8))
			break
		case 3:
			(*CreateFunctionV2)(unsafe.Pointer(p)).FpDestroy = *(*uintptr)(unsafe.Pointer(objv + uintptr((i+1))*8))
			break
		}
	}
	if (*CreateFunctionV2)(unsafe.Pointer(p)).FpFunc != 0 {
		(*CreateFunctionV2)(unsafe.Pointer(p)).FpFunc = tcl.XTcl_DuplicateObj(tls, (*CreateFunctionV2)(unsafe.Pointer(p)).FpFunc)
	}
	if (*CreateFunctionV2)(unsafe.Pointer(p)).FpStep != 0 {
		(*CreateFunctionV2)(unsafe.Pointer(p)).FpStep = tcl.XTcl_DuplicateObj(tls, (*CreateFunctionV2)(unsafe.Pointer(p)).FpStep)
	}
	if (*CreateFunctionV2)(unsafe.Pointer(p)).FpFinal != 0 {
		(*CreateFunctionV2)(unsafe.Pointer(p)).FpFinal = tcl.XTcl_DuplicateObj(tls, (*CreateFunctionV2)(unsafe.Pointer(p)).FpFinal)
	}
	if (*CreateFunctionV2)(unsafe.Pointer(p)).FpDestroy != 0 {
		(*CreateFunctionV2)(unsafe.Pointer(p)).FpDestroy = tcl.XTcl_DuplicateObj(tls, (*CreateFunctionV2)(unsafe.Pointer(p)).FpDestroy)
	}

	if (*CreateFunctionV2)(unsafe.Pointer(p)).FpFunc != 0 {
		(*Tcl_Obj)(unsafe.Pointer((*CreateFunctionV2)(unsafe.Pointer(p)).FpFunc)).FrefCount++
	}
	if (*CreateFunctionV2)(unsafe.Pointer(p)).FpStep != 0 {
		(*Tcl_Obj)(unsafe.Pointer((*CreateFunctionV2)(unsafe.Pointer(p)).FpStep)).FrefCount++
	}
	if (*CreateFunctionV2)(unsafe.Pointer(p)).FpFinal != 0 {
		(*Tcl_Obj)(unsafe.Pointer((*CreateFunctionV2)(unsafe.Pointer(p)).FpFinal)).FrefCount++
	}
	if (*CreateFunctionV2)(unsafe.Pointer(p)).FpDestroy != 0 {
		(*Tcl_Obj)(unsafe.Pointer((*CreateFunctionV2)(unsafe.Pointer(p)).FpDestroy)).FrefCount++
	}

	rc = sqlite3.Xsqlite3_create_function_v2(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* db */)), zFunc, *(*int32)(unsafe.Pointer(bp + 24 /* nArg */)), *(*int32)(unsafe.Pointer(bp + 128 /* enc */)), p,
		func() uintptr {
			if (*CreateFunctionV2)(unsafe.Pointer(p)).FpFunc != 0 {
				return *(*uintptr)(unsafe.Pointer(&struct {
					f func(*crt.TLS, uintptr, int32, uintptr)
				}{cf2Func}))
			}
			return uintptr(0)
		}(),
		func() uintptr {
			if (*CreateFunctionV2)(unsafe.Pointer(p)).FpStep != 0 {
				return *(*uintptr)(unsafe.Pointer(&struct {
					f func(*crt.TLS, uintptr, int32, uintptr)
				}{cf2Step}))
			}
			return uintptr(0)
		}(),
		func() uintptr {
			if (*CreateFunctionV2)(unsafe.Pointer(p)).FpFinal != 0 {
				return *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, uintptr) }{cf2Final}))
			}
			return uintptr(0)
		}(),
		*(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, uintptr) }{cf2Destroy})))
	if rc != 0 {
		tcl.XTcl_ResetResult(tls, interp)
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, sqlite3.Xsqlite3ErrName(tls, rc), 0))
		return 1
	}
	return 0
}

type EncTable = struct {
	FzEnc uintptr
	Fenc  int32
	_     [4]byte
}

// Usage: sqlite3_load_extension DB-HANDLE FILE ?PROC?
func test_load_extension(tls *crt.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:1920:26: */
	bp := tls.Alloc(88)
	defer tls.Free(88)

	// var cmdInfo Tcl_CmdInfo at bp+24, 64

	var db uintptr
	_ = db
	var rc int32
	var zDb uintptr
	var zFile uintptr
	_ = zFile
	var zProc uintptr = uintptr(0)
	_ = zProc
	var zErr uintptr = uintptr(0)

	if (objc != 4) && (objc != 3) {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+22452 /* "DB-HANDLE FILE ?..." */)
		return 1
	}
	zDb = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)))
	zFile = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)))
	if objc == 4 {
		zProc = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(3)*8)))
	}

	// Extract the C database handle from the Tcl command name
	if !(tcl.XTcl_GetCommandInfo(tls, interp, zDb, bp+24 /* &cmdInfo */) != 0) {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21525 /* "command not foun..." */, zDb, uintptr(0)))
		return 1
	}
	db = (*struct{ Fdb uintptr })(unsafe.Pointer((*Tcl_CmdInfo)(unsafe.Pointer(bp + 24 /* &cmdInfo */)).FobjClientData)).Fdb

	// Call the underlying C function. If an error occurs, set rc to
	// TCL_ERROR and load any error string into the interpreter. If no
	// error occurs, set rc to TCL_OK.
	rc = 1
	zErr = sqlite3.Xsqlite3_mprintf(tls, ts+22474 /* "this build omits..." */, 0)
	_ = zProc
	_ = zFile
	if rc != 0 {
		tcl.XTcl_SetResult(tls, interp, func() uintptr {
			if zErr != 0 {
				return zErr
			}
			return ts + 792 /* "" */
		}(), uintptr(1))
		rc = 1
	} else {
		rc = 0
	}
	sqlite3.Xsqlite3_free(tls, zErr)

	return rc
}

// Usage: sqlite3_enable_load_extension DB-HANDLE ONOFF
func test_enable_load(tls *crt.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:1978:26: */
	bp := tls.Alloc(100)
	defer tls.Free(100)

	// var cmdInfo Tcl_CmdInfo at bp+32, 64

	var db uintptr
	_ = db
	var zDb uintptr
	// var onoff int32 at bp+96, 4

	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+22516 /* "DB-HANDLE ONOFF" */)
		return 1
	}
	zDb = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)))

	// Extract the C database handle from the Tcl command name
	if !(tcl.XTcl_GetCommandInfo(tls, interp, zDb, bp+32 /* &cmdInfo */) != 0) {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21525 /* "command not foun..." */, zDb, uintptr(0)))
		return 1
	}
	db = (*struct{ Fdb uintptr })(unsafe.Pointer((*Tcl_CmdInfo)(unsafe.Pointer(bp + 32 /* &cmdInfo */)).FobjClientData)).Fdb

	// Get the onoff parameter
	if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)), bp+96 /* &onoff */) != 0 {
		return 1
	}

	tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+24, ts+22474 /* "this build omits..." */))
	return 1
}

// Usage:  sqlite_abort
//
// Shutdown the process immediately.  This is not a clean shutdown.
// This command is used to test the recoverability of a database in
// the event of a program crash.
func sqlite_abort(tls *crt.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:2024:26: */
	crt.Xexit(tls, 255)
	// This will always fail
	return 0
}

// The following routine is a user-defined SQL function whose purpose
// is to test the sqlite_set_result() API.
func testFunc(tls *crt.TLS, context uintptr, argc int32, argv uintptr) { /* test1.c:2045:13: */
	var zArg0 uintptr
__1:
	if !(argc >= 2) {
		goto __2
	}
	zArg0 = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)))
	if !(zArg0 != 0) {
		goto __3
	}
	if !(0 == sqlite3.Xsqlite3StrICmp(tls, zArg0, ts+17462 /* "int" */)) {
		goto __5
	}
	sqlite3.Xsqlite3_result_int(tls, context, sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8))))
	goto __6
__5:
	if !(sqlite3.Xsqlite3StrICmp(tls, zArg0, ts+3370 /* "int64" */) == 0) {
		goto __7
	}
	sqlite3.Xsqlite3_result_int64(tls, context, sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8))))
	goto __8
__7:
	if !(sqlite3.Xsqlite3StrICmp(tls, zArg0, ts+22532 /* "string" */) == 0) {
		goto __9
	}
	sqlite3.Xsqlite3_result_text(tls, context, sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8))), -1,
		crt.UintptrFromInt32(-1))
	goto __10
__9:
	if !(sqlite3.Xsqlite3StrICmp(tls, zArg0, ts+3376 /* "double" */) == 0) {
		goto __11
	}
	sqlite3.Xsqlite3_result_double(tls, context, sqlite3.Xsqlite3_value_double(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8))))
	goto __12
__11:
	if !(sqlite3.Xsqlite3StrICmp(tls, zArg0, ts+7418 /* "null" */) == 0) {
		goto __13
	}
	sqlite3.Xsqlite3_result_null(tls, context)
	goto __14
__13:
	if !(sqlite3.Xsqlite3StrICmp(tls, zArg0, ts+22539 /* "value" */) == 0) {
		goto __15
	}
	sqlite3.Xsqlite3_result_value(tls, context, *(*uintptr)(unsafe.Pointer(argv + uintptr(sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8))))*8)))
	goto __16
__15:
	goto error_out
__16:
	;
__14:
	;
__12:
	;
__10:
	;
__8:
	;
__6:
	;
	goto __4
__3:
	goto error_out
__4:
	;
	argc = argc - (2)
	argv += 8 * (uintptr(2))
	goto __1
__2:
	;
	return

error_out:
	sqlite3.Xsqlite3_result_error(tls, context,
		ts+22545 /* "first argument s..." */, -1)
}

// Usage:   sqlite_register_test_function  DB  NAME
//
// Register the test SQL function on the database DB under the name NAME.
func test_register_func(tls *crt.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:2083:26: */
	bp := tls.Alloc(56)
	defer tls.Free(56)

	// var db uintptr at bp+48, 8

	var rc int32
	if argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
			ts+22613 /* " DB FUNCTION-NAM..." */, 0))
		return 1
	}
	if getDbPointer(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), bp+48 /* &db */) != 0 {
		return 1
	}
	rc = sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp + 48 /* db */)), *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8)), -1, 1, uintptr(0),
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*crt.TLS, uintptr, int32, uintptr)
		}{testFunc})), uintptr(0), uintptr(0))
	if rc != 0 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+32, sqlite3.Xsqlite3ErrStr(tls, rc), 0))
		return 1
	}
	if sqlite3TestErrCode(tls, interp, *(*uintptr)(unsafe.Pointer(bp + 48 /* db */)), rc) != 0 {
		return 1
	}
	return 0
}

// Usage:  sqlite3_finalize  STMT
//
// Finalize a statement handle.
func test_finalize(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:2112:26: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	// var pStmt uintptr at bp+32, 8

	var rc int32
	var db uintptr = uintptr(0)

	if objc != 2 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615, /* "wrong # args: sh..." */
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(0)*8)), uintptr(0)), ts+22631 /* " <STMT>" */, 0))
		return 1
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), bp+32 /* &pStmt */) != 0 {
		return 1
	}

	if *(*uintptr)(unsafe.Pointer(bp + 32 /* pStmt */)) != 0 {
		db = sqlite3.Xsqlite3_db_handle(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* pStmt */)))
	}
	rc = sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* pStmt */)))
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))
	if (db != 0) && (sqlite3TestErrCode(tls, interp, db, rc) != 0) {
		return 1
	}
	return 0
}

// Usage:  sqlite3_stmt_status  STMT  CODE  RESETFLAG
//
// Get the value of a status counter from a statement.
func test_stmt_status(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:2144:26: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var iValue int32
	var i int32
	*(*int32)(unsafe.Pointer(bp + 8 /* op */)) = 0
	// var resetFlag int32 at bp+12, 4

	var zOpName uintptr
	// var pStmt uintptr at bp, 8

	if objc != 4 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+22639 /* "STMT PARAMETER R..." */)
		return 1
	}
	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), bp /* &pStmt */) != 0 {
		return 1
	}
	zOpName = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)))
	for i = 0; i < (int32(uint64(unsafe.Sizeof(aOp)) / uint64(unsafe.Sizeof(struct {
		FzName uintptr
		Fop    int32
		_      [4]byte
	}{})))); i++ {
		if crt.Xstrcmp(tls, aOp[i].FzName, zOpName) == 0 {
			*(*int32)(unsafe.Pointer(bp + 8 /* op */)) = aOp[i].Fop
			break
		}
	}
	if i >= (int32(uint64(unsafe.Sizeof(aOp)) / uint64(unsafe.Sizeof(struct {
		FzName uintptr
		Fop    int32
		_      [4]byte
	}{})))) {
		if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)), bp+8 /* &op */) != 0 {
			return 1
		}
	}
	if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(3)*8)), bp+12 /* &resetFlag */) != 0 {
		return 1
	}
	iValue = sqlite3.Xsqlite3_stmt_status(tls, *(*uintptr)(unsafe.Pointer(bp /* pStmt */)), *(*int32)(unsafe.Pointer(bp + 8 /* op */)), *(*int32)(unsafe.Pointer(bp + 12 /* resetFlag */)))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, iValue))
	return 0
}

var aOp = [7]struct {
	FzName uintptr
	Fop    int32
	_      [4]byte
}{
	{FzName: ts + 22664 /* "SQLITE_STMTSTATU..." */, Fop: 1},
	{FzName: ts + 22696 /* "SQLITE_STMTSTATU..." */, Fop: 2},
	{FzName: ts + 22719 /* "SQLITE_STMTSTATU..." */, Fop: 3},
	{FzName: ts + 22747 /* "SQLITE_STMTSTATU..." */, Fop: 4},
	{FzName: ts + 22773 /* "SQLITE_STMTSTATU..." */, Fop: 5},
	{FzName: ts + 22801 /* "SQLITE_STMTSTATU..." */, Fop: 6},
	{FzName: ts + 22823 /* "SQLITE_STMTSTATU..." */, Fop: 99},
} /* test1.c:2158:5 */

// Usage:  sqlite3_config_sorterref
//
// Set the SQLITE_CONFIG_SORTERREF_SIZE configuration option
func test_config_sorterref(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:2285:26: */
	bp := tls.Alloc(12)
	defer tls.Free(12)

	// var iVal int32 at bp+8, 4

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+22849 /* "NBYTE" */)
		return 1
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)), bp+8 /* &iVal */) != 0 {
		return 1
	}
	sqlite3.Xsqlite3_config(tls, 28, crt.VaList(bp, *(*int32)(unsafe.Pointer(bp + 8 /* iVal */))))
	return 0
}

// Usage: vfs_current_time_int64
//
// Return the value returned by the default VFS's xCurrentTimeInt64 method.
func vfsCurrentTimeInt64(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:2306:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// var t i64 at bp, 8

	var pVfs uintptr = sqlite3.Xsqlite3_vfs_find(tls, uintptr(0))
	if objc != 1 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+792 /* "" */)
		return 1
	}
	(*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer((pVfs + 136 /* &.xCurrentTimeInt64 */))))(tls, pVfs, bp /* &t */)
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewWideIntObj(tls, int64(*(*i64)(unsafe.Pointer(bp /* t */)))))
	return 0
} // in test_delete.c
func test_delete_database(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:2581:26: */
	var rc int32
	var zFile uintptr
	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+22855 /* "FILE" */)
		return 1
	}
	zFile = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)))
	rc = sqlite3_delete_database(tls, zFile)

	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3ErrName(tls, rc), -1))
	return 0
}

// Usage: atomic_batch_write PATH
func test_atomic_batch_write(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:2603:26: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var zFile uintptr = uintptr(0)                              // Path to file to test
	*(*uintptr)(unsafe.Pointer(bp + 16 /* db */)) = uintptr(0)  // Database handle
	*(*uintptr)(unsafe.Pointer(bp + 24 /* pFd */)) = uintptr(0) // SQLite fd open on zFile
	var bRes int32 = 0                                          // Integer result of this command
	var dc int32 = 0                                            // Device-characteristics mask
	var rc int32                                                // sqlite3_open() return code

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+22860 /* "PATH" */)
		return 1
	}
	zFile = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)))

	rc = sqlite3.Xsqlite3_open(tls, zFile, bp+16 /* &db */)
	if rc != 0 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, sqlite3.Xsqlite3_errmsg(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* db */))), 0))
		sqlite3.Xsqlite3_close(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* db */)))
		return 1
	}

	rc = sqlite3.Xsqlite3_file_control(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* db */)), ts+354 /* "main" */, 7, bp+24 /* &pFd */)
	dc = (*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 24 /* pFd */)))).FpMethods + 96 /* &.xDeviceCharacteristics */))))(tls, *(*uintptr)(unsafe.Pointer(bp + 24 /* pFd */)))
	if (dc & 0x00004000) != 0 {
		bRes = 1
	}

	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, bRes))
	sqlite3.Xsqlite3_close(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* db */)))
	return 0
}

// Usage:  sqlite3_next_stmt  DB  STMT
//
// Return the next statment in sequence after STMT.
func test_next_stmt(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:2645:26: */
	bp := tls.Alloc(114)
	defer tls.Free(114)

	// var pStmt uintptr at bp+56, 8

	*(*uintptr)(unsafe.Pointer(bp + 48 /* db */)) = uintptr(0)
	// var zBuf [50]int8 at bp+64, 50

	if objc != 3 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615, /* "wrong # args: sh..." */
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(0)*8)), uintptr(0)), ts+22865 /* " DB STMT" */, 0))
		return 1
	}

	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), bp+48 /* &db */) != 0 {
		return 1
	}
	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8))), bp+56 /* &pStmt */) != 0 {
		return 1
	}
	*(*uintptr)(unsafe.Pointer(bp + 56 /* pStmt */)) = sqlite3.Xsqlite3_next_stmt(tls, *(*uintptr)(unsafe.Pointer(bp + 48 /* db */)), *(*uintptr)(unsafe.Pointer(bp + 56 /* pStmt */)))
	if *(*uintptr)(unsafe.Pointer(bp + 56 /* pStmt */)) != 0 {
		if sqlite3TestMakePointerStr(tls, interp, bp+64 /* &zBuf[0] */, *(*uintptr)(unsafe.Pointer(bp + 56 /* pStmt */))) != 0 {
			return 1
		}
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+32, bp+64 /* &zBuf[0] */, 0))
	}
	return 0
}

// Usage:  sqlite3_stmt_readonly  STMT
//
// Return true if STMT is a NULL pointer or a pointer to a statement
// that is guaranteed to leave the database unmodified.
func test_stmt_readonly(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:2677:26: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	// var pStmt uintptr at bp+32, 8

	var rc int32

	if objc != 2 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615, /* "wrong # args: sh..." */
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(0)*8)), uintptr(0)), ts+22874 /* " STMT" */, 0))
		return 1
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), bp+32 /* &pStmt */) != 0 {
		return 1
	}
	rc = sqlite3.Xsqlite3_stmt_readonly(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* pStmt */)))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, (crt.Bool32((rc) != 0))))
	return 0
}

// Usage:  sqlite3_stmt_isexplain  STMT
//
// Return 1, 2, or 0 respectively if STMT is an EXPLAIN statement, an
// EXPLAIN QUERY PLAN statement or an ordinary statement or NULL pointer.
func test_stmt_isexplain(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:2704:26: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	// var pStmt uintptr at bp+32, 8

	var rc int32

	if objc != 2 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615, /* "wrong # args: sh..." */
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(0)*8)), uintptr(0)), ts+22874 /* " STMT" */, 0))
		return 1
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), bp+32 /* &pStmt */) != 0 {
		return 1
	}
	rc = sqlite3.Xsqlite3_stmt_isexplain(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* pStmt */)))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, rc))
	return 0
}

// Usage:  sqlite3_stmt_busy  STMT
//
// Return true if STMT is a non-NULL pointer to a statement
// that has been stepped but not to completion.
func test_stmt_busy(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:2731:26: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	// var pStmt uintptr at bp+32, 8

	var rc int32

	if objc != 2 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615, /* "wrong # args: sh..." */
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(0)*8)), uintptr(0)), ts+22874 /* " STMT" */, 0))
		return 1
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), bp+32 /* &pStmt */) != 0 {
		return 1
	}
	rc = sqlite3.Xsqlite3_stmt_busy(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* pStmt */)))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, (crt.Bool32((rc) != 0))))
	return 0
}

// Usage:  uses_stmt_journal  STMT
//
// Return true if STMT uses a statement journal.
func uses_stmt_journal(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:2757:26: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	// var pStmt uintptr at bp+32, 8

	if objc != 2 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615, /* "wrong # args: sh..." */
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(0)*8)), uintptr(0)), ts+22874 /* " STMT" */, 0))
		return 1
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), bp+32 /* &pStmt */) != 0 {
		return 1
	}
	sqlite3.Xsqlite3_stmt_readonly(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* pStmt */)))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, (crt.Bool32((int32(*(*uint16)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32 /* pStmt */)) + 200 /* &.usesStmtJournal */))&0x40>>6)) != 0))))
	return 0
}

// Usage:  sqlite3_reset  STMT
//
// Reset a statement handle.
func test_reset(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:2783:26: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	// var pStmt uintptr at bp+32, 8

	var rc int32

	if objc != 2 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615, /* "wrong # args: sh..." */
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(0)*8)), uintptr(0)), ts+22631 /* " <STMT>" */, 0))
		return 1
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), bp+32 /* &pStmt */) != 0 {
		return 1
	}

	rc = sqlite3.Xsqlite3_reset(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* pStmt */)))
	if (*(*uintptr)(unsafe.Pointer(bp + 32 /* pStmt */)) != 0) && (sqlite3TestErrCode(tls, interp, sqlite3.Xsqlite3_db_handle(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* pStmt */))), rc) != 0) {
		return 1
	}
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))
	//
	//  if( rc ){
	//    return TCL_ERROR;
	//  }
	return 0
}

// Usage:  sqlite3_expired STMT
//
// Return TRUE if a recompilation of the statement is recommended.
func test_expired(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:2818:26: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	// var pStmt uintptr at bp+32, 8

	if objc != 2 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615, /* "wrong # args: sh..." */
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(0)*8)), uintptr(0)), ts+22631 /* " <STMT>" */, 0))
		return 1
	}
	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), bp+32 /* &pStmt */) != 0 {
		return 1
	}
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, (crt.Bool32((sqlite3.Xsqlite3_expired(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* pStmt */)))) != 0))))
	return 0
}

// Usage:  sqlite3_transfer_bindings FROMSTMT TOSTMT
//
// Transfer all bindings from FROMSTMT over to TOSTMT
func test_transfer_bind(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:2842:26: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	// var pStmt1 uintptr at bp+32, 8

	// var pStmt2 uintptr at bp+40, 8

	if objc != 3 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615, /* "wrong # args: sh..." */
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(0)*8)), uintptr(0)), ts+22880 /* " FROM-STMT TO-ST..." */, 0))
		return 1
	}
	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), bp+32 /* &pStmt1 */) != 0 {
		return 1
	}
	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8))), bp+40 /* &pStmt2 */) != 0 {
		return 1
	}
	tcl.XTcl_SetObjResult(tls, interp,
		tcl.XTcl_NewIntObj(tls, sqlite3.Xsqlite3_transfer_bindings(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* pStmt1 */)), *(*uintptr)(unsafe.Pointer(bp + 40 /* pStmt2 */)))))
	return 0
}

// Usage:  sqlite3_changes DB
//
// Return the number of changes made to the database by the last SQL
// execution.
func test_changes(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:2869:26: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	// var db uintptr at bp+32, 8

	if objc != 2 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615, /* "wrong # args: sh..." */
			tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(0)*8))), ts+21667 /* " DB" */, 0))
		return 1
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), bp+32 /* &db */) != 0 {
		return 1
	}
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, sqlite3.Xsqlite3_changes(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* db */)))))
	return 0
}

// This is the "static_bind_value" that variables are bound to when
// the FLAG option of sqlite3_bind is "static"
var sqlite_static_bind_value uintptr = uintptr(0) /* test1.c:2890:13 */
var sqlite_static_bind_nbyte int32 = 0            /* test1.c:2891:12 */

// Usage:  sqlite3_bind  VM  IDX  VALUE  FLAGS
//
// Sets the value of the IDX-th occurrence of "?" in the original SQL
// string.  VALUE is the new value.  If FLAGS=="null" then VALUE is
// ignored and the value is set to NULL.  If FLAGS=="static" then
// the value is set to the value of a static variable named
// "sqlite_static_bind_value".  If FLAGS=="normal" then a copy
// of the VALUE is made.  If FLAGS=="blob10" then a VALUE is ignored
// an a 10-byte blob "abc\000xyz\000pq" is inserted.
func test_bind(tls *crt.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:2904:26: */
	bp := tls.Alloc(142)
	defer tls.Free(142)

	// var pStmt uintptr at bp+80, 8

	var rc int32
	// var idx int32 at bp+88, 4

	if argc != 5 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
			ts+22899 /* " VM IDX VALUE (n..." */, 0))
		return 1
	}
	if getStmtPointer(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), bp+80 /* &pStmt */) != 0 {
		return 1
	}
	if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8)), bp+88 /* &idx */) != 0 {
		return 1
	}
	if crt.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(4)*8)), ts+7418 /* "null" */) == 0 {
		rc = sqlite3.Xsqlite3_bind_null(tls, *(*uintptr)(unsafe.Pointer(bp + 80 /* pStmt */)), *(*int32)(unsafe.Pointer(bp + 88 /* idx */)))
	} else if crt.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(4)*8)), ts+22935 /* "static" */) == 0 {
		rc = sqlite3.Xsqlite3_bind_text(tls, *(*uintptr)(unsafe.Pointer(bp + 80 /* pStmt */)), *(*int32)(unsafe.Pointer(bp + 88 /* idx */)), sqlite_static_bind_value, -1, uintptr(0))
	} else if crt.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(4)*8)), ts+22942 /* "static-nbytes" */) == 0 {
		rc = sqlite3.Xsqlite3_bind_text(tls, *(*uintptr)(unsafe.Pointer(bp + 80 /* pStmt */)), *(*int32)(unsafe.Pointer(bp + 88 /* idx */)), sqlite_static_bind_value,
			sqlite_static_bind_nbyte, uintptr(0))
	} else if crt.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(4)*8)), ts+22956 /* "normal" */) == 0 {
		rc = sqlite3.Xsqlite3_bind_text(tls, *(*uintptr)(unsafe.Pointer(bp + 80 /* pStmt */)), *(*int32)(unsafe.Pointer(bp + 88 /* idx */)), *(*uintptr)(unsafe.Pointer(argv + uintptr(3)*8)), -1, crt.UintptrFromInt32(-1))
	} else if crt.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(4)*8)), ts+22963 /* "blob10" */) == 0 {
		rc = sqlite3.Xsqlite3_bind_text(tls, *(*uintptr)(unsafe.Pointer(bp + 80 /* pStmt */)), *(*int32)(unsafe.Pointer(bp + 88 /* idx */)), ts+22970 /* "abc\x00xyz\x00pq" */, 10, uintptr(0))
	} else {
		tcl.XTcl_AppendResult(tls, interp,
			crt.VaList(bp+32, ts+22981 /* "4th argument sho..." */, 0))
		return 1
	}
	if sqlite3TestErrCode(tls, interp, sqlite3.Xsqlite3_db_handle(tls, *(*uintptr)(unsafe.Pointer(bp + 80 /* pStmt */))), rc) != 0 {
		return 1
	}
	if rc != 0 {
		// var zBuf [50]int8 at bp+92, 50

		sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([50]int8{})), bp+92 /* &zBuf[0] */, ts+23035 /* "(%d) " */, crt.VaList(bp+48, rc))
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+56, bp+92 /* &zBuf[0] */, sqlite3.Xsqlite3ErrStr(tls, rc), 0))
		return 1
	}
	return 0
}

// Usage: add_test_function <db ptr> <utf8> <utf16le> <utf16be>
//
// This function is used to test that SQLite selects the correct user
// function callback when multiple versions (for different text encodings)
// are available.
//
// Calling this routine registers up to three versions of the user function
// "test_function" with database handle <db>.  If the second argument is
// true, then a version of test_function is registered for UTF-8, if the
// third is true, a version is registered for UTF-16le, if the fourth is
// true, a UTF-16be version is available.  Previous versions of
// test_function are deleted.
//
// The user function is implemented by calling the following TCL script:
//
//   "test_function <enc> <arg>"
//
// Where <enc> is one of UTF-8, UTF-16LE or UTF16BE, and <arg> is the
// single argument passed to the SQL function. The value returned by
// the TCL script is used as the return value of the SQL function. It
// is passed to SQLite using UTF-16BE for a UTF-8 test_function(), UTF-8
// for a UTF-16LE test_function(), and UTF-16LE for an implementation that
// prefers UTF-16BE.
func test_function(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:3326:26: */
	return 1
}

// Usage:         sqlite3_test_errstr <err code>
//
// Test that the english language string equivalents for sqlite error codes
// are sane. The parameter is an integer representing an sqlite error code.
// The result is a list of two elements, the string representation of the
// error code and the english language explanation.
func test_errstr(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:3371:26: */
	var zCode uintptr
	var i int32
	if objc != 1 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+23041 /* "<error code>" */)
	}

	zCode = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)))
	for i = 0; i < 200; i++ {
		if 0 == crt.Xstrcmp(tls, sqlite3.Xsqlite3ErrName(tls, i), zCode) {
			break
		}
	}
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrStr(tls, i), uintptr(0))
	return 0
}

// Usage:    breakpoint
//
// This routine exists for one purpose - to provide a place to put a
// breakpoint with GDB that can be triggered using TCL code.  The use
// for this is when a particular test fails on (say) the 1485th iteration.
// In the TCL test script, we can add code like this:
//
//     if {$i==1485} breakpoint
//
// Then run testfixture in the debugger and wait for the breakpoint to
// fire.  Then additional breakpoints can be set to trace down the bug.
func test_breakpoint(tls *crt.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:3404:26: */
	return 0 // Do nothing
}

// Usage:   sqlite3_bind_zeroblob  STMT IDX N
//
// Test the sqlite3_bind_zeroblob interface.  STMT is a prepared statement.
// IDX is the index of a wildcard in the prepared statement.  This command
// binds a N-byte zero-filled BLOB to the wildcard.
func test_bind_zeroblob(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:3420:26: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	// var pStmt uintptr at bp, 8

	// var idx int32 at bp+8, 4

	// var n int32 at bp+12, 4

	var rc int32

	if objc != 4 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+23054 /* "STMT IDX N" */)
		return 1
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), bp /* &pStmt */) != 0 {
		return 1
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)), bp+8 /* &idx */) != 0 {
		return 1
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(3)*8)), bp+12 /* &n */) != 0 {
		return 1
	}

	rc = sqlite3.Xsqlite3_bind_zeroblob(tls, *(*uintptr)(unsafe.Pointer(bp /* pStmt */)), *(*int32)(unsafe.Pointer(bp + 8 /* idx */)), *(*int32)(unsafe.Pointer(bp + 12 /* n */)))
	if sqlite3TestErrCode(tls, interp, sqlite3.Xsqlite3_db_handle(tls, *(*uintptr)(unsafe.Pointer(bp /* pStmt */))), rc) != 0 {
		return 1
	}
	if rc != 0 {
		return 1
	}

	return 0
}

// Usage:   sqlite3_bind_zeroblob64  STMT IDX N
//
// Test the sqlite3_bind_zeroblob64 interface.  STMT is a prepared statement.
// IDX is the index of a wildcard in the prepared statement.  This command
// binds a N-byte zero-filled BLOB to the wildcard.
func test_bind_zeroblob64(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:3456:26: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	// var pStmt uintptr at bp+16, 8

	// var idx int32 at bp+24, 4

	// var n Tcl_WideInt at bp+32, 8

	var rc int32

	if objc != 4 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+23054 /* "STMT IDX N" */)
		return 1
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), bp+16 /* &pStmt */) != 0 {
		return 1
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)), bp+24 /* &idx */) != 0 {
		return 1
	}
	if tcl.XTcl_GetWideIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(3)*8)), bp+32 /* &n */) != 0 {
		return 1
	}

	rc = sqlite3.Xsqlite3_bind_zeroblob64(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* pStmt */)), *(*int32)(unsafe.Pointer(bp + 24 /* idx */)), uint64(*(*Tcl_WideInt)(unsafe.Pointer(bp + 32 /* n */))))
	if sqlite3TestErrCode(tls, interp, sqlite3.Xsqlite3_db_handle(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* pStmt */))), rc) != 0 {
		return 1
	}
	if rc != 0 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, sqlite3.Xsqlite3ErrName(tls, rc), 0))
		return 1
	}

	return 0
}

// Usage:   sqlite3_bind_int  STMT N VALUE
//
// Test the sqlite3_bind_int interface.  STMT is a prepared statement.
// N is the index of a wildcard in the prepared statement.  This command
// binds a 32-bit integer VALUE to that wildcard.
func test_bind_int(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:3493:26: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	// var pStmt uintptr at bp+32, 8

	// var idx int32 at bp+40, 4

	// var value int32 at bp+44, 4

	var rc int32

	if objc != 4 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615, /* "wrong # args: sh..." */
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(0)*8)), uintptr(0)), ts+23065 /* " STMT N VALUE" */, 0))
		return 1
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), bp+32 /* &pStmt */) != 0 {
		return 1
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)), bp+40 /* &idx */) != 0 {
		return 1
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(3)*8)), bp+44 /* &value */) != 0 {
		return 1
	}

	rc = sqlite3.Xsqlite3_bind_int(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* pStmt */)), *(*int32)(unsafe.Pointer(bp + 40 /* idx */)), *(*int32)(unsafe.Pointer(bp + 44 /* value */)))
	if sqlite3TestErrCode(tls, interp, sqlite3.Xsqlite3_db_handle(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* pStmt */))), rc) != 0 {
		return 1
	}
	if rc != 0 {
		return 1
	}

	return 0
}

// Usage:   intarray_addr  INT  ...
//
// Return the address of a C-language array of 32-bit integers.
//
// Space to hold the array is obtained from malloc().  Call this procedure once
// with no arguments in order to release memory.  Each call to this procedure
// overwrites the previous array.
func test_intarray_addr(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:3533:26: */
	var i int32

	sqlite3.Xsqlite3_free(tls, p)
	p = uintptr(0)
	if objc > 1 {
		p = sqlite3.Xsqlite3_malloc(tls, (int32(uint64(unsafe.Sizeof(int32(0))) * (uint64(objc - 1)))))
		if p == uintptr(0) {
			return 1
		}
		for i = 0; i < (objc - 1); i++ {
			if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr((1+i))*8)), (p+uintptr(i)*4)) != 0 {
				sqlite3.Xsqlite3_free(tls, p)
				p = uintptr(0)
				return 1
			}
		}
	}
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewWideIntObj(tls, int64(p)))
	return 0
}

var p uintptr = uintptr(0) /* test1.c:3540:14 */
// Usage:   intarray_addr  INT  ...
//
// Return the address of a C-language array of 32-bit integers.
//
// Space to hold the array is obtained from malloc().  Call this procedure once
// with no arguments in order to release memory.  Each call to this procedure
// overwrites the previous array.
func test_int64array_addr(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:3567:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var i int32

	sqlite3.Xsqlite3_free(tls, p1)
	p1 = uintptr(0)
	if objc > 1 {
		p1 = sqlite3.Xsqlite3_malloc(tls, (int32(uint64(unsafe.Sizeof(sqlite3_int64(0))) * (uint64(objc - 1)))))
		if p1 == uintptr(0) {
			return 1
		}
		for i = 0; i < (objc - 1); i++ {
			// var v Tcl_WideInt at bp, 8

			if tcl.XTcl_GetWideIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr((1+i))*8)), bp /* &v */) != 0 {
				sqlite3.Xsqlite3_free(tls, p1)
				p1 = uintptr(0)
				return 1
			}
			*(*sqlite3_int64)(unsafe.Pointer(p1 + uintptr(i)*8)) = sqlite3_int64(*(*Tcl_WideInt)(unsafe.Pointer(bp /* v */)))
		}
	}
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewWideIntObj(tls, int64(p1)))
	return 0
}

var p1 uintptr = uintptr(0) /* test1.c:3574:24 */
// Usage:   doublearray_addr  INT  ...
//
// Return the address of a C-language array of doubles.
//
// Space to hold the array is obtained from malloc().  Call this procedure once
// with no arguments in order to release memory.  Each call to this procedure
// overwrites the previous array.
func test_doublearray_addr(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:3603:26: */
	var i int32

	sqlite3.Xsqlite3_free(tls, p2)
	p2 = uintptr(0)
	if objc > 1 {
		p2 = sqlite3.Xsqlite3_malloc(tls, (int32(uint64(unsafe.Sizeof(float64(0))) * (uint64(objc - 1)))))
		if p2 == uintptr(0) {
			return 1
		}
		for i = 0; i < (objc - 1); i++ {
			if tcl.XTcl_GetDoubleFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr((1+i))*8)), (p2+uintptr(i)*8)) != 0 {
				sqlite3.Xsqlite3_free(tls, p2)
				p2 = uintptr(0)
				return 1
			}
		}
	}
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewWideIntObj(tls, int64(p2)))
	return 0
}

var p2 uintptr = uintptr(0) /* test1.c:3610:17 */
// Usage:   textarray_addr  TEXT ...
//
// Return the address of a C-language array of strings.
//
// Space to hold the array is obtained from malloc().  Call this procedure once
// with no arguments in order to release memory.  Each call to this procedure
// overwrites the previous array.
func test_textarray_addr(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:3637:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var i int32

	for i = 0; i < n; i++ {
		sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(p3 + uintptr(i)*8)))
	}
	sqlite3.Xsqlite3_free(tls, p3)
	p3 = uintptr(0)
	if objc > 1 {
		p3 = sqlite3.Xsqlite3_malloc(tls, (int32(uint64(unsafe.Sizeof(uintptr(0))) * (uint64(objc - 1)))))
		if p3 == uintptr(0) {
			return 1
		}
		for i = 0; i < (objc - 1); i++ {
			*(*uintptr)(unsafe.Pointer(p3 + uintptr(i)*8)) = sqlite3.Xsqlite3_mprintf(tls, ts+130 /* "%s" */, crt.VaList(bp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr((1+i))*8)))))
		}
	}
	n = (objc - 1)
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewWideIntObj(tls, int64(p3)))
	return 0
}

var n int32 = 0             /* test1.c:3644:14 */
var p3 uintptr = uintptr(0) /* test1.c:3645:15 */

// Usage:   sqlite3_bind_int64  STMT N VALUE
//
// Test the sqlite3_bind_int64 interface.  STMT is a prepared statement.
// N is the index of a wildcard in the prepared statement.  This command
// binds a 64-bit integer VALUE to that wildcard.
func test_bind_int64(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:3670:26: */
	bp := tls.Alloc(56)
	defer tls.Free(56)

	// var pStmt uintptr at bp+32, 8

	// var idx int32 at bp+40, 4

	// var value Tcl_WideInt at bp+48, 8

	var rc int32

	if objc != 4 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615, /* "wrong # args: sh..." */
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(0)*8)), uintptr(0)), ts+23065 /* " STMT N VALUE" */, 0))
		return 1
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), bp+32 /* &pStmt */) != 0 {
		return 1
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)), bp+40 /* &idx */) != 0 {
		return 1
	}
	if tcl.XTcl_GetWideIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(3)*8)), bp+48 /* &value */) != 0 {
		return 1
	}

	rc = sqlite3.Xsqlite3_bind_int64(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* pStmt */)), *(*int32)(unsafe.Pointer(bp + 40 /* idx */)), int64(*(*Tcl_WideInt)(unsafe.Pointer(bp + 48 /* value */))))
	if sqlite3TestErrCode(tls, interp, sqlite3.Xsqlite3_db_handle(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* pStmt */))), rc) != 0 {
		return 1
	}
	if rc != 0 {
		return 1
	}

	return 0
}

// Usage:   sqlite3_bind_double  STMT N VALUE
//
// Test the sqlite3_bind_double interface.  STMT is a prepared statement.
// N is the index of a wildcard in the prepared statement.  This command
// binds a 64-bit integer VALUE to that wildcard.
func test_bind_double(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:3708:26: */
	bp := tls.Alloc(64)
	defer tls.Free(64)

	// var pStmt uintptr at bp+32, 8

	// var idx int32 at bp+40, 4

	*(*float64)(unsafe.Pointer(bp + 48 /* value */)) = float64(0)
	var rc int32
	var zVal uintptr
	var i int32

	if objc != 4 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615, /* "wrong # args: sh..." */
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(0)*8)), uintptr(0)), ts+23065 /* " STMT N VALUE" */, 0))
		return 1
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), bp+32 /* &pStmt */) != 0 {
		return 1
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)), bp+40 /* &idx */) != 0 {
		return 1
	}

	// Intercept the string "NaN" and generate a NaN value for it.
	// All other strings are passed through to Tcl_GetDoubleFromObj().
	// Tcl_GetDoubleFromObj() should understand "NaN" but some versions
	// contain a bug.
	zVal = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(3)*8)))
	for i = 0; uint64(i) < (uint64(unsafe.Sizeof(aSpecialFp)) / uint64(unsafe.Sizeof(struct {
		FzName  uintptr
		FiUpper uint32
		FiLower uint32
	}{}))); i++ {
		if crt.Xstrcmp(tls, aSpecialFp[i].FzName, zVal) == 0 {
			// var x sqlite3_uint64 at bp+56, 8

			*(*sqlite3_uint64)(unsafe.Pointer(bp + 56 /* x */)) = sqlite3_uint64(aSpecialFp[i].FiUpper)
			*(*sqlite3_uint64)(unsafe.Pointer(bp + 56 /* x */)) <<= 32
			*(*sqlite3_uint64)(unsafe.Pointer(bp + 56 /* x */)) |= sqlite3_uint64(aSpecialFp[i].FiLower)

			crt.Xmemcpy(tls, bp+48 /* &value */, bp+56 /* &x */, uint64(8))
			break
		}
	}
	if (uint64(i) >= (uint64(unsafe.Sizeof(aSpecialFp)) / uint64(unsafe.Sizeof(struct {
		FzName  uintptr
		FiUpper uint32
		FiLower uint32
	}{})))) && (tcl.XTcl_GetDoubleFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(3)*8)), bp+48 /* &value */) != 0) {
		return 1
	}
	rc = sqlite3.Xsqlite3_bind_double(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* pStmt */)), *(*int32)(unsafe.Pointer(bp + 40 /* idx */)), *(*float64)(unsafe.Pointer(bp + 48 /* value */)))
	if sqlite3TestErrCode(tls, interp, sqlite3.Xsqlite3_db_handle(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* pStmt */))), rc) != 0 {
		return 1
	}
	if rc != 0 {
		return 1
	}

	return 0
}

var aSpecialFp = [10]struct {
	FzName  uintptr
	FiUpper uint32
	FiLower uint32
}{
	{FzName: ts + 23079 /* "NaN" */, FiUpper: uint32(0x7fffffff), FiLower: 0xffffffff},
	{FzName: ts + 23083 /* "SNaN" */, FiUpper: uint32(0x7ff7ffff), FiLower: 0xffffffff},
	{FzName: ts + 23088 /* "-NaN" */, FiUpper: 0xffffffff, FiLower: 0xffffffff},
	{FzName: ts + 23093 /* "-SNaN" */, FiUpper: 0xfff7ffff, FiLower: 0xffffffff},
	{FzName: ts + 23099 /* "+Inf" */, FiUpper: uint32(0x7ff00000), FiLower: uint32(0x00000000)},
	{FzName: ts + 23104 /* "-Inf" */, FiUpper: 0xfff00000, FiLower: uint32(0x00000000)},
	{FzName: ts + 23109 /* "Epsilon" */, FiUpper: uint32(0x00000000), FiLower: uint32(0x00000001)},
	{FzName: ts + 23117 /* "-Epsilon" */, FiUpper: 0x80000000, FiLower: uint32(0x00000001)},
	{FzName: ts + 23126 /* "NaN0" */, FiUpper: uint32(0x7ff80000), FiLower: uint32(0x00000000)},
	{FzName: ts + 23131 /* "-NaN0" */, FiUpper: 0xfff80000, FiLower: uint32(0x00000000)},
} /* test1.c:3724:5 */

// Usage:   sqlite3_bind_null  STMT N
//
// Test the sqlite3_bind_null interface.  STMT is a prepared statement.
// N is the index of a wildcard in the prepared statement.  This command
// binds a NULL to the wildcard.
func test_bind_null(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:3784:26: */
	bp := tls.Alloc(44)
	defer tls.Free(44)

	// var pStmt uintptr at bp+32, 8

	// var idx int32 at bp+40, 4

	var rc int32

	if objc != 3 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615, /* "wrong # args: sh..." */
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(0)*8)), uintptr(0)), ts+23137 /* " STMT N" */, 0))
		return 1
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), bp+32 /* &pStmt */) != 0 {
		return 1
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)), bp+40 /* &idx */) != 0 {
		return 1
	}

	rc = sqlite3.Xsqlite3_bind_null(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* pStmt */)), *(*int32)(unsafe.Pointer(bp + 40 /* idx */)))
	if sqlite3TestErrCode(tls, interp, sqlite3.Xsqlite3_db_handle(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* pStmt */))), rc) != 0 {
		return 1
	}
	if rc != 0 {
		return 1
	}

	return 0
}

// Usage:   sqlite3_bind_text  STMT N STRING BYTES
//
// Test the sqlite3_bind_text interface.  STMT is a prepared statement.
// N is the index of a wildcard in the prepared statement.  This command
// binds a UTF-8 string STRING to the wildcard.  The string is BYTES bytes
// long.
func test_bind_text(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:3820:26: */
	bp := tls.Alloc(64)
	defer tls.Free(64)

	// var pStmt uintptr at bp+48, 8

	// var idx int32 at bp+56, 4

	// var bytes int32 at bp+60, 4

	var value uintptr
	var rc int32

	if objc != 5 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615, /* "wrong # args: sh..." */
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(0)*8)), uintptr(0)), ts+23145 /* " STMT N VALUE BY..." */, 0))
		return 1
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), bp+48 /* &pStmt */) != 0 {
		return 1
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)), bp+56 /* &idx */) != 0 {
		return 1
	}
	value = tcl.XTcl_GetByteArrayFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(3)*8)), bp+60 /* &bytes */)
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(4)*8)), bp+60 /* &bytes */) != 0 {
		return 1
	}

	rc = sqlite3.Xsqlite3_bind_text(tls, *(*uintptr)(unsafe.Pointer(bp + 48 /* pStmt */)), *(*int32)(unsafe.Pointer(bp + 56 /* idx */)), value, *(*int32)(unsafe.Pointer(bp + 60 /* bytes */)), crt.UintptrFromInt32(-1))
	if sqlite3TestErrCode(tls, interp, sqlite3.Xsqlite3_db_handle(tls, *(*uintptr)(unsafe.Pointer(bp + 48 /* pStmt */))), rc) != 0 {
		return 1
	}
	if rc != 0 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+32, sqlite3.Xsqlite3ErrName(tls, rc), 0))
		return 1
	}

	return 0
}

// Usage:   sqlite3_bind_text16 ?-static? STMT N STRING BYTES
//
// Test the sqlite3_bind_text16 interface.  STMT is a prepared statement.
// N is the index of a wildcard in the prepared statement.  This command
// binds a UTF-16 string STRING to the wildcard.  The string is BYTES bytes
// long.
func test_bind_text16(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:3861:26: */
	return 0
}

// Usage:   sqlite3_bind_blob ?-static? STMT N DATA BYTES
//
// Test the sqlite3_bind_blob interface.  STMT is a prepared statement.
// N is the index of a wildcard in the prepared statement.  This command
// binds a BLOB to the wildcard.  The BLOB is BYTES bytes in size.
func test_bind_blob(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:3909:26: */
	bp := tls.Alloc(284)
	defer tls.Free(284)

	// var pStmt uintptr at bp+64, 8

	// var len int32 at bp+76, 4

	// var idx int32 at bp+72, 4

	// var bytes int32 at bp+80, 4

	var value uintptr
	var rc int32
	var xDestructor sqlite3_destructor_type = crt.UintptrFromInt32(-1)

	if (objc != 5) && (objc != 6) {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615, /* "wrong # args: sh..." */
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(0)*8)), uintptr(0)), ts+23165 /* " STMT N DATA BYT..." */, 0))
		return 1
	}

	if objc == 6 {
		xDestructor = uintptr(0)
		objv += 8
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), bp+64 /* &pStmt */) != 0 {
		return 1
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)), bp+72 /* &idx */) != 0 {
		return 1
	}

	value = tcl.XTcl_GetByteArrayFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(3)*8)), bp+76 /* &len */)
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(4)*8)), bp+80 /* &bytes */) != 0 {
		return 1
	}

	if *(*int32)(unsafe.Pointer(bp + 80 /* bytes */)) > *(*int32)(unsafe.Pointer(bp + 76 /* len */)) {
		// var zBuf [200]int8 at bp+84, 200

		sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([200]int8{})), bp+84, /* &zBuf[0] */
			ts+23184 /* "cannot use %d bl..." */, crt.VaList(bp+32, *(*int32)(unsafe.Pointer(bp + 80 /* bytes */)), *(*int32)(unsafe.Pointer(bp + 76 /* len */))))
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+48, bp+84 /* &zBuf[0] */, -1))
		return 1
	}

	rc = sqlite3.Xsqlite3_bind_blob(tls, *(*uintptr)(unsafe.Pointer(bp + 64 /* pStmt */)), *(*int32)(unsafe.Pointer(bp + 72 /* idx */)), value, *(*int32)(unsafe.Pointer(bp + 80 /* bytes */)), xDestructor)
	if sqlite3TestErrCode(tls, interp, sqlite3.Xsqlite3_db_handle(tls, *(*uintptr)(unsafe.Pointer(bp + 64 /* pStmt */))), rc) != 0 {
		return 1
	}
	if rc != 0 {
		return 1
	}

	return 0
}

// Usage:   sqlite3_bind_parameter_count  STMT
//
// Return the number of wildcards in the given statement.
func test_bind_parameter_count(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:3961:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// var pStmt uintptr at bp, 8

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+23218 /* "STMT" */)
		return 1
	}
	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), bp /* &pStmt */) != 0 {
		return 1
	}
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, sqlite3.Xsqlite3_bind_parameter_count(tls, *(*uintptr)(unsafe.Pointer(bp /* pStmt */)))))
	return 0
}

// Usage:   sqlite3_bind_parameter_name  STMT  N
//
// Return the name of the Nth wildcard.  The first wildcard is 1.
// An empty string is returned if N is out of range or if the wildcard
// is nameless.
func test_bind_parameter_name(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:3985:26: */
	bp := tls.Alloc(12)
	defer tls.Free(12)

	// var pStmt uintptr at bp, 8

	// var i int32 at bp+8, 4

	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+23223 /* "STMT N" */)
		return 1
	}
	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), bp /* &pStmt */) != 0 {
		return 1
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)), bp+8 /* &i */) != 0 {
		return 1
	}
	tcl.XTcl_SetObjResult(tls, interp,
		tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3_bind_parameter_name(tls, *(*uintptr)(unsafe.Pointer(bp /* pStmt */)), *(*int32)(unsafe.Pointer(bp + 8 /* i */))), -1))
	return 0
}

// Usage:   sqlite3_bind_parameter_index  STMT  NAME
//
// Return the index of the wildcard called NAME.  Return 0 if there is
// no such wildcard.
func test_bind_parameter_index(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:4012:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// var pStmt uintptr at bp, 8

	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+23230 /* "STMT NAME" */)
		return 1
	}
	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), bp /* &pStmt */) != 0 {
		return 1
	}
	tcl.XTcl_SetObjResult(tls, interp,
		tcl.XTcl_NewIntObj(tls,
			sqlite3.Xsqlite3_bind_parameter_index(tls, *(*uintptr)(unsafe.Pointer(bp /* pStmt */)), tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8))))))
	return 0
}

// Usage:   sqlite3_clear_bindings STMT
//
func test_clear_bindings(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:4037:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// var pStmt uintptr at bp, 8

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+23218 /* "STMT" */)
		return 1
	}
	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), bp /* &pStmt */) != 0 {
		return 1
	}
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, sqlite3.Xsqlite3_clear_bindings(tls, *(*uintptr)(unsafe.Pointer(bp /* pStmt */)))))
	return 0
}

// Usage:   sqlite3_sleep MILLISECONDS
func test_sleep(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:4057:26: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	// var ms int32 at bp, 4

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+19799 /* "MILLISECONDS" */)
		return 1
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)), bp /* &ms */) != 0 {
		return 1
	}
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, sqlite3.Xsqlite3_sleep(tls, *(*int32)(unsafe.Pointer(bp /* ms */)))))
	return 0
}

// Usage: sqlite3_extended_errcode DB
//
// Return the string representation of the most recent sqlite3_* API
// error code. e.g. "SQLITE_ERROR".
func test_ex_errcode(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:4082:26: */
	bp := tls.Alloc(56)
	defer tls.Free(56)

	// var db uintptr at bp+48, 8

	var rc int32

	if objc != 2 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615, /* "wrong # args: sh..." */
			tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(0)*8))), ts+21667 /* " DB" */, 0))
		return 1
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), bp+48 /* &db */) != 0 {
		return 1
	}
	rc = sqlite3.Xsqlite3_extended_errcode(tls, *(*uintptr)(unsafe.Pointer(bp + 48 /* db */)))
	tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+32, sqlite3.Xsqlite3ErrName(tls, rc), 0))
	return 0
}

// Usage: sqlite3_errcode DB
//
// Return the string representation of the most recent sqlite3_* API
// error code. e.g. "SQLITE_ERROR".
func test_errcode(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:4109:26: */
	bp := tls.Alloc(56)
	defer tls.Free(56)

	// var db uintptr at bp+48, 8

	var rc int32

	if objc != 2 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615, /* "wrong # args: sh..." */
			tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(0)*8))), ts+21667 /* " DB" */, 0))
		return 1
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), bp+48 /* &db */) != 0 {
		return 1
	}
	rc = sqlite3.Xsqlite3_errcode(tls, *(*uintptr)(unsafe.Pointer(bp + 48 /* db */)))
	tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+32, sqlite3.Xsqlite3ErrName(tls, rc), 0))
	return 0
}

// Usage:   sqlite3_errmsg DB
//
// Returns the UTF-8 representation of the error message string for the
// most recent sqlite3_* API call.
func test_errmsg(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:4135:26: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	// var db uintptr at bp+32, 8

	var zErr uintptr

	if objc != 2 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615, /* "wrong # args: sh..." */
			tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(0)*8))), ts+21667 /* " DB" */, 0))
		return 1
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), bp+32 /* &db */) != 0 {
		return 1
	}

	zErr = sqlite3.Xsqlite3_errmsg(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* db */)))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, zErr, -1))
	return 0
}

// Usage:   test_errmsg16 DB
//
// Returns the UTF-16 representation of the error message string for the
// most recent sqlite3_* API call. This is a byte array object at the TCL
// level, and it includes the 0x00 0x00 terminator bytes at the end of the
// UTF-16 string.
func test_errmsg16(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:4164:26: */
	return 0
}

// Usage: sqlite3_prepare DB sql bytes ?tailvar?
//
// Compile up to <bytes> bytes of the supplied SQL string <sql> using
// database handle <DB>. The parameter <tailval> is the name of a global
// variable that is set to the unused portion of <sql> (if any). A
// STMT handle is returned.
func test_prepare(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:4201:26: */
	bp := tls.Alloc(162)
	defer tls.Free(162)

	// var db uintptr at bp+80, 8

	var zSql uintptr
	// var bytes int32 at bp+88, 4

	*(*uintptr)(unsafe.Pointer(bp + 104 /* zTail */)) = uintptr(0)
	*(*uintptr)(unsafe.Pointer(bp + 96 /* pStmt */)) = uintptr(0)
	// var zBuf [50]int8 at bp+112, 50

	var rc int32

	if (objc != 5) && (objc != 4) {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615, /* "wrong # args: sh..." */
			tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(0)*8))), ts+23240 /* " DB sql bytes ?t..." */, 0))
		return 1
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), bp+80 /* &db */) != 0 {
		return 1
	}
	zSql = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)))
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(3)*8)), bp+88 /* &bytes */) != 0 {
		return 1
	}

	rc = sqlite3.Xsqlite3_prepare(tls, *(*uintptr)(unsafe.Pointer(bp + 80 /* db */)), zSql, *(*int32)(unsafe.Pointer(bp + 88 /* bytes */)), bp+96 /* &pStmt */, func() uintptr {
		if objc >= 5 {
			return bp + 104 /* &zTail */
		}
		return uintptr(0)
	}())
	tcl.XTcl_ResetResult(tls, interp)
	if sqlite3TestErrCode(tls, interp, *(*uintptr)(unsafe.Pointer(bp + 80 /* db */)), rc) != 0 {
		return 1
	}
	if (*(*uintptr)(unsafe.Pointer(bp + 104 /* zTail */)) != 0) && (objc >= 5) {
		if *(*int32)(unsafe.Pointer(bp + 88 /* bytes */)) >= 0 {
			*(*int32)(unsafe.Pointer(bp + 88 /* bytes */)) = (*(*int32)(unsafe.Pointer(bp + 88 /* bytes */)) - (int32((int64(*(*uintptr)(unsafe.Pointer(bp + 104 /* zTail */))) - int64(zSql)) / 1)))
		}
		if int32(crt.Xstrlen(tls, *(*uintptr)(unsafe.Pointer(bp + 104 /* zTail */)))) < *(*int32)(unsafe.Pointer(bp + 88 /* bytes */)) {
			*(*int32)(unsafe.Pointer(bp + 88 /* bytes */)) = int32(crt.Xstrlen(tls, *(*uintptr)(unsafe.Pointer(bp + 104 /* zTail */))))
		}
		tcl.XTcl_ObjSetVar2(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(4)*8)), uintptr(0), tcl.XTcl_NewStringObj(tls, *(*uintptr)(unsafe.Pointer(bp + 104 /* zTail */)), *(*int32)(unsafe.Pointer(bp + 88 /* bytes */))), 0)
	}
	if rc != 0 {

		sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([50]int8{})), bp+112 /* &zBuf[0] */, ts+23035 /* "(%d) " */, crt.VaList(bp+32, rc))
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+40, bp+112 /* &zBuf[0] */, sqlite3.Xsqlite3_errmsg(tls, *(*uintptr)(unsafe.Pointer(bp + 80 /* db */))), 0))
		return 1
	}

	if *(*uintptr)(unsafe.Pointer(bp + 96 /* pStmt */)) != 0 {
		if sqlite3TestMakePointerStr(tls, interp, bp+112 /* &zBuf[0] */, *(*uintptr)(unsafe.Pointer(bp + 96 /* pStmt */))) != 0 {
			return 1
		}
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+64, bp+112 /* &zBuf[0] */, 0))
	}
	return 0
}

// Usage: sqlite3_prepare_v2 DB sql bytes ?tailvar?
//
// Compile up to <bytes> bytes of the supplied SQL string <sql> using
// database handle <DB>. The parameter <tailval> is the name of a global
// variable that is set to the unused portion of <sql> (if any). A
// STMT handle is returned.
func test_prepare_v2(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:4258:26: */
	bp := tls.Alloc(162)
	defer tls.Free(162)

	// var db uintptr at bp+80, 8

	var zSql uintptr
	var zCopy uintptr = uintptr(0) // malloc() copy of zSql
	// var bytes int32 at bp+88, 4

	*(*uintptr)(unsafe.Pointer(bp + 96 /* zTail */)) = uintptr(0)
	var pzTail uintptr
	*(*uintptr)(unsafe.Pointer(bp + 104 /* pStmt */)) = uintptr(0)
	// var zBuf [50]int8 at bp+112, 50

	var rc int32

	if (objc != 5) && (objc != 4) {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615, /* "wrong # args: sh..." */
			tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(0)*8))), ts+23264 /* " DB sql bytes ta..." */, 0))
		return 1
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), bp+80 /* &db */) != 0 {
		return 1
	}
	zSql = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)))
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(3)*8)), bp+88 /* &bytes */) != 0 {
		return 1
	}

	// Instead of using zSql directly, make a copy into a buffer obtained
	// directly from malloc(). The idea is to make it easier for valgrind
	// to spot buffer overreads.
	if *(*int32)(unsafe.Pointer(bp + 88 /* bytes */)) >= 0 {
		zCopy = crt.Xmalloc(tls, uint64(*(*int32)(unsafe.Pointer(bp + 88 /* bytes */))))
		crt.Xmemcpy(tls, zCopy, zSql, uint64(*(*int32)(unsafe.Pointer(bp + 88 /* bytes */))))
	} else {
		var n int32 = (int32(crt.Xstrlen(tls, zSql)) + 1)
		zCopy = crt.Xmalloc(tls, uint64(n))
		crt.Xmemcpy(tls, zCopy, zSql, uint64(n))
	}
	if objc >= 5 {
		pzTail = bp + 96 /* &zTail */
	} else {
		pzTail = uintptr(0)
	}
	rc = sqlite3.Xsqlite3_prepare_v2(tls, *(*uintptr)(unsafe.Pointer(bp + 80 /* db */)), zCopy, *(*int32)(unsafe.Pointer(bp + 88 /* bytes */)), bp+104 /* &pStmt */, pzTail)
	if objc >= 5 {
		*(*uintptr)(unsafe.Pointer(bp + 96 /* zTail */)) = (zSql + uintptr(((int64(*(*uintptr)(unsafe.Pointer(bp + 96 /* zTail */))) - int64(zCopy)) / 1)))
	}
	crt.Xfree(tls, zCopy)

	tcl.XTcl_ResetResult(tls, interp)
	if sqlite3TestErrCode(tls, interp, *(*uintptr)(unsafe.Pointer(bp + 80 /* db */)), rc) != 0 {
		return 1
	}
	if ((rc == 0) && (objc >= 5)) && (*(*uintptr)(unsafe.Pointer(bp + 96 /* zTail */)) != 0) {
		if *(*int32)(unsafe.Pointer(bp + 88 /* bytes */)) >= 0 {
			*(*int32)(unsafe.Pointer(bp + 88 /* bytes */)) = (*(*int32)(unsafe.Pointer(bp + 88 /* bytes */)) - (int32((int64(*(*uintptr)(unsafe.Pointer(bp + 96 /* zTail */))) - int64(zSql)) / 1)))
		}
		tcl.XTcl_ObjSetVar2(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(4)*8)), uintptr(0), tcl.XTcl_NewStringObj(tls, *(*uintptr)(unsafe.Pointer(bp + 96 /* zTail */)), *(*int32)(unsafe.Pointer(bp + 88 /* bytes */))), 0)
	}
	if rc != 0 {

		sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([50]int8{})), bp+112 /* &zBuf[0] */, ts+23035 /* "(%d) " */, crt.VaList(bp+32, rc))
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+40, bp+112 /* &zBuf[0] */, sqlite3.Xsqlite3_errmsg(tls, *(*uintptr)(unsafe.Pointer(bp + 80 /* db */))), 0))
		return 1
	}

	if *(*uintptr)(unsafe.Pointer(bp + 104 /* pStmt */)) != 0 {
		if sqlite3TestMakePointerStr(tls, interp, bp+112 /* &zBuf[0] */, *(*uintptr)(unsafe.Pointer(bp + 104 /* pStmt */))) != 0 {
			return 1
		}
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+64, bp+112 /* &zBuf[0] */, 0))
	}
	return 0
}

// Usage: sqlite3_prepare_v3 DB sql bytes flags ?tailvar?
//
// Compile up to <bytes> bytes of the supplied SQL string <sql> using
// database handle <DB> and flags <flags>. The parameter <tailval> is
// the name of a global variable that is set to the unused portion of
// <sql> (if any). A STMT handle is returned.
func test_prepare_v3(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:4332:26: */
	bp := tls.Alloc(162)
	defer tls.Free(162)

	// var db uintptr at bp+80, 8

	var zSql uintptr
	var zCopy uintptr = uintptr(0) // malloc() copy of zSql
	// var bytes int32 at bp+88, 4

	// var flags int32 at bp+92, 4

	*(*uintptr)(unsafe.Pointer(bp + 96 /* zTail */)) = uintptr(0)
	var pzTail uintptr
	*(*uintptr)(unsafe.Pointer(bp + 104 /* pStmt */)) = uintptr(0)
	// var zBuf [50]int8 at bp+112, 50

	var rc int32

	if (objc != 6) && (objc != 5) {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615, /* "wrong # args: sh..." */
			tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(0)*8))), ts+23286 /* " DB sql bytes fl..." */, 0))
		return 1
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), bp+80 /* &db */) != 0 {
		return 1
	}
	zSql = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)))
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(3)*8)), bp+88 /* &bytes */) != 0 {
		return 1
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(4)*8)), bp+92 /* &flags */) != 0 {
		return 1
	}

	// Instead of using zSql directly, make a copy into a buffer obtained
	// directly from malloc(). The idea is to make it easier for valgrind
	// to spot buffer overreads.
	if *(*int32)(unsafe.Pointer(bp + 88 /* bytes */)) >= 0 {
		zCopy = crt.Xmalloc(tls, uint64(*(*int32)(unsafe.Pointer(bp + 88 /* bytes */))))
		crt.Xmemcpy(tls, zCopy, zSql, uint64(*(*int32)(unsafe.Pointer(bp + 88 /* bytes */))))
	} else {
		var n int32 = (int32(crt.Xstrlen(tls, zSql)) + 1)
		zCopy = crt.Xmalloc(tls, uint64(n))
		crt.Xmemcpy(tls, zCopy, zSql, uint64(n))
	}
	if objc >= 6 {
		pzTail = bp + 96 /* &zTail */
	} else {
		pzTail = uintptr(0)
	}
	rc = sqlite3.Xsqlite3_prepare_v3(tls, *(*uintptr)(unsafe.Pointer(bp + 80 /* db */)), zCopy, *(*int32)(unsafe.Pointer(bp + 88 /* bytes */)), uint32(*(*int32)(unsafe.Pointer(bp + 92 /* flags */))), bp+104 /* &pStmt */, pzTail)
	crt.Xfree(tls, zCopy)
	*(*uintptr)(unsafe.Pointer(bp + 96 /* zTail */)) = (zSql + uintptr(((int64(*(*uintptr)(unsafe.Pointer(bp + 96 /* zTail */))) - int64(zCopy)) / 1)))

	tcl.XTcl_ResetResult(tls, interp)
	if sqlite3TestErrCode(tls, interp, *(*uintptr)(unsafe.Pointer(bp + 80 /* db */)), rc) != 0 {
		return 1
	}
	if ((rc == 0) && (*(*uintptr)(unsafe.Pointer(bp + 96 /* zTail */)) != 0)) && (objc >= 6) {
		if *(*int32)(unsafe.Pointer(bp + 88 /* bytes */)) >= 0 {
			*(*int32)(unsafe.Pointer(bp + 88 /* bytes */)) = (*(*int32)(unsafe.Pointer(bp + 88 /* bytes */)) - (int32((int64(*(*uintptr)(unsafe.Pointer(bp + 96 /* zTail */))) - int64(zSql)) / 1)))
		}
		tcl.XTcl_ObjSetVar2(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(5)*8)), uintptr(0), tcl.XTcl_NewStringObj(tls, *(*uintptr)(unsafe.Pointer(bp + 96 /* zTail */)), *(*int32)(unsafe.Pointer(bp + 88 /* bytes */))), 0)
	}
	if rc != 0 {

		sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([50]int8{})), bp+112 /* &zBuf[0] */, ts+23035 /* "(%d) " */, crt.VaList(bp+32, rc))
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+40, bp+112 /* &zBuf[0] */, sqlite3.Xsqlite3_errmsg(tls, *(*uintptr)(unsafe.Pointer(bp + 80 /* db */))), 0))
		return 1
	}

	if *(*uintptr)(unsafe.Pointer(bp + 104 /* pStmt */)) != 0 {
		if sqlite3TestMakePointerStr(tls, interp, bp+112 /* &zBuf[0] */, *(*uintptr)(unsafe.Pointer(bp + 104 /* pStmt */))) != 0 {
			return 1
		}
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+64, bp+112 /* &zBuf[0] */, 0))
	}
	return 0
}

// Usage: sqlite3_prepare_tkt3134 DB
//
// Generate a prepared statement for a zero-byte string as a test
// for ticket #3134.  The string should be preceded by a zero byte.
func test_prepare_tkt3134(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:4403:26: */
	bp := tls.Alloc(146)
	defer tls.Free(146)

	// var db uintptr at bp+80, 8

	*(*uintptr)(unsafe.Pointer(bp + 88 /* pStmt */)) = uintptr(0)
	// var zBuf [50]int8 at bp+96, 50

	var rc int32

	if objc != 2 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615, /* "wrong # args: sh..." */
			tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(0)*8))), ts+23264 /* " DB sql bytes ta..." */, 0))
		return 1
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), bp+80 /* &db */) != 0 {
		return 1
	}
	rc = sqlite3.Xsqlite3_prepare_v2(tls, *(*uintptr)(unsafe.Pointer(bp + 80 /* db */)), (uintptr(unsafe.Pointer(&zSql)) + uintptr(1)), 0, bp+88 /* &pStmt */, uintptr(0))

	if sqlite3TestErrCode(tls, interp, *(*uintptr)(unsafe.Pointer(bp + 80 /* db */)), rc) != 0 {
		return 1
	}
	if rc != 0 {

		sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([50]int8{})), bp+96 /* &zBuf[0] */, ts+23035 /* "(%d) " */, crt.VaList(bp+32, rc))
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+40, bp+96 /* &zBuf[0] */, sqlite3.Xsqlite3_errmsg(tls, *(*uintptr)(unsafe.Pointer(bp + 80 /* db */))), 0))
		return 1
	}

	if *(*uintptr)(unsafe.Pointer(bp + 88 /* pStmt */)) != 0 {
		if sqlite3TestMakePointerStr(tls, interp, bp+96 /* &zBuf[0] */, *(*uintptr)(unsafe.Pointer(bp + 88 /* pStmt */))) != 0 {
			return 1
		}
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+64, bp+96 /* &zBuf[0] */, 0))
	}
	return 0
}

var zSql = *(*[10]int8)(unsafe.Pointer(ts + 23314 /* "\x00SELECT 1" */)) /* test1.c:4410:21 */

// Usage: sqlite3_prepare16 DB sql bytes tailvar
//
// Compile up to <bytes> bytes of the supplied SQL string <sql> using
// database handle <DB>. The parameter <tailval> is the name of a global
// variable that is set to the unused portion of <sql> (if any). A
// STMT handle is returned.
func test_prepare16(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:4446:26: */
	return 0
}

// Usage: sqlite3_prepare16_v2 DB sql bytes ?tailvar?
//
// Compile up to <bytes> bytes of the supplied SQL string <sql> using
// database handle <DB>. The parameter <tailval> is the name of a global
// variable that is set to the unused portion of <sql> (if any). A
// STMT handle is returned.
func test_prepare16_v2(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:4506:26: */
	return 0
}

// Usage: sqlite3_open filename ?options-list?
func test_open(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:4561:26: */
	bp := tls.Alloc(156)
	defer tls.Free(156)

	var zFilename uintptr
	// var db uintptr at bp+48, 8

	// var zBuf [100]int8 at bp+56, 100

	if ((objc != 3) && (objc != 2)) && (objc != 1) {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615, /* "wrong # args: sh..." */
			tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(0)*8))), ts+23324 /* " filename option..." */, 0))
		return 1
	}

	if objc > 1 {
		zFilename = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)))
	} else {
		zFilename = uintptr(0)
	}
	sqlite3.Xsqlite3_open(tls, zFilename, bp+48 /* &db */)

	if sqlite3TestMakePointerStr(tls, interp, bp+56 /* &zBuf[0] */, *(*uintptr)(unsafe.Pointer(bp + 48 /* db */))) != 0 {
		return 1
	}
	tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+32, bp+56 /* &zBuf[0] */, 0))
	return 0
}

// Usage: sqlite3_open_v2 FILENAME FLAGS VFS
func test_open_v2(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:4588:26: */
	bp := tls.Alloc(468)
	defer tls.Free(468)

	var zFilename uintptr
	var zVfs uintptr
	var flags int32 = 0
	// var db uintptr at bp+360, 8

	var rc int32
	// var zBuf [100]int8 at bp+368, 100

	// var nFlag int32 at bp+16, 4

	// var apFlag uintptr at bp+24, 8

	var i int32

	if objc != 4 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+23347 /* "FILENAME FLAGS V..." */)
		return 1
	}
	zFilename = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)))
	zVfs = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(3)*8)))
	if int32(*(*int8)(unsafe.Pointer(zVfs + uintptr(0)))) == 0x00 {
		zVfs = uintptr(0)
	}

	rc = tcl.XTcl_ListObjGetElements(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)), bp+16 /* &nFlag */, bp+24 /* &apFlag */)
	if rc != 0 {
		return rc
	}
	for i = 0; i < *(*int32)(unsafe.Pointer(bp + 16 /* nFlag */)); i++ {
		// var iFlag int32 at bp+352, 4

		*(*[20]OpenFlag)(unsafe.Pointer(bp + 32 /* aFlag */)) = [20]OpenFlag{
			{FzFlag: ts + 23366 /* "SQLITE_OPEN_READ..." */, Fflag: 0x00000001},
			{FzFlag: ts + 23387 /* "SQLITE_OPEN_READ..." */, Fflag: 0x00000002},
			{FzFlag: ts + 23409 /* "SQLITE_OPEN_CREA..." */, Fflag: 0x00000004},
			{FzFlag: ts + 23428 /* "SQLITE_OPEN_DELE..." */, Fflag: 0x00000008},
			{FzFlag: ts + 23454 /* "SQLITE_OPEN_EXCL..." */, Fflag: 0x00000010},
			{FzFlag: ts + 23476 /* "SQLITE_OPEN_AUTO..." */, Fflag: 0x00000020},
			{FzFlag: ts + 23498 /* "SQLITE_OPEN_MAIN..." */, Fflag: 0x00000100},
			{FzFlag: ts + 23518 /* "SQLITE_OPEN_TEMP..." */, Fflag: 0x00000200},
			{FzFlag: ts + 23538 /* "SQLITE_OPEN_TRAN..." */, Fflag: 0x00000400},
			{FzFlag: ts + 23563 /* "SQLITE_OPEN_MAIN..." */, Fflag: 0x00000800},
			{FzFlag: ts + 23588 /* "SQLITE_OPEN_TEMP..." */, Fflag: 0x00001000},
			{FzFlag: ts + 23613 /* "SQLITE_OPEN_SUBJ..." */, Fflag: 0x00002000},
			{FzFlag: ts + 23636 /* "SQLITE_OPEN_MAST..." */, Fflag: 0x00004000},
			{FzFlag: ts + 23663 /* "SQLITE_OPEN_NOMU..." */, Fflag: 0x00008000},
			{FzFlag: ts + 23683 /* "SQLITE_OPEN_FULL..." */, Fflag: 0x00010000},
			{FzFlag: ts + 23705 /* "SQLITE_OPEN_SHAR..." */, Fflag: 0x00020000},
			{FzFlag: ts + 23729 /* "SQLITE_OPEN_PRIV..." */, Fflag: 0x00040000},
			{FzFlag: ts + 23754 /* "SQLITE_OPEN_WAL" */, Fflag: 0x00080000},
			{FzFlag: ts + 23770 /* "SQLITE_OPEN_URI" */, Fflag: 0x00000040},
			{FzFlag: uintptr(0), Fflag: 0},
		}
		rc = tcl.XTcl_GetIndexFromObjStruct(tls, interp, *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 24 /* apFlag */)) + uintptr(i)*8)), bp+32 /* &aFlag[0] */, int32(unsafe.Sizeof(OpenFlag{})),
			ts+23786 /* "flag" */, 0, bp+352 /* &iFlag */)
		if rc != 0 {
			return rc
		}
		flags = flags | ((*OpenFlag)(unsafe.Pointer(bp + 32 /* &aFlag */ + uintptr(*(*int32)(unsafe.Pointer(bp + 352 /* iFlag */)))*16)).Fflag)
	}

	rc = sqlite3.Xsqlite3_open_v2(tls, zFilename, bp+360 /* &db */, flags, zVfs)
	if sqlite3TestMakePointerStr(tls, interp, bp+368 /* &zBuf[0] */, *(*uintptr)(unsafe.Pointer(bp + 360 /* db */))) != 0 {
		return 1
	}
	tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, bp+368 /* &zBuf[0] */, 0))
	return 0
}

type OpenFlag = struct {
	FzFlag uintptr
	Fflag  int32
	_      [4]byte
}

// Usage: sqlite3_open16 filename options
func test_open16(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:4658:26: */
	return 0
}

// Usage: sqlite3_complete16 <UTF-16 string>
//
// Return 1 if the supplied argument is a complete SQL statement, or zero
// otherwise.
func test_complete16(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:4690:26: */
	return 0
}

// Usage: sqlite3_normalize SQL
//
// Return the normalized value for an SQL statement.
func test_normalize(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:4715:26: */
	var zSql uintptr
	var zNorm uintptr

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+16552 /* "SQL" */)
		return 1
	}

	zSql = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)))
	zNorm = sqlite3_normalize(tls, zSql)
	if zNorm != 0 {
		tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, zNorm, -1))
		sqlite3.Xsqlite3_free(tls, zNorm)
	}
	return 0
}

// Usage: sqlite3_step STMT
//
// Advance the statement to the next row.
func test_step(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:4744:26: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	// var pStmt uintptr at bp+32, 8

	var rc int32

	if objc != 2 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615, /* "wrong # args: sh..." */
			tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(0)*8))), ts+22874 /* " STMT" */, 0))
		return 1
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), bp+32 /* &pStmt */) != 0 {
		return 1
	}
	rc = sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* pStmt */)))

	// if( rc!=SQLITE_DONE && rc!=SQLITE_ROW ) return TCL_ERROR;
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))
	return 0
}

func test_sql(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:4767:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// var pStmt uintptr at bp, 8

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+23218 /* "STMT" */)
		return 1
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), bp /* &pStmt */) != 0 {
		return 1
	}
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3_sql(tls, *(*uintptr)(unsafe.Pointer(bp /* pStmt */))), uintptr(1))
	return 0
}
func test_ex_sql(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:4784:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// var pStmt uintptr at bp, 8

	var z uintptr

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+23218 /* "STMT" */)
		return 1
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), bp /* &pStmt */) != 0 {
		return 1
	}
	z = sqlite3.Xsqlite3_expanded_sql(tls, *(*uintptr)(unsafe.Pointer(bp /* pStmt */)))
	tcl.XTcl_SetResult(tls, interp, z, uintptr(1))
	sqlite3.Xsqlite3_free(tls, z)
	return 0
}

// Usage: sqlite3_column_count STMT
//
// Return the number of columns returned by the sql statement STMT.
func test_column_count(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:4829:26: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	// var pStmt uintptr at bp+32, 8

	if objc != 2 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615, /* "wrong # args: sh..." */
			tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(0)*8))), ts+23791 /* " STMT column" */, 0))
		return 1
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), bp+32 /* &pStmt */) != 0 {
		return 1
	}

	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, sqlite3.Xsqlite3_column_count(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* pStmt */)))))
	return 0
}

// Usage: sqlite3_column_type STMT column
//
// Return the type of the data in column 'column' of the current row.
func test_column_type(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:4854:26: */
	bp := tls.Alloc(44)
	defer tls.Free(44)

	// var pStmt uintptr at bp+32, 8

	// var col int32 at bp+40, 4

	var tp int32

	if objc != 3 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615, /* "wrong # args: sh..." */
			tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(0)*8))), ts+23791 /* " STMT column" */, 0))
		return 1
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), bp+32 /* &pStmt */) != 0 {
		return 1
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)), bp+40 /* &col */) != 0 {
		return 1
	}

	tp = sqlite3.Xsqlite3_column_type(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* pStmt */)), *(*int32)(unsafe.Pointer(bp + 40 /* col */)))
	switch tp {
	case 1:
		tcl.XTcl_SetResult(tls, interp, ts+11332 /* "INTEGER" */, uintptr(0))
		break
	case 5:
		tcl.XTcl_SetResult(tls, interp, ts+5494 /* "NULL" */, uintptr(0))
		break
	case 2:
		tcl.XTcl_SetResult(tls, interp, ts+23804 /* "FLOAT" */, uintptr(0))
		break
	case 3:
		tcl.XTcl_SetResult(tls, interp, ts+23810 /* "TEXT" */, uintptr(0))
		break
	case 4:
		tcl.XTcl_SetResult(tls, interp, ts+23815 /* "BLOB" */, uintptr(0))
		break
	default:
	}

	return 0
}

// Usage: sqlite3_column_int64 STMT column
//
// Return the data in column 'column' of the current row cast as an
// wide (64-bit) integer.
func test_column_int64(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:4903:26: */
	bp := tls.Alloc(44)
	defer tls.Free(44)

	// var pStmt uintptr at bp+32, 8

	// var col int32 at bp+40, 4

	var iVal i64

	if objc != 3 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615, /* "wrong # args: sh..." */
			tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(0)*8))), ts+23791 /* " STMT column" */, 0))
		return 1
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), bp+32 /* &pStmt */) != 0 {
		return 1
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)), bp+40 /* &col */) != 0 {
		return 1
	}

	iVal = sqlite3.Xsqlite3_column_int64(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* pStmt */)), *(*int32)(unsafe.Pointer(bp + 40 /* col */)))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewWideIntObj(tls, int64(iVal)))
	return 0
}

// Usage: sqlite3_column_blob STMT column
func test_column_blob(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:4930:26: */
	bp := tls.Alloc(44)
	defer tls.Free(44)

	// var pStmt uintptr at bp+32, 8

	// var col int32 at bp+40, 4

	var len int32
	var pBlob uintptr

	if objc != 3 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615, /* "wrong # args: sh..." */
			tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(0)*8))), ts+23791 /* " STMT column" */, 0))
		return 1
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), bp+32 /* &pStmt */) != 0 {
		return 1
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)), bp+40 /* &col */) != 0 {
		return 1
	}

	len = sqlite3.Xsqlite3_column_bytes(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* pStmt */)), *(*int32)(unsafe.Pointer(bp + 40 /* col */)))
	pBlob = sqlite3.Xsqlite3_column_blob(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* pStmt */)), *(*int32)(unsafe.Pointer(bp + 40 /* col */)))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewByteArrayObj(tls, pBlob, len))
	return 0
}

// Usage: sqlite3_column_double STMT column
//
// Return the data in column 'column' of the current row cast as a double.
func test_column_double(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:4962:26: */
	bp := tls.Alloc(44)
	defer tls.Free(44)

	// var pStmt uintptr at bp+32, 8

	// var col int32 at bp+40, 4

	var rVal float64

	if objc != 3 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615, /* "wrong # args: sh..." */
			tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(0)*8))), ts+23791 /* " STMT column" */, 0))
		return 1
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), bp+32 /* &pStmt */) != 0 {
		return 1
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)), bp+40 /* &col */) != 0 {
		return 1
	}

	rVal = sqlite3.Xsqlite3_column_double(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* pStmt */)), *(*int32)(unsafe.Pointer(bp + 40 /* col */)))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewDoubleObj(tls, rVal))
	return 0
}

// Usage: sqlite3_data_count STMT
//
// Return the number of columns returned by the sql statement STMT.
func test_data_count(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:4991:26: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	// var pStmt uintptr at bp+32, 8

	if objc != 2 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615, /* "wrong # args: sh..." */
			tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(0)*8))), ts+23791 /* " STMT column" */, 0))
		return 1
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), bp+32 /* &pStmt */) != 0 {
		return 1
	}

	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, sqlite3.Xsqlite3_data_count(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* pStmt */)))))
	return 0
}

// Usage: sqlite3_column_text STMT column
//
// Usage: sqlite3_column_decltype STMT column
//
// Usage: sqlite3_column_name STMT column
func test_stmt_utf8(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:5018:26: */
	bp := tls.Alloc(44)
	defer tls.Free(44)

	// var pStmt uintptr at bp+32, 8

	// var col int32 at bp+40, 4

	var xFunc uintptr
	var zRet uintptr

	xFunc = clientData
	if objc != 3 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615, /* "wrong # args: sh..." */
			tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(0)*8))), ts+23791 /* " STMT column" */, 0))
		return 1
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), bp+32 /* &pStmt */) != 0 {
		return 1
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)), bp+40 /* &col */) != 0 {
		return 1
	}
	zRet = (*(*func(*crt.TLS, uintptr, int32) uintptr)(unsafe.Pointer(&xFunc)))(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* pStmt */)), *(*int32)(unsafe.Pointer(bp + 40 /* col */)))
	if zRet != 0 {
		tcl.XTcl_SetResult(tls, interp, zRet, uintptr(0))
	}
	return 0
}

func test_global_recover(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:5045:26: */
	var rc int32
	if objc != 1 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+792 /* "" */)
		return 1
	}
	rc = sqlite3.Xsqlite3_global_recover(tls)
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))
	return 0
}

// Usage: sqlite3_column_text STMT column
//
// Usage: sqlite3_column_decltype STMT column
//
// Usage: sqlite3_column_name STMT column
func test_stmt_utf16(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:5070:26: */

	return 0
}

// Usage: sqlite3_column_int STMT column
//
// Usage: sqlite3_column_bytes STMT column
//
// Usage: sqlite3_column_bytes16 STMT column
//
func test_stmt_int(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:5114:26: */
	bp := tls.Alloc(44)
	defer tls.Free(44)

	// var pStmt uintptr at bp+32, 8

	// var col int32 at bp+40, 4

	var xFunc uintptr

	xFunc = clientData
	if objc != 3 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615, /* "wrong # args: sh..." */
			tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(0)*8))), ts+23791 /* " STMT column" */, 0))
		return 1
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), bp+32 /* &pStmt */) != 0 {
		return 1
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)), bp+40 /* &col */) != 0 {
		return 1
	}

	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, (*(*func(*crt.TLS, uintptr, int32) int32)(unsafe.Pointer(&xFunc)))(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* pStmt */)), *(*int32)(unsafe.Pointer(bp + 40 /* col */)))))
	return 0
}

// Usage:  sqlite_set_magic  DB  MAGIC-NUMBER
//
// Set the db->magic value.  This is used to test error recovery logic.
func sqlite_set_magic(tls *crt.TLS, clientData uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:5143:26: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	// var db uintptr at bp+32, 8

	if argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
			ts+23820 /* " DB MAGIC" */, 0))
		return 1
	}
	if getDbPointer(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), bp+32 /* &db */) != 0 {
		return 1
	}
	if crt.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8)), ts+23830 /* "SQLITE_MAGIC_OPE..." */) == 0 {
		(*sqlite31)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32 /* db */)))).Fmagic = 0xa029a697
	} else if crt.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8)), ts+23848 /* "SQLITE_MAGIC_CLO..." */) == 0 {
		(*sqlite31)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32 /* db */)))).Fmagic = 0x9f3c2d33
	} else if crt.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8)), ts+23868 /* "SQLITE_MAGIC_BUS..." */) == 0 {
		(*sqlite31)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32 /* db */)))).Fmagic = 0xf03b7906
	} else if crt.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8)), ts+23886 /* "SQLITE_MAGIC_ERR..." */) == 0 {
		(*sqlite31)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32 /* db */)))).Fmagic = 0xb5357930
	} else if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8)), (*(*uintptr)(unsafe.Pointer(bp + 32 /* db */))+112 /* &.magic */)) != 0 {
		return 1
	}
	return 0
}

// Usage:  sqlite3_interrupt  DB
//
// Trigger an interrupt on DB
func test_interrupt(tls *crt.TLS, clientData uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:5175:26: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	// var db uintptr at bp+32, 8

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)), ts+21667 /* " DB" */, 0))
		return 1
	}
	if getDbPointer(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), bp+32 /* &db */) != 0 {
		return 1
	}
	sqlite3.Xsqlite3_interrupt(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* db */)))
	return 0
}

// Usage: sqlite_delete_function DB function-name
//
// Delete the user function 'function-name' from database handle DB. It
// is assumed that the user function was created as UTF8, any number of
// arguments (the way the TCL interface does it).
func delete_function(tls *crt.TLS, clientData uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:5198:26: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	var rc int32
	// var db uintptr at bp+32, 8

	if argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
			ts+23905 /* " DB function-nam..." */, 0))
		return 1
	}
	if getDbPointer(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), bp+32 /* &db */) != 0 {
		return 1
	}
	rc = sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* db */)), *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8)), -1, 1, uintptr(0), uintptr(0), uintptr(0), uintptr(0))
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))
	return 0
}

// Usage: sqlite_delete_collation DB collation-name
//
// Delete the collation sequence 'collation-name' from database handle
// DB. It is assumed that the collation sequence was created as UTF8 (the
// way the TCL interface does it).
func delete_collation(tls *crt.TLS, clientData uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:5224:26: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	var rc int32
	// var db uintptr at bp+32, 8

	if argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
			ts+23905 /* " DB function-nam..." */, 0))
		return 1
	}
	if getDbPointer(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), bp+32 /* &db */) != 0 {
		return 1
	}
	rc = sqlite3.Xsqlite3_create_collation(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* db */)), *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8)), 1, uintptr(0), uintptr(0))
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))
	return 0
}

// Usage: sqlite3_get_autocommit DB
//
// Return true if the database DB is currently in auto-commit mode.
// Return false if not.
func get_autocommit(tls *crt.TLS, clientData uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:5249:26: */
	bp := tls.Alloc(94)
	defer tls.Free(94)

	// var zBuf [30]int8 at bp+64, 30

	// var db uintptr at bp+56, 8

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
			ts+21667 /* " DB" */, 0))
		return 1
	}
	if getDbPointer(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), bp+56 /* &db */) != 0 {
		return 1
	}
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([30]int8{})), bp+64 /* &zBuf[0] */, ts+1647 /* "%d" */, crt.VaList(bp+32, sqlite3.Xsqlite3_get_autocommit(tls, *(*uintptr)(unsafe.Pointer(bp + 56 /* db */)))))
	tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+40, bp+64 /* &zBuf[0] */, 0))
	return 0
}

// Usage: sqlite3_busy_timeout DB MS
//
// Set the busy timeout.  This is more easily done using the timeout
// method of the TCL interface.  But we need a way to test the case
// where it returns SQLITE_MISUSE.
func test_busy_timeout(tls *crt.TLS, clientData uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:5275:26: */
	bp := tls.Alloc(60)
	defer tls.Free(60)

	var rc int32
	// var ms int32 at bp+56, 4

	// var db uintptr at bp+48, 8

	if argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
			ts+21667 /* " DB" */, 0))
		return 1
	}
	if getDbPointer(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), bp+48 /* &db */) != 0 {
		return 1
	}
	if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8)), bp+56 /* &ms */) != 0 {
		return 1
	}
	rc = sqlite3.Xsqlite3_busy_timeout(tls, *(*uintptr)(unsafe.Pointer(bp + 48 /* db */)), *(*int32)(unsafe.Pointer(bp + 56 /* ms */)))
	tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+32, sqlite3.Xsqlite3ErrName(tls, rc), 0))
	return 0
}

// Usage:  tcl_variable_type VARIABLENAME
//
// Return the name of the internal representation for the
// value of the given variable.
func tcl_variable_type(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:5301:26: */
	var pVar uintptr
	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+23923 /* "VARIABLE" */)
		return 1
	}
	pVar = tcl.XTcl_GetVar2Ex(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), uintptr(0), 0x200)
	if pVar == uintptr(0) {
		return 1
	}
	if (*Tcl_Obj)(unsafe.Pointer(pVar)).FtypePtr != 0 {
		tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, (*Tcl_ObjType)(unsafe.Pointer((*Tcl_Obj)(unsafe.Pointer(pVar)).FtypePtr)).Fname, -1))
	}
	return 0
}

// Usage:  sqlite3_release_memory ?N?
//
// Attempt to release memory currently held but not actually required.
// The integer N is the number of bytes we are trying to release.  The
// return value is the amount of memory actually released.
func test_release_memory(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:5327:26: */
	return 0
}

// Usage:  sqlite3_db_release_memory DB
//
// Attempt to release memory currently held by database DB.  Return the
// result code (which in the current implementation is always zero).
func test_db_release_memory(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:5358:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// var db uintptr at bp, 8

	var rc int32
	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+2452 /* "DB" */)
		return 1
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), bp /* &db */) != 0 {
		return 1
	}
	rc = sqlite3.Xsqlite3_db_release_memory(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, rc))
	return 0
}

// Usage:  sqlite3_db_cacheflush DB
//
// Attempt to flush any dirty pages to disk.
func test_db_cacheflush(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:5381:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// var db uintptr at bp, 8

	var rc int32
	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+2452 /* "DB" */)
		return 1
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), bp /* &db */) != 0 {
		return 1
	}
	rc = sqlite3.Xsqlite3_db_cacheflush(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)))
	if rc != 0 {
		tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrStr(tls, rc), uintptr(0))
		return 1
	}

	tcl.XTcl_ResetResult(tls, interp)
	return 0
}

// Usage:  sqlite3_system_errno DB
//
// Return the low-level system errno value.
func test_system_errno(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:5409:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// var db uintptr at bp, 8

	var iErrno int32
	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+2452 /* "DB" */)
		return 1
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), bp /* &db */) != 0 {
		return 1
	}
	iErrno = sqlite3.Xsqlite3_system_errno(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, iErrno))
	return 0
}

// Usage:  sqlite3_db_filename DB DBNAME
//
// Return the name of a file associated with a database.
func test_db_filename(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:5432:26: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	// var db uintptr at bp+16, 8

	var zDbName uintptr
	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+23932 /* "DB DBNAME" */)
		return 1
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), bp+16 /* &db */) != 0 {
		return 1
	}
	zDbName = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)))
	tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, sqlite3.Xsqlite3_db_filename(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* db */)), zDbName), uintptr(0)))
	return 0
}

// Usage:  sqlite3_db_readonly DB DBNAME
//
// Return 1 or 0 if DBNAME is readonly or not.  Return -1 if DBNAME does
// not exist.
func test_db_readonly(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:5456:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// var db uintptr at bp, 8

	var zDbName uintptr
	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+23932 /* "DB DBNAME" */)
		return 1
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), bp /* &db */) != 0 {
		return 1
	}
	zDbName = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, sqlite3.Xsqlite3_db_readonly(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), zDbName)))
	return 0
}

// Usage:  sqlite3_soft_heap_limit ?N?
//
// Query or set the soft heap limit for the current thread.  The
// limit is only changed if the N is present.  The previous limit
// is returned.
func test_soft_heap_limit(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:5481:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var amt sqlite3_int64
	*(*Tcl_WideInt)(unsafe.Pointer(bp /* N */)) = int64(-1)
	if (objc != 1) && (objc != 2) {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+23942 /* "?N?" */)
		return 1
	}
	if objc == 2 {
		if tcl.XTcl_GetWideIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)), bp /* &N */) != 0 {
			return 1
		}
	}
	amt = sqlite3.Xsqlite3_soft_heap_limit64(tls, int64(*(*Tcl_WideInt)(unsafe.Pointer(bp /* N */))))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewWideIntObj(tls, int64(amt)))
	return 0
}

// Usage:  sqlite3_hard_heap_limit ?N?
//
// Query or set the hard heap limit for the current thread.  The
// limit is only changed if the N is present.  The previous limit
// is returned.
func test_hard_heap_limit(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:5508:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var amt sqlite3_int64
	*(*Tcl_WideInt)(unsafe.Pointer(bp /* N */)) = int64(-1)
	if (objc != 1) && (objc != 2) {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+23942 /* "?N?" */)
		return 1
	}
	if objc == 2 {
		if tcl.XTcl_GetWideIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)), bp /* &N */) != 0 {
			return 1
		}
	}
	amt = sqlite3.Xsqlite3_hard_heap_limit64(tls, int64(*(*Tcl_WideInt)(unsafe.Pointer(bp /* N */))))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewWideIntObj(tls, int64(amt)))
	return 0
}

// Usage:   sqlite3_thread_cleanup
//
// Call the sqlite3_thread_cleanup API.
func test_thread_cleanup(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:5533:26: */
	sqlite3.Xsqlite3_thread_cleanup(tls)
	return 0
}

// Usage:   sqlite3_pager_refcounts  DB
//
// Return a list of numbers which are the PagerRefcount for all
// pagers on each database connection.
func test_pager_refcounts(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:5551:26: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	// var db uintptr at bp+32, 8

	var i int32
	var v int32
	var a uintptr
	var pResult uintptr

	if objc != 2 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615, /* "wrong # args: sh..." */
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(0)*8)), uintptr(0)), ts+21667 /* " DB" */, 0))
		return 1
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), bp+32 /* &db */) != 0 {
		return 1
	}
	pResult = tcl.XTcl_NewObj(tls)
	for i = 0; i < (*sqlite31)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32 /* db */)))).FnDb; i++ {
		if (*Db)(unsafe.Pointer((*sqlite31)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32 /* db */)))).FaDb+uintptr(i)*32)).FpBt == uintptr(0) {
			v = -1
		} else {
			sqlite3.Xsqlite3_mutex_enter(tls, (*sqlite31)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32 /* db */)))).Fmutex)
			a = sqlite3.Xsqlite3PagerStats(tls, sqlite3.Xsqlite3BtreePager(tls, (*Db)(unsafe.Pointer((*sqlite31)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32 /* db */)))).FaDb+uintptr(i)*32)).FpBt))
			v = *(*int32)(unsafe.Pointer(a + uintptr(0)*4))
			sqlite3.Xsqlite3_mutex_leave(tls, (*sqlite31)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32 /* db */)))).Fmutex)
		}
		tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pResult, tcl.XTcl_NewIntObj(tls, v))
	}
	tcl.XTcl_SetObjResult(tls, interp, pResult)
	return 0
}

// tclcmd:   working_64bit_int
//
// Some TCL builds (ex: cygwin) do not support 64-bit integers.  This
// leads to a number of test failures.  The present command checks the
// TCL build to see whether or not it supports 64-bit integers.  It
// returns TRUE if it does and FALSE if not.
//
// This command is used to warn users that their TCL build is defective
// and that the errors they are seeing in the test scripts might be
// a result of their defective TCL rather than problems in SQLite.
func working_64bit_int(tls *crt.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:5597:26: */
	var pTestObj uintptr
	var working int32 = 0

	pTestObj = tcl.XTcl_NewWideIntObj(tls, (int64(1000000) * int64(1234567890)))
	working = (crt.Bool32(crt.Xstrcmp(tls, tcl.XTcl_GetString(tls, pTestObj), ts+23946 /* "1234567890000000" */) == 0))
	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = pTestObj
		if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, (crt.Bool32((working) != 0))))
	return 0
}

// tclcmd:   vfs_unlink_test
//
// This TCL command unregisters the primary VFS and then registers
// it back again.  This is used to test the ability to register a
// VFS when none are previously registered, and the ability to
// unregister the only available VFS.  Ticket #2738
func vfs_unlink_test(tls *crt.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:5622:26: */
	bp := tls.Alloc(496)
	defer tls.Free(496)

	var i int32
	var pMain uintptr
	// var apVfs [20]uintptr at bp+336, 160

	// var one sqlite3_vfs at bp, 168

	// var two sqlite3_vfs at bp+168, 168

	sqlite3.Xsqlite3_vfs_unregister(tls, uintptr(0))                        // Unregister of NULL is harmless
	(*sqlite3_vfs)(unsafe.Pointer(bp /* &one */)).FzName = ts + 23963       /* "__one" */
	(*sqlite3_vfs)(unsafe.Pointer(bp + 168 /* &two */)).FzName = ts + 23969 /* "__two" */

	// Calling sqlite3_vfs_register with 2nd argument of 0 does not
	// change the default VFS
	pMain = sqlite3.Xsqlite3_vfs_find(tls, uintptr(0))
	sqlite3.Xsqlite3_vfs_register(tls, bp /* &one */, 0)

	sqlite3.Xsqlite3_vfs_register(tls, bp+168 /* &two */, 0)

	// We can find a VFS by its name

	// Calling sqlite_vfs_register with non-zero second parameter changes the
	// default VFS, even if the 1st parameter is an existig VFS that is
	// previously registered as the non-default.
	sqlite3.Xsqlite3_vfs_register(tls, bp /* &one */, 1)

	sqlite3.Xsqlite3_vfs_register(tls, bp+168 /* &two */, 1)

	if pMain != 0 {
		sqlite3.Xsqlite3_vfs_register(tls, pMain, 1)

	}

	// Unlink the default VFS.  Repeat until there are no more VFSes
	// registered.
	for i = 0; uint64(i) < (uint64(unsafe.Sizeof([20]uintptr{})) / uint64(unsafe.Sizeof(uintptr(0)))); i++ {
		*(*uintptr)(unsafe.Pointer(bp + 336 /* &apVfs[0] */ + uintptr(i)*8)) = sqlite3.Xsqlite3_vfs_find(tls, uintptr(0))
		if *(*uintptr)(unsafe.Pointer(bp + 336 /* &apVfs[0] */ + uintptr(i)*8)) != 0 {

			sqlite3.Xsqlite3_vfs_unregister(tls, *(*uintptr)(unsafe.Pointer(bp + 336 /* &apVfs[0] */ + uintptr(i)*8)))
		}
	}

	// Register the main VFS as non-default (will be made default, since
	// it'll be the only one in existence).
	sqlite3.Xsqlite3_vfs_register(tls, pMain, 0)

	// Un-register the main VFS again to restore an empty VFS list
	sqlite3.Xsqlite3_vfs_unregister(tls, pMain)

	/* Relink all VFSes in reverse order. */
	for i = (int32((uint64(unsafe.Sizeof([20]uintptr{})) / uint64(unsafe.Sizeof(uintptr(0)))) - uint64(1))); i >= 0; i-- {
		if *(*uintptr)(unsafe.Pointer(bp + 336 /* &apVfs[0] */ + uintptr(i)*8)) != 0 {
			sqlite3.Xsqlite3_vfs_register(tls, *(*uintptr)(unsafe.Pointer(bp + 336 /* &apVfs[0] */ + uintptr(i)*8)), 1)

		}
	}

	// Unregister out sample VFSes.
	sqlite3.Xsqlite3_vfs_unregister(tls, bp /* &one */)
	sqlite3.Xsqlite3_vfs_unregister(tls, bp+168 /* &two */)

	// Unregistering a VFS that is not currently registered is harmless
	sqlite3.Xsqlite3_vfs_unregister(tls, bp /* &one */)
	sqlite3.Xsqlite3_vfs_unregister(tls, bp+168 /* &two */)

	// We should be left with the original default VFS back as the
	// original

	return 0
}

// tclcmd:   vfs_initfail_test
//
// This TCL command attempts to vfs_find and vfs_register when the
// sqlite3_initialize() interface is failing.  All calls should fail.
func vfs_initfail_test(tls *crt.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:5724:26: */
	bp := tls.Alloc(168)
	defer tls.Free(168)

	// var one sqlite3_vfs at bp, 168

	(*sqlite3_vfs)(unsafe.Pointer(bp /* &one */)).FzName = ts + 23963 /* "__one" */

	if sqlite3.Xsqlite3_vfs_find(tls, uintptr(0)) != 0 {
		return 1
	}
	sqlite3.Xsqlite3_vfs_register(tls, bp /* &one */, 0)
	if sqlite3.Xsqlite3_vfs_find(tls, uintptr(0)) != 0 {
		return 1
	}
	sqlite3.Xsqlite3_vfs_register(tls, bp /* &one */, 1)
	if sqlite3.Xsqlite3_vfs_find(tls, uintptr(0)) != 0 {
		return 1
	}
	return 0
}

// Saved VFSes
var apVfs [20]uintptr /* test1.c:5744:20: */
var nVfs int32 = 0    /* test1.c:5745:12 */

// tclcmd:   vfs_unregister_all
//
// Unregister all VFSes.
func vfs_unregister_all(tls *crt.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:5752:26: */
	var i int32
	for i = 0; i < (int32(uint64(unsafe.Sizeof(apVfs)) / uint64(unsafe.Sizeof(uintptr(0))))); i++ {
		apVfs[i] = sqlite3.Xsqlite3_vfs_find(tls, uintptr(0))
		if apVfs[i] == uintptr(0) {
			break
		}
		sqlite3.Xsqlite3_vfs_unregister(tls, apVfs[i])
	}
	nVfs = i
	return 0
}

// tclcmd:   vfs_reregister_all
//
// Restore all VFSes that were removed using vfs_unregister_all. Taking
// care to put the linked list back together in the same order as it was
// in before vfs_unregister_all was invoked.
func vfs_reregister_all(tls *crt.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:5774:26: */
	var i int32
	for i = (nVfs - 1); i >= 0; i-- {
		sqlite3.Xsqlite3_vfs_register(tls, apVfs[i], 1)
	}
	return 0
}

// tclcmd:   file_control_test DB
//
// This TCL command runs the sqlite3_file_control interface and
// verifies correct operation of the same.
func file_control_test(tls *crt.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:5794:26: */
	bp := tls.Alloc(44)
	defer tls.Free(44)

	*(*int32)(unsafe.Pointer(bp + 40 /* iArg */)) = 0
	// var db uintptr at bp+32, 8

	var rc int32
	_ = rc

	if objc != 2 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615, /* "wrong # args: sh..." */
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(0)*8)), uintptr(0)), ts+21667 /* " DB" */, 0))
		return 1
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), bp+32 /* &db */) != 0 {
		return 1
	}
	rc = sqlite3.Xsqlite3_file_control(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* db */)), uintptr(0), 0, bp+40 /* &iArg */)

	rc = sqlite3.Xsqlite3_file_control(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* db */)), ts+23975 /* "notadatabase" */, 1, bp+40 /* &iArg */)

	rc = sqlite3.Xsqlite3_file_control(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* db */)), ts+354 /* "main" */, -1, bp+40 /* &iArg */)

	rc = sqlite3.Xsqlite3_file_control(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* db */)), ts+8992 /* "temp" */, -1, bp+40 /* &iArg */)

	return 0
}

// tclcmd:   file_control_lasterrno_test DB
//
// This TCL command runs the sqlite3_file_control interface and
// verifies correct operation of the SQLITE_LAST_ERRNO verb.
func file_control_lasterrno_test(tls *crt.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:5829:26: */
	bp := tls.Alloc(76)
	defer tls.Free(76)

	*(*int32)(unsafe.Pointer(bp + 72 /* iArg */)) = 0
	// var db uintptr at bp+64, 8

	var rc int32

	if objc != 2 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615, /* "wrong # args: sh..." */
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(0)*8)), uintptr(0)), ts+21667 /* " DB" */, 0))
		return 1
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), bp+64 /* &db */) != 0 {
		return 1
	}
	rc = sqlite3.Xsqlite3_file_control(tls, *(*uintptr)(unsafe.Pointer(bp + 64 /* db */)), uintptr(0), 4, bp+72 /* &iArg */)
	if rc != 0 {
		tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, rc))
		return 1
	}
	if *(*int32)(unsafe.Pointer(bp + 72 /* iArg */)) != 0 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+32, ts+23988, /* "Unexpected non-z..." */
			tcl.XTcl_GetStringFromObj(tls, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 72 /* iArg */))), uintptr(0)), ts+4435 /* " " */, 0))
		return 1
	}
	return 0
}

// tclcmd:   file_control_data_version DB DBNAME
//
// This TCL command runs the sqlite3_file_control with the
// SQLITE_FCNTL_DATA_VERSION opcode, returning the result.
func file_control_data_version(tls *crt.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:5866:26: */
	bp := tls.Alloc(120)
	defer tls.Free(120)

	// var iVers uint32 at bp+16, 4
	// data version
	var zDb uintptr // Db name ("main", "temp" etc.)
	// var db uintptr at bp+8, 8
	// Database handle
	var rc int32 // file_control() return code
	// var zBuf [100]int8 at bp+20, 100

	if (objc != 3) && (objc != 2) {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+24016 /* "DB [DBNAME]" */)
		return 1
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), bp+8 /* &db */) != 0 {
		return 1
	}
	if objc == 3 {
		zDb = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)))
	} else {
		zDb = uintptr(0)
	}

	rc = sqlite3.Xsqlite3_file_control(tls, *(*uintptr)(unsafe.Pointer(bp + 8 /* db */)), zDb, 35, bp+16 /* &iVers */)
	if rc != 0 {
		tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))
		return 1
	} else {
		sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([100]int8{})), bp+20 /* &zBuf[0] */, ts+24028 /* "%u" */, crt.VaList(bp, *(*uint32)(unsafe.Pointer(bp + 16 /* iVers */))))
		tcl.XTcl_SetResult(tls, interp, bp+20 /* zBuf */, uintptr(1))
		return 0
	}
	return int32(0)
}

// tclcmd:   file_control_chunksize_test DB DBNAME SIZE
//
// This TCL command runs the sqlite3_file_control interface and
// verifies correct operation of the SQLITE_GET_LOCKPROXYFILE and
// SQLITE_SET_LOCKPROXYFILE verbs.
func file_control_chunksize_test(tls *crt.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:5905:26: */
	bp := tls.Alloc(12)
	defer tls.Free(12)

	// var nSize int32 at bp+8, 4
	// New chunk size
	var zDb uintptr // Db name ("main", "temp" etc.)
	// var db uintptr at bp, 8
	// Database handle
	var rc int32 // file_control() return code

	if objc != 4 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+24031 /* "DB DBNAME SIZE" */)
		return 1
	}
	if (getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), bp /* &db */) != 0) ||
		(tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(3)*8)), bp+8 /* &nSize */) != 0) {
		return 1
	}
	zDb = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)))
	if int32(*(*int8)(unsafe.Pointer(zDb + uintptr(0)))) == 0 {
		zDb = uintptr(0)
	}

	rc = sqlite3.Xsqlite3_file_control(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), zDb, 6, bp+8 /* &nSize */)
	if rc != 0 {
		tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))
		return 1
	}
	return 0
}

// tclcmd:   file_control_sizehint_test DB DBNAME SIZE
//
// This TCL command runs the sqlite3_file_control interface
// with SQLITE_FCNTL_SIZE_HINT
func file_control_sizehint_test(tls *crt.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:5942:26: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	// var nSize Tcl_WideInt at bp+8, 8
	// Hinted size
	var zDb uintptr // Db name ("main", "temp" etc.)
	// var db uintptr at bp, 8
	// Database handle
	var rc int32 // file_control() return code

	if objc != 4 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+24031 /* "DB DBNAME SIZE" */)
		return 1
	}
	if (getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), bp /* &db */) != 0) ||
		(tcl.XTcl_GetWideIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(3)*8)), bp+8 /* &nSize */) != 0) {
		return 1
	}
	zDb = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)))
	if int32(*(*int8)(unsafe.Pointer(zDb + uintptr(0)))) == 0 {
		zDb = uintptr(0)
	}

	rc = sqlite3.Xsqlite3_file_control(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), zDb, 5, bp+8 /* &nSize */)
	if rc != 0 {
		tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))
		return 1
	}
	return 0
}

// tclcmd:   file_control_lockproxy_test DB PWD
//
// This TCL command runs the sqlite3_file_control interface and
// verifies correct operation of the SQLITE_GET_LOCKPROXYFILE and
// SQLITE_SET_LOCKPROXYFILE verbs.
func file_control_lockproxy_test(tls *crt.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:5980:26: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	// var db uintptr at bp+32, 8

	if objc != 3 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615, /* "wrong # args: sh..." */
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(0)*8)), uintptr(0)), ts+24046 /* " DB PWD" */, 0))
		return 1
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), bp+32 /* &db */) != 0 {
		return 1
	}

	return 0
}

// tclcmd:   file_control_persist_wal DB PERSIST-FLAG
//
// This TCL command runs the sqlite3_file_control interface with
// the SQLITE_FCNTL_PERSIST_WAL opcode.
func file_control_persist_wal(tls *crt.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:6151:26: */
	bp := tls.Alloc(176)
	defer tls.Free(176)

	// var db uintptr at bp+64, 8

	var rc int32
	// var bPersist int32 at bp+72, 4

	// var z [100]int8 at bp+76, 100

	if objc != 3 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615, /* "wrong # args: sh..." */
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(0)*8)), uintptr(0)), ts+24054 /* " DB FLAG" */, 0))
		return 1
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), bp+64 /* &db */) != 0 {
		return 1
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)), bp+72 /* &bPersist */) != 0 {
		return 1
	}
	rc = sqlite3.Xsqlite3_file_control(tls, *(*uintptr)(unsafe.Pointer(bp + 64 /* db */)), uintptr(0), 10, bp+72 /* &bPersist */)
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([100]int8{})), bp+76 /* &z[0] */, ts+24063 /* "%d %d" */, crt.VaList(bp+32, rc, *(*int32)(unsafe.Pointer(bp + 72 /* bPersist */))))
	tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+48, bp+76 /* &z[0] */, uintptr(0)))
	return 0
}

// tclcmd:   file_control_powersafe_overwrite DB PSOW-FLAG
//
// This TCL command runs the sqlite3_file_control interface with
// the SQLITE_FCNTL_POWERSAFE_OVERWRITE opcode.
func file_control_powersafe_overwrite(tls *crt.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:6183:26: */
	bp := tls.Alloc(176)
	defer tls.Free(176)

	// var db uintptr at bp+64, 8

	var rc int32
	// var b int32 at bp+72, 4

	// var z [100]int8 at bp+76, 100

	if objc != 3 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615, /* "wrong # args: sh..." */
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(0)*8)), uintptr(0)), ts+24054 /* " DB FLAG" */, 0))
		return 1
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), bp+64 /* &db */) != 0 {
		return 1
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)), bp+72 /* &b */) != 0 {
		return 1
	}
	rc = sqlite3.Xsqlite3_file_control(tls, *(*uintptr)(unsafe.Pointer(bp + 64 /* db */)), uintptr(0), 13, bp+72 /* &b */)
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([100]int8{})), bp+76 /* &z[0] */, ts+24063 /* "%d %d" */, crt.VaList(bp+32, rc, *(*int32)(unsafe.Pointer(bp + 72 /* b */))))
	tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+48, bp+76 /* &z[0] */, uintptr(0)))
	return 0
}

// tclcmd:   file_control_vfsname DB ?AUXDB?
//
// Return a string that describes the stack of VFSes.
func file_control_vfsname(tls *crt.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:6215:26: */
	bp := tls.Alloc(64)
	defer tls.Free(64)

	// var db uintptr at bp+48, 8

	var zDbName uintptr = ts + 354 /* "main" */
	*(*uintptr)(unsafe.Pointer(bp + 56 /* zVfsName */)) = uintptr(0)

	if (objc != 2) && (objc != 3) {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615, /* "wrong # args: sh..." */
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(0)*8)), uintptr(0)), ts+24069 /* " DB ?AUXDB?" */, 0))
		return 1
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), bp+48 /* &db */) != 0 {
		return 1
	}
	if objc == 3 {
		zDbName = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)))
	}
	sqlite3.Xsqlite3_file_control(tls, *(*uintptr)(unsafe.Pointer(bp + 48 /* db */)), zDbName, 12, bp+56 /* &zVfsName */)
	tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+32, *(*uintptr)(unsafe.Pointer(bp + 56 /* zVfsName */)), uintptr(0)))
	sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(bp + 56 /* zVfsName */)))
	return 0
}

// tclcmd:   file_control_tempfilename DB ?AUXDB?
//
// Return a string that is a temporary filename
func file_control_tempfilename(tls *crt.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:6247:26: */
	bp := tls.Alloc(64)
	defer tls.Free(64)

	// var db uintptr at bp+48, 8

	var zDbName uintptr = ts + 354 /* "main" */
	*(*uintptr)(unsafe.Pointer(bp + 56 /* zTName */)) = uintptr(0)

	if (objc != 2) && (objc != 3) {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615, /* "wrong # args: sh..." */
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(0)*8)), uintptr(0)), ts+24069 /* " DB ?AUXDB?" */, 0))
		return 1
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), bp+48 /* &db */) != 0 {
		return 1
	}
	if objc == 3 {
		zDbName = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)))
	}
	sqlite3.Xsqlite3_file_control(tls, *(*uintptr)(unsafe.Pointer(bp + 48 /* db */)), zDbName, 16, bp+56 /* &zTName */)
	tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+32, *(*uintptr)(unsafe.Pointer(bp + 56 /* zTName */)), uintptr(0)))
	sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(bp + 56 /* zTName */)))
	return 0
}

// tclcmd:   sqlite3_vfs_list
//
//   Return a tcl list containing the names of all registered vfs's.
func vfs_list(tls *crt.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:6280:26: */
	var pVfs uintptr
	var pRet uintptr = tcl.XTcl_NewObj(tls)
	if objc != 1 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+792 /* "" */)
		return 1
	}
	for pVfs = sqlite3.Xsqlite3_vfs_find(tls, uintptr(0)); pVfs != 0; pVfs = (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpNext {
		tcl.XTcl_ListObjAppendElement(tls, interp, pRet, tcl.XTcl_NewStringObj(tls, (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FzName, -1))
	}
	tcl.XTcl_SetObjResult(tls, interp, pRet)
	return 0
}

// tclcmd:   sqlite3_limit DB ID VALUE
//
// This TCL command runs the sqlite3_limit interface and
// verifies correct operation of the same.
func test_limit(tls *crt.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:6305:26: */
	bp := tls.Alloc(68)
	defer tls.Free(68)

	// var db uintptr at bp+56, 8

	var rc int32
	var i int32
	var id int32 = 0
	// var val int32 at bp+64, 4

	var zId uintptr

	if objc != 4 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615, /* "wrong # args: sh..." */
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(0)*8)), uintptr(0)), ts+24081 /* " DB ID VALUE" */, 0))
		return 1
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), bp+56 /* &db */) != 0 {
		return 1
	}
	zId = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)))
	for i = 0; uint64(i) < (uint64(unsafe.Sizeof(aId)) / uint64(unsafe.Sizeof(struct {
		FzName uintptr
		Fid    int32
		_      [4]byte
	}{}))); i++ {
		if crt.Xstrcmp(tls, zId, aId[i].FzName) == 0 {
			id = aId[i].Fid
			break
		}
	}
	if uint64(i) >= (uint64(unsafe.Sizeof(aId)) / uint64(unsafe.Sizeof(struct {
		FzName uintptr
		Fid    int32
		_      [4]byte
	}{}))) {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+32, ts+24094 /* "unknown limit ty..." */, zId, uintptr(0)))
		return 1
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(3)*8)), bp+64 /* &val */) != 0 {
		return 1
	}
	rc = sqlite3.Xsqlite3_limit(tls, *(*uintptr)(unsafe.Pointer(bp + 56 /* db */)), id, *(*int32)(unsafe.Pointer(bp + 64 /* val */)))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, rc))
	return 0
}

var aId = [14]struct {
	FzName uintptr
	Fid    int32
	_      [4]byte
}{
	{FzName: ts + 24115 /* "SQLITE_LIMIT_LEN..." */, Fid: 0},
	{FzName: ts + 24135 /* "SQLITE_LIMIT_SQL..." */, Fid: 1},
	{FzName: ts + 24159 /* "SQLITE_LIMIT_COL..." */, Fid: 2},
	{FzName: ts + 24179 /* "SQLITE_LIMIT_EXP..." */, Fid: 3},
	{FzName: ts + 24203 /* "SQLITE_LIMIT_COM..." */, Fid: 4},
	{FzName: ts + 24232 /* "SQLITE_LIMIT_VDB..." */, Fid: 5},
	{FzName: ts + 24253 /* "SQLITE_LIMIT_FUN..." */, Fid: 6},
	{FzName: ts + 24279 /* "SQLITE_LIMIT_ATT..." */, Fid: 7},
	{FzName: ts + 24301 /* "SQLITE_LIMIT_LIK..." */, Fid: 8},
	{FzName: ts + 24334 /* "SQLITE_LIMIT_VAR..." */, Fid: 9},
	{FzName: ts + 24363 /* "SQLITE_LIMIT_TRI..." */, Fid: 10},
	{FzName: ts + 24390 /* "SQLITE_LIMIT_WOR..." */, Fid: 11},

	// Out of range test cases
	{FzName: ts + 24418 /* "SQLITE_LIMIT_TOO..." */, Fid: -1},
	{FzName: ts + 24440 /* "SQLITE_LIMIT_TOO..." */, Fid: (11 + 1)},
} /* test1.c:6316:5 */

// tclcmd:  save_prng_state
//
// Save the state of the pseudo-random number generator.
// At the same time, verify that sqlite3_test_control works even when
// called with an out-of-range opcode.
func save_prng_state(tls *crt.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:6368:26: */
	var rc int32 = sqlite3.Xsqlite3_test_control(tls, 9999, 0)
	_ = rc

	rc = sqlite3.Xsqlite3_test_control(tls, -1, 0)

	sqlite3.Xsqlite3_test_control(tls, 5, 0)
	return 0
}

// tclcmd:  restore_prng_state
func restore_prng_state(tls *crt.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:6384:26: */
	sqlite3.Xsqlite3_test_control(tls, 6, 0)
	return 0
}

// tclcmd:  reset_prng_state
func reset_prng_state(tls *crt.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:6396:26: */
	sqlite3.Xsqlite3_randomness(tls, 0, uintptr(0))
	return 0
}

// tclcmd:  prng_seed INT ?DB?
//
// Set up the SQLITE_TESTCTRL_PRNG_SEED pragma with parameter INT and DB.
// INT is an integer.  DB is a database connection, or a NULL pointer if
// omitted.
//
// When INT!=0 and DB!=0, set the PRNG seed to the value of the schema
// cookie for DB, or to INT if the schema cookie happens to be zero.
//
// When INT!=0 and DB==0, set the PRNG seed to just INT.
//
// If INT==0 and DB==0 then use the default procedure of calling the
// xRandomness method on the default VFS to get the PRNG seed.
func prng_seed(tls *crt.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:6420:26: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	*(*int32)(unsafe.Pointer(bp + 16 /* i */)) = 0
	*(*uintptr)(unsafe.Pointer(bp + 24 /* db */)) = uintptr(0)
	if (objc != 2) && (objc != 3) {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+24460 /* "SEED ?DB?" */)
		return 1
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(0)*8)), bp+16 /* &i */) != 0 {
		return 1
	}
	if (objc == 3) && (getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8))), bp+24 /* &db */) != 0) {
		return 1
	}
	sqlite3.Xsqlite3_test_control(tls, 28, crt.VaList(bp, *(*int32)(unsafe.Pointer(bp + 16 /* i */)), *(*uintptr)(unsafe.Pointer(bp + 24 /* db */))))
	return 0
}

// tclcmd:  database_may_be_corrupt
//
// Indicate that database files might be corrupt. In other words, set the normal
// state of operation.
func database_may_be_corrupt(tls *crt.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:6446:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	sqlite3.Xsqlite3_test_control(tls, 20, crt.VaList(bp, 0))
	return 0
}

// tclcmd:  database_never_corrupt
//
// Indicate that database files are always well-formed. This enables
// extra assert() statements that test conditions that are always true
// for well-formed databases.
func database_never_corrupt(tls *crt.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:6462:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	sqlite3.Xsqlite3_test_control(tls, 20, crt.VaList(bp, 1))
	return 0
}

// tclcmd:  pcache_stats
func test_pcache_stats(tls *crt.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:6475:26: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	// var nMin int32 at bp+8, 4

	// var nMax int32 at bp+4, 4

	// var nCurrent int32 at bp, 4

	// var nRecyclable int32 at bp+12, 4

	var pRet uintptr

	sqlite3.Xsqlite3PcacheStats(tls, bp /* &nCurrent */, bp+4 /* &nMax */, bp+8 /* &nMin */, bp+12 /* &nRecyclable */)

	pRet = tcl.XTcl_NewObj(tls)
	tcl.XTcl_ListObjAppendElement(tls, interp, pRet, tcl.XTcl_NewStringObj(tls, ts+24470 /* "current" */, -1))
	tcl.XTcl_ListObjAppendElement(tls, interp, pRet, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp /* nCurrent */))))
	tcl.XTcl_ListObjAppendElement(tls, interp, pRet, tcl.XTcl_NewStringObj(tls, ts+24478 /* "max" */, -1))
	tcl.XTcl_ListObjAppendElement(tls, interp, pRet, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 4 /* nMax */))))
	tcl.XTcl_ListObjAppendElement(tls, interp, pRet, tcl.XTcl_NewStringObj(tls, ts+24482 /* "min" */, -1))
	tcl.XTcl_ListObjAppendElement(tls, interp, pRet, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 8 /* nMin */))))
	tcl.XTcl_ListObjAppendElement(tls, interp, pRet, tcl.XTcl_NewStringObj(tls, ts+24486 /* "recyclable" */, -1))
	tcl.XTcl_ListObjAppendElement(tls, interp, pRet, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 12 /* nRecyclable */))))

	tcl.XTcl_SetObjResult(tls, interp, pRet)

	return 0
}

func test_unlock_notify_cb(tls *crt.TLS, aArg uintptr, nArg int32) { /* test1.c:6505:13: */
	var ii int32
	for ii = 0; ii < nArg; ii++ {
		tcl.XTcl_EvalEx(tls, *(*uintptr)(unsafe.Pointer(aArg + uintptr(ii)*8)), ts+20362 /* "unlock_notify" */, -1, 0x020000)
	}
}

// tclcmd:  sqlite3_unlock_notify db
func test_unlock_notify(tls *crt.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:6517:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// var db uintptr at bp, 8

	var rc int32

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+2452 /* "DB" */)
		return 1
	}

	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), bp /* &db */) != 0 {
		return 1
	}
	rc = sqlite3.Xsqlite3_unlock_notify(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, int32)
	}{test_unlock_notify_cb})), interp)
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))
	return 0
}

// tclcmd:  sqlite3_wal_checkpoint db ?NAME?
func test_wal_checkpoint(tls *crt.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:6543:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var zDb uintptr = uintptr(0)
	// var db uintptr at bp, 8

	var rc int32

	if (objc != 3) && (objc != 2) {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+24497 /* "DB ?NAME?" */)
		return 1
	}

	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), bp /* &db */) != 0 {
		return 1
	}
	if objc == 3 {
		zDb = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)))
	}
	rc = sqlite3.Xsqlite3_wal_checkpoint(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), zDb)
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))
	return 0
}

// tclcmd:  sqlite3_wal_checkpoint_v2 db MODE ?NAME?
//
// This command calls the wal_checkpoint_v2() function with the specified
// mode argument (passive, full or restart). If present, the database name
// NAME is passed as the second argument to wal_checkpoint_v2(). If it the
// NAME argument is not present, a NULL pointer is passed instead.
//
// If wal_checkpoint_v2() returns any value other than SQLITE_BUSY or
// SQLITE_OK, then this command returns TCL_ERROR. The Tcl result is set
// to the error message obtained from sqlite3_errmsg().
//
// Otherwise, this command returns a list of three integers. The first integer
// is 1 if SQLITE_BUSY was returned, or 0 otherwise. The following two integers
// are the values returned via the output parameters by wal_checkpoint_v2() -
// the number of frames in the log and the number of frames in the log
// that have been checkpointed.
func test_wal_checkpoint_v2(tls *crt.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:6587:26: */
	bp := tls.Alloc(96)
	defer tls.Free(96)

	var zDb uintptr = uintptr(0)
	// var db uintptr at bp+32, 8

	var rc int32
	// var eMode int32 at bp+40, 4

	*(*int32)(unsafe.Pointer(bp + 88 /* nLog */)) = -555
	*(*int32)(unsafe.Pointer(bp + 92 /* nCkpt */)) = -555
	var pRet uintptr

	*(*[5]uintptr)(unsafe.Pointer(bp + 48 /* aMode */)) = [5]uintptr{ts + 24507 /* "passive" */, ts + 24515 /* "full" */, ts + 24520 /* "restart" */, ts + 24528 /* "truncate" */, uintptr(0)}

	if (objc != 3) && (objc != 4) {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+24537 /* "DB MODE ?NAME?" */)
		return 1
	}

	if objc == 4 {
		zDb = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(3)*8)))
	}
	if (getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), bp+32 /* &db */) != 0) || ((0 != tcl.XTcl_GetIntFromObj(tls, uintptr(0), *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)), bp+40 /* &eMode */)) &&
		(0 != tcl.XTcl_GetIndexFromObjStruct(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)), bp+48 /* &aMode[0] */, int32(unsafe.Sizeof(uintptr(0))), ts+24552 /* "mode" */, 0, bp+40 /* &eMode */))) {
		return 1
	}

	rc = sqlite3.Xsqlite3_wal_checkpoint_v2(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* db */)), zDb, *(*int32)(unsafe.Pointer(bp + 40 /* eMode */)), bp+88 /* &nLog */, bp+92 /* &nCkpt */)
	if (rc != 0) && (rc != 5) {
		var zErrCode uintptr = sqlite3.Xsqlite3ErrName(tls, rc)
		tcl.XTcl_ResetResult(tls, interp)
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, zErrCode, ts+16720 /* " - " */, sqlite3.Xsqlite3_errmsg(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* db */))), 0))
		return 1
	}

	pRet = tcl.XTcl_NewObj(tls)
	tcl.XTcl_ListObjAppendElement(tls, interp, pRet, tcl.XTcl_NewIntObj(tls, func() int32 {
		if rc == 5 {
			return 1
		}
		return 0
	}()))
	tcl.XTcl_ListObjAppendElement(tls, interp, pRet, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 88 /* nLog */))))
	tcl.XTcl_ListObjAppendElement(tls, interp, pRet, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 92 /* nCkpt */))))
	tcl.XTcl_SetObjResult(tls, interp, pRet)

	return 0
}

// tclcmd:  sqlite3_wal_autocheckpoint db VALUE
func test_wal_autocheckpoint(tls *crt.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:6643:26: */
	bp := tls.Alloc(12)
	defer tls.Free(12)

	// var db uintptr at bp, 8

	var rc int32
	// var iVal int32 at bp+8, 4

	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+24557 /* "DB VALUE" */)
		return 1
	}

	if (getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), bp /* &db */) != 0) ||
		(tcl.XTcl_GetIntFromObj(tls, uintptr(0), *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)), bp+8 /* &iVal */) != 0) {
		return 1
	}

	rc = sqlite3.Xsqlite3_wal_autocheckpoint(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), *(*int32)(unsafe.Pointer(bp + 8 /* iVal */)))
	tcl.XTcl_ResetResult(tls, interp)
	if rc != 0 {
		var zErrCode uintptr = sqlite3.Xsqlite3ErrName(tls, rc)
		tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, zErrCode, -1))
		return 1
	}

	return 0
}

// tclcmd:  test_sqlite3_log ?SCRIPT?
type LogCallback = struct {
	FpInterp uintptr
	FpObj    uintptr
}

// tclcmd:  test_sqlite3_log ?SCRIPT?
var logcallback = LogCallback{FpInterp: uintptr(0), FpObj: uintptr(0)} /* test1.c:6683:3 */
func xLogcallback(tls *crt.TLS, unused uintptr, err int32, zMsg uintptr) { /* test1.c:6684:13: */
	var pNew uintptr = tcl.XTcl_DuplicateObj(tls, logcallback.FpObj)
	(*Tcl_Obj)(unsafe.Pointer(pNew)).FrefCount++
	tcl.XTcl_ListObjAppendElement(tls,
		uintptr(0), pNew, tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3ErrName(tls, err), -1))
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pNew, tcl.XTcl_NewStringObj(tls, zMsg, -1))
	tcl.XTcl_EvalObjEx(tls, logcallback.FpInterp, pNew, (0x020000 | 0x040000))
	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = pNew
		if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
}
func test_sqlite3_log(tls *crt.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:6694:26: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	if objc > 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+18615 /* "SCRIPT" */)
		return 1
	}
	if logcallback.FpObj != 0 {
		for ok := true; ok; ok = 0 != 0 {
			var _objPtr uintptr = logcallback.FpObj
			if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
		logcallback.FpObj = uintptr(0)
		logcallback.FpInterp = uintptr(0)
		sqlite3.Xsqlite3_config(tls, 16, crt.VaList(bp, uintptr(0), uintptr(0)))
	}
	if objc > 1 {
		logcallback.FpObj = *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))
		(*Tcl_Obj)(unsafe.Pointer(logcallback.FpObj)).FrefCount++
		logcallback.FpInterp = interp
		sqlite3.Xsqlite3_config(tls, 16, crt.VaList(bp+16, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*crt.TLS, uintptr, int32, uintptr)
		}{xLogcallback})), uintptr(0)))
	}
	return 0
}

//     tcl_objproc COMMANDNAME ARGS...
//
// Run a TCL command using its objProc interface.  Throw an error if
// the command has no objProc interface.
func runAsObjProc(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:6725:26: */
	bp := tls.Alloc(112)
	defer tls.Free(112)

	// var cmdInfo Tcl_CmdInfo at bp+48, 64

	if objc < 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+24566 /* "COMMAND ..." */)
		return 1
	}
	if !(tcl.XTcl_GetCommandInfo(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), bp+48 /* &cmdInfo */) != 0) {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21525, /* "command not foun..." */
			tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), uintptr(0)))
		return 1
	}
	if (*Tcl_CmdInfo)(unsafe.Pointer(bp+48 /* &cmdInfo */)).FobjProc == uintptr(0) {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+24, ts+24578, /* "command has no o..." */
			tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), uintptr(0)))
		return 1
	}
	return (*(*func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer((bp + 48 /* &cmdInfo */ + 8 /* &.objProc */))))(tls, (*Tcl_CmdInfo)(unsafe.Pointer(bp+48 /* &cmdInfo */)).FobjClientData, interp, (objc - 1), (objv + uintptr(1)*8))
}

// WARNING: The following function, printExplainQueryPlan() is an exact
// copy of example code from eqp.in (eqp.html). If this code is modified,
// then the documentation copy needs to be modified as well.
// Argument pStmt is a prepared SQL statement. This function compiles
// an EXPLAIN QUERY PLAN command to report on the prepared statement,
// and prints the report to stdout using printf().
func printExplainQueryPlan(tls *crt.TLS, pStmt uintptr) int32 { /* test1.c:6760:5: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var zSql uintptr     // Input SQL
	var zExplain uintptr // SQL with EXPLAIN QUERY PLAN prepended
	// var pExplain uintptr at bp+40, 8
	// Compiled EXPLAIN QUERY PLAN command
	var rc int32 // Return code from sqlite3_prepare_v2()

	zSql = sqlite3.Xsqlite3_sql(tls, pStmt)
	if zSql == uintptr(0) {
		return 1
	}

	zExplain = sqlite3.Xsqlite3_mprintf(tls, ts+538 /* "EXPLAIN QUERY PL..." */, crt.VaList(bp, zSql))
	if zExplain == uintptr(0) {
		return 7
	}

	rc = sqlite3.Xsqlite3_prepare_v2(tls, sqlite3.Xsqlite3_db_handle(tls, pStmt), zExplain, -1, bp+40 /* &pExplain */, uintptr(0))
	sqlite3.Xsqlite3_free(tls, zExplain)
	if rc != 0 {
		return rc
	}

	for 100 == sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 40 /* pExplain */))) {
		var iSelectid int32 = sqlite3.Xsqlite3_column_int(tls, *(*uintptr)(unsafe.Pointer(bp + 40 /* pExplain */)), 0)
		var iOrder int32 = sqlite3.Xsqlite3_column_int(tls, *(*uintptr)(unsafe.Pointer(bp + 40 /* pExplain */)), 1)
		var iFrom int32 = sqlite3.Xsqlite3_column_int(tls, *(*uintptr)(unsafe.Pointer(bp + 40 /* pExplain */)), 2)
		var zDetail uintptr = sqlite3.Xsqlite3_column_text(tls, *(*uintptr)(unsafe.Pointer(bp + 40 /* pExplain */)), 3)

		crt.Xprintf(tls, ts+24603 /* "%d %d %d %s\n" */, crt.VaList(bp+8, iSelectid, iOrder, iFrom, zDetail))
	}

	return sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 40 /* pExplain */)))
}

func test_print_eqp(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:6788:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var rc int32
	// var pStmt uintptr at bp, 8

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+23218 /* "STMT" */)
		return 1
	}
	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), bp /* &pStmt */) != 0 {
		return 1
	}
	rc = printExplainQueryPlan(tls, *(*uintptr)(unsafe.Pointer(bp /* pStmt */)))
	// This is needed on Windows so that a test case using this
	// function can open a read pipe and get the output of
	// printExplainQueryPlan() immediately.
	crt.Xfflush(tls, crt.Xstdout)
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))
	return 0
}

// sqlite3_test_control VERB ARGS...
func test_test_control(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:6816:26: */
	bp := tls.Alloc(184)
	defer tls.Free(184)

	*(*[4]Verb)(unsafe.Pointer(bp + 64 /* aVerb */)) = [4]Verb{
		{FzName: ts + 24616 /* "SQLITE_TESTCTRL_..." */, Fi: 18},
		{FzName: ts + 24648 /* "SQLITE_TESTCTRL_..." */, Fi: 24},
		{FzName: ts + 24676 /* "SQLITE_TESTCTRL_..." */, Fi: 25},
		{FzName: ts + 24701 /* "SQLITE_TESTCTRL_..." */, Fi: 17},
	}
	// var iVerb int32 at bp+128, 4

	var iFlag int32
	var rc int32

	if objc < 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+24736 /* "VERB ARGS..." */)
		return 1
	}

	rc = tcl.XTcl_GetIndexFromObjStruct(tls,
		interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)), bp+64 /* &aVerb[0] */, int32(unsafe.Sizeof(Verb{})), ts+24749 /* "VERB" */, 0, bp+128 /* &iVerb */)
	if rc != 0 {
		return rc
	}

	iFlag = (*Verb)(unsafe.Pointer(bp + 64 /* &aVerb */ + uintptr(*(*int32)(unsafe.Pointer(bp + 128 /* iVerb */)))*16)).Fi
	switch iFlag {
	case 17:
		{
			*(*uintptr)(unsafe.Pointer(bp + 136 /* db */)) = uintptr(0)
			if objc != 3 {
				tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+2452 /* "DB" */)
				return 1
			}
			if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8))), bp+136 /* &db */) != 0 {
				return 1
			}
			sqlite3.Xsqlite3_test_control(tls, 17, crt.VaList(bp, *(*uintptr)(unsafe.Pointer(bp + 136 /* db */))))
			break
		}
	case 18:
		{
			// var val int32 at bp+144, 4

			if objc != 3 {
				tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+24754 /* "ONOFF" */)
				return 1
			}
			if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)), bp+144 /* &val */) != 0 {
				return 1
			}
			sqlite3.Xsqlite3_test_control(tls, iFlag, crt.VaList(bp+8, *(*int32)(unsafe.Pointer(bp + 144 /* val */))))
			break
		}

	case 24:
		{
			// var val int32 at bp+160, 4

			// var db uintptr at bp+152, 8

			if objc != 4 {
				tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+24760 /* "DB LIMIT" */)
				return 1
			}
			if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8))), bp+152 /* &db */) != 0 {
				return 1
			}
			if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(3)*8)), bp+160 /* &val */) != 0 {
				return 1
			}
			sqlite3.Xsqlite3_test_control(tls, 24, crt.VaList(bp+16, *(*uintptr)(unsafe.Pointer(bp + 152 /* db */)), *(*int32)(unsafe.Pointer(bp + 160 /* val */))))
			break
		}

	case 25:
		{
			// var onOff int32 at bp+176, 4

			// var tnum int32 at bp+180, 4

			var zDbName uintptr
			// var db uintptr at bp+168, 8

			if objc != 6 {
				tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+24769 /* "DB dbName onOff ..." */)
				return 1
			}
			if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8))), bp+168 /* &db */) != 0 {
				return 1
			}
			zDbName = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(3)*8)))
			if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(4)*8)), bp+176 /* &onOff */) != 0 {
				return 1
			}
			if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(5)*8)), bp+180 /* &tnum */) != 0 {
				return 1
			}
			sqlite3.Xsqlite3_test_control(tls, 25, crt.VaList(bp+32, *(*uintptr)(unsafe.Pointer(bp + 168 /* db */)), zDbName, *(*int32)(unsafe.Pointer(bp + 176 /* onOff */)), *(*int32)(unsafe.Pointer(bp + 180 /* tnum */))))
			break
		}
	}

	tcl.XTcl_ResetResult(tls, interp)
	return 0
}

type Verb = struct {
	FzName uintptr
	Fi     int32
	_      [4]byte
}

// Some versions of <linux/posix_types.h> define this macros.
// It's easier to assume 8-bit bytes than to get CHAR_BIT.

// fd_set for select and pselect.
type fd_set1 = struct{ Ffds_bits [16]int64 } /* select.h:70:5 */

// Value to indicate that there is no limit.

// We can represent all limits.

// Type for resource quantity measurement.
type rlim_t = uint64   /* resource.h:133:20 */
type rlim64_t = uint64 /* resource.h:136:20 */

type rlimit = struct {
	Frlim_cur rlim_t
	Frlim_max rlim_t
}

// Define struct rusage.
//   Copyright (C) 1994-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//   Copyright (C) 2002-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Structure which says how much of each resource has been used.

// The purpose of all the unions is to have the kernel-compatible layout
//   while keeping the API type as 'long int', and among machines where
//   __syscall_slong_t is not 'long int', this only does the right thing
//   for little-endian ones, like x32.
type rusage = struct {
	Fru_utime struct {
		Ftv_sec  int64
		Ftv_usec int64
	}
	Fru_stime struct {
		Ftv_sec  int64
		Ftv_usec int64
	}
	F__32  struct{ Fru_maxrss int64 }
	F__40  struct{ Fru_ixrss int64 }
	F__48  struct{ Fru_idrss int64 }
	F__56  struct{ Fru_isrss int64 }
	F__64  struct{ Fru_minflt int64 }
	F__72  struct{ Fru_majflt int64 }
	F__80  struct{ Fru_nswap int64 }
	F__88  struct{ Fru_inblock int64 }
	F__96  struct{ Fru_oublock int64 }
	F__104 struct{ Fru_msgsnd int64 }
	F__112 struct{ Fru_msgrcv int64 }
	F__120 struct{ Fru_nsignals int64 }
	F__128 struct{ Fru_nvcsw int64 }
	F__136 struct{ Fru_nivcsw int64 }
}

func test_getrusage(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:6906:26: */
	bp := tls.Alloc(1216)
	defer tls.Free(1216)

	// var buf [1024]int8 at bp+192, 1024

	// var r rusage at bp+48, 144

	crt.Xmemset(tls, bp+48 /* &r */, 0, uint64(unsafe.Sizeof(rusage{})))
	crt.Xgetrusage(tls, 0, bp+48 /* &r */)

	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([1024]int8{})), bp+192, /* &buf[0] */
		ts+24790, /* "ru_utime=%d.%06d..." */
		crt.VaList(bp, int32((*rusage)(unsafe.Pointer(bp+48 /* &r */)).Fru_utime.Ftv_sec), int32((*rusage)(unsafe.Pointer(bp+48 /* &r */)).Fru_utime.Ftv_usec),
			int32((*rusage)(unsafe.Pointer(bp+48 /* &r */)).Fru_stime.Ftv_sec), int32((*rusage)(unsafe.Pointer(bp+48 /* &r */)).Fru_stime.Ftv_usec),
			int32(*(*int64)(unsafe.Pointer(bp + 48 /* &r */ + 64 /* &.ru_minflt */))), int32(*(*int64)(unsafe.Pointer(bp + 48 /* &r */ + 72 /* &.ru_majflt */)))))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, bp+192 /* &buf[0] */, -1))
	return 0
}

//      optimization_control DB OPT BOOLEAN
//
// Enable or disable query optimizations using the sqlite3_test_control()
// interface.  Disable if BOOLEAN is false and enable if BOOLEAN is true.
// OPT is the name of the optimization to be disabled.
func optimization_control(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:7186:26: */
	bp := tls.Alloc(68)
	defer tls.Free(68)

	var i int32
	// var db uintptr at bp+56, 8

	var zOpt uintptr
	// var onoff int32 at bp+64, 4

	var mask int32 = 0

	if objc != 4 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+24850 /* "DB OPT BOOLEAN" */)
		return 1
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), bp+56 /* &db */) != 0 {
		return 1
	}
	if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(3)*8)), bp+64 /* &onoff */) != 0 {
		return 1
	}
	zOpt = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)))
	for i = 0; uint64(i) < (uint64(unsafe.Sizeof(aOpt)) / uint64(unsafe.Sizeof(struct {
		FzOptName uintptr
		Fmask     int32
		_         [4]byte
	}{}))); i++ {
		if crt.Xstrcmp(tls, zOpt, aOpt[i].FzOptName) == 0 {
			mask = aOpt[i].Fmask
			break
		}
	}
	if *(*int32)(unsafe.Pointer(bp + 64 /* onoff */)) != 0 {
		mask = ^mask
	}
	if uint64(i) >= (uint64(unsafe.Sizeof(aOpt)) / uint64(unsafe.Sizeof(struct {
		FzOptName uintptr
		Fmask     int32
		_         [4]byte
	}{}))) {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+24865, /* "unknown optimiza..." */
			uintptr(0)))
		for i = 0; uint64(i) < (uint64(unsafe.Sizeof(aOpt)) / uint64(unsafe.Sizeof(struct {
			FzOptName uintptr
			Fmask     int32
			_         [4]byte
		}{}))); i++ {
			tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+16, ts+4435 /* " " */, aOpt[i].FzOptName, uintptr(0)))
		}
		return 1
	}
	sqlite3.Xsqlite3_test_control(tls, 15, crt.VaList(bp+40, *(*uintptr)(unsafe.Pointer(bp + 56 /* db */)), mask))
	return 0
}

var aOpt = [13]struct {
	FzOptName uintptr
	Fmask     int32
	_         [4]byte
}{
	{FzOptName: ts + 24906 /* "all" */, Fmask: 0xffff},
	{FzOptName: ts + 24910 /* "none" */, Fmask: 0},
	{FzOptName: ts + 24915 /* "query-flattener" */, Fmask: 0x0001},
	{FzOptName: ts + 24931 /* "groupby-order" */, Fmask: 0x0004},
	{FzOptName: ts + 24945 /* "factor-constants" */, Fmask: 0x0008},
	{FzOptName: ts + 24962 /* "distinct-opt" */, Fmask: 0x0010},
	{FzOptName: ts + 24975 /* "cover-idx-scan" */, Fmask: 0x0020},
	{FzOptName: ts + 24990 /* "order-by-idx-joi..." */, Fmask: 0x0040},
	{FzOptName: ts + 25008 /* "transitive" */, Fmask: 0x0080},
	{FzOptName: ts + 25019 /* "omit-noop-join" */, Fmask: 0x0100},
	{FzOptName: ts + 25034 /* "stat4" */, Fmask: 0x0800},
	{FzOptName: ts + 25040 /* "skip-scan" */, Fmask: 0x4000},
	{FzOptName: ts + 25050 /* "push-down" */, Fmask: 0x1000},
} /* test1.c:7200:5 */

//     load_static_extension DB NAME ...
//
// Load one or more statically linked extensions.
func tclLoadStaticExtensionCmd(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:7247:26: */
	bp := tls.Alloc(80)
	defer tls.Free(80)

	// var db uintptr at bp+64, 8

	var zName uintptr
	var i int32
	var j int32
	var rc int32
	*(*uintptr)(unsafe.Pointer(bp + 72 /* zErrMsg */)) = uintptr(0)
	if objc < 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+25060 /* "DB NAME ..." */)
		return 1
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), bp+64 /* &db */) != 0 {
		return 1
	}
	for j = 2; j < objc; j++ {
		zName = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(j)*8)))
		for i = 0; i < (int32(uint64(unsafe.Sizeof(aExtension)) / uint64(unsafe.Sizeof(struct {
			FzExtName uintptr
			FpInit    uintptr
		}{})))); i++ {
			if crt.Xstrcmp(tls, zName, aExtension[i].FzExtName) == 0 {
				break
			}
		}
		if i >= (int32(uint64(unsafe.Sizeof(aExtension)) / uint64(unsafe.Sizeof(struct {
			FzExtName uintptr
			FpInit    uintptr
		}{})))) {
			tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+25072 /* "no such extensio..." */, zName, uintptr(0)))
			return 1
		}
		if aExtension[i].FpInit != 0 {
			rc = (*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((uintptr(unsafe.Pointer(&aExtension)) + uintptr(i)*16 + 8 /* &.pInit */))))(tls, *(*uintptr)(unsafe.Pointer(bp + 64 /* db */)), bp+72 /* &zErrMsg */, uintptr(0))
		} else {
			rc = 0
		}
		if (rc != 0) || (*(*uintptr)(unsafe.Pointer(bp + 72 /* zErrMsg */)) != 0) {
			tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+24, ts+25092 /* "initialization o..." */, zName, ts+25111 /* " failed: " */, *(*uintptr)(unsafe.Pointer(bp + 72 /* zErrMsg */)),
				uintptr(0)))
			sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(bp + 72 /* zErrMsg */)))
			return 1
		}
	}
	return 0
}

var aExtension = [19]struct {
	FzExtName uintptr
	FpInit    uintptr
}{
	{FzExtName: ts + 25121 /* "amatch" */, FpInit: 0},
	{FzExtName: ts + 3452 /* "carray" */, FpInit: 0},
	{FzExtName: ts + 25128 /* "closure" */, FpInit: 0},
	{FzExtName: ts + 4424 /* "csv" */, FpInit: 0},
	{FzExtName: ts + 4437 /* "eval" */, FpInit: 0},
	{FzExtName: ts + 4515 /* "explain" */, FpInit: 0},
	{FzExtName: ts + 25136 /* "fileio" */, FpInit: 0},
	{FzExtName: ts + 5119 /* "fuzzer" */, FpInit: 0},
	{FzExtName: ts + 5223 /* "ieee754" */, FpInit: 0},
	{FzExtName: ts + 25143 /* "nextchar" */, FpInit: 0},
	{FzExtName: ts + 5829 /* "percentile" */, FpInit: 0},
	{FzExtName: ts + 5904 /* "prefixes" */, FpInit: 0},
	{FzExtName: ts + 6216 /* "regexp" */, FpInit: 0},
	{FzExtName: ts + 6284 /* "remember" */, FpInit: 0},
	{FzExtName: ts + 25152 /* "series" */, FpInit: 0},
	{FzExtName: ts + 25159 /* "spellfix" */, FpInit: 0},
	{FzExtName: ts + 25168 /* "totype" */, FpInit: 0},
	{FzExtName: ts + 8982 /* "unionvtab" */, FpInit: 0},
	{FzExtName: ts + 9682 /* "wholenumber" */, FpInit: 0},
} /* test1.c:7280:5 */

//     sorter_test_fakeheap BOOL
//
func sorter_test_fakeheap(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:7343:26: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	// var bArg int32 at bp, 4

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+25175 /* "BOOL" */)
		return 1
	}

	if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)), bp /* &bArg */) != 0 {
		return 1
	}

	if *(*int32)(unsafe.Pointer(bp /* bArg */)) != 0 {
		if sqlite3.Xsqlite3Config.FpHeap == uintptr(0) {
			sqlite3.Xsqlite3Config.FpHeap = crt.UintptrFromInt64(int64(-1))
		}
	} else {
		if sqlite3.Xsqlite3Config.FpHeap == (crt.UintptrFromInt64(int64(-1))) {
			sqlite3.Xsqlite3Config.FpHeap = uintptr(0)
		}
	}

	tcl.XTcl_ResetResult(tls, interp)
	return 0
}

//     sorter_test_sort4_helper DB SQL1 NSTEP SQL2
//
// Compile SQL statement $SQL1 and step it $NSTEP times. For each row,
// check that the leftmost and rightmost columns returned are both integers,
// and that both contain the same value.
//
// Then execute statement $SQL2. Check that the statement returns the same
// set of integers in the same order as in the previous step (using $SQL1).
func sorter_test_sort4_helper(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:7383:26: */
	bp := tls.Alloc(80)
	defer tls.Free(80)

	var zSql1 uintptr
	var zSql2 uintptr
	// var nStep int32 at bp+64, 4

	var iStep int32
	var iCksum1 uint32
	var iCksum2 uint32
	var rc int32
	var iB int32
	// var db uintptr at bp+56, 8

	// var pStmt uintptr at bp+72, 8

	var a int32
	var a1 int32
	iCksum1 = uint32(0)
	iCksum2 = uint32(0)

	if !(objc != 5) {
		goto __1
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+25180 /* "DB SQL1 NSTEP SQ..." */)
	return 1
__1:
	;

	if !(getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), bp+56 /* &db */) != 0) {
		goto __2
	}
	return 1
__2:
	;
	zSql1 = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)))
	if !(tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(3)*8)), bp+64 /* &nStep */) != 0) {
		goto __3
	}
	return 1
__3:
	;
	zSql2 = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(4)*8)))

	rc = sqlite3.Xsqlite3_prepare_v2(tls, *(*uintptr)(unsafe.Pointer(bp + 56 /* db */)), zSql1, -1, bp+72 /* &pStmt */, uintptr(0))
	if !(rc != 0) {
		goto __4
	}
	goto sql_error
__4:
	;

	iB = (sqlite3.Xsqlite3_column_count(tls, *(*uintptr)(unsafe.Pointer(bp + 72 /* pStmt */))) - 1)
	iStep = 0
__5:
	if !((iStep < *(*int32)(unsafe.Pointer(bp + 64 /* nStep */))) && (100 == sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 72 /* pStmt */))))) {
		goto __7
	}
	a = sqlite3.Xsqlite3_column_int(tls, *(*uintptr)(unsafe.Pointer(bp + 72 /* pStmt */)), 0)
	if !(a != sqlite3.Xsqlite3_column_int(tls, *(*uintptr)(unsafe.Pointer(bp + 72 /* pStmt */)), iB)) {
		goto __8
	}
	tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+25199 /* "data error: (a!=..." */, 0))
	return 1
__8:
	;

	iCksum1 = iCksum1 + ((iCksum1 << 3) + uint32(a))
	goto __6
__6:
	iStep++
	goto __5
	goto __7
__7:
	;
	rc = sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 72 /* pStmt */)))
	if !(rc != 0) {
		goto __9
	}
	goto sql_error
__9:
	;

	rc = sqlite3.Xsqlite3_prepare_v2(tls, *(*uintptr)(unsafe.Pointer(bp + 56 /* db */)), zSql2, -1, bp+72 /* &pStmt */, uintptr(0))
	if !(rc != 0) {
		goto __10
	}
	goto sql_error
__10:
	;
	iStep = 0
__11:
	if !(100 == sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 72 /* pStmt */)))) {
		goto __13
	}
	a1 = sqlite3.Xsqlite3_column_int(tls, *(*uintptr)(unsafe.Pointer(bp + 72 /* pStmt */)), 0)
	iCksum2 = iCksum2 + ((iCksum2 << 3) + uint32(a1))
	goto __12
__12:
	iStep++
	goto __11
	goto __13
__13:
	;
	rc = sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 72 /* pStmt */)))
	if !(rc != 0) {
		goto __14
	}
	goto sql_error
__14:
	;

	if !(iCksum1 != iCksum2) {
		goto __15
	}
	tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+16, ts+25218 /* "checksum mismatc..." */, 0))
	return 1
__15:
	;

	return 0
sql_error:
	tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+32, ts+25236 /* "sql error: " */, sqlite3.Xsqlite3_errmsg(tls, *(*uintptr)(unsafe.Pointer(bp + 56 /* db */))), 0))
	return 1
}

// tclcmd: bad_behavior TYPE
//
// Do some things that should trigger a valgrind or -fsanitize=undefined
// warning.  This is used to verify that errors and warnings output by those
// tools are detected by the test scripts.
//
//       TYPE       BEHAVIOR
//       1          Overflow a signed integer
//       2          Jump based on an uninitialized variable
//       3          Read after free
//       4          Panic
func test_bad_behavior(tls *crt.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:7586:26: */
	bp := tls.Alloc(44)
	defer tls.Free(44)

	// var iType int32 at bp, 4

	var xyz int32
	var i int32 = *(*int32)(unsafe.Pointer(clientData))
	var j int32
	// var w [10]int32 at bp+4, 40

	var a uintptr
	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+25248 /* "TYPE" */)
		return 1
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)), bp /* &iType */) != 0 {
		return 1
	}
	switch *(*int32)(unsafe.Pointer(bp /* iType */)) {
	case 1:
		{
			xyz = (0x7fffff00 - i)
			xyz = xyz + (0x100)
			tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, xyz))
			break
		}
	case 2:
		{
			*(*int32)(unsafe.Pointer(bp + 4 /* &w[0] */ + uintptr(1)*4)) = 5
			if *(*int32)(unsafe.Pointer(bp + 4 /* &w[0] */ + uintptr(i)*4)) > 0 {
				*(*int32)(unsafe.Pointer(bp + 4 /* &w[0] */ + uintptr(1)*4))++
			}
			tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 4 /* &w[0] */ + uintptr(1)*4))))
			break
		}
	case 3:
		{
			a = crt.Xmalloc(tls, (uint64(unsafe.Sizeof(int32(0))) * uint64(10)))
			for j = 0; j < 10; j++ {
				*(*int32)(unsafe.Pointer(a + uintptr(j)*4)) = j
			}
			crt.Xfree(tls, a)
			tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(a + uintptr(i)*4))))
			break
		}
	case 4:
		{
			tcl.XTcl_Panic(tls, ts+25253 /* "Deliberate panic" */, 0)
			break
		}
	}
	return 0
}

// tclcmd:   register_dbstat_vtab DB
//
// Cause the dbstat virtual table to be available on the connection DB
func test_register_dbstat_vtab(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:7636:26: */
	bp := tls.Alloc(64)
	defer tls.Free(64)

	var zDb uintptr
	// var cmdInfo Tcl_CmdInfo at bp, 64

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+2452 /* "DB" */)
		return 1
	}

	zDb = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)))
	if tcl.XTcl_GetCommandInfo(tls, interp, zDb, bp /* &cmdInfo */) != 0 {
		var db uintptr = (*struct{ Fdb uintptr })(unsafe.Pointer((*Tcl_CmdInfo)(unsafe.Pointer(bp /* &cmdInfo */)).FobjClientData)).Fdb
		sqlite3.Xsqlite3DbstatRegister(tls, db)
	}
	return 0
}

// tclcmd:   sqlite3_db_config DB SETTING VALUE
//
// Invoke sqlite3_db_config() for one of the setting values.
func test_sqlite3_db_config(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:7670:26: */
	bp := tls.Alloc(28)
	defer tls.Free(28)

	var i int32
	*(*int32)(unsafe.Pointer(bp + 24 /* v */)) = 0
	var zSetting uintptr
	// var db uintptr at bp+16, 8

	if (objc != 4) && (objc != 3) {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+25270 /* "DB SETTING [VALU..." */)
		return 1
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), bp+16 /* &db */) != 0 {
		return 1
	}
	zSetting = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)))
	if sqlite3.Xsqlite3_strglob(tls, ts+25289 /* "SQLITE_*" */, zSetting) == 0 {
		zSetting += uintptr(7)
	}
	if sqlite3.Xsqlite3_strglob(tls, ts+25298 /* "DBCONFIG_*" */, zSetting) == 0 {
		zSetting += uintptr(9)
	}
	if sqlite3.Xsqlite3_strglob(tls, ts+25309 /* "ENABLE_*" */, zSetting) == 0 {
		zSetting += uintptr(7)
	}
	for i = 0; i < (int32(uint64(unsafe.Sizeof(aSetting)) / uint64(unsafe.Sizeof(struct {
		FzName uintptr
		FeVal  int32
		_      [4]byte
	}{})))); i++ {
		if crt.Xstrcmp(tls, zSetting, aSetting[i].FzName) == 0 {
			break
		}
	}
	if i >= (int32(uint64(unsafe.Sizeof(aSetting)) / uint64(unsafe.Sizeof(struct {
		FzName uintptr
		FeVal  int32
		_      [4]byte
	}{})))) {
		tcl.XTcl_SetObjResult(tls, interp,
			tcl.XTcl_NewStringObj(tls, ts+25318 /* "unknown sqlite3_..." */, -1))
		return 1
	}
	if objc == 4 {
		if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(3)*8)), bp+24 /* &v */) != 0 {
			return 1
		}
	} else {
		*(*int32)(unsafe.Pointer(bp + 24 /* v */)) = -1
	}
	sqlite3.Xsqlite3_db_config(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* db */)), aSetting[i].FeVal, crt.VaList(bp, *(*int32)(unsafe.Pointer(bp + 24 /* v */)), bp+24 /* &v */))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 24 /* v */))))
	return 0
}

var aSetting = [14]struct {
	FzName uintptr
	FeVal  int32
	_      [4]byte
}{
	{FzName: ts + 25352 /* "FKEY" */, FeVal: 1002},
	{FzName: ts + 25357 /* "TRIGGER" */, FeVal: 1003},
	{FzName: ts + 25365 /* "FTS3_TOKENIZER" */, FeVal: 1004},
	{FzName: ts + 25380 /* "LOAD_EXTENSION" */, FeVal: 1005},
	{FzName: ts + 25395 /* "NO_CKPT_ON_CLOSE" */, FeVal: 1006},
	{FzName: ts + 25412 /* "QPSG" */, FeVal: 1007},
	{FzName: ts + 25417 /* "TRIGGER_EQP" */, FeVal: 1008},
	{FzName: ts + 25429 /* "RESET_DB" */, FeVal: 1009},
	{FzName: ts + 25438 /* "DEFENSIVE" */, FeVal: 1010},
	{FzName: ts + 25448 /* "WRITABLE_SCHEMA" */, FeVal: 1011},
	{FzName: ts + 25464 /* "LEGACY_ALTER_TAB..." */, FeVal: 1012},
	{FzName: ts + 25483 /* "DQS_DML" */, FeVal: 1013},
	{FzName: ts + 25491 /* "DQS_DDL" */, FeVal: 1014},
	{FzName: ts + 25499 /* "LEGACY_FILE_FORM..." */, FeVal: 1016},
} /* test1.c:7679:5 */

// Change the name of the main database schema from "main" to "icecube".
func test_dbconfig_maindbname_icecube(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:7730:26: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var rc int32
	// var db uintptr at bp+8, 8

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+2452 /* "DB" */)
		return 1
	} else {
		if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), bp+8 /* &db */) != 0 {
			return 1
		}
		rc = sqlite3.Xsqlite3_db_config(tls, *(*uintptr)(unsafe.Pointer(bp + 8 /* db */)), 1000, crt.VaList(bp, ts+25518 /* "icecube" */))
		tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, rc))
		return 0
	}
	return int32(0)
}

// Usage: sqlite3_mmap_warm DB DBNAME
func test_mmap_warm(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:7753:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	if (objc != 2) && (objc != 3) {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+25526 /* "DB ?DBNAME?" */)
		return 1
	} else {
		var rc int32
		// var db uintptr at bp, 8

		var zDb uintptr = uintptr(0)
		if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), bp /* &db */) != 0 {
			return 1
		}
		if objc == 3 {
			zDb = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)))
		}
		rc = sqlite3_mmap_warm(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), zDb)
		tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3ErrName(tls, rc), -1))
		return 0
	}
	return int32(0)
}

// Usage:  decode_hexdb TEXT
//
// Example:   db deserialize [decode_hexdb $output_of_dbtotxt]
//
// This routine returns a byte-array for an SQLite database file that
// is constructed from a text input which is the output of the "dbtotxt"
// utility.
func test_decode_hexdb(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:7788:26: */
	bp := tls.Alloc(296)
	defer tls.Free(296)

	var zIn uintptr = uintptr(0)
	var a uintptr = uintptr(0)
	*(*int32)(unsafe.Pointer(bp + 216 /* n */)) = 0
	var lineno int32 = 0
	var i int32
	var iNext int32
	var iOffset int32 = 0
	// var j int32 at bp+224, 4

	// var k int32 at bp+228, 4

	var rc int32
	// var x [16]uint32 at bp+232, 64

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+25538 /* "HEXDB" */)
		return 1
	}
	zIn = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)))
	for i = 0; *(*int8)(unsafe.Pointer(zIn + uintptr(i))) != 0; i = iNext {
		lineno++
		for iNext = i; (*(*int8)(unsafe.Pointer(zIn + uintptr(iNext))) != 0) && (int32(*(*int8)(unsafe.Pointer(zIn + uintptr(iNext)))) != '\n'); iNext++ {
		}
		if int32(*(*int8)(unsafe.Pointer(zIn + uintptr(iNext)))) == '\n' {
			iNext++
		}
		for (int32(*(*int8)(unsafe.Pointer(zIn + uintptr(i)))) == ' ') || (int32(*(*int8)(unsafe.Pointer(zIn + uintptr(i)))) == '\t') {
			i++
		}
		if a == uintptr(0) {
			// var pgsz int32 at bp+220, 4

			rc = crt.X__isoc99_sscanf(tls, (zIn + uintptr(i)), ts+25544 /* "| size %d pagesi..." */, crt.VaList(bp, bp+216 /* &n */, bp+220 /* &pgsz */))
			if rc != 2 {
				continue
			}
			if ((*(*int32)(unsafe.Pointer(bp + 220 /* pgsz */)) < 512) || (*(*int32)(unsafe.Pointer(bp + 220 /* pgsz */)) > 65536)) || ((*(*int32)(unsafe.Pointer(bp + 220 /* pgsz */)) & (*(*int32)(unsafe.Pointer(bp + 220 /* pgsz */)) - 1)) != 0) {
				tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+16, ts+25566 /* "bad 'pagesize' f..." */, uintptr(0)))
				return 1
			}
			*(*int32)(unsafe.Pointer(bp + 216 /* n */)) = (((*(*int32)(unsafe.Pointer(bp + 216 /* n */)) + *(*int32)(unsafe.Pointer(bp + 220 /* pgsz */))) - 1) & ^(*(*int32)(unsafe.Pointer(bp + 220 /* pgsz */)) - 1)) // Round n up to the next multiple of pgsz
			if *(*int32)(unsafe.Pointer(bp + 216 /* n */)) < 512 {
				tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+32, ts+25587 /* "bad 'size' field" */, uintptr(0)))
				return 1
			}
			a = crt.Xmalloc(tls, uint64(*(*int32)(unsafe.Pointer(bp + 216 /* n */))))
			if a == uintptr(0) {
				tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+48, ts+2471 /* "out of memory" */, uintptr(0)))
				return 1
			}
			crt.Xmemset(tls, a, 0, uint64(*(*int32)(unsafe.Pointer(bp + 216 /* n */))))
			continue
		}
		rc = crt.X__isoc99_sscanf(tls, (zIn + uintptr(i)), ts+25604 /* "| page %d offset..." */, crt.VaList(bp+64, bp+224 /* &j */, bp+228 /* &k */))
		if rc == 2 {
			iOffset = *(*int32)(unsafe.Pointer(bp + 228 /* k */))
			continue
		}
		rc = crt.X__isoc99_sscanf(tls, (zIn + uintptr(i)), ts+25624, /* "| %d: %x %x %x %..." */
			crt.VaList(bp+80, bp+224 /* &j */, (bp+232 /* &x */ +uintptr(0)*4), (bp+232 /* &x */ +uintptr(1)*4), (bp+232 /* &x */ +uintptr(2)*4), (bp+232 /* &x */ +uintptr(3)*4), (bp+232 /* &x */ +uintptr(4)*4), (bp+232 /* &x */ +uintptr(5)*4), (bp+232 /* &x */ +uintptr(6)*4), (bp+232 /* &x */ +uintptr(7)*4),
				(bp+232 /* &x */ +uintptr(8)*4), (bp+232 /* &x */ +uintptr(9)*4), (bp+232 /* &x */ +uintptr(10)*4), (bp+232 /* &x */ +uintptr(11)*4), (bp+232 /* &x */ +uintptr(12)*4), (bp+232 /* &x */ +uintptr(13)*4), (bp+232 /* &x */ +uintptr(14)*4), (bp+232 /* &x */ +uintptr(15)*4)))
		if rc == 17 {
			*(*int32)(unsafe.Pointer(bp + 228 /* k */)) = (iOffset + *(*int32)(unsafe.Pointer(bp + 224 /* j */)))
			if (*(*int32)(unsafe.Pointer(bp + 228 /* k */)) + 16) <= *(*int32)(unsafe.Pointer(bp + 216 /* n */)) {
				var ii int32
				for ii = 0; ii < 16; ii++ {
					*(*uint8)(unsafe.Pointer(a + uintptr((*(*int32)(unsafe.Pointer(bp + 228 /* k */)) + ii)))) = (uint8(*(*uint32)(unsafe.Pointer(bp + 232 /* &x[0] */ + uintptr(ii)*4)) & uint32(0xff)))
				}
			}
			continue
		}
	}
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewByteArrayObj(tls, a, *(*int32)(unsafe.Pointer(bp + 216 /* n */))))
	crt.Xfree(tls, a)
	return 0
}

// Register commands with the TCL interpreter.
func Sqlitetest1_Init(tls *crt.TLS, interp uintptr) int32 { /* test1.c:7860:5: */
	var i int32

	for i = 0; uint64(i) < (uint64(unsafe.Sizeof(aCmd)) / uint64(unsafe.Sizeof(struct {
		FzName uintptr
		FxProc uintptr
	}{}))); i++ {
		tcl.XTcl_CreateCommand(tls, interp, aCmd[i].FzName, aCmd[i].FxProc, uintptr(0), uintptr(0))
	}
	for i = 0; uint64(i) < (uint64(unsafe.Sizeof(aObjCmd1)) / uint64(unsafe.Sizeof(struct {
		FzName      uintptr
		FxProc      uintptr
		FclientData uintptr
	}{}))); i++ {
		tcl.XTcl_CreateObjCommand(tls, interp, aObjCmd1[i].FzName,
			aObjCmd1[i].FxProc, aObjCmd1[i].FclientData, uintptr(0))
	}
	tcl.XTcl_LinkVar(tls, interp, ts+25678, /* "sqlite_search_co..." */
		uintptr(unsafe.Pointer(&sqlite3.Xsqlite3_search_count)), 1)
	tcl.XTcl_LinkVar(tls, interp, ts+25698, /* "sqlite_found_cou..." */
		uintptr(unsafe.Pointer(&sqlite3.Xsqlite3_found_count)), 1)
	tcl.XTcl_LinkVar(tls, interp, ts+25717, /* "sqlite_sort_coun..." */
		uintptr(unsafe.Pointer(&sqlite3.Xsqlite3_sort_count)), 1)
	tcl.XTcl_LinkVar(tls, interp, ts+25735, /* "sqlite3_max_blob..." */
		uintptr(unsafe.Pointer(&sqlite3.Xsqlite3_max_blobsize)), 1)
	tcl.XTcl_LinkVar(tls, interp, ts+25756, /* "sqlite_like_coun..." */
		uintptr(unsafe.Pointer(&sqlite3.Xsqlite3_like_count)), 1)
	tcl.XTcl_LinkVar(tls, interp, ts+25774, /* "sqlite_interrupt..." */
		uintptr(unsafe.Pointer(&sqlite3.Xsqlite3_interrupt_count)), 1)
	tcl.XTcl_LinkVar(tls, interp, ts+25797, /* "sqlite_open_file..." */
		uintptr(unsafe.Pointer(&sqlite3.Xsqlite3_open_file_count)), 1)
	tcl.XTcl_LinkVar(tls, interp, ts+25820, /* "sqlite_current_t..." */
		uintptr(unsafe.Pointer(&sqlite3.Xsqlite3_current_time)), 1)
	tcl.XTcl_LinkVar(tls, interp, ts+25840, /* "sqlite3_xferopt_..." */
		uintptr(unsafe.Pointer(&sqlite3.Xsqlite3_xferopt_count)), 1)
	tcl.XTcl_LinkVar(tls, interp, ts+25862, /* "sqlite3_pager_re..." */
		uintptr(unsafe.Pointer(&sqlite3.Xsqlite3_pager_readdb_count)), 1)
	tcl.XTcl_LinkVar(tls, interp, ts+25889, /* "sqlite3_pager_wr..." */
		uintptr(unsafe.Pointer(&sqlite3.Xsqlite3_pager_writedb_count)), 1)
	tcl.XTcl_LinkVar(tls, interp, ts+25917, /* "sqlite3_pager_wr..." */
		uintptr(unsafe.Pointer(&sqlite3.Xsqlite3_pager_writej_count)), 1)
	{
		tcl.XTcl_LinkVar(tls, interp, ts+25944, /* "sqlite_query_pla..." */
			uintptr(unsafe.Pointer(&query_plan)), (4 | 0x80))
	}
	tcl.XTcl_LinkVar(tls, interp, ts+25962, /* "sqlite_opentemp_..." */
		uintptr(unsafe.Pointer(&sqlite3.Xsqlite3_opentemp_count)), 1)
	tcl.XTcl_LinkVar(tls, interp, ts+25984, /* "sqlite_static_bi..." */
		uintptr(unsafe.Pointer(&sqlite_static_bind_value)), 4)
	tcl.XTcl_LinkVar(tls, interp, ts+26009, /* "sqlite_static_bi..." */
		uintptr(unsafe.Pointer(&sqlite_static_bind_nbyte)), 1)
	tcl.XTcl_LinkVar(tls, interp, ts+26034, /* "sqlite_temp_dire..." */
		uintptr(unsafe.Pointer(&sqlite3.Xsqlite3_temp_directory)), 4)
	tcl.XTcl_LinkVar(tls, interp, ts+26056, /* "sqlite_data_dire..." */
		uintptr(unsafe.Pointer(&sqlite3.Xsqlite3_data_directory)), 4)
	tcl.XTcl_LinkVar(tls, interp, ts+26078, /* "bitmask_size" */
		uintptr(unsafe.Pointer(&bitmask_size)), (1 | 0x80))
	tcl.XTcl_LinkVar(tls, interp, ts+26091, /* "longdouble_size" */
		uintptr(unsafe.Pointer(&longdouble_size)), (1 | 0x80))
	tcl.XTcl_LinkVar(tls, interp, ts+26107, /* "sqlite_sync_coun..." */
		uintptr(unsafe.Pointer(&sqlite3.Xsqlite3_sync_count)), 1)
	tcl.XTcl_LinkVar(tls, interp, ts+26125, /* "sqlite_fullsync_..." */
		uintptr(unsafe.Pointer(&sqlite3.Xsqlite3_fullsync_count)), 1)
	return 0
}

var iZero int32 = 0 /* test1.c:7873:14 */
var aCmd = [40]struct {
	FzName uintptr
	FxProc uintptr
}{
	{FzName: ts + 26147 /* "db_enter" */, FxProc: 0},
	{FzName: ts + 26156 /* "db_leave" */, FxProc: 0},
	{FzName: ts + 26165 /* "sqlite3_mprintf_..." */, FxProc: 0},
	{FzName: ts + 26185 /* "sqlite3_mprintf_..." */, FxProc: 0},
	{FzName: ts + 26207 /* "sqlite3_mprintf_..." */, FxProc: 0},
	{FzName: ts + 26228 /* "sqlite3_mprintf_..." */, FxProc: 0},
	{FzName: ts + 26248 /* "sqlite3_snprintf..." */, FxProc: 0},
	{FzName: ts + 26269 /* "sqlite3_mprintf_..." */, FxProc: 0},
	{FzName: ts + 26293 /* "sqlite3_mprintf_..." */, FxProc: 0},
	{FzName: ts + 26316 /* "sqlite3_mprintf_..." */, FxProc: 0},
	{FzName: ts + 26339 /* "sqlite3_mprintf_..." */, FxProc: 0},
	{FzName: ts + 26365 /* "sqlite3_mprintf_..." */, FxProc: 0},
	{FzName: ts + 26388 /* "sqlite3_mprintf_..." */, FxProc: 0},
	{FzName: ts + 26411 /* "sqlite3_snprintf..." */, FxProc: 0},
	{FzName: ts + 26432 /* "sqlite3_last_ins..." */, FxProc: 0},
	{FzName: ts + 26458 /* "sqlite3_exec_pri..." */, FxProc: 0},
	{FzName: ts + 26478 /* "sqlite3_exec_hex" */, FxProc: 0},
	{FzName: ts + 26495 /* "sqlite3_exec" */, FxProc: 0},
	{FzName: ts + 26508 /* "sqlite3_exec_nr" */, FxProc: 0},
	{FzName: ts + 26524 /* "sqlite3_get_tabl..." */, FxProc: 0},
	{FzName: ts + 26549 /* "sqlite3_close" */, FxProc: 0},
	{FzName: ts + 26563 /* "sqlite3_close_v2" */, FxProc: 0},
	{FzName: ts + 26580 /* "sqlite3_create_f..." */, FxProc: 0},
	{FzName: ts + 26604 /* "sqlite3_create_a..." */, FxProc: 0},
	{FzName: ts + 26629 /* "sqlite3_drop_mod..." */, FxProc: 0},
	{FzName: ts + 26650 /* "sqlite_register_..." */, FxProc: 0},
	{FzName: ts + 26680 /* "sqlite_abort" */, FxProc: 0},
	{FzName: ts + 26693 /* "sqlite_bind" */, FxProc: 0},
	{FzName: ts + 26705 /* "breakpoint" */, FxProc: 0},
	{FzName: ts + 26716 /* "sqlite3_key" */, FxProc: 0},
	{FzName: ts + 26728 /* "sqlite3_rekey" */, FxProc: 0},
	{FzName: ts + 26742 /* "sqlite_set_magic" */, FxProc: 0},
	{FzName: ts + 26759 /* "sqlite3_interrup..." */, FxProc: 0},
	{FzName: ts + 26777 /* "sqlite_delete_fu..." */, FxProc: 0},
	{FzName: ts + 26800 /* "sqlite_delete_co..." */, FxProc: 0},
	{FzName: ts + 26824 /* "sqlite3_get_auto..." */, FxProc: 0},
	{FzName: ts + 26847 /* "sqlite3_busy_tim..." */, FxProc: 0},
	{FzName: ts + 26868 /* "printf" */, FxProc: 0},
	{FzName: ts + 26875 /* "sqlite3IoTrace" */, FxProc: 0},
	{FzName: ts + 26890 /* "clang_sanitize_a..." */, FxProc: 0},
} /* test1.c:7877:5 */
var aObjCmd1 = [129]struct {
	FzName      uintptr
	FxProc      uintptr
	FclientData uintptr
}{
	{FzName: ts + 26913 /* "sqlite3_db_confi..." */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 26931 /* "bad_behavior" */, FxProc: 0, FclientData: 0},
	{FzName: ts + 26944 /* "register_dbstat_..." */, FxProc: 0},
	{FzName: ts + 26965 /* "sqlite3_connecti..." */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 26992 /* "intarray_addr" */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 27006 /* "int64array_addr" */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 27022 /* "doublearray_addr" */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 27039 /* "textarray_addr" */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 27054 /* "sqlite3_bind_int" */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 27071 /* "sqlite3_bind_zer..." */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 27093 /* "sqlite3_bind_zer..." */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 27117 /* "sqlite3_bind_int..." */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 27136 /* "sqlite3_bind_dou..." */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 27156 /* "sqlite3_bind_nul..." */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 27174 /* "sqlite3_bind_tex..." */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 27192 /* "sqlite3_bind_tex..." */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 27212 /* "sqlite3_bind_blo..." */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 27230 /* "sqlite3_bind_par..." */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 27259 /* "sqlite3_bind_par..." */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 27287 /* "sqlite3_bind_par..." */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 27316 /* "sqlite3_clear_bi..." */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 27339 /* "sqlite3_sleep" */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 27353 /* "sqlite3_errcode" */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 27369 /* "sqlite3_extended..." */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 27394 /* "sqlite3_errmsg" */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 27409 /* "sqlite3_errmsg16" */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 27426 /* "sqlite3_open" */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 27439 /* "sqlite3_open16" */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 27454 /* "sqlite3_open_v2" */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 27470 /* "sqlite3_complete..." */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 27489 /* "sqlite3_normaliz..." */, FxProc: 0, FclientData: uintptr(0)},

	{FzName: ts + 27507 /* "sqlite3_prepare" */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 27523 /* "sqlite3_prepare1..." */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 27541 /* "sqlite3_prepare_..." */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 27560 /* "sqlite3_prepare_..." */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 27579 /* "sqlite3_prepare_..." */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 27603 /* "sqlite3_prepare1..." */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 27624 /* "sqlite3_finalize" */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 27641 /* "sqlite3_stmt_sta..." */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 27661 /* "sqlite3_reset" */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 27675 /* "sqlite3_expired" */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 27691 /* "sqlite3_transfer..." */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 27717 /* "sqlite3_changes" */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 27733 /* "sqlite3_step" */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 27746 /* "sqlite3_sql" */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 27758 /* "sqlite3_expanded..." */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 27779 /* "sqlite3_next_stm..." */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 27797 /* "sqlite3_stmt_rea..." */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 27819 /* "sqlite3_stmt_ise..." */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 27842 /* "sqlite3_stmt_bus..." */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 27860 /* "uses_stmt_journa..." */, FxProc: 0, FclientData: uintptr(0)},

	{FzName: ts + 27878 /* "sqlite3_release_..." */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 27901 /* "sqlite3_db_relea..." */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 27927 /* "sqlite3_db_cache..." */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 27949 /* "sqlite3_system_e..." */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 27970 /* "sqlite3_db_filen..." */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 27990 /* "sqlite3_db_reado..." */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 28010 /* "sqlite3_soft_hea..." */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 28034 /* "sqlite3_soft_hea..." */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 28060 /* "sqlite3_hard_hea..." */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 28086 /* "sqlite3_thread_c..." */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 28109 /* "sqlite3_pager_re..." */, FxProc: 0, FclientData: uintptr(0)},

	{FzName: ts + 28133 /* "sqlite3_load_ext..." */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 28156 /* "sqlite3_enable_l..." */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 28186 /* "sqlite3_extended..." */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 28216 /* "sqlite3_limit" */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 28230 /* "dbconfig_maindbn..." */, FxProc: 0},

	{FzName: ts + 28258 /* "save_prng_state" */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 28274 /* "restore_prng_sta..." */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 28293 /* "reset_prng_state" */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 28310 /* "prng_seed" */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 28320 /* "database_never_c..." */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 28343 /* "database_may_be_..." */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 28367 /* "optimization_con..." */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 28388 /* "tcl_objproc" */, FxProc: 0, FclientData: uintptr(0)},

	// sqlite3_column_*() API
	{FzName: ts + 28400 /* "sqlite3_column_c..." */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 28421 /* "sqlite3_data_cou..." */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 28440 /* "sqlite3_column_t..." */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 28460 /* "sqlite3_column_b..." */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 28480 /* "sqlite3_column_d..." */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 28502 /* "sqlite3_column_i..." */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 28523 /* "sqlite3_column_t..." */, FxProc: 0, FclientData: 0},
	{FzName: ts + 28543 /* "sqlite3_column_n..." */, FxProc: 0, FclientData: 0},
	{FzName: ts + 28563 /* "sqlite3_column_i..." */, FxProc: 0, FclientData: 0},
	{FzName: ts + 28582 /* "sqlite3_column_b..." */, FxProc: 0, FclientData: 0},

	{FzName: ts + 28603 /* "sqlite3_create_c..." */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 28631 /* "sqlite3_global_r..." */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 28654 /* "working_64bit_in..." */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 28672 /* "vfs_unlink_test" */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 28688 /* "vfs_initfail_tes..." */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 28706 /* "vfs_unregister_a..." */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 28725 /* "vfs_reregister_a..." */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 28744 /* "file_control_tes..." */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 28762 /* "file_control_las..." */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 28790 /* "file_control_loc..." */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 28818 /* "file_control_chu..." */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 28846 /* "file_control_siz..." */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 28873 /* "file_control_dat..." */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 28899 /* "file_control_per..." */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 28924 /* "file_control_pow..." */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 28957 /* "file_control_vfs..." */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 28978 /* "file_control_tem..." */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 29004 /* "sqlite3_vfs_list" */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 29021 /* "sqlite3_create_f..." */, FxProc: 0, FclientData: uintptr(0)},

	// Functions from os.h
	{FzName: ts + 29048 /* "sqlite3_test_err..." */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 29068 /* "tcl_variable_typ..." */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 29086 /* "sqlite3_enable_s..." */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 29114 /* "sqlite3_shared_c..." */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 29142 /* "sqlite3_libversi..." */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 29168 /* "sqlite3_table_co..." */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 29198 /* "sqlite3_blob_reo..." */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 29218 /* "pcache_stats" */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 29231 /* "sqlite3_unlock_n..." */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 29253 /* "sqlite3_wal_chec..." */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 29276 /* "sqlite3_wal_chec..." */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 29302 /* "sqlite3_wal_auto..." */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 29329 /* "test_sqlite3_log" */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 29346 /* "print_explain_qu..." */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 29371 /* "sqlite3_test_con..." */, FxProc: 0},
	{FzName: ts + 29392 /* "getrusage" */, FxProc: 0},
	{FzName: ts + 29402 /* "load_static_exte..." */, FxProc: 0},
	{FzName: ts + 29424 /* "sorter_test_fake..." */, FxProc: 0},
	{FzName: ts + 29445 /* "sorter_test_sort..." */, FxProc: 0},
	{FzName: ts + 29470 /* "vfs_current_time..." */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 29493 /* "sqlite3_delete_d..." */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 29517 /* "atomic_batch_wri..." */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 29536 /* "sqlite3_mmap_war..." */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 29554 /* "sqlite3_config_s..." */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 29579 /* "decode_hexdb" */, FxProc: 0, FclientData: uintptr(0)},
}                                                                               /* test1.c:7925:5 */
var bitmask_size int32 = (int32(uint64(unsafe.Sizeof(Bitmask(0))) * uint64(8))) /* test1.c:8143:14 */
var longdouble_size int32 = int32(unsafe.Sizeof(float64(0)))                    /* test1.c:8144:14 */
var query_plan uintptr = ts + 29592                                             /* "*** OBSOLETE VAR..." */ /* test1.c:8219:23 */

// Page size and reserved size used for testing.
var test_pagesize int32 = 1024 /* test2.c:31:12 */

// Dummy page reinitializer
func pager_test_reiniter(tls *crt.TLS, pNotUsed uintptr) { /* test2.c:36:13: */
	return
}

// Usage:   pager_open FILENAME N-PAGE
//
// Open a new pager
func pager_open(tls *crt.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test2.c:45:26: */
	bp := tls.Alloc(192)
	defer tls.Free(192)

	// var pageSize u32 at bp+88, 4

	// var pPager uintptr at bp+80, 8

	// var nPage int32 at bp+72, 4

	var rc int32
	// var zBuf [100]int8 at bp+92, 100

	if argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
			ts+29618 /* " FILENAME N-PAGE..." */, 0))
		return 1
	}
	if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8)), bp+72 /* &nPage */) != 0 {
		return 1
	}
	rc = sqlite3.Xsqlite3PagerOpen(tls, sqlite3.Xsqlite3_vfs_find(tls, uintptr(0)), bp+80 /* &pPager */, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), 0, 0,
		((0x00000002 | 0x00000004) | 0x00000100),
		*(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, uintptr) }{pager_test_reiniter})))
	if rc != 0 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+32, sqlite3.Xsqlite3ErrName(tls, rc), 0))
		return 1
	}
	sqlite3.Xsqlite3PagerSetCachesize(tls, *(*uintptr)(unsafe.Pointer(bp + 80 /* pPager */)), *(*int32)(unsafe.Pointer(bp + 72 /* nPage */)))
	*(*u32)(unsafe.Pointer(bp + 88 /* pageSize */)) = u32(test_pagesize)
	sqlite3.Xsqlite3PagerSetPagesize(tls, *(*uintptr)(unsafe.Pointer(bp + 80 /* pPager */)), bp+88 /* &pageSize */, -1)
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([100]int8{})), bp+92 /* &zBuf[0] */, ts+20002 /* "%p" */, crt.VaList(bp+48, *(*uintptr)(unsafe.Pointer(bp + 80 /* pPager */))))
	tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+56, bp+92 /* &zBuf[0] */, 0))
	return 0
}

// Usage:   pager_close ID
//
// Close the given pager.
func pager_close(tls *crt.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test2.c:82:26: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var pPager uintptr
	var rc int32
	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
			ts+29636 /* " ID\"" */, 0))
		return 1
	}
	pPager = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)))
	rc = sqlite3.Xsqlite3PagerClose(tls, pPager, uintptr(0))
	if rc != 0 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+32, sqlite3.Xsqlite3ErrName(tls, rc), 0))
		return 1
	}
	return 0
}

// Usage:   pager_rollback ID
//
// Rollback changes
func pager_rollback(tls *crt.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test2.c:109:26: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var pPager uintptr
	var rc int32
	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
			ts+29636 /* " ID\"" */, 0))
		return 1
	}
	pPager = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)))
	rc = sqlite3.Xsqlite3PagerRollback(tls, pPager)
	if rc != 0 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+32, sqlite3.Xsqlite3ErrName(tls, rc), 0))
		return 1
	}
	return 0
}

// Usage:   pager_commit ID
//
// Commit all changes
func pager_commit(tls *crt.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test2.c:136:26: */
	bp := tls.Alloc(64)
	defer tls.Free(64)

	var pPager uintptr
	var rc int32
	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
			ts+29636 /* " ID\"" */, 0))
		return 1
	}
	pPager = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)))
	rc = sqlite3.Xsqlite3PagerCommitPhaseOne(tls, pPager, uintptr(0), 0)
	if rc != 0 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+32, sqlite3.Xsqlite3ErrName(tls, rc), 0))
		return 1
	}
	rc = sqlite3.Xsqlite3PagerCommitPhaseTwo(tls, pPager)
	if rc != 0 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+48, sqlite3.Xsqlite3ErrName(tls, rc), 0))
		return 1
	}
	return 0
}

// Usage:   pager_stmt_begin ID
//
// Start a new checkpoint.
func pager_stmt_begin(tls *crt.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test2.c:168:26: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var pPager uintptr
	var rc int32
	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
			ts+29636 /* " ID\"" */, 0))
		return 1
	}
	pPager = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)))
	rc = sqlite3.Xsqlite3PagerOpenSavepoint(tls, pPager, 1)
	if rc != 0 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+32, sqlite3.Xsqlite3ErrName(tls, rc), 0))
		return 1
	}
	return 0
}

// Usage:   pager_stmt_rollback ID
//
// Rollback changes to a checkpoint
func pager_stmt_rollback(tls *crt.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test2.c:195:26: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var pPager uintptr
	var rc int32
	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
			ts+29636 /* " ID\"" */, 0))
		return 1
	}
	pPager = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)))
	rc = sqlite3.Xsqlite3PagerSavepoint(tls, pPager, 2, 0)
	sqlite3.Xsqlite3PagerSavepoint(tls, pPager, 1, 0)
	if rc != 0 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+32, sqlite3.Xsqlite3ErrName(tls, rc), 0))
		return 1
	}
	return 0
}

// Usage:   pager_stmt_commit ID
//
// Commit changes to a checkpoint
func pager_stmt_commit(tls *crt.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test2.c:223:26: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var pPager uintptr
	var rc int32
	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
			ts+29636 /* " ID\"" */, 0))
		return 1
	}
	pPager = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)))
	rc = sqlite3.Xsqlite3PagerSavepoint(tls, pPager, 1, 0)
	if rc != 0 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+32, sqlite3.Xsqlite3ErrName(tls, rc), 0))
		return 1
	}
	return 0
}

// Usage:   pager_stats ID
//
// Return pager statistics.
func pager_stats(tls *crt.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test2.c:250:26: */
	bp := tls.Alloc(140)
	defer tls.Free(140)

	var pPager uintptr
	var i int32
	var a uintptr
	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
			ts+29636 /* " ID\"" */, 0))
		return 1
	}
	pPager = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)))
	a = sqlite3.Xsqlite3PagerStats(tls, pPager)
	for i = 0; i < 9; i++ {
		// var zBuf [100]int8 at bp+40, 100

		tcl.XTcl_AppendElement(tls, interp, zName[i])
		sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([100]int8{})), bp+40 /* &zBuf[0] */, ts+1647 /* "%d" */, crt.VaList(bp+32, *(*int32)(unsafe.Pointer(a + uintptr(i)*4))))
		tcl.XTcl_AppendElement(tls, interp, bp+40 /* &zBuf[0] */)
	}
	return 0
}

var zName = [9]uintptr{
	ts + 29641 /* "ref" */, ts + 29645 /* "page" */, ts + 24478 /* "max" */, ts + 18523 /* "size" */, ts + 16575 /* "state" */, ts + 29650, /* "err" */
	ts + 29654 /* "hit" */, ts + 29658 /* "miss" */, ts + 29663, /* "ovfl" */
} /* test2.c:266:17 */

// Usage:   pager_pagecount ID
//
// Return the size of the database file.
func pager_pagecount(tls *crt.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test2.c:283:26: */
	bp := tls.Alloc(160)
	defer tls.Free(160)

	var pPager uintptr
	// var zBuf [100]int8 at bp+60, 100

	// var nPage int32 at bp+56, 4

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
			ts+29636 /* " ID\"" */, 0))
		return 1
	}
	pPager = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)))
	sqlite3.Xsqlite3PagerPagecount(tls, pPager, bp+56 /* &nPage */)
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([100]int8{})), bp+60 /* &zBuf[0] */, ts+1647 /* "%d" */, crt.VaList(bp+32, *(*int32)(unsafe.Pointer(bp + 56 /* nPage */))))
	tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+40, bp+60 /* &zBuf[0] */, 0))
	return 0
}

// Usage:   page_get ID PGNO
//
// Return a pointer to a page from the database.
func page_get(tls *crt.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test2.c:309:26: */
	bp := tls.Alloc(188)
	defer tls.Free(188)

	var pPager uintptr
	// var zBuf [100]int8 at bp+88, 100

	*(*uintptr)(unsafe.Pointer(bp + 80 /* pPage */)) = uintptr(0)
	// var pgno int32 at bp+72, 4

	var rc int32
	if argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
			ts+29668 /* " ID PGNO\"" */, 0))
		return 1
	}
	pPager = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)))
	if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8)), bp+72 /* &pgno */) != 0 {
		return 1
	}
	rc = sqlite3.Xsqlite3PagerSharedLock(tls, pPager)
	if rc == 0 {
		rc = sqlite3.Xsqlite3PagerGet(tls, pPager, uint32(*(*int32)(unsafe.Pointer(bp + 72 /* pgno */))), bp+80 /* &pPage */, 0)
	}
	if rc != 0 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+32, sqlite3.Xsqlite3ErrName(tls, rc), 0))
		return 1
	}
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([100]int8{})), bp+88 /* &zBuf[0] */, ts+20002 /* "%p" */, crt.VaList(bp+48, *(*uintptr)(unsafe.Pointer(bp + 80 /* pPage */))))
	tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+56, bp+88 /* &zBuf[0] */, 0))
	return 0
}

// Usage:   page_lookup ID PGNO
//
// Return a pointer to a page if the page is already in cache.
// If not in cache, return an empty string.
func page_lookup(tls *crt.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test2.c:346:26: */
	bp := tls.Alloc(160)
	defer tls.Free(160)

	var pPager uintptr
	// var zBuf [100]int8 at bp+60, 100

	var pPage uintptr
	// var pgno int32 at bp+56, 4

	if argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
			ts+29668 /* " ID PGNO\"" */, 0))
		return 1
	}
	pPager = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)))
	if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8)), bp+56 /* &pgno */) != 0 {
		return 1
	}
	pPage = sqlite3.Xsqlite3PagerLookup(tls, pPager, uint32(*(*int32)(unsafe.Pointer(bp + 56 /* pgno */))))
	if pPage != 0 {
		sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([100]int8{})), bp+60 /* &zBuf[0] */, ts+20002 /* "%p" */, crt.VaList(bp+32, pPage))
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+40, bp+60 /* &zBuf[0] */, 0))
	}
	return 0
}

// Usage:   pager_truncate ID PGNO
func pager_truncate(tls *crt.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test2.c:374:26: */
	bp := tls.Alloc(36)
	defer tls.Free(36)

	var pPager uintptr
	// var pgno int32 at bp+32, 4

	if argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
			ts+29668 /* " ID PGNO\"" */, 0))
		return 1
	}
	pPager = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)))
	if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8)), bp+32 /* &pgno */) != 0 {
		return 1
	}
	sqlite3.Xsqlite3PagerTruncateImage(tls, pPager, uint32(*(*int32)(unsafe.Pointer(bp + 32 /* pgno */))))
	return 0
}

// Usage:   page_unref PAGE
//
// Drop a pointer to a page.
func page_unref(tls *crt.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test2.c:399:26: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var pPage uintptr
	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
			ts+29678 /* " PAGE\"" */, 0))
		return 1
	}
	pPage = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)))
	sqlite3.Xsqlite3PagerUnref(tls, pPage)
	return 0
}

// Usage:   page_read PAGE
//
// Return the content of a page
func page_read(tls *crt.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test2.c:421:26: */
	bp := tls.Alloc(148)
	defer tls.Free(148)

	// var zBuf [100]int8 at bp+48, 100

	var pPage uintptr
	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
			ts+29678 /* " PAGE\"" */, 0))
		return 1
	}
	pPage = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)))
	crt.Xmemcpy(tls, bp+48 /* &zBuf[0] */, sqlite3.Xsqlite3PagerGetData(tls, pPage), uint64(unsafe.Sizeof([100]int8{})))
	tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+32, bp+48 /* &zBuf[0] */, 0))
	return 0
}

// Usage:   page_number PAGE
//
// Return the page number for a page.
func page_number(tls *crt.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test2.c:445:26: */
	bp := tls.Alloc(156)
	defer tls.Free(156)

	// var zBuf [100]int8 at bp+56, 100

	var pPage uintptr
	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
			ts+29678 /* " PAGE\"" */, 0))
		return 1
	}
	pPage = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)))
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([100]int8{})), bp+56 /* &zBuf[0] */, ts+1647 /* "%d" */, crt.VaList(bp+32, sqlite3.Xsqlite3PagerPagenumber(tls, pPage)))
	tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+40, bp+56 /* &zBuf[0] */, 0))
	return 0
}

// Usage:   page_write PAGE DATA
//
// Write something into a page.
func page_write(tls *crt.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test2.c:469:26: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var pPage uintptr
	var pData uintptr
	var rc int32
	if argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
			ts+29685 /* " PAGE DATA\"" */, 0))
		return 1
	}
	pPage = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)))
	rc = sqlite3.Xsqlite3PagerWrite(tls, pPage)
	if rc != 0 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+32, sqlite3.Xsqlite3ErrName(tls, rc), 0))
		return 1
	}
	pData = sqlite3.Xsqlite3PagerGetData(tls, pPage)
	crt.Xstrncpy(tls, pData, *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8)), (uint64(test_pagesize - 1)))
	*(*int8)(unsafe.Pointer(pData + uintptr((test_pagesize - 1)))) = int8(0)
	return 0
}

// Usage:   fake_big_file  N  FILENAME
//
// Write a few bytes at the N megabyte point of FILENAME.  This will
// create a large file.  If the file was a valid SQLite database, then
// the next time the database is opened, SQLite will begin allocating
// new pages after N.  If N is 2096 or bigger, this will test the
// ability of SQLite to write to large files.
func fake_big_file(tls *crt.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test2.c:505:26: */
	bp := tls.Alloc(96)
	defer tls.Free(96)

	var pVfs uintptr
	*(*uintptr)(unsafe.Pointer(bp + 88 /* fd */)) = uintptr(0)
	var rc int32
	// var n int32 at bp+80, 4

	var offset i64
	var zFile uintptr
	var nFile int32
	if argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
			ts+29697 /* " N-MEGABYTES FIL..." */, 0))
		return 1
	}
	if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), bp+80 /* &n */) != 0 {
		return 1
	}

	pVfs = sqlite3.Xsqlite3_vfs_find(tls, uintptr(0))
	nFile = int32(crt.Xstrlen(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8))))
	zFile = sqlite3.Xsqlite3_malloc(tls, (nFile + 2))
	if zFile == uintptr(0) {
		return 1
	}
	crt.Xmemcpy(tls, zFile, *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8)), (uint64(nFile + 1)))
	*(*int8)(unsafe.Pointer(zFile + uintptr((nFile + 1)))) = int8(0)
	rc = sqlite3.Xsqlite3OsOpenMalloc(tls, pVfs, zFile, bp+88, /* &fd */
		((0x00000004 | 0x00000002) | 0x00000100), uintptr(0))
	if rc != 0 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+32, ts+29716 /* "open failed: " */, sqlite3.Xsqlite3ErrName(tls, rc), 0))
		sqlite3.Xsqlite3_free(tls, zFile)
		return 1
	}
	offset = i64(*(*int32)(unsafe.Pointer(bp + 80 /* n */)))
	offset = offset * (int64(1024 * 1024))
	rc = sqlite3.Xsqlite3OsWrite(tls, *(*uintptr)(unsafe.Pointer(bp + 88 /* fd */)), ts+29730 /* "Hello, World!" */, 14, offset)
	sqlite3.Xsqlite3OsCloseFree(tls, *(*uintptr)(unsafe.Pointer(bp + 88 /* fd */)))
	sqlite3.Xsqlite3_free(tls, zFile)
	if rc != 0 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+56, ts+29744 /* "write failed: " */, sqlite3.Xsqlite3ErrName(tls, rc), 0))
		return 1
	}
	return 0
}

// test_control_pending_byte  PENDING_BYTE
//
// Set the PENDING_BYTE using the sqlite3_test_control() interface.
func testPendingByte(tls *crt.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test2.c:558:26: */
	bp := tls.Alloc(44)
	defer tls.Free(44)

	// var pbyte int32 at bp+40, 4

	var rc int32
	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
			ts+29759 /* " PENDING-BYTE\"" */, uintptr(0)))
		return 1
	}
	if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), bp+40 /* &pbyte */) != 0 {
		return 1
	}
	rc = sqlite3.Xsqlite3_test_control(tls, 11, crt.VaList(bp+32, *(*int32)(unsafe.Pointer(bp + 40 /* pbyte */))))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, rc))
	return 0
}

// The sqlite3FaultSim() callback:
var faultSimInterp uintptr = uintptr(0) /* test2.c:580:19 */
var faultSimScriptSize int32 = 0        /* test2.c:581:12 */
var faultSimScript uintptr              /* test2.c:582:13: */
func faultSimCallback(tls *crt.TLS, x int32) int32 { /* test2.c:583:12: */
	bp := tls.Alloc(38)
	defer tls.Free(38)

	// var zInt [30]int8 at bp+8, 30

	var i int32
	var isNeg int32
	var rc int32
	if x == 0 {
		crt.Xmemcpy(tls, (faultSimScript + uintptr(faultSimScriptSize)), ts+8293 /* "0" */, uint64(2))
	} else {
		// Convert x to text without using any sqlite3 routines
		if x < 0 {
			isNeg = 1
			x = -x
		} else {
			isNeg = 0
		}
		*(*int8)(unsafe.Pointer(bp + 8 /* &zInt[0] */ + uintptr((uint64(unsafe.Sizeof([30]int8{})) - uint64(1))))) = int8(0)
		i = (int32(uint64(unsafe.Sizeof([30]int8{})) - uint64(2)))
	__1:
		if !((i > 0) && (x > 0)) {
			goto __3
		}
		{
			*(*int8)(unsafe.Pointer(bp + 8 /* &zInt[0] */ + uintptr(i))) = (int8((x % 10) + '0'))
		}
		goto __2
	__2:
		i--
		x = x / (10)
		goto __1
		goto __3
	__3:
		;
		if isNeg != 0 {
			*(*int8)(unsafe.Pointer(bp + 8 /* &zInt[0] */ + uintptr(crt.PostDecInt32(&i, 1)))) = int8('-')
		}
		crt.Xmemcpy(tls, (faultSimScript + uintptr(faultSimScriptSize)), ((bp + 8 /* &zInt[0] */ + uintptr(i)) + uintptr(1)), (uint64(unsafe.Sizeof([30]int8{})) - uint64(i)))
	}
	rc = tcl.XTcl_Eval(tls, faultSimInterp, faultSimScript)
	if rc != 0 {
		crt.Xfprintf(tls, crt.Xstderr, ts+29774 /* "fault simulator ..." */, crt.VaList(bp, faultSimScript))
		rc = 1
	} else {
		rc = crt.Xatoi(tls, tcl.XTcl_GetStringResult(tls, faultSimInterp))
	}
	tcl.XTcl_ResetResult(tls, faultSimInterp)
	return rc
}

// sqlite3_test_control_fault_install SCRIPT
//
// Arrange to invoke SCRIPT with the integer argument to sqlite3FaultSim()
// appended, whenever sqlite3FaultSim() is called.  Or, if SCRIPT is the
// empty string, cancel the sqlite3FaultSim() callback.
func faultInstallCmd(tls *crt.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test2.c:623:26: */
	bp := tls.Alloc(64)
	defer tls.Free(64)

	var zScript uintptr
	var nScript int32
	var rc int32
	if (argc != 1) && (argc != 2) {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
			ts+29810 /* " SCRIPT\"" */, uintptr(0)))
	}
	if argc == 2 {
		zScript = *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8))
	} else {
		zScript = ts + 792 /* "" */
	}
	nScript = int32(crt.Xstrlen(tls, zScript))
	if faultSimScript != 0 {
		crt.Xfree(tls, faultSimScript)
		faultSimScript = uintptr(0)
	}
	if nScript == 0 {
		rc = sqlite3.Xsqlite3_test_control(tls, 9, crt.VaList(bp+32, 0))
	} else {
		faultSimScript = crt.Xmalloc(tls, (uint64(nScript + 100)))
		if faultSimScript == uintptr(0) {
			tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+40, ts+2471 /* "out of memory" */, uintptr(0)))
			return 1
		}
		crt.Xmemcpy(tls, faultSimScript, zScript, uint64(nScript))
		*(*int8)(unsafe.Pointer(faultSimScript + uintptr(nScript))) = int8(' ')
		faultSimScriptSize = (nScript + 1)
		faultSimInterp = interp
		rc = sqlite3.Xsqlite3_test_control(tls, 9, crt.VaList(bp+56, *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, int32) int32 }{faultSimCallback}))))
	}
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, rc))
	return 0
}

// sqlite3BitvecBuiltinTest SIZE PROGRAM
//
// Invoke the SQLITE_TESTCTRL_BITVEC_TEST operator on test_control.
// See comments on sqlite3BitvecBuiltinTest() for additional information.
func testBitvecBuiltinTest(tls *crt.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test2.c:666:26: */
	bp := tls.Alloc(452)
	defer tls.Free(452)

	// var sz int32 at bp+48, 4

	var rc int32
	var nProg int32 = 0
	// var aProg [100]int32 at bp+52, 400

	var z uintptr
	if argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
			ts+29819 /* " SIZE PROGRAM\"" */, uintptr(0)))
	}
	if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), bp+48 /* &sz */) != 0 {
		return 1
	}
	z = *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8))
	for (nProg < 99) && (*(*int8)(unsafe.Pointer(z)) != 0) {
		for (*(*int8)(unsafe.Pointer(z)) != 0) && !((int32(sqlite3.Xsqlite3CtypeMap[uint8(*(*int8)(unsafe.Pointer(z)))]) & 0x04) != 0) {
			z++
		}
		if int32(*(*int8)(unsafe.Pointer(z))) == 0 {
			break
		}
		*(*int32)(unsafe.Pointer(bp + 52 /* &aProg[0] */ + uintptr(crt.PostIncInt32(&nProg, 1))*4)) = crt.Xatoi(tls, z)
		for (int32(sqlite3.Xsqlite3CtypeMap[uint8(*(*int8)(unsafe.Pointer(z)))]) & 0x04) != 0 {
			z++
		}
	}
	*(*int32)(unsafe.Pointer(bp + 52 /* &aProg[0] */ + uintptr(nProg)*4)) = 0
	rc = sqlite3.Xsqlite3_test_control(tls, 8, crt.VaList(bp+32, *(*int32)(unsafe.Pointer(bp + 48 /* sz */)), bp+52 /* &aProg[0] */))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, rc))
	return 0
}

// Register commands with the TCL interpreter.
func Sqlitetest2_Init(tls *crt.TLS, interp uintptr) int32 { /* test2.c:697:5: */
	var i int32
	for i = 0; uint64(i) < (uint64(unsafe.Sizeof(aCmd1)) / uint64(unsafe.Sizeof(struct {
		FzName uintptr
		FxProc uintptr
	}{}))); i++ {
		tcl.XTcl_CreateCommand(tls, interp, aCmd1[i].FzName, aCmd1[i].FxProc, uintptr(0), uintptr(0))
	}
	tcl.XTcl_LinkVar(tls, interp, ts+29834, /* "sqlite_io_error_..." */
		uintptr(unsafe.Pointer(&sqlite3.Xsqlite3_io_error_pending)), 1)
	tcl.XTcl_LinkVar(tls, interp, ts+29858, /* "sqlite_io_error_..." */
		uintptr(unsafe.Pointer(&sqlite3.Xsqlite3_io_error_persist)), 1)
	tcl.XTcl_LinkVar(tls, interp, ts+29882, /* "sqlite_io_error_..." */
		uintptr(unsafe.Pointer(&sqlite3.Xsqlite3_io_error_hit)), 1)
	tcl.XTcl_LinkVar(tls, interp, ts+29902, /* "sqlite_io_error_..." */
		uintptr(unsafe.Pointer(&sqlite3.Xsqlite3_io_error_hardhit)), 1)
	tcl.XTcl_LinkVar(tls, interp, ts+29926, /* "sqlite_diskfull_..." */
		uintptr(unsafe.Pointer(&sqlite3.Xsqlite3_diskfull_pending)), 1)
	tcl.XTcl_LinkVar(tls, interp, ts+29950, /* "sqlite_diskfull" */
		uintptr(unsafe.Pointer(&sqlite3.Xsqlite3_diskfull)), 1)
	tcl.XTcl_LinkVar(tls, interp, ts+29966, /* "sqlite_pending_b..." */
		uintptr(unsafe.Pointer(&sqlite3.Xsqlite3PendingByte)), (1 | 0x80))
	return 0
}

var aCmd1 = [20]struct {
	FzName uintptr
	FxProc uintptr
}{
	{FzName: ts + 29986 /* "pager_open" */, FxProc: 0},
	{FzName: ts + 29997 /* "pager_close" */, FxProc: 0},
	{FzName: ts + 30009 /* "pager_commit" */, FxProc: 0},
	{FzName: ts + 30022 /* "pager_rollback" */, FxProc: 0},
	{FzName: ts + 30037 /* "pager_stmt_begin" */, FxProc: 0},
	{FzName: ts + 30054 /* "pager_stmt_commi..." */, FxProc: 0},
	{FzName: ts + 30072 /* "pager_stmt_rollb..." */, FxProc: 0},
	{FzName: ts + 30092 /* "pager_stats" */, FxProc: 0},
	{FzName: ts + 30104 /* "pager_pagecount" */, FxProc: 0},
	{FzName: ts + 30120 /* "page_get" */, FxProc: 0},
	{FzName: ts + 30129 /* "page_lookup" */, FxProc: 0},
	{FzName: ts + 30141 /* "page_unref" */, FxProc: 0},
	{FzName: ts + 30152 /* "page_read" */, FxProc: 0},
	{FzName: ts + 30162 /* "page_write" */, FxProc: 0},
	{FzName: ts + 30173 /* "page_number" */, FxProc: 0},
	{FzName: ts + 30185 /* "pager_truncate" */, FxProc: 0},
	{FzName: ts + 30200 /* "fake_big_file" */, FxProc: 0},
	{FzName: ts + 30214 /* "sqlite3BitvecBui..." */, FxProc: 0},
	{FzName: ts + 30239 /* "sqlite3_test_con..." */, FxProc: 0},
	{FzName: ts + 30273 /* "sqlite3_test_con..." */, FxProc: 0},
} /* test2.c:707:5 */

// Defer sourcing vdbe.h and btree.h until after the "u8" and
// "BusyHandler" typedefs. vdbe.h also requires a few of the opaque
// pointer types (i.e. FuncDef) defined above.
// 2001 September 15
//
// The author disclaims copyright to this source code.  In place of
// a legal notice, here is a blessing:
//
//    May you do good and not evil.
//    May you find forgiveness for yourself and forgive others.
//    May you share freely, never taking more than you give.
//
//
// This header file defines the interface that the sqlite B-Tree file
// subsystem.  See comments in the source code for a detailed description
// of what each interface routine does.

// TODO: This definition is just included so other modules compile. It
// needs to be revisited.

// If defined as non-zero, auto-vacuum is enabled by default. Otherwise
// it must be turned on for each database using "PRAGMA auto_vacuum = 1".

// Forward declarations of structure
type Btree = Btree1       /* btree.h:39:22 */
type BtCursor = BtCursor1 /* btree.h:40:25 */
type BtShared = BtShared1 /* btree.h:41:25 */

// 2004 April 6
//
// The author disclaims copyright to this source code.  In place of
// a legal notice, here is a blessing:
//
//    May you do good and not evil.
//    May you find forgiveness for yourself and forgive others.
//    May you share freely, never taking more than you give.
//
//
// This file implements an external (disk-based) database using BTrees.
// For a detailed discussion of BTrees, refer to
//
//     Donald E. Knuth, THE ART OF COMPUTER PROGRAMMING, Volume 3:
//     "Sorting And Searching", pages 473-480. Addison-Wesley
//     Publishing Company, Reading, Massachusetts.
//
// The basic idea is that each page of the file contains N database
// entries and N+1 pointers to subpages.
//
//   ----------------------------------------------------------------
//   |  Ptr(0) | Key(0) | Ptr(1) | Key(1) | ... | Key(N-1) | Ptr(N) |
//   ----------------------------------------------------------------
//
// All of the keys on the page that Ptr(0) points to have values less
// than Key(0).  All of the keys on page Ptr(1) and its subpages have
// values greater than Key(0) and less than Key(1).  All of the keys
// on Ptr(N) and its subpages have values greater than Key(N-1).  And
// so forth.
//
// Finding a particular key requires reading O(log(M)) pages from the
// disk where M is the number of entries in the tree.
//
// In this implementation, a single file can hold one or more separate
// BTrees.  Each BTree is identified by the index of its root page.  The
// key and data for any entry are combined to form the "payload".  A
// fixed amount of payload can be carried directly on the database
// page.  If the payload is larger than the preset amount then surplus
// bytes are stored on overflow pages.  The payload for an entry
// and the preceding pointer are combined to form a "Cell".  Each
// page has a small header which contains the Ptr(N) pointer and other
// information such as the size of key and data.
//
// FORMAT DETAILS
//
// The file is divided into pages.  The first page is called page 1,
// the second is page 2, and so forth.  A page number of zero indicates
// "no such page".  The page size can be any power of 2 between 512 and 65536.
// Each page can be either a btree page, a freelist page, an overflow
// page, or a pointer-map page.
//
// The first page is always a btree page.  The first 100 bytes of the first
// page contain a special header (the "file header") that describes the file.
// The format of the file header is as follows:
//
//   OFFSET   SIZE    DESCRIPTION
//      0      16     Header string: "SQLite format 3\000"
//     16       2     Page size in bytes.  (1 means 65536)
//     18       1     File format write version
//     19       1     File format read version
//     20       1     Bytes of unused space at the end of each page
//     21       1     Max embedded payload fraction (must be 64)
//     22       1     Min embedded payload fraction (must be 32)
//     23       1     Min leaf payload fraction (must be 32)
//     24       4     File change counter
//     28       4     Reserved for future use
//     32       4     First freelist page
//     36       4     Number of freelist pages in the file
//     40      60     15 4-byte meta values passed to higher layers
//
//     40       4     Schema cookie
//     44       4     File format of schema layer
//     48       4     Size of page cache
//     52       4     Largest root-page (auto/incr_vacuum)
//     56       4     1=UTF-8 2=UTF16le 3=UTF16be
//     60       4     User version
//     64       4     Incremental vacuum mode
//     68       4     Application-ID
//     72      20     unused
//     92       4     The version-valid-for number
//     96       4     SQLITE_VERSION_NUMBER
//
// All of the integer values are big-endian (most significant byte first).
//
// The file change counter is incremented when the database is changed
// This counter allows other processes to know when the file has changed
// and thus when they need to flush their cache.
//
// The max embedded payload fraction is the amount of the total usable
// space in a page that can be consumed by a single cell for standard
// B-tree (non-LEAFDATA) tables.  A value of 255 means 100%.  The default
// is to limit the maximum cell size so that at least 4 cells will fit
// on one page.  Thus the default max embedded payload fraction is 64.
//
// If the payload for a cell is larger than the max payload, then extra
// payload is spilled to overflow pages.  Once an overflow page is allocated,
// as many bytes as possible are moved into the overflow pages without letting
// the cell size drop below the min embedded payload fraction.
//
// The min leaf payload fraction is like the min embedded payload fraction
// except that it applies to leaf nodes in a LEAFDATA tree.  The maximum
// payload fraction for a LEAFDATA tree is always 100% (or 255) and it
// not specified in the header.
//
// Each btree pages is divided into three sections:  The header, the
// cell pointer array, and the cell content area.  Page 1 also has a 100-byte
// file header that occurs before the page header.
//
//      |----------------|
//      | file header    |   100 bytes.  Page 1 only.
//      |----------------|
//      | page header    |   8 bytes for leaves.  12 bytes for interior nodes
//      |----------------|
//      | cell pointer   |   |  2 bytes per cell.  Sorted order.
//      | array          |   |  Grows downward
//      |                |   v
//      |----------------|
//      | unallocated    |
//      | space          |
//      |----------------|   ^  Grows upwards
//      | cell content   |   |  Arbitrary order interspersed with freeblocks.
//      | area           |   |  and free space fragments.
//      |----------------|
//
// The page headers looks like this:
//
//   OFFSET   SIZE     DESCRIPTION
//      0       1      Flags. 1: intkey, 2: zerodata, 4: leafdata, 8: leaf
//      1       2      byte offset to the first freeblock
//      3       2      number of cells on this page
//      5       2      first byte of the cell content area
//      7       1      number of fragmented free bytes
//      8       4      Right child (the Ptr(N) value).  Omitted on leaves.
//
// The flags define the format of this btree page.  The leaf flag means that
// this page has no children.  The zerodata flag means that this page carries
// only keys and no data.  The intkey flag means that the key is an integer
// which is stored in the key size entry of the cell header rather than in
// the payload area.
//
// The cell pointer array begins on the first byte after the page header.
// The cell pointer array contains zero or more 2-byte numbers which are
// offsets from the beginning of the page to the cell content in the cell
// content area.  The cell pointers occur in sorted order.  The system strives
// to keep free space after the last cell pointer so that new cells can
// be easily added without having to defragment the page.
//
// Cell content is stored at the very end of the page and grows toward the
// beginning of the page.
//
// Unused space within the cell content area is collected into a linked list of
// freeblocks.  Each freeblock is at least 4 bytes in size.  The byte offset
// to the first freeblock is given in the header.  Freeblocks occur in
// increasing order.  Because a freeblock must be at least 4 bytes in size,
// any group of 3 or fewer unused bytes in the cell content area cannot
// exist on the freeblock chain.  A group of 3 or fewer free bytes is called
// a fragment.  The total number of bytes in all fragments is recorded.
// in the page header at offset 7.
//
//    SIZE    DESCRIPTION
//      2     Byte offset of the next freeblock
//      2     Bytes in this freeblock
//
// Cells are of variable length.  Cells are stored in the cell content area at
// the end of the page.  Pointers to the cells are in the cell pointer array
// that immediately follows the page header.  Cells is not necessarily
// contiguous or in order, but cell pointers are contiguous and in order.
//
// Cell content makes use of variable length integers.  A variable
// length integer is 1 to 9 bytes where the lower 7 bits of each
// byte are used.  The integer consists of all bytes that have bit 8 set and
// the first byte with bit 8 clear.  The most significant byte of the integer
// appears first.  A variable-length integer may not be more than 9 bytes long.
// As a special case, all 8 bytes of the 9th byte are used as data.  This
// allows a 64-bit integer to be encoded in 9 bytes.
//
//    0x00                      becomes  0x00000000
//    0x7f                      becomes  0x0000007f
//    0x81 0x00                 becomes  0x00000080
//    0x82 0x00                 becomes  0x00000100
//    0x80 0x7f                 becomes  0x0000007f
//    0x8a 0x91 0xd1 0xac 0x78  becomes  0x12345678
//    0x81 0x81 0x81 0x81 0x01  becomes  0x10204081
//
// Variable length integers are used for rowids and to hold the number of
// bytes of key and data in a btree cell.
//
// The content of a cell looks like this:
//
//    SIZE    DESCRIPTION
//      4     Page number of the left child. Omitted if leaf flag is set.
//     var    Number of bytes of data. Omitted if the zerodata flag is set.
//     var    Number of bytes of key. Or the key itself if intkey flag is set.
//      *     Payload
//      4     First page of the overflow chain.  Omitted if no overflow
//
// Overflow pages form a linked list.  Each page except the last is completely
// filled with data (pagesize - 4 bytes).  The last page can have as little
// as 1 byte of data.
//
//    SIZE    DESCRIPTION
//      4     Page number of next overflow page
//      *     Data
//
// Freelist pages come in two subtypes: trunk pages and leaf pages.  The
// file header points to the first in a linked list of trunk page.  Each trunk
// page points to multiple leaf pages.  The content of a leaf page is
// unspecified.  A trunk page looks like this:
//
//    SIZE    DESCRIPTION
//      4     Page number of next trunk page
//      4     Number of leaf pointers on this page
//      *     zero or more pages numbers of leaves
// 2001 September 15
//
// The author disclaims copyright to this source code.  In place of
// a legal notice, here is a blessing:
//
//    May you do good and not evil.
//    May you find forgiveness for yourself and forgive others.
//    May you share freely, never taking more than you give.
//
//
// Internal interface definitions for SQLite.
//

// The following value is the maximum cell size assuming a maximum page
// size give above.

// The maximum number of cells on a single page of the database.  This
// assumes a minimum cell size of 6 bytes  (4 bytes for the cell itself
// plus 2 bytes for the index to the cell in the page header).  Such
// small cells will be rare, but they are possible.

// Forward declarations
type MemPage1 = struct {
	FisInit          u8
	FbBusy           u8
	FintKey          u8
	FintKeyLeaf      u8
	Fpgno            Pgno
	Fleaf            u8
	FhdrOffset       u8
	FchildPtrSize    u8
	Fmax1bytePayload u8
	FnOverflow       u8
	FmaxLocal        u16
	FminLocal        u16
	FcellOffset      u16
	FnFree           int32
	FnCell           u16
	FmaskPage        u16
	FaiOvfl          [4]u16
	FapOvfl          [4]uintptr
	FpBt             uintptr
	FaData           uintptr
	FaDataEnd        uintptr
	FaCellIdx        uintptr
	FaDataOfst       uintptr
	FpDbPage         uintptr
	FxCellSize       uintptr
	FxParseCell      uintptr
}

// 2004 April 6
//
// The author disclaims copyright to this source code.  In place of
// a legal notice, here is a blessing:
//
//    May you do good and not evil.
//    May you find forgiveness for yourself and forgive others.
//    May you share freely, never taking more than you give.
//
//
// This file implements an external (disk-based) database using BTrees.
// For a detailed discussion of BTrees, refer to
//
//     Donald E. Knuth, THE ART OF COMPUTER PROGRAMMING, Volume 3:
//     "Sorting And Searching", pages 473-480. Addison-Wesley
//     Publishing Company, Reading, Massachusetts.
//
// The basic idea is that each page of the file contains N database
// entries and N+1 pointers to subpages.
//
//   ----------------------------------------------------------------
//   |  Ptr(0) | Key(0) | Ptr(1) | Key(1) | ... | Key(N-1) | Ptr(N) |
//   ----------------------------------------------------------------
//
// All of the keys on the page that Ptr(0) points to have values less
// than Key(0).  All of the keys on page Ptr(1) and its subpages have
// values greater than Key(0) and less than Key(1).  All of the keys
// on Ptr(N) and its subpages have values greater than Key(N-1).  And
// so forth.
//
// Finding a particular key requires reading O(log(M)) pages from the
// disk where M is the number of entries in the tree.
//
// In this implementation, a single file can hold one or more separate
// BTrees.  Each BTree is identified by the index of its root page.  The
// key and data for any entry are combined to form the "payload".  A
// fixed amount of payload can be carried directly on the database
// page.  If the payload is larger than the preset amount then surplus
// bytes are stored on overflow pages.  The payload for an entry
// and the preceding pointer are combined to form a "Cell".  Each
// page has a small header which contains the Ptr(N) pointer and other
// information such as the size of key and data.
//
// FORMAT DETAILS
//
// The file is divided into pages.  The first page is called page 1,
// the second is page 2, and so forth.  A page number of zero indicates
// "no such page".  The page size can be any power of 2 between 512 and 65536.
// Each page can be either a btree page, a freelist page, an overflow
// page, or a pointer-map page.
//
// The first page is always a btree page.  The first 100 bytes of the first
// page contain a special header (the "file header") that describes the file.
// The format of the file header is as follows:
//
//   OFFSET   SIZE    DESCRIPTION
//      0      16     Header string: "SQLite format 3\000"
//     16       2     Page size in bytes.  (1 means 65536)
//     18       1     File format write version
//     19       1     File format read version
//     20       1     Bytes of unused space at the end of each page
//     21       1     Max embedded payload fraction (must be 64)
//     22       1     Min embedded payload fraction (must be 32)
//     23       1     Min leaf payload fraction (must be 32)
//     24       4     File change counter
//     28       4     Reserved for future use
//     32       4     First freelist page
//     36       4     Number of freelist pages in the file
//     40      60     15 4-byte meta values passed to higher layers
//
//     40       4     Schema cookie
//     44       4     File format of schema layer
//     48       4     Size of page cache
//     52       4     Largest root-page (auto/incr_vacuum)
//     56       4     1=UTF-8 2=UTF16le 3=UTF16be
//     60       4     User version
//     64       4     Incremental vacuum mode
//     68       4     Application-ID
//     72      20     unused
//     92       4     The version-valid-for number
//     96       4     SQLITE_VERSION_NUMBER
//
// All of the integer values are big-endian (most significant byte first).
//
// The file change counter is incremented when the database is changed
// This counter allows other processes to know when the file has changed
// and thus when they need to flush their cache.
//
// The max embedded payload fraction is the amount of the total usable
// space in a page that can be consumed by a single cell for standard
// B-tree (non-LEAFDATA) tables.  A value of 255 means 100%.  The default
// is to limit the maximum cell size so that at least 4 cells will fit
// on one page.  Thus the default max embedded payload fraction is 64.
//
// If the payload for a cell is larger than the max payload, then extra
// payload is spilled to overflow pages.  Once an overflow page is allocated,
// as many bytes as possible are moved into the overflow pages without letting
// the cell size drop below the min embedded payload fraction.
//
// The min leaf payload fraction is like the min embedded payload fraction
// except that it applies to leaf nodes in a LEAFDATA tree.  The maximum
// payload fraction for a LEAFDATA tree is always 100% (or 255) and it
// not specified in the header.
//
// Each btree pages is divided into three sections:  The header, the
// cell pointer array, and the cell content area.  Page 1 also has a 100-byte
// file header that occurs before the page header.
//
//      |----------------|
//      | file header    |   100 bytes.  Page 1 only.
//      |----------------|
//      | page header    |   8 bytes for leaves.  12 bytes for interior nodes
//      |----------------|
//      | cell pointer   |   |  2 bytes per cell.  Sorted order.
//      | array          |   |  Grows downward
//      |                |   v
//      |----------------|
//      | unallocated    |
//      | space          |
//      |----------------|   ^  Grows upwards
//      | cell content   |   |  Arbitrary order interspersed with freeblocks.
//      | area           |   |  and free space fragments.
//      |----------------|
//
// The page headers looks like this:
//
//   OFFSET   SIZE     DESCRIPTION
//      0       1      Flags. 1: intkey, 2: zerodata, 4: leafdata, 8: leaf
//      1       2      byte offset to the first freeblock
//      3       2      number of cells on this page
//      5       2      first byte of the cell content area
//      7       1      number of fragmented free bytes
//      8       4      Right child (the Ptr(N) value).  Omitted on leaves.
//
// The flags define the format of this btree page.  The leaf flag means that
// this page has no children.  The zerodata flag means that this page carries
// only keys and no data.  The intkey flag means that the key is an integer
// which is stored in the key size entry of the cell header rather than in
// the payload area.
//
// The cell pointer array begins on the first byte after the page header.
// The cell pointer array contains zero or more 2-byte numbers which are
// offsets from the beginning of the page to the cell content in the cell
// content area.  The cell pointers occur in sorted order.  The system strives
// to keep free space after the last cell pointer so that new cells can
// be easily added without having to defragment the page.
//
// Cell content is stored at the very end of the page and grows toward the
// beginning of the page.
//
// Unused space within the cell content area is collected into a linked list of
// freeblocks.  Each freeblock is at least 4 bytes in size.  The byte offset
// to the first freeblock is given in the header.  Freeblocks occur in
// increasing order.  Because a freeblock must be at least 4 bytes in size,
// any group of 3 or fewer unused bytes in the cell content area cannot
// exist on the freeblock chain.  A group of 3 or fewer free bytes is called
// a fragment.  The total number of bytes in all fragments is recorded.
// in the page header at offset 7.
//
//    SIZE    DESCRIPTION
//      2     Byte offset of the next freeblock
//      2     Bytes in this freeblock
//
// Cells are of variable length.  Cells are stored in the cell content area at
// the end of the page.  Pointers to the cells are in the cell pointer array
// that immediately follows the page header.  Cells is not necessarily
// contiguous or in order, but cell pointers are contiguous and in order.
//
// Cell content makes use of variable length integers.  A variable
// length integer is 1 to 9 bytes where the lower 7 bits of each
// byte are used.  The integer consists of all bytes that have bit 8 set and
// the first byte with bit 8 clear.  The most significant byte of the integer
// appears first.  A variable-length integer may not be more than 9 bytes long.
// As a special case, all 8 bytes of the 9th byte are used as data.  This
// allows a 64-bit integer to be encoded in 9 bytes.
//
//    0x00                      becomes  0x00000000
//    0x7f                      becomes  0x0000007f
//    0x81 0x00                 becomes  0x00000080
//    0x82 0x00                 becomes  0x00000100
//    0x80 0x7f                 becomes  0x0000007f
//    0x8a 0x91 0xd1 0xac 0x78  becomes  0x12345678
//    0x81 0x81 0x81 0x81 0x01  becomes  0x10204081
//
// Variable length integers are used for rowids and to hold the number of
// bytes of key and data in a btree cell.
//
// The content of a cell looks like this:
//
//    SIZE    DESCRIPTION
//      4     Page number of the left child. Omitted if leaf flag is set.
//     var    Number of bytes of data. Omitted if the zerodata flag is set.
//     var    Number of bytes of key. Or the key itself if intkey flag is set.
//      *     Payload
//      4     First page of the overflow chain.  Omitted if no overflow
//
// Overflow pages form a linked list.  Each page except the last is completely
// filled with data (pagesize - 4 bytes).  The last page can have as little
// as 1 byte of data.
//
//    SIZE    DESCRIPTION
//      4     Page number of next overflow page
//      *     Data
//
// Freelist pages come in two subtypes: trunk pages and leaf pages.  The
// file header points to the first in a linked list of trunk page.  Each trunk
// page points to multiple leaf pages.  The content of a leaf page is
// unspecified.  A trunk page looks like this:
//
//    SIZE    DESCRIPTION
//      4     Page number of next trunk page
//      4     Number of leaf pointers on this page
//      *     zero or more pages numbers of leaves
// 2001 September 15
//
// The author disclaims copyright to this source code.  In place of
// a legal notice, here is a blessing:
//
//    May you do good and not evil.
//    May you find forgiveness for yourself and forgive others.
//    May you share freely, never taking more than you give.
//
//
// Internal interface definitions for SQLite.
//

// The following value is the maximum cell size assuming a maximum page
// size give above.

// The maximum number of cells on a single page of the database.  This
// assumes a minimum cell size of 6 bytes  (4 bytes for the cell itself
// plus 2 bytes for the index to the cell in the page header).  Such
// small cells will be rare, but they are possible.

// Forward declarations
type MemPage = MemPage1 /* btreeInt.h:232:24 */
type BtLock1 = struct {
	FpBtree uintptr
	FiTable Pgno
	FeLock  u8
	FpNext  uintptr
}

type BtLock = BtLock1 /* btreeInt.h:233:23 */
type CellInfo1 = struct {
	FnKey     i64
	FpPayload uintptr
	FnPayload u32
	FnLocal   u16
	FnSize    u16
}

type CellInfo = CellInfo1 /* btreeInt.h:234:25 */

// Legal values for BtCursor.curFlags

// Potential values for BtCursor.eState.
//
// CURSOR_INVALID:
//   Cursor does not point to a valid entry. This can happen (for example)
//   because the table is empty or because BtreeCursorFirst() has not been
//   called.
//
// CURSOR_VALID:
//   Cursor points to a valid entry. getPayload() etc. may be called.
//
// CURSOR_SKIPNEXT:
//   Cursor is valid except that the Cursor.skipNext field is non-zero
//   indicating that the next sqlite3BtreeNext() or sqlite3BtreePrevious()
//   operation should be a no-op.
//
// CURSOR_REQUIRESEEK:
//   The table that this cursor was opened on still exists, but has been
//   modified since the cursor was last used. The cursor position is saved
//   in variables BtCursor.pKey and BtCursor.nKey. When a cursor is in
//   this state, restoreCursorPosition() can be called to attempt to
//   seek the cursor to the saved position.
//
// CURSOR_FAULT:
//   An unrecoverable error (an I/O error or a malloc failure) has occurred
//   on a different connection that shares the BtShared cache with this
//   cursor.  The error has left the cache in an inconsistent state.
//   Do nothing else with this cursor.  Any attempt to use the cursor
//   should return the error code stored in BtCursor.skipNext

// The database page the PENDING_BYTE occupies. This page is never used.

// These macros define the location of the pointer-map entry for a
// database page. The first argument to each is the number of usable
// bytes on each page of the database (often 1024). The second is the
// page number to look up in the pointer map.
//
// PTRMAP_PAGENO returns the database page number of the pointer-map
// page that stores the required pointer. PTRMAP_PTROFFSET returns
// the offset of the requested map entry.
//
// If the pgno argument passed to PTRMAP_PAGENO is a pointer-map page,
// then pgno is returned. So (pgno==PTRMAP_PAGENO(pgsz, pgno)) can be
// used to test if pgno is a pointer-map page. PTRMAP_ISPAGE implements
// this test.

// The pointer map is a lookup table that identifies the parent page for
// each child page in the database file.  The parent page is the page that
// contains a pointer to the child.  Every page in the database contains
// 0 or 1 parent pages.  (In this context 'database page' refers
// to any page that is not part of the pointer map itself.)  Each pointer map
// entry consists of a single byte 'type' and a 4 byte parent page number.
// The PTRMAP_XXX identifiers below are the valid types.
//
// The purpose of the pointer map is to facility moving pages from one
// position in the file to another as part of autovacuum.  When a page
// is moved, the pointer in its parent must be updated to point to the
// new location.  The pointer map is used to locate the parent page quickly.
//
// PTRMAP_ROOTPAGE: The database page is a root-page. The page-number is not
//                  used in this case.
//
// PTRMAP_FREEPAGE: The database page is an unused (free) page. The page-number
//                  is not used in this case.
//
// PTRMAP_OVERFLOW1: The database page is the first page in a list of
//                   overflow pages. The page number identifies the page that
//                   contains the cell with a pointer to this overflow page.
//
// PTRMAP_OVERFLOW2: The database page is the second or later page in a list of
//                   overflow pages. The page-number identifies the previous
//                   page in the overflow page list.
//
// PTRMAP_BTREE: The database page is a non-root btree page. The page number
//               identifies the parent page in the btree.

// A bunch of assert() statements to check the transaction state variables
// of handle p (type Btree*) are internally consistent.

// The ISAUTOVACUUM macro is used within balance_nonroot() to determine
// if the database supports auto-vacuum or not. Because it is used
// within an expression that is an argument to another macro
// (sqliteMallocRaw), it is not possible to use conditional compilation.
// So, this macro is defined instead.

// This structure is passed around through all the sanity checking routines
// in order to keep track of some global state information.
//
// The aRef[] array is allocated so that there is 1 bit for each page in
// the database. As the integrity-check proceeds, for each page used in
// the database the corresponding bit is set. This allows integrity-check to
// detect pages that are used twice and orphaned pages (both of which
// indicate corruption).
type IntegrityCk1 = struct {
	FpBt          uintptr
	FpPager       uintptr
	FaPgRef       uintptr
	FnPage        Pgno
	FmxErr        int32
	FnErr         int32
	FmallocFailed int32
	FzPfx         uintptr
	Fv1           int32
	Fv2           int32
	FerrMsg       StrAccum
	Fheap         uintptr
	Fdb           uintptr
}

// Legal values for BtCursor.curFlags

// Potential values for BtCursor.eState.
//
// CURSOR_INVALID:
//   Cursor does not point to a valid entry. This can happen (for example)
//   because the table is empty or because BtreeCursorFirst() has not been
//   called.
//
// CURSOR_VALID:
//   Cursor points to a valid entry. getPayload() etc. may be called.
//
// CURSOR_SKIPNEXT:
//   Cursor is valid except that the Cursor.skipNext field is non-zero
//   indicating that the next sqlite3BtreeNext() or sqlite3BtreePrevious()
//   operation should be a no-op.
//
// CURSOR_REQUIRESEEK:
//   The table that this cursor was opened on still exists, but has been
//   modified since the cursor was last used. The cursor position is saved
//   in variables BtCursor.pKey and BtCursor.nKey. When a cursor is in
//   this state, restoreCursorPosition() can be called to attempt to
//   seek the cursor to the saved position.
//
// CURSOR_FAULT:
//   An unrecoverable error (an I/O error or a malloc failure) has occurred
//   on a different connection that shares the BtShared cache with this
//   cursor.  The error has left the cache in an inconsistent state.
//   Do nothing else with this cursor.  Any attempt to use the cursor
//   should return the error code stored in BtCursor.skipNext

// The database page the PENDING_BYTE occupies. This page is never used.

// These macros define the location of the pointer-map entry for a
// database page. The first argument to each is the number of usable
// bytes on each page of the database (often 1024). The second is the
// page number to look up in the pointer map.
//
// PTRMAP_PAGENO returns the database page number of the pointer-map
// page that stores the required pointer. PTRMAP_PTROFFSET returns
// the offset of the requested map entry.
//
// If the pgno argument passed to PTRMAP_PAGENO is a pointer-map page,
// then pgno is returned. So (pgno==PTRMAP_PAGENO(pgsz, pgno)) can be
// used to test if pgno is a pointer-map page. PTRMAP_ISPAGE implements
// this test.

// The pointer map is a lookup table that identifies the parent page for
// each child page in the database file.  The parent page is the page that
// contains a pointer to the child.  Every page in the database contains
// 0 or 1 parent pages.  (In this context 'database page' refers
// to any page that is not part of the pointer map itself.)  Each pointer map
// entry consists of a single byte 'type' and a 4 byte parent page number.
// The PTRMAP_XXX identifiers below are the valid types.
//
// The purpose of the pointer map is to facility moving pages from one
// position in the file to another as part of autovacuum.  When a page
// is moved, the pointer in its parent must be updated to point to the
// new location.  The pointer map is used to locate the parent page quickly.
//
// PTRMAP_ROOTPAGE: The database page is a root-page. The page-number is not
//                  used in this case.
//
// PTRMAP_FREEPAGE: The database page is an unused (free) page. The page-number
//                  is not used in this case.
//
// PTRMAP_OVERFLOW1: The database page is the first page in a list of
//                   overflow pages. The page number identifies the page that
//                   contains the cell with a pointer to this overflow page.
//
// PTRMAP_OVERFLOW2: The database page is the second or later page in a list of
//                   overflow pages. The page-number identifies the previous
//                   page in the overflow page list.
//
// PTRMAP_BTREE: The database page is a non-root btree page. The page number
//               identifies the parent page in the btree.

// A bunch of assert() statements to check the transaction state variables
// of handle p (type Btree*) are internally consistent.

// The ISAUTOVACUUM macro is used within balance_nonroot() to determine
// if the database supports auto-vacuum or not. Because it is used
// within an expression that is an argument to another macro
// (sqliteMallocRaw), it is not possible to use conditional compilation.
// So, this macro is defined instead.

// This structure is passed around through all the sanity checking routines
// in order to keep track of some global state information.
//
// The aRef[] array is allocated so that there is 1 bit for each page in
// the database. As the integrity-check proceeds, for each page used in
// the database the corresponding bit is set. This allows integrity-check to
// detect pages that are used twice and orphaned pages (both of which
// indicate corruption).
type IntegrityCk = IntegrityCk1 /* btreeInt.h:674:28 */

// A bogus sqlite3 connection structure for use in the btree
// tests.
var sDb sqlite31          /* test3.c:32:16: */
var nRefSqlite3 int32 = 0 /* test3.c:33:12 */

// Usage:   btree_open FILENAME NCACHE
//
// Open a new database
func btree_open(tls *crt.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test3.c:40:26: */
	bp := tls.Alloc(188)
	defer tls.Free(188)

	// var pBt uintptr at bp+80, 8

	var rc int32
	// var nCache int32 at bp+72, 4

	// var zBuf [100]int8 at bp+88, 100

	var n int32
	var zFilename uintptr
	if argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
			ts+30308 /* " FILENAME NCACHE..." */, 0))
		return 1
	}
	if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8)), bp+72 /* &nCache */) != 0 {
		return 1
	}
	nRefSqlite3++
	if nRefSqlite3 == 1 {
		sDb.FpVfs = sqlite3.Xsqlite3_vfs_find(tls, uintptr(0))
		sDb.Fmutex = sqlite3.Xsqlite3MutexAlloc(tls, 1)
		sqlite3.Xsqlite3_mutex_enter(tls, sDb.Fmutex)
	}
	n = int32(crt.Xstrlen(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8))))
	zFilename = sqlite3.Xsqlite3_malloc(tls, (n + 2))
	if zFilename == uintptr(0) {
		return 1
	}
	crt.Xmemcpy(tls, zFilename, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), (uint64(n + 1)))
	*(*int8)(unsafe.Pointer(zFilename + uintptr((n + 1)))) = int8(0)
	rc = sqlite3.Xsqlite3BtreeOpen(tls, sDb.FpVfs, zFilename, uintptr(unsafe.Pointer(&sDb)), bp+80 /* &pBt */, 0,
		((0x00000002 | 0x00000004) | 0x00000100))
	sqlite3.Xsqlite3_free(tls, zFilename)
	if rc != 0 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+32, sqlite3.Xsqlite3ErrName(tls, rc), 0))
		return 1
	}
	sqlite3.Xsqlite3BtreeSetCacheSize(tls, *(*uintptr)(unsafe.Pointer(bp + 80 /* pBt */)), *(*int32)(unsafe.Pointer(bp + 72 /* nCache */)))
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([100]int8{})), bp+88 /* &zBuf[0] */, ts+20002 /* "%p" */, crt.VaList(bp+48, *(*uintptr)(unsafe.Pointer(bp + 80 /* pBt */))))
	tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+56, bp+88 /* &zBuf[0] */, 0))
	return 0
}

// Usage:   btree_close ID
//
// Close the given database.
func btree_close(tls *crt.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test3.c:86:26: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var pBt uintptr
	var rc int32
	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
			ts+29636 /* " ID\"" */, 0))
		return 1
	}
	pBt = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)))
	rc = sqlite3.Xsqlite3BtreeClose(tls, pBt)
	if rc != 0 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+32, sqlite3.Xsqlite3ErrName(tls, rc), 0))
		return 1
	}
	nRefSqlite3--
	if nRefSqlite3 == 0 {
		sqlite3.Xsqlite3_mutex_leave(tls, sDb.Fmutex)
		sqlite3.Xsqlite3_mutex_free(tls, sDb.Fmutex)
		sDb.Fmutex = uintptr(0)
		sDb.FpVfs = uintptr(0)
	}
	return 0
}

// Usage:   btree_begin_transaction ID
//
// Start a new transaction
func btree_begin_transaction(tls *crt.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test3.c:121:26: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var pBt uintptr
	var rc int32
	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
			ts+29636 /* " ID\"" */, 0))
		return 1
	}
	pBt = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)))
	sqlite3.Xsqlite3BtreeEnter(tls, pBt)
	rc = sqlite3.Xsqlite3BtreeBeginTrans(tls, pBt, 1, uintptr(0))
	sqlite3.Xsqlite3BtreeLeave(tls, pBt)
	if rc != 0 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+32, sqlite3.Xsqlite3ErrName(tls, rc), 0))
		return 1
	}
	return 0
}

// Usage:   btree_pager_stats ID
//
// Returns pager statistics
func btree_pager_stats(tls *crt.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test3.c:150:26: */
	bp := tls.Alloc(140)
	defer tls.Free(140)

	var pBt uintptr
	var i int32
	var a uintptr

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
			ts+29636 /* " ID\"" */, 0))
		return 1
	}
	pBt = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)))

	// Normally in this file, with a b-tree handle opened using the
	// [btree_open] command it is safe to call sqlite3BtreeEnter() directly.
	// But this function is sometimes called with a btree handle obtained
	// from an open SQLite connection (using [btree_from_db]). In this case
	// we need to obtain the mutex for the controlling SQLite handle before
	// it is safe to call sqlite3BtreeEnter().
	sqlite3.Xsqlite3_mutex_enter(tls, (*sqlite31)(unsafe.Pointer((*Btree)(unsafe.Pointer(pBt)).Fdb)).Fmutex)

	sqlite3.Xsqlite3BtreeEnter(tls, pBt)
	a = sqlite3.Xsqlite3PagerStats(tls, sqlite3.Xsqlite3BtreePager(tls, pBt))
	for i = 0; i < 11; i++ {
		// var zBuf [100]int8 at bp+40, 100

		tcl.XTcl_AppendElement(tls, interp, zName1[i])
		sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([100]int8{})), bp+40 /* &zBuf[0] */, ts+1647 /* "%d" */, crt.VaList(bp+32, *(*int32)(unsafe.Pointer(a + uintptr(i)*4))))
		tcl.XTcl_AppendElement(tls, interp, bp+40 /* &zBuf[0] */)
	}
	sqlite3.Xsqlite3BtreeLeave(tls, pBt)

	// Release the mutex on the SQLite handle that controls this b-tree
	sqlite3.Xsqlite3_mutex_leave(tls, (*sqlite31)(unsafe.Pointer((*Btree)(unsafe.Pointer(pBt)).Fdb)).Fmutex)
	return 0
}

var zName1 = [11]uintptr{
	ts + 29641 /* "ref" */, ts + 29645 /* "page" */, ts + 24478 /* "max" */, ts + 18523 /* "size" */, ts + 16575 /* "state" */, ts + 29650, /* "err" */
	ts + 29654 /* "hit" */, ts + 29658 /* "miss" */, ts + 29663 /* "ovfl" */, ts + 30332 /* "read" */, ts + 30337, /* "write" */
} /* test3.c:179:17 */

// Usage:   btree_cursor ID TABLENUM WRITEABLE
//
// Create a new cursor.  Return the ID for the cursor.
func btree_cursor(tls *crt.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test3.c:200:26: */
	bp := tls.Alloc(110)
	defer tls.Free(110)

	var pBt uintptr
	// var iTable int32 at bp+72, 4

	var pCur uintptr
	var rc int32 = 0
	// var wrFlag int32 at bp+76, 4

	// var zBuf [30]int8 at bp+80, 30

	if argc != 4 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
			ts+30343 /* " ID TABLENUM WRI..." */, 0))
		return 1
	}
	pBt = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)))
	if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8)), bp+72 /* &iTable */) != 0 {
		return 1
	}
	if tcl.XTcl_GetBoolean(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(3)*8)), bp+76 /* &wrFlag */) != 0 {
		return 1
	}
	if *(*int32)(unsafe.Pointer(bp + 76 /* wrFlag */)) != 0 {
		*(*int32)(unsafe.Pointer(bp + 76 /* wrFlag */)) = 0x00000004
	}
	pCur = tcl.XTcl_Alloc(tls, uint32(sqlite3.Xsqlite3BtreeCursorSize(tls)))
	crt.Xmemset(tls, pCur, 0, uint64(sqlite3.Xsqlite3BtreeCursorSize(tls)))
	sqlite3.Xsqlite3_mutex_enter(tls, (*sqlite31)(unsafe.Pointer((*Btree)(unsafe.Pointer(pBt)).Fdb)).Fmutex)
	sqlite3.Xsqlite3BtreeEnter(tls, pBt)
	rc = sqlite3.Xsqlite3BtreeLockTable(tls, pBt, *(*int32)(unsafe.Pointer(bp + 72 /* iTable */)), crt.BoolUint8(!(!(*(*int32)(unsafe.Pointer(bp + 76 /* wrFlag */)) != 0))))
	if rc == 0 {
		rc = sqlite3.Xsqlite3BtreeCursor(tls, pBt, *(*int32)(unsafe.Pointer(bp + 72 /* iTable */)), *(*int32)(unsafe.Pointer(bp + 76 /* wrFlag */)), uintptr(0), pCur)
	}
	sqlite3.Xsqlite3BtreeLeave(tls, pBt)
	sqlite3.Xsqlite3_mutex_leave(tls, (*sqlite31)(unsafe.Pointer((*Btree)(unsafe.Pointer(pBt)).Fdb)).Fmutex)
	if rc != 0 {
		tcl.XTcl_Free(tls, pCur)
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+32, sqlite3.Xsqlite3ErrName(tls, rc), 0))
		return 1
	}
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([30]int8{})), bp+80 /* &zBuf[0] */, ts+20002 /* "%p" */, crt.VaList(bp+48, pCur))
	tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+56, bp+80 /* &zBuf[0] */, 0))
	return 0
}

// Usage:   btree_close_cursor ID
//
// Close a cursor opened using btree_cursor.
func btree_close_cursor(tls *crt.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test3.c:249:26: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var pCur uintptr
	var rc int32

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
			ts+29636 /* " ID\"" */, 0))
		return 1
	}
	pCur = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)))
	{
		var pBt uintptr = (*BtCursor)(unsafe.Pointer(pCur)).FpBtree
		sqlite3.Xsqlite3_mutex_enter(tls, (*sqlite31)(unsafe.Pointer((*Btree)(unsafe.Pointer(pBt)).Fdb)).Fmutex)
		sqlite3.Xsqlite3BtreeEnter(tls, pBt)
		rc = sqlite3.Xsqlite3BtreeCloseCursor(tls, pCur)
		sqlite3.Xsqlite3BtreeLeave(tls, pBt)
		sqlite3.Xsqlite3_mutex_leave(tls, (*sqlite31)(unsafe.Pointer((*Btree)(unsafe.Pointer(pBt)).Fdb)).Fmutex)
	}
	tcl.XTcl_Free(tls, pCur)
	if rc != 0 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+32, sqlite3.Xsqlite3ErrName(tls, rc), 0))
		return 1
	}
	return 0
}

// Usage:   btree_next ID
//
// Move the cursor to the next entry in the table.  Return 0 on success
// or 1 if the cursor was already on the last entry in the table or if
// the table is empty.
func btree_next(tls *crt.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test3.c:291:26: */
	bp := tls.Alloc(172)
	defer tls.Free(172)

	var pCur uintptr
	var rc int32
	var res int32 = 0
	// var zBuf [100]int8 at bp+72, 100

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
			ts+29636 /* " ID\"" */, 0))
		return 1
	}
	pCur = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)))
	sqlite3.Xsqlite3BtreeEnter(tls, (*BtCursor)(unsafe.Pointer(pCur)).FpBtree)
	rc = sqlite3.Xsqlite3BtreeNext(tls, pCur, 0)
	if rc == 101 {
		res = 1
		rc = 0
	}
	sqlite3.Xsqlite3BtreeLeave(tls, (*BtCursor)(unsafe.Pointer(pCur)).FpBtree)
	if rc != 0 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+32, sqlite3.Xsqlite3ErrName(tls, rc), 0))
		return 1
	}
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([100]int8{})), bp+72 /* &zBuf[0] */, ts+1647 /* "%d" */, crt.VaList(bp+48, res))
	tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+56, bp+72 /* &zBuf[0] */, 0))
	return 0
}

// Usage:   btree_first ID
//
// Move the cursor to the first entry in the table.  Return 0 if the
// cursor was left point to something and 1 if the table is empty.
func btree_first(tls *crt.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test3.c:330:26: */
	bp := tls.Alloc(176)
	defer tls.Free(176)

	var pCur uintptr
	var rc int32
	*(*int32)(unsafe.Pointer(bp + 72 /* res */)) = 0
	// var zBuf [100]int8 at bp+76, 100

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
			ts+29636 /* " ID\"" */, 0))
		return 1
	}
	pCur = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)))
	sqlite3.Xsqlite3BtreeEnter(tls, (*BtCursor)(unsafe.Pointer(pCur)).FpBtree)
	rc = sqlite3.Xsqlite3BtreeFirst(tls, pCur, bp+72 /* &res */)
	sqlite3.Xsqlite3BtreeLeave(tls, (*BtCursor)(unsafe.Pointer(pCur)).FpBtree)
	if rc != 0 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+32, sqlite3.Xsqlite3ErrName(tls, rc), 0))
		return 1
	}
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([100]int8{})), bp+76 /* &zBuf[0] */, ts+1647 /* "%d" */, crt.VaList(bp+48, *(*int32)(unsafe.Pointer(bp + 72 /* res */))))
	tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+56, bp+76 /* &zBuf[0] */, 0))
	return 0
}

// Usage:   btree_eof ID
//
// Return TRUE if the given cursor is not pointing at a valid entry.
// Return FALSE if the cursor does point to a valid entry.
func btree_eof(tls *crt.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test3.c:365:26: */
	bp := tls.Alloc(106)
	defer tls.Free(106)

	var pCur uintptr
	var rc int32
	// var zBuf [50]int8 at bp+56, 50

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
			ts+29636 /* " ID\"" */, 0))
		return 1
	}
	pCur = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)))
	sqlite3.Xsqlite3BtreeEnter(tls, (*BtCursor)(unsafe.Pointer(pCur)).FpBtree)
	rc = sqlite3.Xsqlite3BtreeEof(tls, pCur)
	sqlite3.Xsqlite3BtreeLeave(tls, (*BtCursor)(unsafe.Pointer(pCur)).FpBtree)
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([50]int8{})), bp+56 /* &zBuf[0] */, ts+1647 /* "%d" */, crt.VaList(bp+32, rc))
	tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+40, bp+56 /* &zBuf[0] */, 0))
	return 0
}

// Usage:   btree_payload_size ID
//
// Return the number of bytes of payload
func btree_payload_size(tls *crt.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test3.c:394:26: */
	bp := tls.Alloc(106)
	defer tls.Free(106)

	var pCur uintptr
	var n u32
	// var zBuf [50]int8 at bp+56, 50

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
			ts+29636 /* " ID\"" */, 0))
		return 1
	}
	pCur = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)))
	sqlite3.Xsqlite3BtreeEnter(tls, (*BtCursor)(unsafe.Pointer(pCur)).FpBtree)
	n = sqlite3.Xsqlite3BtreePayloadSize(tls, pCur)
	sqlite3.Xsqlite3BtreeLeave(tls, (*BtCursor)(unsafe.Pointer(pCur)).FpBtree)
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([50]int8{})), bp+56 /* &zBuf[0] */, ts+24028 /* "%u" */, crt.VaList(bp+32, n))
	tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+40, bp+56 /* &zBuf[0] */, 0))
	return 0
}

// usage:   varint_test  START  MULTIPLIER  COUNT  INCREMENT
//
// This command tests the putVarint() and getVarint()
// routines, both for accuracy and for speed.
//
// An integer is written using putVarint() and read back with
// getVarint() and varified to be unchanged.  This repeats COUNT
// times.  The first integer is START*MULTIPLIER.  Each iteration
// increases the integer by INCREMENT.
//
// This command returns nothing if it works.  It returns an error message
// if something goes wrong.
func btree_varint_test(tls *crt.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test3.c:432:26: */
	bp := tls.Alloc(516)
	defer tls.Free(516)

	// var start u32 at bp+184, 4

	// var mult u32 at bp+188, 4

	// var count u32 at bp+192, 4

	// var incr u32 at bp+196, 4

	var in u64
	// var out u64 at bp+504, 8

	var n1 int32
	var n2 int32
	var i int32
	var j int32
	// var zBuf [100]uint8 at bp+200, 100

	if argc != 5 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
			ts+30367 /* " START MULTIPLIE..." */, 0))
		return 1
	}
	if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), bp+184 /* &start */) != 0 {
		return 1
	}
	if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8)), bp+188 /* &mult */) != 0 {
		return 1
	}
	if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(3)*8)), bp+192 /* &count */) != 0 {
		return 1
	}
	if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(4)*8)), bp+196 /* &incr */) != 0 {
		return 1
	}
	in = u64(*(*u32)(unsafe.Pointer(bp + 184 /* start */)))
	in = in * (u64(*(*u32)(unsafe.Pointer(bp + 188 /* mult */))))
	for i = 0; i < int32(*(*u32)(unsafe.Pointer(bp + 192 /* count */))); i++ {
		// var zErr [200]int8 at bp+300, 200

		n1 = sqlite3.Xsqlite3PutVarint(tls, bp+200 /* &zBuf[0] */, in)
		if (n1 > 9) || (n1 < 1) {
			sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([200]int8{})), bp+300, /* &zErr[0] */
				ts+30402 /* "putVarint return..." */, crt.VaList(bp+32, n1))
			tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+40, bp+300 /* &zErr[0] */, 0))
			return 1
		}
		n2 = int32(sqlite3.Xsqlite3GetVarint(tls, bp+200 /* &zBuf[0] */, bp+504 /* &out */))
		if n1 != n2 {
			sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([200]int8{})), bp+300, /* &zErr[0] */
				ts+30452 /* "putVarint return..." */, crt.VaList(bp+56, n1, n2))
			tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+72, bp+300 /* &zErr[0] */, 0))
			return 1
		}
		if in != *(*u64)(unsafe.Pointer(bp + 504 /* out */)) {
			sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([200]int8{})), bp+300, /* &zErr[0] */
				ts+30500 /* "Wrote 0x%016llx ..." */, crt.VaList(bp+88, in, *(*u64)(unsafe.Pointer(bp + 504 /* out */))))
			tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+104, bp+300 /* &zErr[0] */, 0))
			return 1
		}
		if (in & uint64(0xffffffff)) == in {
			// var out32 u32 at bp+512, 4

			n2 = int32(func() uint8 {
				if int32(*(*uint8)(unsafe.Pointer(bp + 200 /* zBuf */))) < int32(u8(0x80)) {
					return uint8(func() int32 {
						(*(*u32)(unsafe.Pointer(bp + 512 /* out32 */))) = u32(*(*uint8)(unsafe.Pointer(bp + 200 /* zBuf */)))
						return 1
					}())
				}
				return sqlite3.Xsqlite3GetVarint32(tls, bp+200 /* &zBuf[0] */, bp+512 /* &out32 */)
			}())
			*(*u64)(unsafe.Pointer(bp + 504 /* out */)) = u64(*(*u32)(unsafe.Pointer(bp + 512 /* out32 */)))
			if n1 != n2 {
				sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([200]int8{})), bp+300, /* &zErr[0] */
					ts+30539, /* "putVarint return..." */
					crt.VaList(bp+120, n1, n2))
				tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+136, bp+300 /* &zErr[0] */, 0))
				return 1
			}
			if in != *(*u64)(unsafe.Pointer(bp + 504 /* out */)) {
				sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([200]int8{})), bp+300, /* &zErr[0] */
					ts+30589, /* "Wrote 0x%016llx ..." */
					crt.VaList(bp+152, in, *(*u64)(unsafe.Pointer(bp + 504 /* out */))))
				tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+168, bp+300 /* &zErr[0] */, 0))
				return 1
			}
		}

		// In order to get realistic timings, run getVarint 19 more times.
		// This is because getVarint is called about 20 times more often
		// than putVarint.
		for j = 0; j < 19; j++ {
			sqlite3.Xsqlite3GetVarint(tls, bp+200 /* &zBuf[0] */, bp+504 /* &out */)
		}
		in = in + (u64(*(*u32)(unsafe.Pointer(bp + 196 /* incr */))))
	}
	return 0
}

// usage:   btree_from_db  DB-HANDLE
//
// This command returns the btree handle for the main database associated
// with the database-handle passed as the argument. Example usage:
//
// sqlite3 db test.db
// set bt [btree_from_db db]
func btree_from_db(tls *crt.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test3.c:516:26: */
	bp := tls.Alloc(236)
	defer tls.Free(236)

	// var zBuf [100]int8 at bp+136, 100

	// var info Tcl_CmdInfo at bp+72, 64

	var db uintptr
	var pBt uintptr
	var iDb int32 = 0

	if (argc != 2) && (argc != 3) {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
			ts+30645 /* " DB-HANDLE ?N?\"" */, 0))
		return 1
	}

	if 1 != tcl.XTcl_GetCommandInfo(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), bp+72 /* &info */) {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+32, ts+30661 /* "No such db-handl..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), ts+18666 /* "\"" */, 0))
		return 1
	}
	if argc == 3 {
		iDb = crt.Xatoi(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8)))
	}

	db = *(*uintptr)(unsafe.Pointer((*Tcl_CmdInfo)(unsafe.Pointer(bp + 72 /* &info */)).FobjClientData))

	pBt = (*Db)(unsafe.Pointer((*sqlite31)(unsafe.Pointer(db)).FaDb + uintptr(iDb)*32)).FpBt
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([100]int8{})), bp+136 /* &zBuf[0] */, ts+20002 /* "%p" */, crt.VaList(bp+64, pBt))
	tcl.XTcl_SetResult(tls, interp, bp+136 /* &zBuf[0] */, uintptr(1))
	return 0
}

// Usage:   btree_ismemdb ID
//
// Return true if the B-Tree is currently stored entirely in memory.
func btree_ismemdb(tls *crt.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test3.c:556:26: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var pBt uintptr
	var res int32
	var pFile uintptr

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
			ts+29636 /* " ID\"" */, 0))
		return 1
	}
	pBt = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)))
	sqlite3.Xsqlite3_mutex_enter(tls, (*sqlite31)(unsafe.Pointer((*Btree)(unsafe.Pointer(pBt)).Fdb)).Fmutex)
	sqlite3.Xsqlite3BtreeEnter(tls, pBt)
	pFile = sqlite3.Xsqlite3PagerFile(tls, sqlite3.Xsqlite3BtreePager(tls, pBt))
	res = (crt.Bool32((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods == uintptr(0)))
	sqlite3.Xsqlite3BtreeLeave(tls, pBt)
	sqlite3.Xsqlite3_mutex_leave(tls, (*sqlite31)(unsafe.Pointer((*Btree)(unsafe.Pointer(pBt)).Fdb)).Fmutex)
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, (crt.Bool32((res) != 0))))
	return 0
}

// usage:   btree_set_cache_size ID NCACHE
//
// Set the size of the cache used by btree $ID.
func btree_set_cache_size(tls *crt.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test3.c:587:26: */
	bp := tls.Alloc(36)
	defer tls.Free(36)

	// var nCache int32 at bp+32, 4

	var pBt uintptr

	if argc != 3 {
		tcl.XTcl_AppendResult(tls,
			interp, crt.VaList(bp, ts+21615 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)), ts+30682 /* " BT NCACHE\"" */, 0))
		return 1
	}
	pBt = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)))
	if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8)), bp+32 /* &nCache */) != 0 {
		return 1
	}

	sqlite3.Xsqlite3_mutex_enter(tls, (*sqlite31)(unsafe.Pointer((*Btree)(unsafe.Pointer(pBt)).Fdb)).Fmutex)
	sqlite3.Xsqlite3BtreeEnter(tls, pBt)
	sqlite3.Xsqlite3BtreeSetCacheSize(tls, pBt, *(*int32)(unsafe.Pointer(bp + 32 /* nCache */)))
	sqlite3.Xsqlite3BtreeLeave(tls, pBt)
	sqlite3.Xsqlite3_mutex_leave(tls, (*sqlite31)(unsafe.Pointer((*Btree)(unsafe.Pointer(pBt)).Fdb)).Fmutex)
	return 0
}

// usage:   btree_insert CSR ?KEY? VALUE
//
// Set the size of the cache used by btree $ID.
func btree_insert(tls *crt.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test3.c:617:26: */
	bp := tls.Alloc(68)
	defer tls.Free(68)

	var pCur uintptr
	// var rc int32 at bp+64, 4

	// var x BtreePayload at bp+16, 48

	if (objc != 4) && (objc != 3) {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+30694 /* "?-intkey? CSR KE..." */)
		return 1
	}

	crt.Xmemset(tls, bp+16 /* &x */, 0, uint64(unsafe.Sizeof(BtreePayload{})))
	if objc == 4 {
		if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)), bp+64 /* &rc */) != 0 {
			return 1
		}
		(*BtreePayload)(unsafe.Pointer(bp + 16 /* &x */)).FnKey = sqlite3_int64(*(*int32)(unsafe.Pointer(bp + 64 /* rc */)))
		(*BtreePayload)(unsafe.Pointer(bp + 16 /* &x */)).FpData = tcl.XTcl_GetByteArrayFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(3)*8)), (bp + 16 /* &x */ + 36 /* &.nData */))
	} else {
		(*BtreePayload)(unsafe.Pointer(bp + 16 /* &x */)).FpKey = tcl.XTcl_GetByteArrayFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)), bp+64 /* &rc */)
		(*BtreePayload)(unsafe.Pointer(bp + 16 /* &x */)).FnKey = sqlite3_int64(*(*int32)(unsafe.Pointer(bp + 64 /* rc */)))
	}
	pCur = sqlite3TestTextToPtr(tls, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))))

	sqlite3.Xsqlite3_mutex_enter(tls, (*sqlite31)(unsafe.Pointer((*Btree)(unsafe.Pointer((*BtCursor)(unsafe.Pointer(pCur)).FpBtree)).Fdb)).Fmutex)
	sqlite3.Xsqlite3BtreeEnter(tls, (*BtCursor)(unsafe.Pointer(pCur)).FpBtree)
	*(*int32)(unsafe.Pointer(bp + 64 /* rc */)) = sqlite3.Xsqlite3BtreeInsert(tls, pCur, bp+16 /* &x */, 0, 0)
	sqlite3.Xsqlite3BtreeLeave(tls, (*BtCursor)(unsafe.Pointer(pCur)).FpBtree)
	sqlite3.Xsqlite3_mutex_leave(tls, (*sqlite31)(unsafe.Pointer((*Btree)(unsafe.Pointer((*BtCursor)(unsafe.Pointer(pCur)).FpBtree)).Fdb)).Fmutex)

	tcl.XTcl_ResetResult(tls, interp)
	if *(*int32)(unsafe.Pointer(bp + 64 /* rc */)) != 0 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, sqlite3.Xsqlite3ErrName(tls, *(*int32)(unsafe.Pointer(bp + 64 /* rc */))), 0))
		return 1
	}
	return 0
}

// Register commands with the TCL interpreter.
func Sqlitetest3_Init(tls *crt.TLS, interp uintptr) int32 { /* test3.c:661:5: */
	var i int32

	for i = 0; uint64(i) < (uint64(unsafe.Sizeof(aCmd2)) / uint64(unsafe.Sizeof(struct {
		FzName uintptr
		FxProc uintptr
	}{}))); i++ {
		tcl.XTcl_CreateCommand(tls, interp, aCmd2[i].FzName, aCmd2[i].FxProc, uintptr(0), uintptr(0))
	}

	tcl.XTcl_CreateObjCommand(tls, interp, ts+30718 /* "btree_insert" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
	}{btree_insert})), uintptr(0), uintptr(0))

	return 0
}

var aCmd2 = [14]struct {
	FzName uintptr
	FxProc uintptr
}{
	{FzName: ts + 30731 /* "btree_open" */, FxProc: 0},
	{FzName: ts + 30742 /* "btree_close" */, FxProc: 0},
	{FzName: ts + 30754 /* "btree_begin_tran..." */, FxProc: 0},
	{FzName: ts + 30778 /* "btree_pager_stat..." */, FxProc: 0},
	{FzName: ts + 30796 /* "btree_cursor" */, FxProc: 0},
	{FzName: ts + 30809 /* "btree_close_curs..." */, FxProc: 0},
	{FzName: ts + 30828 /* "btree_next" */, FxProc: 0},
	{FzName: ts + 30839 /* "btree_eof" */, FxProc: 0},
	{FzName: ts + 30849 /* "btree_payload_si..." */, FxProc: 0},
	{FzName: ts + 30868 /* "btree_first" */, FxProc: 0},
	{FzName: ts + 30880 /* "btree_varint_tes..." */, FxProc: 0},
	{FzName: ts + 30898 /* "btree_from_db" */, FxProc: 0},
	{FzName: ts + 30912 /* "btree_ismemdb" */, FxProc: 0},
	{FzName: ts + 30926 /* "btree_set_cache_..." */, FxProc: 0},
} /* test3.c:665:5 */

// Basic access functions.

// Data structure to describe CPU mask.
type cpu_set_t = struct{ F__bits [16]uint64 } /* cpu-set.h:42:3 */

// Each thread is controlled by an instance of the following
// structure.
type Thread1 = struct {
	FzFilename  uintptr
	FxOp        uintptr
	FzArg       uintptr
	Fopnum      int32
	Fbusy       int32
	Fcompleted  int32
	Fdb         uintptr
	FpStmt      uintptr
	FzErr       uintptr
	FzStaticErr uintptr
	Frc         int32
	Fargc       int32
	Fargv       [100]uintptr
	Fcolv       [100]uintptr
}

// Each thread is controlled by an instance of the following
// structure.
type Thread = Thread1 /* test4.c:33:23 */

// There can be as many as 26 threads running at once.  Each is named
// by a capital letter: A, B, C, ..., Y, Z.
var threadset [26]Thread /* test4.c:61:15: */

// The main loop for a thread.  Threads use busy waiting.
func test_thread_main(tls *crt.TLS, pArg uintptr) uintptr { /* test4.c:67:13: */
	var p uintptr = pArg
	if (*Thread)(unsafe.Pointer(p)).Fdb != 0 {
		sqlite3.Xsqlite3_close(tls, (*Thread)(unsafe.Pointer(p)).Fdb)
	}
	sqlite3.Xsqlite3_open(tls, (*Thread)(unsafe.Pointer(p)).FzFilename, (p + 40 /* &.db */))
	if 0 != sqlite3.Xsqlite3_errcode(tls, (*Thread)(unsafe.Pointer(p)).Fdb) {
		(*Thread)(unsafe.Pointer(p)).FzErr = crt.Xstrdup(tls, sqlite3.Xsqlite3_errmsg(tls, (*Thread)(unsafe.Pointer(p)).Fdb))
		sqlite3.Xsqlite3_close(tls, (*Thread)(unsafe.Pointer(p)).Fdb)
		(*Thread)(unsafe.Pointer(p)).Fdb = uintptr(0)
	}
	(*Thread)(unsafe.Pointer(p)).FpStmt = uintptr(0)
	(*Thread)(unsafe.Pointer(p)).Fcompleted = 1
	for (*Thread)(unsafe.Pointer(p)).Fopnum <= (*Thread)(unsafe.Pointer(p)).Fcompleted {
		crt2.Xsched_yield(tls)
	}
	for (*Thread)(unsafe.Pointer(p)).FxOp != 0 {
		if ((*Thread)(unsafe.Pointer(p)).FzErr != 0) && ((*Thread)(unsafe.Pointer(p)).FzErr != (*Thread)(unsafe.Pointer(p)).FzStaticErr) {
			sqlite3.Xsqlite3_free(tls, (*Thread)(unsafe.Pointer(p)).FzErr)
			(*Thread)(unsafe.Pointer(p)).FzErr = uintptr(0)
		}
		(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((p + 8 /* &.xOp */))))(tls, p)
		(*Thread)(unsafe.Pointer(p)).Fcompleted++
		for (*Thread)(unsafe.Pointer(p)).Fopnum <= (*Thread)(unsafe.Pointer(p)).Fcompleted {
			crt2.Xsched_yield(tls)
		}
	}
	if (*Thread)(unsafe.Pointer(p)).FpStmt != 0 {
		sqlite3.Xsqlite3_finalize(tls, (*Thread)(unsafe.Pointer(p)).FpStmt)
		(*Thread)(unsafe.Pointer(p)).FpStmt = uintptr(0)
	}
	if (*Thread)(unsafe.Pointer(p)).Fdb != 0 {
		sqlite3.Xsqlite3_close(tls, (*Thread)(unsafe.Pointer(p)).Fdb)
		(*Thread)(unsafe.Pointer(p)).Fdb = uintptr(0)
	}
	if ((*Thread)(unsafe.Pointer(p)).FzErr != 0) && ((*Thread)(unsafe.Pointer(p)).FzErr != (*Thread)(unsafe.Pointer(p)).FzStaticErr) {
		sqlite3.Xsqlite3_free(tls, (*Thread)(unsafe.Pointer(p)).FzErr)
		(*Thread)(unsafe.Pointer(p)).FzErr = uintptr(0)
	}
	(*Thread)(unsafe.Pointer(p)).Fcompleted++
	sqlite3.Xsqlite3_thread_cleanup(tls)
	return uintptr(0)
}

// Get a thread ID which is an upper case letter.  Return the index.
// If the argument is not a valid thread ID put an error message in
// the interpreter and return -1.
func parse_thread_id(tls *crt.TLS, interp uintptr, zArg uintptr) int32 { /* test4.c:114:12: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	if (((zArg == uintptr(0)) || (int32(*(*int8)(unsafe.Pointer(zArg + uintptr(0)))) == 0)) || (int32(*(*int8)(unsafe.Pointer(zArg + uintptr(1)))) != 0)) || !((int32(*(*uint16)(unsafe.Pointer((*(*uintptr)(unsafe.Pointer(crt.X__ctype_b_loc(tls)))) + uintptr(int32(uint8(*(*int8)(unsafe.Pointer(zArg + uintptr(0))))))*2))) & int32(uint16(256))) != 0) {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+30947 /* "thread ID must b..." */, 0))
		return -1
	}
	return (int32(*(*int8)(unsafe.Pointer(zArg + uintptr(0)))) - 'A')
}

// Usage:    thread_create NAME  FILENAME
//
// NAME should be an upper case letter.  Start the thread running with
// an open connection to the given database.
func tcl_thread_create(tls *crt.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test4.c:128:26: */
	bp := tls.Alloc(96)
	defer tls.Free(96)

	var i int32
	// var x pthread_t at bp+88, 8

	var rc int32

	if argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
			ts+30986 /* " ID FILENAME" */, 0))
		return 1
	}
	i = parse_thread_id(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)))
	if i < 0 {
		return 1
	}
	if threadset[i].Fbusy != 0 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+32, ts+30999 /* "thread " */, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), ts+31007 /* " is already runn..." */, 0))
		return 1
	}
	threadset[i].Fbusy = 1
	sqlite3.Xsqlite3_free(tls, threadset[i].FzFilename)
	threadset[i].FzFilename = sqlite3.Xsqlite3_mprintf(tls, ts+130 /* "%s" */, crt.VaList(bp+64, *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8))))
	threadset[i].Fopnum = 1
	threadset[i].Fcompleted = 0
	rc = crt2.Xpthread_create(tls, bp+88 /* &x */, uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr) uintptr
	}{test_thread_main})), (uintptr(unsafe.Pointer(&threadset)) + uintptr(i)*1680))
	if rc != 0 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+72, ts+31027 /* "failed to create..." */, 0))
		sqlite3.Xsqlite3_free(tls, threadset[i].FzFilename)
		threadset[i].Fbusy = 0
		return 1
	}
	crt2.Xpthread_detach(tls, *(*pthread_t)(unsafe.Pointer(bp + 88 /* x */)))
	return 0
}

// Wait for a thread to reach its idle state.
func test_thread_wait(tls *crt.TLS, p uintptr) { /* test4.c:168:13: */
	for (*Thread)(unsafe.Pointer(p)).Fopnum > (*Thread)(unsafe.Pointer(p)).Fcompleted {
		crt2.Xsched_yield(tls)
	}
}

// Usage:  thread_wait ID
//
// Wait on thread ID to reach its idle state.
func tcl_thread_wait(tls *crt.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test4.c:177:26: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var i int32

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
			ts+31055 /* " ID" */, 0))
		return 1
	}
	i = parse_thread_id(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)))
	if i < 0 {
		return 1
	}
	if !(threadset[i].Fbusy != 0) {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+32, ts+31059 /* "no such thread" */, 0))
		return 1
	}
	test_thread_wait(tls, (uintptr(unsafe.Pointer(&threadset)) + uintptr(i)*1680))
	return 0
}

// Stop a thread.
func test_stop_thread(tls *crt.TLS, p uintptr) { /* test4.c:203:13: */
	test_thread_wait(tls, p)
	(*Thread)(unsafe.Pointer(p)).FxOp = uintptr(0)
	(*Thread)(unsafe.Pointer(p)).Fopnum++
	test_thread_wait(tls, p)
	sqlite3.Xsqlite3_free(tls, (*Thread)(unsafe.Pointer(p)).FzArg)
	(*Thread)(unsafe.Pointer(p)).FzArg = uintptr(0)
	sqlite3.Xsqlite3_free(tls, (*Thread)(unsafe.Pointer(p)).FzFilename)
	(*Thread)(unsafe.Pointer(p)).FzFilename = uintptr(0)
	(*Thread)(unsafe.Pointer(p)).Fbusy = 0
}

// Usage:  thread_halt ID
//
// Cause a thread to shut itself down.  Wait for the shutdown to be
// completed.  If ID is "*" then stop all threads.
func tcl_thread_halt(tls *crt.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test4.c:221:26: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var i int32

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
			ts+31055 /* " ID" */, 0))
		return 1
	}
	if (int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)) + uintptr(0)))) == '*') && (int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)) + uintptr(1)))) == 0) {
		for i = 0; i < 26; i++ {
			if threadset[i].Fbusy != 0 {
				test_stop_thread(tls, (uintptr(unsafe.Pointer(&threadset)) + uintptr(i)*1680))
			}
		}
	} else {
		i = parse_thread_id(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)))
		if i < 0 {
			return 1
		}
		if !(threadset[i].Fbusy != 0) {
			tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+32, ts+31059 /* "no such thread" */, 0))
			return 1
		}
		test_stop_thread(tls, (uintptr(unsafe.Pointer(&threadset)) + uintptr(i)*1680))
	}
	return 0
}

// Usage: thread_argc  ID
//
// Wait on the most recent thread_step to complete, then return the
// number of columns in the result set.
func tcl_thread_argc(tls *crt.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test4.c:256:26: */
	bp := tls.Alloc(172)
	defer tls.Free(172)

	var i int32
	// var zBuf [100]int8 at bp+72, 100

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
			ts+31055 /* " ID" */, 0))
		return 1
	}
	i = parse_thread_id(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)))
	if i < 0 {
		return 1
	}
	if !(threadset[i].Fbusy != 0) {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+32, ts+31059 /* "no such thread" */, 0))
		return 1
	}
	test_thread_wait(tls, (uintptr(unsafe.Pointer(&threadset)) + uintptr(i)*1680))
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([100]int8{})), bp+72 /* &zBuf[0] */, ts+1647 /* "%d" */, crt.VaList(bp+48, threadset[i].Fargc))
	tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+56, bp+72 /* &zBuf[0] */, 0))
	return 0
}

// Usage: thread_argv  ID   N
//
// Wait on the most recent thread_step to complete, then return the
// value of the N-th columns in the result set.
func tcl_thread_argv(tls *crt.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test4.c:288:26: */
	bp := tls.Alloc(84)
	defer tls.Free(84)

	var i int32
	// var n int32 at bp+80, 4

	if argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
			ts+31074 /* " ID N" */, 0))
		return 1
	}
	i = parse_thread_id(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)))
	if i < 0 {
		return 1
	}
	if !(threadset[i].Fbusy != 0) {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+32, ts+31059 /* "no such thread" */, 0))
		return 1
	}
	if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8)), bp+80 /* &n */) != 0 {
		return 1
	}
	test_thread_wait(tls, (uintptr(unsafe.Pointer(&threadset)) + uintptr(i)*1680))
	if (*(*int32)(unsafe.Pointer(bp + 80 /* n */)) < 0) || (*(*int32)(unsafe.Pointer(bp + 80 /* n */)) >= threadset[i].Fargc) {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+48, ts+31080 /* "column number ou..." */, 0))
		return 1
	}
	tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+64, *(*uintptr)(unsafe.Pointer((uintptr(unsafe.Pointer(&threadset)) + uintptr(i)*1680 + 80 /* &.argv */) + uintptr(*(*int32)(unsafe.Pointer(bp + 80 /* n */)))*8)), 0))
	return 0
}

// Usage: thread_colname  ID   N
//
// Wait on the most recent thread_step to complete, then return the
// name of the N-th columns in the result set.
func tcl_thread_colname(tls *crt.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test4.c:324:26: */
	bp := tls.Alloc(84)
	defer tls.Free(84)

	var i int32
	// var n int32 at bp+80, 4

	if argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
			ts+31074 /* " ID N" */, 0))
		return 1
	}
	i = parse_thread_id(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)))
	if i < 0 {
		return 1
	}
	if !(threadset[i].Fbusy != 0) {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+32, ts+31059 /* "no such thread" */, 0))
		return 1
	}
	if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8)), bp+80 /* &n */) != 0 {
		return 1
	}
	test_thread_wait(tls, (uintptr(unsafe.Pointer(&threadset)) + uintptr(i)*1680))
	if (*(*int32)(unsafe.Pointer(bp + 80 /* n */)) < 0) || (*(*int32)(unsafe.Pointer(bp + 80 /* n */)) >= threadset[i].Fargc) {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+48, ts+31080 /* "column number ou..." */, 0))
		return 1
	}
	tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+64, *(*uintptr)(unsafe.Pointer((uintptr(unsafe.Pointer(&threadset)) + uintptr(i)*1680 + 880 /* &.colv */) + uintptr(*(*int32)(unsafe.Pointer(bp + 80 /* n */)))*8)), 0))
	return 0
}

// Usage: thread_result  ID
//
// Wait on the most recent operation to complete, then return the
// result code from that operation.
func tcl_thread_result(tls *crt.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test4.c:360:26: */
	bp := tls.Alloc(64)
	defer tls.Free(64)

	var i int32
	var zName uintptr

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
			ts+31055 /* " ID" */, 0))
		return 1
	}
	i = parse_thread_id(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)))
	if i < 0 {
		return 1
	}
	if !(threadset[i].Fbusy != 0) {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+32, ts+31059 /* "no such thread" */, 0))
		return 1
	}
	test_thread_wait(tls, (uintptr(unsafe.Pointer(&threadset)) + uintptr(i)*1680))
	zName = sqlite3.Xsqlite3ErrName(tls, threadset[i].Frc)
	tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+48, zName, 0))
	return 0
}

// Usage: thread_error  ID
//
// Wait on the most recent operation to complete, then return the
// error string.
func tcl_thread_error(tls *crt.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test4.c:392:26: */
	bp := tls.Alloc(64)
	defer tls.Free(64)

	var i int32

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
			ts+31055 /* " ID" */, 0))
		return 1
	}
	i = parse_thread_id(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)))
	if i < 0 {
		return 1
	}
	if !(threadset[i].Fbusy != 0) {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+32, ts+31059 /* "no such thread" */, 0))
		return 1
	}
	test_thread_wait(tls, (uintptr(unsafe.Pointer(&threadset)) + uintptr(i)*1680))
	tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+48, threadset[i].FzErr, 0))
	return 0
}

// This procedure runs in the thread to compile an SQL statement.
func do_compile(tls *crt.TLS, p uintptr) { /* test4.c:419:13: */
	if (*Thread)(unsafe.Pointer(p)).Fdb == uintptr(0) {
		(*Thread)(unsafe.Pointer(p)).FzErr = crt.AssignPtrUintptr(p+64 /* &.zStaticErr */, ts+31107 /* "no database is o..." */)
		(*Thread)(unsafe.Pointer(p)).Frc = 1
		return
	}
	if (*Thread)(unsafe.Pointer(p)).FpStmt != 0 {
		sqlite3.Xsqlite3_finalize(tls, (*Thread)(unsafe.Pointer(p)).FpStmt)
		(*Thread)(unsafe.Pointer(p)).FpStmt = uintptr(0)
	}
	(*Thread)(unsafe.Pointer(p)).Frc = sqlite3.Xsqlite3_prepare(tls, (*Thread)(unsafe.Pointer(p)).Fdb, (*Thread)(unsafe.Pointer(p)).FzArg, -1, (p + 48 /* &.pStmt */), uintptr(0))
}

// Usage: thread_compile ID SQL
//
// Compile a new virtual machine.
func tcl_thread_compile(tls *crt.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test4.c:437:26: */
	bp := tls.Alloc(56)
	defer tls.Free(56)

	var i int32
	if argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
			ts+31127 /* " ID SQL" */, 0))
		return 1
	}
	i = parse_thread_id(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)))
	if i < 0 {
		return 1
	}
	if !(threadset[i].Fbusy != 0) {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+32, ts+31059 /* "no such thread" */, 0))
		return 1
	}
	test_thread_wait(tls, (uintptr(unsafe.Pointer(&threadset)) + uintptr(i)*1680))
	threadset[i].FxOp = *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, uintptr) }{do_compile}))
	sqlite3.Xsqlite3_free(tls, threadset[i].FzArg)
	threadset[i].FzArg = sqlite3.Xsqlite3_mprintf(tls, ts+130 /* "%s" */, crt.VaList(bp+48, *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8))))
	threadset[i].Fopnum++
	return 0
}

// This procedure runs in the thread to step the virtual machine.
func do_step(tls *crt.TLS, p uintptr) { /* test4.c:466:13: */
	var i int32
	if (*Thread)(unsafe.Pointer(p)).FpStmt == uintptr(0) {
		(*Thread)(unsafe.Pointer(p)).FzErr = crt.AssignPtrUintptr(p+64 /* &.zStaticErr */, ts+31135 /* "no virtual machi..." */)
		(*Thread)(unsafe.Pointer(p)).Frc = 1
		return
	}
	(*Thread)(unsafe.Pointer(p)).Frc = sqlite3.Xsqlite3_step(tls, (*Thread)(unsafe.Pointer(p)).FpStmt)
	if (*Thread)(unsafe.Pointer(p)).Frc == 100 {
		(*Thread)(unsafe.Pointer(p)).Fargc = sqlite3.Xsqlite3_column_count(tls, (*Thread)(unsafe.Pointer(p)).FpStmt)
		for i = 0; i < sqlite3.Xsqlite3_data_count(tls, (*Thread)(unsafe.Pointer(p)).FpStmt); i++ {
			*(*uintptr)(unsafe.Pointer((p + 80 /* &.argv */) + uintptr(i)*8)) = sqlite3.Xsqlite3_column_text(tls, (*Thread)(unsafe.Pointer(p)).FpStmt, i)
		}
		for i = 0; i < (*Thread)(unsafe.Pointer(p)).Fargc; i++ {
			*(*uintptr)(unsafe.Pointer((p + 880 /* &.colv */) + uintptr(i)*8)) = sqlite3.Xsqlite3_column_name(tls, (*Thread)(unsafe.Pointer(p)).FpStmt, i)
		}
	}
}

// Usage: thread_step ID
//
// Advance the virtual machine by one step
func tcl_thread_step(tls *crt.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test4.c:490:26: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var i int32
	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
			ts+31164 /* " IDL" */, 0))
		return 1
	}
	i = parse_thread_id(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)))
	if i < 0 {
		return 1
	}
	if !(threadset[i].Fbusy != 0) {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+32, ts+31059 /* "no such thread" */, 0))
		return 1
	}
	test_thread_wait(tls, (uintptr(unsafe.Pointer(&threadset)) + uintptr(i)*1680))
	threadset[i].FxOp = *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, uintptr) }{do_step}))
	threadset[i].Fopnum++
	return 0
}

// This procedure runs in the thread to finalize a virtual machine.
func do_finalize(tls *crt.TLS, p uintptr) { /* test4.c:517:13: */
	if (*Thread)(unsafe.Pointer(p)).FpStmt == uintptr(0) {
		(*Thread)(unsafe.Pointer(p)).FzErr = crt.AssignPtrUintptr(p+64 /* &.zStaticErr */, ts+31135 /* "no virtual machi..." */)
		(*Thread)(unsafe.Pointer(p)).Frc = 1
		return
	}
	(*Thread)(unsafe.Pointer(p)).Frc = sqlite3.Xsqlite3_finalize(tls, (*Thread)(unsafe.Pointer(p)).FpStmt)
	(*Thread)(unsafe.Pointer(p)).FpStmt = uintptr(0)
}

// Usage: thread_finalize ID
//
// Finalize the virtual machine.
func tcl_thread_finalize(tls *crt.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test4.c:532:26: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var i int32
	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
			ts+31164 /* " IDL" */, 0))
		return 1
	}
	i = parse_thread_id(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)))
	if i < 0 {
		return 1
	}
	if !(threadset[i].Fbusy != 0) {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+32, ts+31059 /* "no such thread" */, 0))
		return 1
	}
	test_thread_wait(tls, (uintptr(unsafe.Pointer(&threadset)) + uintptr(i)*1680))
	threadset[i].FxOp = *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, uintptr) }{do_finalize}))
	sqlite3.Xsqlite3_free(tls, threadset[i].FzArg)
	threadset[i].FzArg = uintptr(0)
	threadset[i].Fopnum++
	return 0
}

// Usage: thread_swap ID ID
//
// Interchange the sqlite* pointer between two threads.
func tcl_thread_swap(tls *crt.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test4.c:563:26: */
	bp := tls.Alloc(64)
	defer tls.Free(64)

	var i int32
	var j int32
	var temp uintptr
	if argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
			ts+31169 /* " ID1 ID2" */, 0))
		return 1
	}
	i = parse_thread_id(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)))
	if i < 0 {
		return 1
	}
	if !(threadset[i].Fbusy != 0) {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+32, ts+31059 /* "no such thread" */, 0))
		return 1
	}
	test_thread_wait(tls, (uintptr(unsafe.Pointer(&threadset)) + uintptr(i)*1680))
	j = parse_thread_id(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8)))
	if j < 0 {
		return 1
	}
	if !(threadset[j].Fbusy != 0) {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+48, ts+31059 /* "no such thread" */, 0))
		return 1
	}
	test_thread_wait(tls, (uintptr(unsafe.Pointer(&threadset)) + uintptr(j)*1680))
	temp = threadset[i].Fdb
	threadset[i].Fdb = threadset[j].Fdb
	threadset[j].Fdb = temp
	return 0
}

// Usage: thread_db_get ID
//
// Return the database connection pointer for the given thread.  Then
// remove the pointer from the thread itself.  Afterwards, the thread
// can be stopped and the connection can be used by the main thread.
func tcl_thread_db_get(tls *crt.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test4.c:603:26: */
	bp := tls.Alloc(164)
	defer tls.Free(164)

	var i int32
	// var zBuf [100]int8 at bp+64, 100

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
			ts+31055 /* " ID" */, 0))
		return 1
	}
	i = parse_thread_id(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)))
	if i < 0 {
		return 1
	}
	if !(threadset[i].Fbusy != 0) {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+32, ts+31059 /* "no such thread" */, 0))
		return 1
	}
	test_thread_wait(tls, (uintptr(unsafe.Pointer(&threadset)) + uintptr(i)*1680))
	sqlite3TestMakePointerStr(tls, interp, bp+64 /* &zBuf[0] */, threadset[i].Fdb)
	threadset[i].Fdb = uintptr(0)
	tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+48, bp+64 /* &zBuf[0] */, uintptr(0)))
	return 0
}

// Usage: thread_db_put ID DB
//
func tcl_thread_db_put(tls *crt.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test4.c:634:26: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var i int32
	if argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
			ts+31178 /* " ID DB" */, 0))
		return 1
	}
	i = parse_thread_id(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)))
	if i < 0 {
		return 1
	}
	if !(threadset[i].Fbusy != 0) {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+32, ts+31059 /* "no such thread" */, 0))
		return 1
	}
	test_thread_wait(tls, (uintptr(unsafe.Pointer(&threadset)) + uintptr(i)*1680))

	threadset[i].Fdb = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8)))
	return 0
}

// Usage: thread_stmt_get ID
//
// Return the database stmt pointer for the given thread.  Then
// remove the pointer from the thread itself.
func tcl_thread_stmt_get(tls *crt.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test4.c:666:26: */
	bp := tls.Alloc(164)
	defer tls.Free(164)

	var i int32
	// var zBuf [100]int8 at bp+64, 100

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
			ts+31055 /* " ID" */, 0))
		return 1
	}
	i = parse_thread_id(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)))
	if i < 0 {
		return 1
	}
	if !(threadset[i].Fbusy != 0) {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+32, ts+31059 /* "no such thread" */, 0))
		return 1
	}
	test_thread_wait(tls, (uintptr(unsafe.Pointer(&threadset)) + uintptr(i)*1680))
	sqlite3TestMakePointerStr(tls, interp, bp+64 /* &zBuf[0] */, threadset[i].FpStmt)
	threadset[i].FpStmt = uintptr(0)
	tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+48, bp+64 /* &zBuf[0] */, uintptr(0)))
	return 0
}

// Register commands with the TCL interpreter.
func Sqlitetest4_Init(tls *crt.TLS, interp uintptr) int32 { /* test4.c:696:5: */
	var i int32

	for i = 0; uint64(i) < (uint64(unsafe.Sizeof(aCmd3)) / uint64(unsafe.Sizeof(struct {
		FzName uintptr
		FxProc uintptr
	}{}))); i++ {
		tcl.XTcl_CreateCommand(tls, interp, aCmd3[i].FzName, aCmd3[i].FxProc, uintptr(0), uintptr(0))
	}
	return 0
}

var aCmd3 = [15]struct {
	FzName uintptr
	FxProc uintptr
}{
	{FzName: ts + 31185 /* "thread_create" */, FxProc: 0},
	{FzName: ts + 31199 /* "thread_wait" */, FxProc: 0},
	{FzName: ts + 31211 /* "thread_halt" */, FxProc: 0},
	{FzName: ts + 31223 /* "thread_argc" */, FxProc: 0},
	{FzName: ts + 31235 /* "thread_argv" */, FxProc: 0},
	{FzName: ts + 31247 /* "thread_colname" */, FxProc: 0},
	{FzName: ts + 31262 /* "thread_result" */, FxProc: 0},
	{FzName: ts + 31276 /* "thread_error" */, FxProc: 0},
	{FzName: ts + 31289 /* "thread_compile" */, FxProc: 0},
	{FzName: ts + 31304 /* "thread_step" */, FxProc: 0},
	{FzName: ts + 31316 /* "thread_finalize" */, FxProc: 0},
	{FzName: ts + 31332 /* "thread_swap" */, FxProc: 0},
	{FzName: ts + 31344 /* "thread_db_get" */, FxProc: 0},
	{FzName: ts + 31358 /* "thread_db_put" */, FxProc: 0},
	{FzName: ts + 31372 /* "thread_stmt_get" */, FxProc: 0},
} /* test4.c:700:5 */

// end block for C++

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:
// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.20 General utilities	<stdlib.h>

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.21 String handling	<string.h>

// The first argument is a TCL UTF-8 string. Return the byte array
// object with the encoded representation of the string, including
// the NULL terminator.
func binarize(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test5.c:33:26: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	// var len int32 at bp, 4

	var bytes uintptr
	var pRet uintptr

	bytes = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)), bp /* &len */)
	pRet = tcl.XTcl_NewByteArrayObj(tls, bytes, (*(*int32)(unsafe.Pointer(bp /* len */)) + 1))
	tcl.XTcl_SetObjResult(tls, interp, pRet)
	return 0
}

// Usage: test_value_overhead <repeat-count> <do-calls>.
//
// This routine is used to test the overhead of calls to
// sqlite3_value_text(), on a value that contains a UTF-8 string. The idea
// is to figure out whether or not it is a problem to use sqlite3_value
// structures with collation sequence functions.
//
// If <do-calls> is 0, then the calls to sqlite3_value_text() are not
// actually made.
func test_value_overhead(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test5.c:61:26: */
	bp := tls.Alloc(96)
	defer tls.Free(96)

	// var do_calls int32 at bp+36, 4

	// var repeat_count int32 at bp+32, 4

	var i int32
	// var val Mem at bp+40, 56

	if objc != 3 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615, /* "wrong # args: sh..." */
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(0)*8)), uintptr(0)), ts+31388 /* " <repeat-count> ..." */, 0))
		return 1
	}

	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)), bp+32 /* &repeat_count */) != 0 {
		return 1
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)), bp+36 /* &do_calls */) != 0 {
		return 1
	}

	(*Mem)(unsafe.Pointer(bp + 40 /* &val */)).Fflags = (u16((0x0002 | 0x0200) | 0x0800))
	(*Mem)(unsafe.Pointer(bp + 40 /* &val */)).Fz = ts + 31415 /* "hello world" */
	(*Mem)(unsafe.Pointer(bp + 40 /* &val */)).Fenc = u8(1)

	for i = 0; i < *(*int32)(unsafe.Pointer(bp + 32 /* repeat_count */)); i++ {
		if *(*int32)(unsafe.Pointer(bp + 36 /* do_calls */)) != 0 {
			sqlite3.Xsqlite3_value_text(tls, bp+40 /* &val */)
		}
	}

	return 0
}

func name_to_enc(tls *crt.TLS, interp uintptr, pObj uintptr) u8 { /* test5.c:94:11: */
	bp := tls.Alloc(104)
	defer tls.Free(104)

	*(*[5]EncName)(unsafe.Pointer(bp + 24 /* encnames */)) = [5]EncName{
		{FzName: ts + 31427 /* "UTF8" */, Fenc: u8(1)},
		{FzName: ts + 31432 /* "UTF16LE" */, Fenc: u8(2)},
		{FzName: ts + 31440 /* "UTF16BE" */, Fenc: u8(3)},
		{FzName: ts + 31448 /* "UTF16" */, Fenc: u8(4)},
		{FzName: uintptr(0), Fenc: u8(0)},
	}
	var pEnc uintptr
	var z uintptr = tcl.XTcl_GetString(tls, pObj)
	for pEnc = (bp + 24 /* &encnames */ + uintptr(0)*16); (*EncName)(unsafe.Pointer(pEnc)).FzName != 0; pEnc += 16 {
		if 0 == sqlite3.Xsqlite3StrICmp(tls, z, (*EncName)(unsafe.Pointer(pEnc)).FzName) {
			break
		}
	}
	if !(int32((*EncName)(unsafe.Pointer(pEnc)).Fenc) != 0) {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+31454 /* "No such encoding..." */, z, 0))
	}
	if int32((*EncName)(unsafe.Pointer(pEnc)).Fenc) == 4 {
		return u8(2)
	}
	return (*EncName)(unsafe.Pointer(pEnc)).Fenc
}

type EncName = struct {
	FzName uintptr
	Fenc   u8
	_      [7]byte
}

// Usage:   test_translate <string/blob> <from enc> <to enc> ?<transient>?
//
func test_translate(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test5.c:125:26: */
	bp := tls.Alloc(44)
	defer tls.Free(44)

	var enc_from u8
	var enc_to u8
	var pVal uintptr
	var z uintptr
	// var len int32 at bp+40, 4

	var xDel uintptr = uintptr(0)

	if (objc != 4) && (objc != 5) {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615, /* "wrong # args: sh..." */
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(0)*8)), uintptr(0)),
			ts+31473 /* " <string/blob> <..." */, 0))
		return 1
	}
	if objc == 5 {
		xDel = *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, uintptr) }{sqlite3.Xsqlite3_free}))
	}

	enc_from = name_to_enc(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)))
	if !(enc_from != 0) {
		return 1
	}
	enc_to = name_to_enc(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(3)*8)))
	if !(enc_to != 0) {
		return 1
	}

	pVal = sqlite3.Xsqlite3ValueNew(tls, uintptr(0))

	if int32(enc_from) == 1 {
		z = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)))
		if objc == 5 {
			z = sqlite3.Xsqlite3_mprintf(tls, ts+130 /* "%s" */, crt.VaList(bp+32, z))
		}
		sqlite3.Xsqlite3ValueSetStr(tls, pVal, -1, z, enc_from, xDel)
	} else {
		z = tcl.XTcl_GetByteArrayFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)), bp+40 /* &len */)
		if objc == 5 {
			var zTmp uintptr = z
			z = sqlite3.Xsqlite3_malloc(tls, *(*int32)(unsafe.Pointer(bp + 40 /* len */)))
			crt.Xmemcpy(tls, z, zTmp, uint64(*(*int32)(unsafe.Pointer(bp + 40 /* len */))))
		}
		sqlite3.Xsqlite3ValueSetStr(tls, pVal, -1, z, enc_from, xDel)
	}

	z = sqlite3.Xsqlite3ValueText(tls, pVal, enc_to)
	*(*int32)(unsafe.Pointer(bp + 40 /* len */)) = (sqlite3.Xsqlite3ValueBytes(tls, pVal, enc_to) + (func() int32 {
		if int32(enc_to) == 1 {
			return 1
		}
		return 2
	}()))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewByteArrayObj(tls, z, *(*int32)(unsafe.Pointer(bp + 40 /* len */))))

	sqlite3.Xsqlite3ValueFree(tls, pVal)

	return 0
}
func test_translate_selftest(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test5.c:189:26: */
	return 0
}

// Register commands with the TCL interpreter.
func Sqlitetest5_Init(tls *crt.TLS, interp uintptr) int32 { /* test5.c:205:5: */
	var i int32
	for i = 0; uint64(i) < (uint64(unsafe.Sizeof(aCmd4)) / uint64(unsafe.Sizeof(struct {
		FzName uintptr
		FxProc uintptr
	}{}))); i++ {
		tcl.XTcl_CreateObjCommand(tls, interp, aCmd4[i].FzName, aCmd4[i].FxProc, uintptr(0), uintptr(0))
	}
	return 0
}

var aCmd4 = [4]struct {
	FzName uintptr
	FxProc uintptr
}{
	{FzName: ts + 31508 /* "binarize" */, FxProc: 0},
	{FzName: ts + 31517 /* "test_value_overh..." */, FxProc: 0},
	{FzName: ts + 31537 /* "test_translate" */, FxProc: 0},
	{FzName: ts + 31552 /* "translate_selfte..." */, FxProc: 0},
} /* test5.c:209:5 */

// end block for C++

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:

// #define TRACE_CRASHTEST

type CrashFile1 = struct {
	FpMethod   uintptr
	FpRealFile uintptr
	FzName     uintptr
	Fflags     int32
	FzData     uintptr
	FnData     int32
	FiSize     i64
}

// end block for C++

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:

// #define TRACE_CRASHTEST

type CrashFile = CrashFile1 /* test6.c:29:26 */
type CrashGlobal1 = struct {
	FpWriteList             uintptr
	FpWriteListEnd          uintptr
	FiSectorSize            int32
	FiDeviceCharacteristics int32
	FiCrash                 int32
	FzCrashFile             [500]int8
}

type CrashGlobal = CrashGlobal1 /* test6.c:30:28 */
type WriteBuffer1 = struct {
	FiOffset i64
	FnBuf    int32
	FzBuf    uintptr
	FpFile   uintptr
	FpNext   uintptr
}

type WriteBuffer = WriteBuffer1 /* test6.c:31:28 */

var g = CrashGlobal{FpWriteList: uintptr(0), FpWriteListEnd: uintptr(0), FiSectorSize: 4096, FiDeviceCharacteristics: 0, FiCrash: 0} /* test6.c:156:20 */

// Set this global variable to 1 to enable crash testing.
var sqlite3CrashTestEnable int32 = 0 /* test6.c:161:12 */

func crash_malloc(tls *crt.TLS, nByte int32) uintptr { /* test6.c:163:13: */
	return tcl.XTcl_AttemptAlloc(tls, uint32(size_t(nByte)))
}
func crash_free(tls *crt.TLS, p uintptr) { /* test6.c:166:13: */
	tcl.XTcl_Free(tls, p)
}
func crash_realloc(tls *crt.TLS, p uintptr, n int32) uintptr { /* test6.c:169:13: */
	return tcl.XTcl_AttemptRealloc(tls, p, uint32(size_t(n)))
}

// Wrapper around the sqlite3OsWrite() function that avoids writing to the
// 512 byte block begining at offset PENDING_BYTE.
func writeDbFile(tls *crt.TLS, p uintptr, z uintptr, iAmt i64, iOff i64) int32 { /* test6.c:177:12: */
	var rc int32 = 0
	var iSkip int32 = 0
	if (iAmt - i64(iSkip)) > int64(0) {
		rc = sqlite3.Xsqlite3OsWrite(tls, (*CrashFile)(unsafe.Pointer(p)).FpRealFile, (z + uintptr(iSkip)), (int32(iAmt - i64(iSkip))), (iOff + i64(iSkip)))
	}
	return rc
}

// Flush the write-list as if xSync() had been called on file handle
// pFile. If isCrash is true, simulate a crash.
func writeListSync(tls *crt.TLS, pFile uintptr, isCrash int32) int32 { /* test6.c:190:12: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var rc int32 = 0
	var iDc int32 = g.FiDeviceCharacteristics
	var pWrite uintptr
	var ppPtr uintptr

	// If this is not a crash simulation, set pFinal to point to the
	// last element of the write-list that is associated with file handle
	// pFile.
	//
	// If this is a crash simulation, set pFinal to an arbitrarily selected
	// element of the write-list.
	var pFinal uintptr = uintptr(0)
	if !(isCrash != 0) {
		for pWrite = g.FpWriteList; pWrite != 0; pWrite = (*WriteBuffer)(unsafe.Pointer(pWrite)).FpNext {
			if (*WriteBuffer)(unsafe.Pointer(pWrite)).FpFile == pFile {
				pFinal = pWrite
			}
		}
	} else if (iDc & (0x00000400 | 0x00000200)) != 0 {
		var nWrite int32 = 0
		// var iFinal int32 at bp, 4

		for pWrite = g.FpWriteList; pWrite != 0; pWrite = (*WriteBuffer)(unsafe.Pointer(pWrite)).FpNext {
			nWrite++
		}
		sqlite3.Xsqlite3_randomness(tls, int32(unsafe.Sizeof(int32(0))), bp /* &iFinal */)
		*(*int32)(unsafe.Pointer(bp /* iFinal */)) = ((func() int32 {
			if *(*int32)(unsafe.Pointer(bp /* iFinal */)) < 0 {
				return (-1 * *(*int32)(unsafe.Pointer(bp /* iFinal */)))
			}
			return *(*int32)(unsafe.Pointer(bp /* iFinal */))
		}()) % nWrite)
		for pWrite = g.FpWriteList; *(*int32)(unsafe.Pointer(bp /* iFinal */)) > 0; pWrite = (*WriteBuffer)(unsafe.Pointer(pWrite)).FpNext {
			*(*int32)(unsafe.Pointer(bp /* iFinal */))--
		}
		pFinal = pWrite
	}

	ppPtr = (uintptr(unsafe.Pointer(&g)) /* &.pWriteList */)
	for pWrite = *(*uintptr)(unsafe.Pointer(ppPtr)); (rc == 0) && (pWrite != 0); pWrite = *(*uintptr)(unsafe.Pointer(ppPtr)) {
		var pRealFile uintptr = (*CrashFile)(unsafe.Pointer((*WriteBuffer)(unsafe.Pointer(pWrite)).FpFile)).FpRealFile

		// (eAction==1)      -> write block out normally,
		// (eAction==2)      -> do nothing,
		// (eAction==3)      -> trash sectors.
		var eAction int32 = 0
		if !(isCrash != 0) {
			eAction = 2
			if ((*WriteBuffer)(unsafe.Pointer(pWrite)).FpFile == pFile) || ((iDc & 0x00000400) != 0) {
				eAction = 1
			}
		} else {
			// var random int8 at bp+4, 1

			sqlite3.Xsqlite3_randomness(tls, 1, bp+4 /* &random */)

			// Do not select option 3 (sector trashing) if the IOCAP_ATOMIC flag
			// is set or this is an OsTruncate(), not an Oswrite().
			if ((iDc & 0x00000001) != 0) || ((*WriteBuffer)(unsafe.Pointer(pWrite)).FzBuf == uintptr(0)) {
				*(*int8)(unsafe.Pointer(bp + 4 /* random */)) &= int8(0x01)
			}

			// If IOCAP_SEQUENTIAL is set and this is not the final entry
			// in the truncated write-list, always select option 1 (write
			// out correctly).
			if ((iDc & 0x00000400) != 0) && (pWrite != pFinal) {
				*(*int8)(unsafe.Pointer(bp + 4 /* random */)) = int8(0)
			}

			// If IOCAP_SAFE_APPEND is set and this OsWrite() operation is
			// an append (first byte of the written region is 1 byte past the
			// current EOF), always select option 1 (write out correctly).
			if ((iDc & 0x00000200) != 0) && ((*WriteBuffer)(unsafe.Pointer(pWrite)).FzBuf != 0) {
				// var iSize i64 at bp+8, 8

				sqlite3.Xsqlite3OsFileSize(tls, pRealFile, bp+8 /* &iSize */)
				if *(*i64)(unsafe.Pointer(bp + 8 /* iSize */)) == (*WriteBuffer)(unsafe.Pointer(pWrite)).FiOffset {
					*(*int8)(unsafe.Pointer(bp + 4 /* random */)) = int8(0)
				}
			}

			if (int32(*(*int8)(unsafe.Pointer(bp + 4 /* random */))) & 0x06) == 0x06 {
				eAction = 3
			} else {
				eAction = func() int32 {
					if (int32(*(*int8)(unsafe.Pointer(bp + 4 /* random */))) & 0x01) != 0 {
						return 2
					}
					return 1
				}()
			}
		}

		switch eAction {
		case 1:
			{ // Write out correctly
				if (*WriteBuffer)(unsafe.Pointer(pWrite)).FzBuf != 0 {
					rc = writeDbFile(tls,
						(*WriteBuffer)(unsafe.Pointer(pWrite)).FpFile, (*WriteBuffer)(unsafe.Pointer(pWrite)).FzBuf, int64((*WriteBuffer)(unsafe.Pointer(pWrite)).FnBuf), (*WriteBuffer)(unsafe.Pointer(pWrite)).FiOffset)
				} else {
					rc = sqlite3.Xsqlite3OsTruncate(tls, pRealFile, (*WriteBuffer)(unsafe.Pointer(pWrite)).FiOffset)
				}
				*(*uintptr)(unsafe.Pointer(ppPtr)) = (*WriteBuffer)(unsafe.Pointer(pWrite)).FpNext
				crash_free(tls, pWrite)
				break
			}
		case 2:
			{ // Do nothing
				ppPtr = (pWrite + 32 /* &.pNext */)
				break
			}
		case 3:
			{ // Trash sectors
				var zGarbage uintptr
				var iFirst int32 = (int32((*WriteBuffer)(unsafe.Pointer(pWrite)).FiOffset / i64(g.FiSectorSize)))
				var iLast int32 = (int32((((*WriteBuffer)(unsafe.Pointer(pWrite)).FiOffset + i64((*WriteBuffer)(unsafe.Pointer(pWrite)).FnBuf)) - int64(1)) / i64(g.FiSectorSize)))

				zGarbage = crash_malloc(tls, g.FiSectorSize)
				if zGarbage != 0 {
					var i sqlite3_int64
					for i = sqlite3_int64(iFirst); (rc == 0) && (i <= sqlite3_int64(iLast)); i++ {
						sqlite3.Xsqlite3_randomness(tls, g.FiSectorSize, zGarbage)
						rc = writeDbFile(tls,
							(*WriteBuffer)(unsafe.Pointer(pWrite)).FpFile, zGarbage, int64(g.FiSectorSize), (i * sqlite3_int64(g.FiSectorSize)))
					}
					crash_free(tls, zGarbage)
				} else {
					rc = 7
				}

				ppPtr = (pWrite + 32 /* &.pNext */)
				break
			}

		default:
		}

		if pWrite == pFinal {
			break
		}
	}

	if (rc == 0) && (isCrash != 0) {
		crt.Xexit(tls, -1)
	}

	for pWrite = g.FpWriteList; (pWrite != 0) && ((*WriteBuffer)(unsafe.Pointer(pWrite)).FpNext != 0); pWrite = (*WriteBuffer)(unsafe.Pointer(pWrite)).FpNext {
	}
	g.FpWriteListEnd = pWrite

	return rc
}

// Add an entry to the end of the write-list.
func writeListAppend(tls *crt.TLS, pFile uintptr, iOffset sqlite3_int64, zBuf uintptr, nBuf int32) int32 { /* test6.c:362:12: */
	var pNew uintptr

	pNew = crash_malloc(tls, (int32(uint64(unsafe.Sizeof(WriteBuffer{})) + uint64(nBuf))))
	if pNew == uintptr(0) {
		crt.Xfprintf(tls, crt.Xstderr, ts+31571 /* "out of memory in..." */, 0)
	}
	crt.Xmemset(tls, pNew, 0, (uint64(unsafe.Sizeof(WriteBuffer{})) + uint64(nBuf)))
	(*WriteBuffer)(unsafe.Pointer(pNew)).FiOffset = iOffset
	(*WriteBuffer)(unsafe.Pointer(pNew)).FnBuf = nBuf
	(*WriteBuffer)(unsafe.Pointer(pNew)).FpFile = pFile
	if zBuf != 0 {
		(*WriteBuffer)(unsafe.Pointer(pNew)).FzBuf = (pNew + uintptr(1)*40)
		crt.Xmemcpy(tls, (*WriteBuffer)(unsafe.Pointer(pNew)).FzBuf, zBuf, uint64(nBuf))
	}

	if g.FpWriteList != 0 {

		(*WriteBuffer)(unsafe.Pointer(g.FpWriteListEnd)).FpNext = pNew
	} else {
		g.FpWriteList = pNew
	}
	g.FpWriteListEnd = pNew

	return 0
}

// Close a crash-file.
func cfClose(tls *crt.TLS, pFile uintptr) int32 { /* test6.c:399:12: */
	var pCrash uintptr = pFile
	writeListSync(tls, pCrash, 0)
	sqlite3.Xsqlite3OsClose(tls, (*CrashFile)(unsafe.Pointer(pCrash)).FpRealFile)
	return 0
}

// Read data from a crash-file.
func cfRead(tls *crt.TLS, pFile uintptr, zBuf uintptr, iAmt int32, iOfst sqlite_int64) int32 { /* test6.c:409:12: */
	var pCrash uintptr = pFile
	var nCopy int32 = func() int32 {
		if (i64(iAmt)) < ((*CrashFile)(unsafe.Pointer(pCrash)).FiSize - iOfst) {
			return int32(i64(iAmt))
		}
		return (int32((*CrashFile)(unsafe.Pointer(pCrash)).FiSize - iOfst))
	}()

	if nCopy > 0 {
		crt.Xmemcpy(tls, zBuf, ((*CrashFile)(unsafe.Pointer(pCrash)).FzData + uintptr(iOfst)), uint64(nCopy))
	}

	// Check the file-size to see if this is a short-read
	if nCopy < iAmt {
		return (10 | (int32(2) << 8))
	}

	return 0
}

// Write data to a crash-file.
func cfWrite(tls *crt.TLS, pFile uintptr, zBuf uintptr, iAmt int32, iOfst sqlite_int64) int32 { /* test6.c:433:12: */
	var pCrash uintptr = pFile
	if (sqlite_int64(iAmt) + iOfst) > (*CrashFile)(unsafe.Pointer(pCrash)).FiSize {
		(*CrashFile)(unsafe.Pointer(pCrash)).FiSize = i64((int32(sqlite_int64(iAmt) + iOfst)))
	}
	for (*CrashFile)(unsafe.Pointer(pCrash)).FiSize > i64((*CrashFile)(unsafe.Pointer(pCrash)).FnData) {
		var zNew uintptr
		var nNew int32 = (((*CrashFile)(unsafe.Pointer(pCrash)).FnData * 2) + 4096)
		zNew = crash_realloc(tls, (*CrashFile)(unsafe.Pointer(pCrash)).FzData, nNew)
		if !(zNew != 0) {
			return 7
		}
		crt.Xmemset(tls, (zNew + uintptr((*CrashFile)(unsafe.Pointer(pCrash)).FnData)), 0, (uint64(nNew - (*CrashFile)(unsafe.Pointer(pCrash)).FnData)))
		(*CrashFile)(unsafe.Pointer(pCrash)).FnData = nNew
		(*CrashFile)(unsafe.Pointer(pCrash)).FzData = zNew
	}
	crt.Xmemcpy(tls, ((*CrashFile)(unsafe.Pointer(pCrash)).FzData + uintptr(iOfst)), zBuf, uint64(iAmt))
	return writeListAppend(tls, pFile, iOfst, zBuf, iAmt)
}

// Truncate a crash-file.
func cfTruncate(tls *crt.TLS, pFile uintptr, size sqlite_int64) int32 { /* test6.c:461:12: */
	var pCrash uintptr = pFile

	if (*CrashFile)(unsafe.Pointer(pCrash)).FiSize > size {
		(*CrashFile)(unsafe.Pointer(pCrash)).FiSize = i64(int32(size))
	}
	return writeListAppend(tls, pFile, size, uintptr(0), 0)
}

// Sync a crash-file.
func cfSync(tls *crt.TLS, pFile uintptr, flags int32) int32 { /* test6.c:473:12: */
	var pCrash uintptr = pFile
	var isCrash int32 = 0

	var zName uintptr = (*CrashFile)(unsafe.Pointer(pCrash)).FzName
	var zCrashFile uintptr = uintptr(unsafe.Pointer(&g)) + 28 /* &.zCrashFile */
	var nName int32 = int32(crt.Xstrlen(tls, zName))
	var nCrashFile int32 = int32(crt.Xstrlen(tls, zCrashFile))

	if (nCrashFile > 0) && (int32(*(*int8)(unsafe.Pointer(zCrashFile + uintptr((nCrashFile - 1))))) == '*') {
		nCrashFile--
		if nName > nCrashFile {
			nName = nCrashFile
		}
	}

	if (nName == nCrashFile) && (0 == crt.Xmemcmp(tls, zName, zCrashFile, uint64(nName))) {
		if (crt.PreDecInt32(&g.FiCrash, 1)) == 0 {
			isCrash = 1
		}
	}

	return writeListSync(tls, pCrash, isCrash)
}

// Return the current file-size of the crash-file.
func cfFileSize(tls *crt.TLS, pFile uintptr, pSize uintptr) int32 { /* test6.c:505:12: */
	var pCrash uintptr = pFile
	*(*sqlite_int64)(unsafe.Pointer(pSize)) = (*CrashFile)(unsafe.Pointer(pCrash)).FiSize
	return 0
}

// Calls related to file-locks are passed on to the real file handle.
func cfLock(tls *crt.TLS, pFile uintptr, eLock int32) int32 { /* test6.c:514:12: */
	return sqlite3.Xsqlite3OsLock(tls, (*CrashFile)(unsafe.Pointer(pFile)).FpRealFile, eLock)
}
func cfUnlock(tls *crt.TLS, pFile uintptr, eLock int32) int32 { /* test6.c:517:12: */
	return sqlite3.Xsqlite3OsUnlock(tls, (*CrashFile)(unsafe.Pointer(pFile)).FpRealFile, eLock)
}
func cfCheckReservedLock(tls *crt.TLS, pFile uintptr, pResOut uintptr) int32 { /* test6.c:520:12: */
	return sqlite3.Xsqlite3OsCheckReservedLock(tls, (*CrashFile)(unsafe.Pointer(pFile)).FpRealFile, pResOut)
}
func cfFileControl(tls *crt.TLS, pFile uintptr, op int32, pArg uintptr) int32 { /* test6.c:523:12: */
	if op == 5 {
		var pCrash uintptr = pFile
		var nByte i64 = *(*i64)(unsafe.Pointer(pArg))
		if nByte > (*CrashFile)(unsafe.Pointer(pCrash)).FiSize {
			if 0 == writeListAppend(tls, pFile, nByte, uintptr(0), 0) {
				(*CrashFile)(unsafe.Pointer(pCrash)).FiSize = i64(int32(nByte))
			}
		}
		return 0
	}
	return sqlite3.Xsqlite3OsFileControl(tls, (*CrashFile)(unsafe.Pointer(pFile)).FpRealFile, op, pArg)
}

// The xSectorSize() and xDeviceCharacteristics() functions return
// the global values configured by the [sqlite_crashparams] tcl
//  interface.
func cfSectorSize(tls *crt.TLS, pFile uintptr) int32 { /* test6.c:542:12: */
	return g.FiSectorSize
}
func cfDeviceCharacteristics(tls *crt.TLS, pFile uintptr) int32 { /* test6.c:545:12: */
	return g.FiDeviceCharacteristics
}

// Pass-throughs for WAL support.
func cfShmLock(tls *crt.TLS, pFile uintptr, ofst int32, n int32, flags int32) int32 { /* test6.c:552:12: */
	return sqlite3.Xsqlite3OsShmLock(tls, (*CrashFile)(unsafe.Pointer(pFile)).FpRealFile, ofst, n, flags)
}
func cfShmBarrier(tls *crt.TLS, pFile uintptr) { /* test6.c:555:13: */
	sqlite3.Xsqlite3OsShmBarrier(tls, (*CrashFile)(unsafe.Pointer(pFile)).FpRealFile)
}
func cfShmUnmap(tls *crt.TLS, pFile uintptr, delFlag int32) int32 { /* test6.c:558:12: */
	return sqlite3.Xsqlite3OsShmUnmap(tls, (*CrashFile)(unsafe.Pointer(pFile)).FpRealFile, delFlag)
}
func cfShmMap(tls *crt.TLS, pFile uintptr, iRegion int32, sz int32, w int32, pp uintptr) int32 { /* test6.c:561:12: */
	return sqlite3.Xsqlite3OsShmMap(tls, (*CrashFile)(unsafe.Pointer(pFile)).FpRealFile, iRegion, sz, w, pp)
}

var CrashFileVtab = sqlite3_io_methods{FiVersion: 2, FxClose: // iVersion
0, FxRead:// xClose
0, FxWrite:// xRead
0, FxTruncate:// xWrite
0, FxSync:// xTruncate
0, FxFileSize:// xSync
0, FxLock:// xFileSize
0, FxUnlock:// xLock
0, FxCheckReservedLock:// xUnlock
0, FxFileControl:// xCheckReservedLock
0, FxSectorSize:// xFileControl
0, FxDeviceCharacteristics:// xSectorSize
0, FxShmMap:// xDeviceCharacteristics
0, FxShmLock:// xShmMap
0, FxShmBarrier:// xShmLock
0, FxShmUnmap:// xShmBarrier
0, // xShmUnmap
} /* test6.c:571:33 */

// Open a crash-file file handle.
//
// The caller will have allocated pVfs->szOsFile bytes of space
// at pFile. This file uses this space for the CrashFile structure
// and allocates space for the "real" file structure using
// sqlite3_malloc(). The assumption here is (pVfs->szOsFile) is
// equal or greater than sizeof(CrashFile).
func cfOpen(tls *crt.TLS, pCfVfs uintptr, zName uintptr, pFile uintptr, flags int32, pOutFlags uintptr) int32 { /* test6.c:607:12: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var pVfs uintptr = (*sqlite3_vfs)(unsafe.Pointer(pCfVfs)).FpAppData
	var rc int32
	var pWrapper uintptr = pFile
	var pReal uintptr = (pWrapper + uintptr(1)*56)

	crt.Xmemset(tls, pWrapper, 0, uint64(unsafe.Sizeof(CrashFile{})))
	rc = sqlite3.Xsqlite3OsOpen(tls, pVfs, zName, pReal, flags, pOutFlags)

	if rc == 0 {
		// var iSize i64 at bp, 8

		(*CrashFile)(unsafe.Pointer(pWrapper)).FpMethod = uintptr(unsafe.Pointer(&CrashFileVtab))
		(*CrashFile)(unsafe.Pointer(pWrapper)).FzName = zName
		(*CrashFile)(unsafe.Pointer(pWrapper)).FpRealFile = pReal
		rc = sqlite3.Xsqlite3OsFileSize(tls, pReal, bp /* &iSize */)
		(*CrashFile)(unsafe.Pointer(pWrapper)).FiSize = i64(int32(*(*i64)(unsafe.Pointer(bp /* iSize */))))
		(*CrashFile)(unsafe.Pointer(pWrapper)).Fflags = flags
	}
	if rc == 0 {
		(*CrashFile)(unsafe.Pointer(pWrapper)).FnData = (int32(int64(4096) + (*CrashFile)(unsafe.Pointer(pWrapper)).FiSize))
		(*CrashFile)(unsafe.Pointer(pWrapper)).FzData = crash_malloc(tls, (*CrashFile)(unsafe.Pointer(pWrapper)).FnData)
		if (*CrashFile)(unsafe.Pointer(pWrapper)).FzData != 0 {
			// os_unix.c contains an assert() that fails if the caller attempts
			// to read data from the 512-byte locking region of a file opened
			// with the SQLITE_OPEN_MAIN_DB flag. This region of a database file
			// never contains valid data anyhow. So avoid doing such a read here.
			//
			// UPDATE: It also contains an assert() verifying that each call
			// to the xRead() method reads less than 128KB of data.
			var iOff i64

			crt.Xmemset(tls, (*CrashFile)(unsafe.Pointer(pWrapper)).FzData, 0, uint64((*CrashFile)(unsafe.Pointer(pWrapper)).FnData))
			for iOff = int64(0); iOff < (*CrashFile)(unsafe.Pointer(pWrapper)).FiSize; iOff = iOff + (int64(512)) {
				var nRead int32 = (int32((*CrashFile)(unsafe.Pointer(pWrapper)).FiSize - iOff))
				if nRead > 512 {
					nRead = 512
				}
				rc = sqlite3.Xsqlite3OsRead(tls, pReal, ((*CrashFile)(unsafe.Pointer(pWrapper)).FzData + uintptr(iOff)), nRead, iOff)
			}
		} else {
			rc = 7
		}
	}
	if (rc != 0) && ((*CrashFile)(unsafe.Pointer(pWrapper)).FpMethod != 0) {
		sqlite3.Xsqlite3OsClose(tls, pFile)
	}
	return rc
}

func cfDelete(tls *crt.TLS, pCfVfs uintptr, zPath uintptr, dirSync int32) int32 { /* test6.c:661:12: */
	var pVfs uintptr = (*sqlite3_vfs)(unsafe.Pointer(pCfVfs)).FpAppData
	return (*(*func(*crt.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer((pVfs + 48 /* &.xDelete */))))(tls, pVfs, zPath, dirSync)
}
func cfAccess(tls *crt.TLS, pCfVfs uintptr, zPath uintptr, flags int32, pResOut uintptr) int32 { /* test6.c:665:12: */
	var pVfs uintptr = (*sqlite3_vfs)(unsafe.Pointer(pCfVfs)).FpAppData
	return (*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer((pVfs + 56 /* &.xAccess */))))(tls, pVfs, zPath, flags, pResOut)
}
func cfFullPathname(tls *crt.TLS, pCfVfs uintptr, zPath uintptr, nPathOut int32, zPathOut uintptr) int32 { /* test6.c:674:12: */
	var pVfs uintptr = (*sqlite3_vfs)(unsafe.Pointer(pCfVfs)).FpAppData
	return (*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer((pVfs + 64 /* &.xFullPathname */))))(tls, pVfs, zPath, nPathOut, zPathOut)
}
func cfDlOpen(tls *crt.TLS, pCfVfs uintptr, zPath uintptr) uintptr { /* test6.c:683:13: */
	var pVfs uintptr = (*sqlite3_vfs)(unsafe.Pointer(pCfVfs)).FpAppData
	return (*(*func(*crt.TLS, uintptr, uintptr) uintptr)(unsafe.Pointer((pVfs + 72 /* &.xDlOpen */))))(tls, pVfs, zPath)
}
func cfDlError(tls *crt.TLS, pCfVfs uintptr, nByte int32, zErrMsg uintptr) { /* test6.c:687:13: */
	var pVfs uintptr = (*sqlite3_vfs)(unsafe.Pointer(pCfVfs)).FpAppData
	(*(*func(*crt.TLS, uintptr, int32, uintptr))(unsafe.Pointer((pVfs + 80 /* &.xDlError */))))(tls, pVfs, nByte, zErrMsg)
}
func cfDlSym(tls *crt.TLS, pCfVfs uintptr, pH uintptr, zSym uintptr) uintptr { /* test6.c:691:13: */
	var pVfs uintptr = (*sqlite3_vfs)(unsafe.Pointer(pCfVfs)).FpAppData
	return (*(*func(*crt.TLS, uintptr, uintptr, uintptr) uintptr)(unsafe.Pointer((pVfs + 88 /* &.xDlSym */))))(tls, pVfs, pH, zSym)
}
func cfDlClose(tls *crt.TLS, pCfVfs uintptr, pHandle uintptr) { /* test6.c:695:13: */
	var pVfs uintptr = (*sqlite3_vfs)(unsafe.Pointer(pCfVfs)).FpAppData
	(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((pVfs + 96 /* &.xDlClose */))))(tls, pVfs, pHandle)
}
func cfRandomness(tls *crt.TLS, pCfVfs uintptr, nByte int32, zBufOut uintptr) int32 { /* test6.c:699:12: */
	var pVfs uintptr = (*sqlite3_vfs)(unsafe.Pointer(pCfVfs)).FpAppData
	return (*(*func(*crt.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer((pVfs + 104 /* &.xRandomness */))))(tls, pVfs, nByte, zBufOut)
}
func cfSleep(tls *crt.TLS, pCfVfs uintptr, nMicro int32) int32 { /* test6.c:703:12: */
	var pVfs uintptr = (*sqlite3_vfs)(unsafe.Pointer(pCfVfs)).FpAppData
	return (*(*func(*crt.TLS, uintptr, int32) int32)(unsafe.Pointer((pVfs + 112 /* &.xSleep */))))(tls, pVfs, nMicro)
}
func cfCurrentTime(tls *crt.TLS, pCfVfs uintptr, pTimeOut uintptr) int32 { /* test6.c:707:12: */
	var pVfs uintptr = (*sqlite3_vfs)(unsafe.Pointer(pCfVfs)).FpAppData
	return (*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer((pVfs + 120 /* &.xCurrentTime */))))(tls, pVfs, pTimeOut)
}
func cfGetLastError(tls *crt.TLS, pCfVfs uintptr, n int32, z uintptr) int32 { /* test6.c:711:12: */
	var pVfs uintptr = (*sqlite3_vfs)(unsafe.Pointer(pCfVfs)).FpAppData
	return (*(*func(*crt.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer((pVfs + 128 /* &.xGetLastError */))))(tls, pVfs, n, z)
}

func processDevSymArgs(tls *crt.TLS, interp uintptr, objc int32, objv uintptr, piDeviceChar uintptr, piSectorSize uintptr) int32 { /* test6.c:716:12: */
	bp := tls.Alloc(316)
	defer tls.Free(316)

	*(*[14]DeviceFlag)(unsafe.Pointer(bp + 88 /* aFlag */)) = [14]DeviceFlag{
		{FzName: ts + 31609 /* "atomic" */, FiValue: 0x00000001},
		{FzName: ts + 31616 /* "atomic512" */, FiValue: 0x00000002},
		{FzName: ts + 31626 /* "atomic1k" */, FiValue: 0x00000004},
		{FzName: ts + 31635 /* "atomic2k" */, FiValue: 0x00000008},
		{FzName: ts + 31644 /* "atomic4k" */, FiValue: 0x00000010},
		{FzName: ts + 31653 /* "atomic8k" */, FiValue: 0x00000020},
		{FzName: ts + 31662 /* "atomic16k" */, FiValue: 0x00000040},
		{FzName: ts + 31672 /* "atomic32k" */, FiValue: 0x00000080},
		{FzName: ts + 31682 /* "atomic64k" */, FiValue: 0x00000100},
		{FzName: ts + 31692 /* "sequential" */, FiValue: 0x00000400},
		{FzName: ts + 31703 /* "safe_append" */, FiValue: 0x00000200},
		{FzName: ts + 31715 /* "powersafe_overwr..." */, FiValue: 0x00001000},
		{FzName: ts + 31735 /* "batch-atomic" */, FiValue: 0x00004000},
		{FzName: uintptr(0), FiValue: 0},
	}
	var i int32
	var iDc int32 = 0
	*(*int32)(unsafe.Pointer(bp + 68 /* iSectorSize */)) = 0
	var setSectorsize int32 = 0
	var setDeviceChar int32 = 0

	for i = 0; i < objc; i = i + (2) {
		// var nOpt int32 at bp+64, 4

		var zOpt uintptr = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(i)*8)), bp+64 /* &nOpt */)

		if (((*(*int32)(unsafe.Pointer(bp + 64 /* nOpt */)) > 11) || (*(*int32)(unsafe.Pointer(bp + 64 /* nOpt */)) < 2)) || (crt.Xstrncmp(tls, ts+31748 /* "-sectorsize" */, zOpt, uint64(*(*int32)(unsafe.Pointer(bp + 64 /* nOpt */)))) != 0)) &&
			(((*(*int32)(unsafe.Pointer(bp + 64 /* nOpt */)) > 16) || (*(*int32)(unsafe.Pointer(bp + 64 /* nOpt */)) < 2)) || (crt.Xstrncmp(tls, ts+31760 /* "-characteristics" */, zOpt, uint64(*(*int32)(unsafe.Pointer(bp + 64 /* nOpt */)))) != 0)) {
			tcl.XTcl_AppendResult(tls, interp,
				crt.VaList(bp, ts+31777 /* "Bad option: \"" */, zOpt,
					ts+31791 /* "\" - must be \"-ch..." */, 0))
			return 1
		}
		if i == (objc - 1) {
			tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+32, ts+31839 /* "Option requires ..." */, zOpt, ts+18666 /* "\"" */, 0))
			return 1
		}

		if int32(*(*int8)(unsafe.Pointer(zOpt + uintptr(1)))) == 's' {
			if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr((i+1))*8)), bp+68 /* &iSectorSize */) != 0 {
				return 1
			}
			setSectorsize = 1
		} else {
			var j int32
			// var apObj uintptr at bp+80, 8

			// var nObj int32 at bp+72, 4

			if tcl.XTcl_ListObjGetElements(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr((i+1))*8)), bp+72 /* &nObj */, bp+80 /* &apObj */) != 0 {
				return 1
			}
			for j = 0; j < *(*int32)(unsafe.Pointer(bp + 72 /* nObj */)); j++ {
				var rc int32
				// var iChoice int32 at bp+312, 4

				var pFlag uintptr = tcl.XTcl_DuplicateObj(tls, *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 80 /* apObj */)) + uintptr(j)*8)))
				(*Tcl_Obj)(unsafe.Pointer(pFlag)).FrefCount++
				tcl.XTcl_UtfToLower(tls, tcl.XTcl_GetString(tls, pFlag))

				rc = tcl.XTcl_GetIndexFromObjStruct(tls,
					interp, pFlag, bp+88 /* &aFlag[0] */, int32(unsafe.Sizeof(DeviceFlag{})), ts+31870 /* "no such flag" */, 0, bp+312 /* &iChoice */)
				for ok := true; ok; ok = 0 != 0 {
					var _objPtr uintptr = pFlag
					if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
						tcl.XTclFreeObj(tls, _objPtr)
					}
				}
				if rc != 0 {
					return 1
				}

				iDc = iDc | ((*DeviceFlag)(unsafe.Pointer(bp + 88 /* &aFlag */ + uintptr(*(*int32)(unsafe.Pointer(bp + 312 /* iChoice */)))*16)).FiValue)
			}
			setDeviceChar = 1
		}
	}

	if setDeviceChar != 0 {
		*(*int32)(unsafe.Pointer(piDeviceChar)) = iDc
	}
	if setSectorsize != 0 {
		*(*int32)(unsafe.Pointer(piSectorSize)) = *(*int32)(unsafe.Pointer(bp + 68 /* iSectorSize */))
	}

	return 0
}

type DeviceFlag = struct {
	FzName  uintptr
	FiValue int32
	_       [4]byte
}

// tclcmd:   sqlite3_crash_now
//
// Simulate a crash immediately. This function does not return
// (writeListSync() calls exit(-1)).
func crashNowCmd(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test6.c:816:26: */
	if objc != 1 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+792 /* "" */)
		return 1
	}
	writeListSync(tls, uintptr(0), 1)

	return 0
}

// tclcmd:   sqlite_crash_enable ENABLE ?DEFAULT?
//
// Parameter ENABLE must be a boolean value. If true, then the "crash"
// vfs is added to the system. If false, it is removed.
func crashEnableCmd(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test6.c:837:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// var isEnable int32 at bp, 4

	*(*int32)(unsafe.Pointer(bp + 4 /* isDefault */)) = 0

	if (objc != 2) && (objc != 3) {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+31883 /* "ENABLE ?DEFAULT?" */)
		return 1
	}

	if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)), bp /* &isEnable */) != 0 {
		return 1
	}
	if (objc == 3) && (tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)), bp+4 /* &isDefault */) != 0) {
		return 1
	}

	if ((*(*int32)(unsafe.Pointer(bp /* isEnable */)) != 0) && (crashVfs.FpAppData != 0)) || (!(*(*int32)(unsafe.Pointer(bp /* isEnable */)) != 0) && !(int32(crashVfs.FpAppData) != 0)) {
		return 0
	}

	if crashVfs.FpAppData == uintptr(0) {
		var pOriginalVfs uintptr = sqlite3.Xsqlite3_vfs_find(tls, uintptr(0))
		crashVfs.FmxPathname = (*sqlite3_vfs)(unsafe.Pointer(pOriginalVfs)).FmxPathname
		crashVfs.FpAppData = pOriginalVfs
		crashVfs.FszOsFile = (int32(uint64(unsafe.Sizeof(CrashFile{})) + uint64((*sqlite3_vfs)(unsafe.Pointer(pOriginalVfs)).FszOsFile)))
		sqlite3.Xsqlite3_vfs_register(tls, uintptr(unsafe.Pointer(&crashVfs)), *(*int32)(unsafe.Pointer(bp + 4 /* isDefault */)))
	} else {
		crashVfs.FpAppData = uintptr(0)
		sqlite3.Xsqlite3_vfs_unregister(tls, uintptr(unsafe.Pointer(&crashVfs)))
	}

	return 0
}

var crashVfs = sqlite3_vfs{FiVersion: 2, FszOsFile: // iVersion
0, FmxPathname:// szOsFile
0, FpNext:// mxPathname
uintptr(0), FzName:// pNext
ts + 31900, /* "crash" */ FpAppData:// zName
uintptr(0), FxOpen:// pAppData

0, FxDelete:// xOpen
0, FxAccess:// xDelete
0, FxFullPathname:// xAccess
0, FxDlOpen:// xFullPathname
0, FxDlError:// xDlOpen
0, FxDlSym:// xDlError
0, FxDlClose:// xDlSym
0, FxRandomness:// xDlClose
0, FxSleep:// xRandomness
0, FxCurrentTime:// xSleep
0, FxGetLastError:// xCurrentTime
0, FxCurrentTimeInt64:// xGetLastError
uintptr(0), // xCurrentTimeInt64
} /* test6.c:845:22 */

// tclcmd:   sqlite_crashparams ?OPTIONS? DELAY CRASHFILE
//
// This procedure implements a TCL command that enables crash testing
// in testfixture.  Once enabled, crash testing cannot be disabled.
//
// Available options are "-characteristics" and "-sectorsize". Both require
// an argument. For -sectorsize, this is the simulated sector size in
// bytes. For -characteristics, the argument must be a list of io-capability
// flags to simulate. Valid flags are "atomic", "atomic512", "atomic1K",
// "atomic2K", "atomic4K", "atomic8K", "atomic16K", "atomic32K",
// "atomic64K", "sequential" and "safe_append".
//
// Example:
//
//   sqlite_crashparams -sect 1024 -char {atomic sequential} ./test.db 1
//
func crashParamsObjCmd(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test6.c:916:26: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	// var iDelay int32 at bp+36, 4

	var zCrashFile uintptr
	// var nCrashFile int32 at bp+32, 4

	// var iDc int32 at bp+40, 4

	// var iSectorSize int32 at bp+44, 4

	*(*int32)(unsafe.Pointer(bp + 40 /* iDc */)) = -1
	*(*int32)(unsafe.Pointer(bp + 44 /* iSectorSize */)) = -1

	if !(objc < 3) {
		goto __1
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+31906 /* "?OPTIONS? DELAY ..." */)
	goto error
__1:
	;

	zCrashFile = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr((objc-1))*8)), bp+32 /* &nCrashFile */)
	if !(uint64(*(*int32)(unsafe.Pointer(bp + 32 /* nCrashFile */))) >= uint64(unsafe.Sizeof([500]int8{}))) {
		goto __2
	}
	tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+31932 /* "Filename is too ..." */, zCrashFile, ts+18666 /* "\"" */, 0))
	goto error
__2:
	;
	if !(tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr((objc-2))*8)), bp+36 /* &iDelay */) != 0) {
		goto __3
	}
	goto error
__3:
	;

	if !(processDevSymArgs(tls, interp, (objc-3), (objv+uintptr(1)*8), bp+40 /* &iDc */, bp+44 /* &iSectorSize */) != 0) {
		goto __4
	}
	return 1
__4:
	;

	if !(*(*int32)(unsafe.Pointer(bp + 40 /* iDc */)) >= 0) {
		goto __5
	}
	g.FiDeviceCharacteristics = *(*int32)(unsafe.Pointer(bp + 40 /* iDc */))
__5:
	;
	if !(*(*int32)(unsafe.Pointer(bp + 44 /* iSectorSize */)) >= 0) {
		goto __6
	}
	g.FiSectorSize = *(*int32)(unsafe.Pointer(bp + 44 /* iSectorSize */))
__6:
	;

	g.FiCrash = *(*int32)(unsafe.Pointer(bp + 36 /* iDelay */))
	crt.Xmemcpy(tls, uintptr(unsafe.Pointer(&g))+28 /* &.zCrashFile */, zCrashFile, (uint64(*(*int32)(unsafe.Pointer(bp + 32 /* nCrashFile */)) + 1)))
	sqlite3CrashTestEnable = 1
	return 0

error:
	return 1
}

func devSymObjCmd(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test6.c:963:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	*(*int32)(unsafe.Pointer(bp /* iDc */)) = -1
	*(*int32)(unsafe.Pointer(bp + 4 /* iSectorSize */)) = -1

	if processDevSymArgs(tls, interp, (objc-1), (objv+uintptr(1)*8), bp /* &iDc */, bp+4 /* &iSectorSize */) != 0 {
		return 1
	}
	devsym_register(tls, *(*int32)(unsafe.Pointer(bp /* iDc */)), *(*int32)(unsafe.Pointer(bp + 4 /* iSectorSize */)))

	return 0
}

// tclcmd: sqlite3_crash_on_write N
func writeCrashObjCmd(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test6.c:985:26: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	*(*int32)(unsafe.Pointer(bp /* nWrite */)) = 0

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+31956 /* "NWRITE" */)
		return 1
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)), bp /* &nWrite */) != 0 {
		return 1
	}

	devsym_crash_on_write(tls, *(*int32)(unsafe.Pointer(bp /* nWrite */)))
	return 0
}

// tclcmd: unregister_devsim
func dsUnregisterObjCmd(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test6.c:1009:26: */

	if objc != 1 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+792 /* "" */)
		return 1
	}

	devsym_unregister(tls)
	return 0
}

// tclcmd: register_jt_vfs ?-default? PARENT-VFS
func jtObjCmd(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test6.c:1029:26: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var zParent uintptr = uintptr(0)

	if (objc != 2) && (objc != 3) {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+31963 /* "?-default? PAREN..." */)
		return 1
	}
	zParent = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)))
	if objc == 3 {
		if crt.Xstrcmp(tls, zParent, ts+31985 /* "-default" */) != 0 {
			tcl.XTcl_AppendResult(tls, interp,
				crt.VaList(bp, ts+18565 /* "bad option \"" */, zParent, ts+31994 /* "\": must be -defa..." */, 0))
			return 1
		}
		zParent = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)))
	}

	if !(int32(*(*int8)(unsafe.Pointer(zParent))) != 0) {
		zParent = uintptr(0)
	}
	if jt_register(tls, zParent, (crt.Bool32(objc == 3))) != 0 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+32, ts+32014 /* "Error in jt_regi..." */, 0))
		return 1
	}

	return 0
}

// tclcmd: unregister_jt_vfs
func jtUnregisterObjCmd(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test6.c:1067:26: */

	if objc != 1 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+792 /* "" */)
		return 1
	}

	jt_unregister(tls)
	return 0
}

// This procedure registers the TCL procedures defined in this file.
func Sqlitetest6_Init(tls *crt.TLS, interp uintptr) int32 { /* test6.c:1089:5: */
	tcl.XTcl_CreateObjCommand(tls, interp, ts+32035 /* "sqlite3_crash_en..." */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{crashEnableCmd})), uintptr(0), uintptr(0))
	tcl.XTcl_CreateObjCommand(tls, interp, ts+32056 /* "sqlite3_crashpar..." */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{crashParamsObjCmd})), uintptr(0), uintptr(0))
	tcl.XTcl_CreateObjCommand(tls, interp, ts+32076 /* "sqlite3_crash_no..." */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{crashNowCmd})), uintptr(0), uintptr(0))
	tcl.XTcl_CreateObjCommand(tls, interp, ts+32094 /* "sqlite3_simulate..." */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{devSymObjCmd})), uintptr(0), uintptr(0))
	tcl.XTcl_CreateObjCommand(tls, interp, ts+32118 /* "sqlite3_crash_on..." */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{writeCrashObjCmd})), uintptr(0), uintptr(0))
	tcl.XTcl_CreateObjCommand(tls, interp, ts+32141 /* "unregister_devsi..." */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{dsUnregisterObjCmd})), uintptr(0), uintptr(0))
	tcl.XTcl_CreateObjCommand(tls, interp, ts+32159 /* "register_jt_vfs" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{jtObjCmd})), uintptr(0), uintptr(0))
	tcl.XTcl_CreateObjCommand(tls, interp, ts+32175 /* "unregister_jt_vf..." */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{jtUnregisterObjCmd})), uintptr(0), uintptr(0))
	return 0
}

// end block for C++

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:

// This test only works on UNIX with a SQLITE_THREADSAFE build that includes
// the SQLITE_SERVER option.
func Sqlitetest7_Init(tls *crt.TLS, interp uintptr) int32 { /* test7.c:717:5: */ return 0 }

// end block for C++

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:
// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.20 General utilities	<stdlib.h>

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.21 String handling	<string.h>

type echo_vtab1 = struct {
	Fbase          sqlite3_vtab
	Finterp        uintptr
	Fdb            uintptr
	FisPattern     int32
	FinTransaction int32
	FzThis         uintptr
	FzTableName    uintptr
	FzLogName      uintptr
	FnCol          int32
	FaIndex        uintptr
	FaCol          uintptr
}

// end block for C++

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:
// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.20 General utilities	<stdlib.h>

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.21 String handling	<string.h>

type echo_vtab = echo_vtab1 /* test8.c:27:26 */
type echo_cursor1 = struct {
	Fbase  sqlite3_vtab_cursor
	FpStmt uintptr
}

type echo_cursor = echo_cursor1 /* test8.c:28:28 */

func simulateVtabError(tls *crt.TLS, p uintptr, zMethod uintptr) int32 { /* test8.c:97:12: */
	bp := tls.Alloc(152)
	defer tls.Free(152)

	var zErr uintptr
	// var zVarname [128]int8 at bp+24, 128

	*(*int8)(unsafe.Pointer(bp + 24 /* &zVarname[0] */ + uintptr(127))) = int8(0)
	sqlite3.Xsqlite3_snprintf(tls, 127, bp+24 /* &zVarname[0] */, ts+32193 /* "echo_module_fail..." */, crt.VaList(bp, zMethod, (*echo_vtab)(unsafe.Pointer(p)).FzTableName))
	zErr = tcl.XTcl_GetVar2(tls, (*echo_vtab)(unsafe.Pointer(p)).Finterp, bp+24 /* &zVarname[0] */, uintptr(0), 1)
	if zErr != 0 {
		(*echo_vtab)(unsafe.Pointer(p)).Fbase.FzErrMsg = sqlite3.Xsqlite3_mprintf(tls, ts+32217 /* "echo-vtab-error:..." */, crt.VaList(bp+16, zErr))
	}
	return (crt.Bool32(zErr != uintptr(0)))
}

// Convert an SQL-style quoted string into a normal string by removing
// the quote characters.  The conversion is done in-place.  If the
// input does not begin with a quote character, then this routine
// is a no-op.
//
// Examples:
//
//     "abc"   becomes   abc
//     'xyz'   becomes   xyz
//     [pqr]   becomes   pqr
//     `mno`   becomes   mno
func dequoteString(tls *crt.TLS, z uintptr) { /* test8.c:122:13: */
	var quote int32
	var i int32
	var j int32
	if z == uintptr(0) {
		return
	}
	quote = int32(*(*int8)(unsafe.Pointer(z + uintptr(0))))
	switch quote {
	case '\'':
		break
	case '"':
		break
	case '`':
		break // For MySQL compatibility
	case '[':
		quote = ']'
		break // For MS SqlServer compatibility
	default:
		return
	}
	i = 1
	j = 0
	for ; *(*int8)(unsafe.Pointer(z + uintptr(i))) != 0; i++ {
		if int32(*(*int8)(unsafe.Pointer(z + uintptr(i)))) == quote {
			if int32(*(*int8)(unsafe.Pointer(z + uintptr((i + 1))))) == quote {
				*(*int8)(unsafe.Pointer(z + uintptr(crt.PostIncInt32(&j, 1)))) = int8(quote)
				i++
			} else {
				*(*int8)(unsafe.Pointer(z + uintptr(crt.PostIncInt32(&j, 1)))) = int8(0)
				break
			}
		} else {
			*(*int8)(unsafe.Pointer(z + uintptr(crt.PostIncInt32(&j, 1)))) = *(*int8)(unsafe.Pointer(z + uintptr(i)))
		}
	}
}

// Retrieve the column names for the table named zTab via database
// connection db. SQLITE_OK is returned on success, or an sqlite error
// code otherwise.
//
// If successful, the number of columns is written to *pnCol. *paCol is
// set to point at sqlite3_malloc()'d space containing the array of
// nCol column names. The caller is responsible for calling sqlite3_free
// on *paCol.
func getColumnNames(tls *crt.TLS, db uintptr, zTab uintptr, paCol uintptr, pnCol uintptr) int32 { /* test8.c:159:12: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	var aCol uintptr
	var zSql uintptr
	// var pStmt uintptr at bp+16, 8

	var rc int32
	var nCol int32
	var zName uintptr
	var ii int32
	var nBytes int32
	var zSpace uintptr
	aCol = uintptr(0)
	*(*uintptr)(unsafe.Pointer(bp + 16 /* pStmt */)) = uintptr(0)
	rc = 0
	nCol = 0

	// Prepare the statement "SELECT * FROM <tbl>". The column names
	// of the result set of the compiled SELECT will be the same as
	// the column names of table <tbl>.
	zSql = sqlite3.Xsqlite3_mprintf(tls, ts+32237 /* "SELECT * FROM %Q" */, crt.VaList(bp, zTab))
	if !(!(zSql != 0)) {
		goto __1
	}
	rc = 7
	goto out
__1:
	;
	rc = sqlite3.Xsqlite3_prepare(tls, db, zSql, -1, bp+16 /* &pStmt */, uintptr(0))
	sqlite3.Xsqlite3_free(tls, zSql)

	if !(rc == 0) {
		goto __2
	}
	nCol = sqlite3.Xsqlite3_column_count(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* pStmt */)))

	// Figure out how much space to allocate for the array of column names
	// (including space for the strings themselves). Then allocate it.
	nBytes = (int32(uint64(unsafe.Sizeof(uintptr(0))) * uint64(nCol)))
	ii = 0
__3:
	if !(ii < nCol) {
		goto __5
	}
	zName = sqlite3.Xsqlite3_column_name(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* pStmt */)), ii)
	if !(!(zName != 0)) {
		goto __6
	}
	rc = 7
	goto out
__6:
	;
	nBytes = nBytes + (int32(crt.Xstrlen(tls, zName)) + 1)
	goto __4
__4:
	ii++
	goto __3
	goto __5
__5:
	;
	aCol = sqlite3.Xsqlite3MallocZero(tls, uint64(nBytes))
	if !(!(aCol != 0)) {
		goto __7
	}
	rc = 7
	goto out
__7:
	;

	// Copy the column names into the allocated space and set up the
	// pointers in the aCol[] array.
	zSpace = (aCol + uintptr(nCol)*8)
	ii = 0
__8:
	if !(ii < nCol) {
		goto __10
	}
	*(*uintptr)(unsafe.Pointer(aCol + uintptr(ii)*8)) = zSpace
	sqlite3.Xsqlite3_snprintf(tls, nBytes, zSpace, ts+130 /* "%s" */, crt.VaList(bp+8, sqlite3.Xsqlite3_column_name(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* pStmt */)), ii)))
	zSpace += (uintptr(int32(crt.Xstrlen(tls, zSpace)) + 1))
	goto __9
__9:
	ii++
	goto __8
	goto __10
__10:
	;
__2:
	;

	*(*uintptr)(unsafe.Pointer(paCol)) = aCol
	*(*int32)(unsafe.Pointer(pnCol)) = nCol

out:
	sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* pStmt */)))
	return rc
}

// Parameter zTab is the name of a table in database db with nCol
// columns. This function allocates an array of integers nCol in
// size and populates it according to any implicit or explicit
// indices on table zTab.
//
// If successful, SQLITE_OK is returned and *paIndex set to point
// at the allocated array. Otherwise, an error code is returned.
//
// See comments associated with the member variable aIndex above
// "struct echo_vtab" for details of the contents of the array.
func getIndexArray(tls *crt.TLS, db uintptr, zTab uintptr, nCol int32, paIndex uintptr) int32 { /* test8.c:239:12: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	// var pStmt uintptr at bp+16, 8

	var aIndex uintptr
	var rc int32
	var zSql uintptr
	var cid int32
	var zIdx uintptr
	// var pStmt2 uintptr at bp+24, 8

	var rc2 int32
	*(*uintptr)(unsafe.Pointer(bp + 16 /* pStmt */)) = uintptr(0)
	aIndex = uintptr(0)

	// Allocate space for the index array
	aIndex = sqlite3.Xsqlite3MallocZero(tls, (uint64(uint64(unsafe.Sizeof(int32(0))) * uint64(nCol))))
	if !(!(aIndex != 0)) {
		goto __1
	}
	rc = 7
	goto get_index_array_out
__1:
	;

	// Compile an sqlite pragma to loop through all indices on table zTab
	zSql = sqlite3.Xsqlite3_mprintf(tls, ts+32254 /* "PRAGMA index_lis..." */, crt.VaList(bp, zTab))
	if !(!(zSql != 0)) {
		goto __2
	}
	rc = 7
	goto get_index_array_out
__2:
	;
	rc = sqlite3.Xsqlite3_prepare(tls, db, zSql, -1, bp+16 /* &pStmt */, uintptr(0))
	sqlite3.Xsqlite3_free(tls, zSql)

	// For each index, figure out the left-most column and set the
	// corresponding entry in aIndex[] to 1.
__3:
	if !((*(*uintptr)(unsafe.Pointer(bp + 16 /* pStmt */)) != 0) && (sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* pStmt */))) == 100)) {
		goto __4
	}
	zIdx = sqlite3.Xsqlite3_column_text(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* pStmt */)), 1)
	*(*uintptr)(unsafe.Pointer(bp + 24 /* pStmt2 */)) = uintptr(0)
	if !(zIdx == uintptr(0)) {
		goto __5
	}
	goto __3
__5:
	;
	zSql = sqlite3.Xsqlite3_mprintf(tls, ts+32276 /* "PRAGMA index_inf..." */, crt.VaList(bp+8, zIdx))
	if !(!(zSql != 0)) {
		goto __6
	}
	rc = 7
	goto get_index_array_out
__6:
	;
	rc = sqlite3.Xsqlite3_prepare(tls, db, zSql, -1, bp+24 /* &pStmt2 */, uintptr(0))
	sqlite3.Xsqlite3_free(tls, zSql)
	if !((*(*uintptr)(unsafe.Pointer(bp + 24 /* pStmt2 */)) != 0) && (sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 24 /* pStmt2 */))) == 100)) {
		goto __7
	}
	cid = sqlite3.Xsqlite3_column_int(tls, *(*uintptr)(unsafe.Pointer(bp + 24 /* pStmt2 */)), 1)

	*(*int32)(unsafe.Pointer(aIndex + uintptr(cid)*4)) = 1
__7:
	;
	if !(*(*uintptr)(unsafe.Pointer(bp + 24 /* pStmt2 */)) != 0) {
		goto __8
	}
	rc = sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 24 /* pStmt2 */)))
__8:
	;
	if !(rc != 0) {
		goto __9
	}
	goto get_index_array_out
__9:
	;
	goto __3
__4:
	;

get_index_array_out:
	if !(*(*uintptr)(unsafe.Pointer(bp + 16 /* pStmt */)) != 0) {
		goto __10
	}
	rc2 = sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* pStmt */)))
	if !(rc == 0) {
		goto __11
	}
	rc = rc2
__11:
	;
__10:
	;
	if !(rc != 0) {
		goto __12
	}
	sqlite3.Xsqlite3_free(tls, aIndex)
	aIndex = uintptr(0)
__12:
	;
	*(*uintptr)(unsafe.Pointer(paIndex)) = aIndex
	return rc
}

// Global Tcl variable $echo_module is a list. This routine appends
// the string element zArg to that list in interpreter interp.
func appendToEchoModule(tls *crt.TLS, interp uintptr, zArg uintptr) { /* test8.c:313:13: */
	var flags int32 = ((4 | 8) | 1)
	tcl.XTcl_SetVar2(tls, interp, ts+32298 /* "echo_module" */, uintptr(0), func() uintptr {
		if zArg != 0 {
			return zArg
		}
		return ts + 792 /* "" */
	}(), flags)
}

// This function is called from within the echo-modules xCreate and
// xConnect methods. The argc and argv arguments are copies of those
// passed to the calling method. This function is responsible for
// calling sqlite3_declare_vtab() to declare the schema of the virtual
// table being created or connected.
//
// If the constructor was passed just one argument, i.e.:
//
//   CREATE TABLE t1 AS echo(t2);
//
// Then t2 is assumed to be the name of a *real* database table. The
// schema of the virtual table is declared by passing a copy of the
// CREATE TABLE statement for the real table to sqlite3_declare_vtab().
// Hence, the virtual table should have exactly the same column names and
// types as the real table.
func echoDeclareVtab(tls *crt.TLS, pVtab uintptr, db uintptr) int32 { /* test8.c:335:12: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var rc int32 = 0

	if (*echo_vtab)(unsafe.Pointer(pVtab)).FzTableName != 0 {
		*(*uintptr)(unsafe.Pointer(bp /* pStmt */)) = uintptr(0)
		rc = sqlite3.Xsqlite3_prepare(tls, db,
			ts+32310, /* "SELECT sql FROM ..." */
			-1, bp /* &pStmt */, uintptr(0))
		if rc == 0 {
			sqlite3.Xsqlite3_bind_text(tls, *(*uintptr)(unsafe.Pointer(bp /* pStmt */)), 1, (*echo_vtab)(unsafe.Pointer(pVtab)).FzTableName, -1, uintptr(0))
			if sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp /* pStmt */))) == 100 {
				var rc2 int32
				var zCreateTable uintptr = sqlite3.Xsqlite3_column_text(tls, *(*uintptr)(unsafe.Pointer(bp /* pStmt */)), 0)
				rc = sqlite3.Xsqlite3_declare_vtab(tls, db, zCreateTable)
				rc2 = sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp /* pStmt */)))
				if rc == 0 {
					rc = rc2
				}
			} else {
				rc = sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp /* pStmt */)))
				if rc == 0 {
					rc = 1
				}
			}
			if rc == 0 {
				rc = getColumnNames(tls, db, (*echo_vtab)(unsafe.Pointer(pVtab)).FzTableName, (pVtab + 88 /* &.aCol */), (pVtab + 72 /* &.nCol */))
			}
			if rc == 0 {
				rc = getIndexArray(tls, db, (*echo_vtab)(unsafe.Pointer(pVtab)).FzTableName, (*echo_vtab)(unsafe.Pointer(pVtab)).FnCol, (pVtab + 80 /* &.aIndex */))
			}
		}
	}

	return rc
}

// This function frees all runtime structures associated with the virtual
// table pVtab.
func echoDestructor(tls *crt.TLS, pVtab uintptr) int32 { /* test8.c:378:12: */
	var p uintptr = pVtab
	sqlite3.Xsqlite3_free(tls, (*echo_vtab)(unsafe.Pointer(p)).FaIndex)
	sqlite3.Xsqlite3_free(tls, (*echo_vtab)(unsafe.Pointer(p)).FaCol)
	sqlite3.Xsqlite3_free(tls, (*echo_vtab)(unsafe.Pointer(p)).FzThis)
	sqlite3.Xsqlite3_free(tls, (*echo_vtab)(unsafe.Pointer(p)).FzTableName)
	sqlite3.Xsqlite3_free(tls, (*echo_vtab)(unsafe.Pointer(p)).FzLogName)
	sqlite3.Xsqlite3_free(tls, p)
	return 0
}

type EchoModule1 = struct{ Finterp uintptr }

type EchoModule = EchoModule1 /* test8.c:389:27 */

// This function is called to do the work of the xConnect() method -
// to allocate the required in-memory structures for a newly connected
// virtual table.
func echoConstructor(tls *crt.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVtab uintptr, pzErr uintptr) int32 { /* test8.c:399:12: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var rc int32
	var i int32
	var pVtab uintptr

	// Allocate the sqlite3_vtab/echo_vtab structure itself
	pVtab = sqlite3.Xsqlite3MallocZero(tls, uint64(unsafe.Sizeof(echo_vtab{})))
	if !(pVtab != 0) {
		return 7
	}
	(*echo_vtab)(unsafe.Pointer(pVtab)).Finterp = (*EchoModule)(unsafe.Pointer(pAux)).Finterp
	(*echo_vtab)(unsafe.Pointer(pVtab)).Fdb = db

	// Allocate echo_vtab.zThis
	(*echo_vtab)(unsafe.Pointer(pVtab)).FzThis = sqlite3.Xsqlite3_mprintf(tls, ts+130 /* "%s" */, crt.VaList(bp, *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8))))
	if !(int32((*echo_vtab)(unsafe.Pointer(pVtab)).FzThis) != 0) {
		echoDestructor(tls, pVtab)
		return 7
	}

	// Allocate echo_vtab.zTableName
	if argc > 3 {
		(*echo_vtab)(unsafe.Pointer(pVtab)).FzTableName = sqlite3.Xsqlite3_mprintf(tls, ts+130 /* "%s" */, crt.VaList(bp+8, *(*uintptr)(unsafe.Pointer(argv + uintptr(3)*8))))
		dequoteString(tls, (*echo_vtab)(unsafe.Pointer(pVtab)).FzTableName)
		if ((*echo_vtab)(unsafe.Pointer(pVtab)).FzTableName != 0) && (int32(*(*int8)(unsafe.Pointer((*echo_vtab)(unsafe.Pointer(pVtab)).FzTableName + uintptr(0)))) == '*') {
			var z uintptr = sqlite3.Xsqlite3_mprintf(tls, ts+32374 /* "%s%s" */, crt.VaList(bp+16, *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8)), ((*echo_vtab)(unsafe.Pointer(pVtab)).FzTableName+uintptr(1))))
			sqlite3.Xsqlite3_free(tls, (*echo_vtab)(unsafe.Pointer(pVtab)).FzTableName)
			(*echo_vtab)(unsafe.Pointer(pVtab)).FzTableName = z
			(*echo_vtab)(unsafe.Pointer(pVtab)).FisPattern = 1
		}
		if !(int32((*echo_vtab)(unsafe.Pointer(pVtab)).FzTableName) != 0) {
			echoDestructor(tls, pVtab)
			return 7
		}
	}

	// Log the arguments to this function to Tcl var ::echo_module
	for i = 0; i < argc; i++ {
		appendToEchoModule(tls, (*echo_vtab)(unsafe.Pointer(pVtab)).Finterp, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8)))
	}

	// Invoke sqlite3_declare_vtab and set up other members of the echo_vtab
	// structure. If an error occurs, delete the sqlite3_vtab structure and
	// return an error code.
	rc = echoDeclareVtab(tls, pVtab, db)
	if rc != 0 {
		echoDestructor(tls, pVtab)
		return rc
	}

	// Success. Set *ppVtab and return
	*(*uintptr)(unsafe.Pointer(ppVtab)) = (pVtab /* &.base */)
	return 0
}

// Echo virtual table module xCreate method.
func echoCreate(tls *crt.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVtab uintptr, pzErr uintptr) int32 { /* test8.c:464:12: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	var rc int32 = 0
	appendToEchoModule(tls, (*EchoModule)(unsafe.Pointer(pAux)).Finterp, ts+32379 /* "xCreate" */)
	rc = echoConstructor(tls, db, pAux, argc, argv, ppVtab, pzErr)

	// If there were two arguments passed to the module at the SQL level
	// (i.e. "CREATE VIRTUAL TABLE tbl USING echo(arg1, arg2)"), then
	// the second argument is used as a table name. Attempt to create
	// such a table with a single column, "logmsg". This table will
	// be used to log calls to the xUpdate method. It will be deleted
	// when the virtual table is DROPed.
	//
	// Note: The main point of this is to test that we can drop tables
	// from within an xDestroy method call.
	if (rc == 0) && (argc == 5) {
		var zSql uintptr
		var pVtab uintptr = *(*uintptr)(unsafe.Pointer(ppVtab))
		(*echo_vtab)(unsafe.Pointer(pVtab)).FzLogName = sqlite3.Xsqlite3_mprintf(tls, ts+130 /* "%s" */, crt.VaList(bp, *(*uintptr)(unsafe.Pointer(argv + uintptr(4)*8))))
		zSql = sqlite3.Xsqlite3_mprintf(tls, ts+32387 /* "CREATE TABLE %Q(..." */, crt.VaList(bp+8, (*echo_vtab)(unsafe.Pointer(pVtab)).FzLogName))
		rc = sqlite3.Xsqlite3_exec(tls, db, zSql, uintptr(0), uintptr(0), uintptr(0))
		sqlite3.Xsqlite3_free(tls, zSql)
		if rc != 0 {
			*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+130 /* "%s" */, crt.VaList(bp+16, sqlite3.Xsqlite3_errmsg(tls, db)))
		}
	}

	if (*(*uintptr)(unsafe.Pointer(ppVtab)) != 0) && (rc != 0) {
		echoDestructor(tls, *(*uintptr)(unsafe.Pointer(ppVtab)))
		*(*uintptr)(unsafe.Pointer(ppVtab)) = uintptr(0)
	}

	if rc == 0 {
		(*echo_vtab)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(ppVtab)))).FinTransaction = 1
	}

	return rc
}

// Echo virtual table module xConnect method.
func echoConnect(tls *crt.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVtab uintptr, pzErr uintptr) int32 { /* test8.c:512:12: */
	appendToEchoModule(tls, (*EchoModule)(unsafe.Pointer(pAux)).Finterp, ts+32411 /* "xConnect" */)
	return echoConstructor(tls, db, pAux, argc, argv, ppVtab, pzErr)
}

// Echo virtual table module xDisconnect method.
func echoDisconnect(tls *crt.TLS, pVtab uintptr) int32 { /* test8.c:526:12: */
	appendToEchoModule(tls, (*echo_vtab)(unsafe.Pointer(pVtab)).Finterp, ts+32420 /* "xDisconnect" */)
	return echoDestructor(tls, pVtab)
}

// Echo virtual table module xDestroy method.
func echoDestroy(tls *crt.TLS, pVtab uintptr) int32 { /* test8.c:534:12: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var rc int32 = 0
	var p uintptr = pVtab
	appendToEchoModule(tls, (*echo_vtab)(unsafe.Pointer(pVtab)).Finterp, ts+32432 /* "xDestroy" */)

	// Drop the "log" table, if one exists (see echoCreate() for details)
	if (p != 0) && ((*echo_vtab)(unsafe.Pointer(p)).FzLogName != 0) {
		var zSql uintptr
		zSql = sqlite3.Xsqlite3_mprintf(tls, ts+32441 /* "DROP TABLE %Q" */, crt.VaList(bp, (*echo_vtab)(unsafe.Pointer(p)).FzLogName))
		rc = sqlite3.Xsqlite3_exec(tls, (*echo_vtab)(unsafe.Pointer(p)).Fdb, zSql, uintptr(0), uintptr(0), uintptr(0))
		sqlite3.Xsqlite3_free(tls, zSql)
	}

	if rc == 0 {
		rc = echoDestructor(tls, pVtab)
	}
	return rc
}

// Echo virtual table module xOpen method.
func echoOpen(tls *crt.TLS, pVTab uintptr, ppCursor uintptr) int32 { /* test8.c:556:12: */
	var pCur uintptr
	if simulateVtabError(tls, pVTab, ts+32455 /* "xOpen" */) != 0 {
		return 1
	}
	pCur = sqlite3.Xsqlite3MallocZero(tls, uint64(unsafe.Sizeof(echo_cursor{})))
	*(*uintptr)(unsafe.Pointer(ppCursor)) = pCur
	return func() int32 {
		if pCur != 0 {
			return 0
		}
		return 7
	}()
}

// Echo virtual table module xClose method.
func echoClose(tls *crt.TLS, cur uintptr) int32 { /* test8.c:569:12: */
	var rc int32
	var pCur uintptr = cur
	var pStmt uintptr = (*echo_cursor)(unsafe.Pointer(pCur)).FpStmt
	(*echo_cursor)(unsafe.Pointer(pCur)).FpStmt = uintptr(0)
	sqlite3.Xsqlite3_free(tls, pCur)
	rc = sqlite3.Xsqlite3_finalize(tls, pStmt)
	return rc
}

// Return non-zero if the cursor does not currently point to a valid record
// (i.e if the scan has finished), or zero otherwise.
func echoEof(tls *crt.TLS, cur uintptr) int32 { /* test8.c:583:12: */
	return func() int32 {
		if (*echo_cursor)(unsafe.Pointer(cur)).FpStmt != 0 {
			return 0
		}
		return 1
	}()
}

// Echo virtual table module xNext method.
func echoNext(tls *crt.TLS, cur uintptr) int32 { /* test8.c:590:12: */
	var rc int32 = 0
	var pCur uintptr = cur

	if simulateVtabError(tls, (*sqlite3_vtab_cursor)(unsafe.Pointer(cur)).FpVtab, ts+32461 /* "xNext" */) != 0 {
		return 1
	}

	if (*echo_cursor)(unsafe.Pointer(pCur)).FpStmt != 0 {
		rc = sqlite3.Xsqlite3_step(tls, (*echo_cursor)(unsafe.Pointer(pCur)).FpStmt)
		if rc == 100 {
			rc = 0
		} else {
			rc = sqlite3.Xsqlite3_finalize(tls, (*echo_cursor)(unsafe.Pointer(pCur)).FpStmt)
			(*echo_cursor)(unsafe.Pointer(pCur)).FpStmt = uintptr(0)
		}
	}

	return rc
}

// Echo virtual table module xColumn method.
func echoColumn(tls *crt.TLS, cur uintptr, ctx uintptr, i int32) int32 { /* test8.c:614:12: */
	var iCol int32 = (i + 1)
	var pStmt uintptr = (*echo_cursor)(unsafe.Pointer(cur)).FpStmt

	if simulateVtabError(tls, (*sqlite3_vtab_cursor)(unsafe.Pointer(cur)).FpVtab, ts+32467 /* "xColumn" */) != 0 {
		return 1
	}

	if !(pStmt != 0) {
		sqlite3.Xsqlite3_result_null(tls, ctx)
	} else {

		sqlite3.Xsqlite3_result_value(tls, ctx, sqlite3.Xsqlite3_column_value(tls, pStmt, iCol))
	}
	return 0
}

// Echo virtual table module xRowid method.
func echoRowid(tls *crt.TLS, cur uintptr, pRowid uintptr) int32 { /* test8.c:634:12: */
	var pStmt uintptr = (*echo_cursor)(unsafe.Pointer(cur)).FpStmt

	if simulateVtabError(tls, (*sqlite3_vtab_cursor)(unsafe.Pointer(cur)).FpVtab, ts+32475 /* "xRowid" */) != 0 {
		return 1
	}

	*(*sqlite_int64)(unsafe.Pointer(pRowid)) = sqlite3.Xsqlite3_column_int64(tls, pStmt, 0)
	return 0
}

// Compute a simple hash of the null terminated string zString.
//
// This module uses only sqlite3_index_info.idxStr, not
// sqlite3_index_info.idxNum. So to test idxNum, when idxStr is set
// in echoBestIndex(), idxNum is set to the corresponding hash value.
// In echoFilter(), code assert()s that the supplied idxNum value is
// indeed the hash of the supplied idxStr.
func hashString(tls *crt.TLS, zString uintptr) int32 { /* test8.c:654:12: */
	var val u32 = u32(0)
	var ii int32
	for ii = 0; *(*int8)(unsafe.Pointer(zString + uintptr(ii))) != 0; ii++ {
		val = ((val << 3) + u32(int32(*(*int8)(unsafe.Pointer(zString + uintptr(ii))))))
	}
	return (int32(val & u32(0x7fffffff)))
}

// Echo virtual table module xFilter method.
func echoFilter(tls *crt.TLS, pVtabCursor uintptr, idxNum int32, idxStr uintptr, argc int32, argv uintptr) int32 { /* test8.c:666:12: */
	var rc int32
	var i int32

	var pCur uintptr = pVtabCursor
	var pVtab uintptr = (*sqlite3_vtab_cursor)(unsafe.Pointer(pVtabCursor)).FpVtab
	var db uintptr = (*echo_vtab)(unsafe.Pointer(pVtab)).Fdb

	if simulateVtabError(tls, pVtab, ts+32482 /* "xFilter" */) != 0 {
		return 1
	}

	// Check that idxNum matches idxStr

	// Log arguments to the ::echo_module Tcl variable
	appendToEchoModule(tls, (*echo_vtab)(unsafe.Pointer(pVtab)).Finterp, ts+32482 /* "xFilter" */)
	appendToEchoModule(tls, (*echo_vtab)(unsafe.Pointer(pVtab)).Finterp, idxStr)
	for i = 0; i < argc; i++ {
		appendToEchoModule(tls, (*echo_vtab)(unsafe.Pointer(pVtab)).Finterp, sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8))))
	}

	sqlite3.Xsqlite3_finalize(tls, (*echo_cursor)(unsafe.Pointer(pCur)).FpStmt)
	(*echo_cursor)(unsafe.Pointer(pCur)).FpStmt = uintptr(0)

	// Prepare the SQL statement created by echoBestIndex and bind the
	// runtime parameters passed to this function to it.
	rc = sqlite3.Xsqlite3_prepare(tls, db, idxStr, -1, (pCur + 8 /* &.pStmt */), uintptr(0))

	for i = 0; (rc == 0) && (i < argc); i++ {
		rc = sqlite3.Xsqlite3_bind_value(tls, (*echo_cursor)(unsafe.Pointer(pCur)).FpStmt, (i + 1), *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8)))
	}

	// If everything was successful, advance to the first row of the scan
	if rc == 0 {
		rc = echoNext(tls, pVtabCursor)
	}

	return rc
}

// A helper function used by echoUpdate() and echoBestIndex() for
// manipulating strings in concert with the sqlite3_mprintf() function.
//
// Parameter pzStr points to a pointer to a string allocated with
// sqlite3_mprintf. The second parameter, zAppend, points to another
// string. The two strings are concatenated together and *pzStr
// set to point at the result. The initial buffer pointed to by *pzStr
// is deallocated via sqlite3_free().
//
// If the third argument, doFree, is true, then sqlite3_free() is
// also called to free the buffer pointed to by zAppend.
func string_concat(tls *crt.TLS, pzStr uintptr, zAppend uintptr, doFree int32, pRc uintptr) { /* test8.c:726:13: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	var zIn uintptr = *(*uintptr)(unsafe.Pointer(pzStr))
	if (!(zAppend != 0) && (doFree != 0)) && (*(*int32)(unsafe.Pointer(pRc)) == 0) {
		*(*int32)(unsafe.Pointer(pRc)) = 7
	}
	if *(*int32)(unsafe.Pointer(pRc)) != 0 {
		sqlite3.Xsqlite3_free(tls, zIn)
		zIn = uintptr(0)
	} else {
		if zIn != 0 {
			var zTemp uintptr = zIn
			zIn = sqlite3.Xsqlite3_mprintf(tls, ts+32374 /* "%s%s" */, crt.VaList(bp, zIn, zAppend))
			sqlite3.Xsqlite3_free(tls, zTemp)
		} else {
			zIn = sqlite3.Xsqlite3_mprintf(tls, ts+130 /* "%s" */, crt.VaList(bp+16, zAppend))
		}
		if !(zIn != 0) {
			*(*int32)(unsafe.Pointer(pRc)) = 7
		}
	}
	*(*uintptr)(unsafe.Pointer(pzStr)) = zIn
	if doFree != 0 {
		sqlite3.Xsqlite3_free(tls, zAppend)
	}
}

// This function returns a pointer to an sqlite3_malloc()ed buffer
// containing the select-list (the thing between keywords SELECT and FROM)
// to query the underlying real table with for the scan described by
// argument pIdxInfo.
//
// If the current SQLite version is earlier than 3.10.0, this is just "*"
// (select all columns). Or, for version 3.10.0 and greater, the list of
// columns identified by the pIdxInfo->colUsed mask.
func echoSelectList(tls *crt.TLS, pTab uintptr, pIdxInfo uintptr) uintptr { /* test8.c:762:13: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	var zRet uintptr = uintptr(0)
	if sqlite3.Xsqlite3_libversion_number(tls) < 3010000 {
		zRet = sqlite3.Xsqlite3_mprintf(tls, ts+32490 /* ", *" */, 0)
	} else {
		var i int32
		for i = 0; i < (*echo_vtab)(unsafe.Pointer(pTab)).FnCol; i++ {
			if ((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FcolUsed & (sqlite3_uint64(uint64(1)) << (func() int32 {
				if i >= 63 {
					return 63
				}
				return i
			}()))) != 0 {
				zRet = sqlite3.Xsqlite3_mprintf(tls, ts+32494 /* "%z, %s" */, crt.VaList(bp, zRet, *(*uintptr)(unsafe.Pointer((*echo_vtab)(unsafe.Pointer(pTab)).FaCol + uintptr(i)*8))))
			} else {
				zRet = sqlite3.Xsqlite3_mprintf(tls, ts+32501 /* "%z, NULL" */, crt.VaList(bp+16, zRet))
			}
			if !(zRet != 0) {
				break
			}
		}
	}
	return zRet
}

// The echo module implements the subset of query constraints and sort
// orders that may take advantage of SQLite indices on the underlying
// real table. For example, if the real table is declared as:
//
//     CREATE TABLE real(a, b, c);
//     CREATE INDEX real_index ON real(b);
//
// then the echo module handles WHERE or ORDER BY clauses that refer
// to the column "b", but not "a" or "c". If a multi-column index is
// present, only its left most column is considered.
//
// This xBestIndex method encodes the proposed search strategy as
// an SQL query on the real table underlying the virtual echo module
// table and stores the query in sqlite3_index_info.idxStr. The SQL
// statement is of the form:
//
//   SELECT rowid, * FROM <real-table> ?<where-clause>? ?<order-by-clause>?
//
// where the <where-clause> and <order-by-clause> are determined
// by the contents of the structure pointed to by the pIdxInfo argument.
func echoBestIndex(tls *crt.TLS, tab uintptr, pIdxInfo uintptr) int32 { /* test8.c:802:12: */
	bp := tls.Alloc(100)
	defer tls.Free(100)

	var ii int32
	*(*uintptr)(unsafe.Pointer(bp + 88 /* zQuery */)) = uintptr(0)
	var zCol uintptr = uintptr(0)
	var zNew uintptr
	var nArg int32 = 0
	var zSep uintptr = ts + 9599 /* "WHERE" */
	var pVtab uintptr = tab
	*(*uintptr)(unsafe.Pointer(bp + 80 /* pStmt */)) = uintptr(0)
	var interp uintptr = (*echo_vtab)(unsafe.Pointer(pVtab)).Finterp

	var nRow int32 = 0
	var useIdx int32 = 0
	*(*int32)(unsafe.Pointer(bp + 96 /* rc */)) = 0
	var useCost int32 = 0
	var cost float64 = float64(0)
	var isIgnoreUsable int32 = 0
	if tcl.XTcl_GetVar2(tls, interp, ts+32510 /* "echo_module_igno..." */, uintptr(0), 1) != 0 {
		isIgnoreUsable = 1
	}

	if simulateVtabError(tls, pVtab, ts+32536 /* "xBestIndex" */) != 0 {
		return 1
	}

	// Determine the number of rows in the table and store this value in local
	// variable nRow. The 'estimated-cost' of the scan will be the number of
	// rows in the table for a linear scan, or the log (base 2) of the
	// number of rows if the proposed scan uses an index.
	if tcl.XTcl_GetVar2(tls, interp, ts+32547 /* "echo_module_cost" */, uintptr(0), 1) != 0 {
		cost = crt.Xatof(tls, tcl.XTcl_GetVar2(tls, interp, ts+32547 /* "echo_module_cost" */, uintptr(0), 1))
		useCost = 1
	} else {
		*(*uintptr)(unsafe.Pointer(bp + 88 /* zQuery */)) = sqlite3.Xsqlite3_mprintf(tls, ts+32564 /* "SELECT count(*) ..." */, crt.VaList(bp, (*echo_vtab)(unsafe.Pointer(pVtab)).FzTableName))
		if !(*(*uintptr)(unsafe.Pointer(bp + 88 /* zQuery */)) != 0) {
			return 7
		}
		*(*int32)(unsafe.Pointer(bp + 96 /* rc */)) = sqlite3.Xsqlite3_prepare(tls, (*echo_vtab)(unsafe.Pointer(pVtab)).Fdb, *(*uintptr)(unsafe.Pointer(bp + 88 /* zQuery */)), -1, bp+80 /* &pStmt */, uintptr(0))
		sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(bp + 88 /* zQuery */)))
		if *(*int32)(unsafe.Pointer(bp + 96 /* rc */)) != 0 {
			return *(*int32)(unsafe.Pointer(bp + 96 /* rc */))
		}
		sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 80 /* pStmt */)))
		nRow = sqlite3.Xsqlite3_column_int(tls, *(*uintptr)(unsafe.Pointer(bp + 80 /* pStmt */)), 0)
		*(*int32)(unsafe.Pointer(bp + 96 /* rc */)) = sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 80 /* pStmt */)))
		if *(*int32)(unsafe.Pointer(bp + 96 /* rc */)) != 0 {
			return *(*int32)(unsafe.Pointer(bp + 96 /* rc */))
		}
	}

	zCol = echoSelectList(tls, pVtab, pIdxInfo)
	if !(zCol != 0) {
		return 7
	}
	*(*uintptr)(unsafe.Pointer(bp + 88 /* zQuery */)) = sqlite3.Xsqlite3_mprintf(tls, ts+32588 /* "SELECT rowid%z F..." */, crt.VaList(bp+8, zCol, (*echo_vtab)(unsafe.Pointer(pVtab)).FzTableName))
	if !(*(*uintptr)(unsafe.Pointer(bp + 88 /* zQuery */)) != 0) {
		return 7
	}

	for ii = 0; ii < (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnConstraint; ii++ {
		var pConstraint uintptr
		var pUsage uintptr
		var iCol int32

		pConstraint = ((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraint + uintptr(ii)*12)
		pUsage = ((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(ii)*8)

		if !(isIgnoreUsable != 0) && !(int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fusable) != 0) {
			continue
		}

		iCol = (*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).FiColumn
		if (iCol < 0) || (*(*int32)(unsafe.Pointer((*echo_vtab)(unsafe.Pointer(pVtab)).FaIndex + uintptr(iCol)*4)) != 0) {
			var zNewCol uintptr
			if iCol >= 0 {
				zNewCol = *(*uintptr)(unsafe.Pointer((*echo_vtab)(unsafe.Pointer(pVtab)).FaCol + uintptr(iCol)*8))
			} else {
				zNewCol = ts + 32611 /* "rowid" */
			}
			var zOp uintptr = uintptr(0)
			useIdx = 1
			switch int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) {
			case 2:
				zOp = ts + 32617 /* "=" */
				break
				fallthrough
			case 16:
				zOp = ts + 32619 /* "<" */
				break
				fallthrough
			case 4:
				zOp = ts + 32621 /* ">" */
				break
				fallthrough
			case 8:
				zOp = ts + 32623 /* "<=" */
				break
				fallthrough
			case 32:
				zOp = ts + 32626 /* ">=" */
				break
				fallthrough
			case 64:
				// Purposely translate the MATCH operator into a LIKE, which
				// will be used by the next block of code to construct a new
				// query.  It should also be noted here that the next block
				// of code requires the first letter of this operator to be
				// in upper-case to trigger the special MATCH handling (i.e.
				// wrapping the bound parameter with literal '%'s).
				zOp = ts + 32629 /* "LIKE" */
				break
				fallthrough
			case 65:
				zOp = ts + 32634 /* "like" */
				break
				fallthrough
			case 66:
				zOp = ts + 32639 /* "glob" */
				break
				fallthrough
			case 67:
				zOp = ts + 6216 /* "regexp" */
				break
			}
			if zOp != 0 {
				if int32(*(*int8)(unsafe.Pointer(zOp + uintptr(0)))) == 'L' {
					zNew = sqlite3.Xsqlite3_mprintf(tls, ts+32644, /* " %s %s LIKE (SEL..." */
						crt.VaList(bp+24, zSep, zNewCol))
				} else {
					zNew = sqlite3.Xsqlite3_mprintf(tls, ts+32679 /* " %s %s %s ?" */, crt.VaList(bp+40, zSep, zNewCol, zOp))
				}
				string_concat(tls, bp+88 /* &zQuery */, zNew, 1, bp+96 /* &rc */)
				zSep = ts + 9626 /* "AND" */
				(*sqlite3_index_constraint_usage)(unsafe.Pointer(pUsage)).FargvIndex = crt.PreIncInt32(&nArg, 1)
				(*sqlite3_index_constraint_usage)(unsafe.Pointer(pUsage)).Fomit = uint8(1)
			}
		}
	}

	// If there is only one term in the ORDER BY clause, and it is
	// on a column that this virtual table has an index for, then consume
	// the ORDER BY clause.
	if ((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnOrderBy == 1) && (((*sqlite3_index_orderby)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaOrderBy)).FiColumn < 0) || (*(*int32)(unsafe.Pointer((*echo_vtab)(unsafe.Pointer(pVtab)).FaIndex + uintptr((*sqlite3_index_orderby)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaOrderBy)).FiColumn)*4)) != 0)) {
		var iCol int32 = (*sqlite3_index_orderby)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaOrderBy)).FiColumn
		var zNewCol uintptr
		if iCol >= 0 {
			zNewCol = *(*uintptr)(unsafe.Pointer((*echo_vtab)(unsafe.Pointer(pVtab)).FaCol + uintptr(iCol)*8))
		} else {
			zNewCol = ts + 32611 /* "rowid" */
		}
		var zDir uintptr
		if (*sqlite3_index_orderby)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaOrderBy)).Fdesc != 0 {
			zDir = ts + 32691 /* "DESC" */
		} else {
			zDir = ts + 32696 /* "ASC" */
		}
		zNew = sqlite3.Xsqlite3_mprintf(tls, ts+32700 /* " ORDER BY %s %s" */, crt.VaList(bp+64, zNewCol, zDir))
		string_concat(tls, bp+88 /* &zQuery */, zNew, 1, bp+96 /* &rc */)
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).ForderByConsumed = 1
	}

	appendToEchoModule(tls, (*echo_vtab)(unsafe.Pointer(pVtab)).Finterp, ts+32536 /* "xBestIndex" */)

	appendToEchoModule(tls, (*echo_vtab)(unsafe.Pointer(pVtab)).Finterp, *(*uintptr)(unsafe.Pointer(bp + 88 /* zQuery */)))

	if !(*(*uintptr)(unsafe.Pointer(bp + 88 /* zQuery */)) != 0) {
		return *(*int32)(unsafe.Pointer(bp + 96 /* rc */))
	}
	(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxNum = hashString(tls, *(*uintptr)(unsafe.Pointer(bp + 88 /* zQuery */)))
	(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxStr = *(*uintptr)(unsafe.Pointer(bp + 88 /* zQuery */))
	(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FneedToFreeIdxStr = 1
	if useCost != 0 {
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = cost
	} else if useIdx != 0 {
		// Approximation of log2(nRow).
		for ii = 0; uint64(ii) < ((uint64(unsafe.Sizeof(int32(0))) * uint64(8)) - uint64(1)); ii++ {
			if (nRow & (int32(1) << ii)) != 0 {
				(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = float64(ii)
			}
		}
	} else {
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = float64(nRow)
	}
	return *(*int32)(unsafe.Pointer(bp + 96 /* rc */))
}

// The xUpdate method for echo module virtual tables.
//
//    apData[0]  apData[1]  apData[2..]
//
//    INTEGER                              DELETE
//
//    INTEGER    NULL       (nCol args)    UPDATE (do not set rowid)
//    INTEGER    INTEGER    (nCol args)    UPDATE (with SET rowid = <arg1>)
//
//    NULL       NULL       (nCol args)    INSERT INTO (automatic rowid value)
//    NULL       INTEGER    (nCol args)    INSERT (incl. rowid value)
//
func echoUpdate(tls *crt.TLS, tab uintptr, nData int32, apData uintptr, pRowid uintptr) int32 { /* test8.c:968:5: */
	bp := tls.Alloc(136)
	defer tls.Free(136)

	var pVtab uintptr = tab
	var db uintptr = (*echo_vtab)(unsafe.Pointer(pVtab)).Fdb
	*(*int32)(unsafe.Pointer(bp + 104 /* rc */)) = 0

	*(*uintptr)(unsafe.Pointer(bp + 128 /* pStmt */)) = uintptr(0)
	*(*uintptr)(unsafe.Pointer(bp + 96 /* z */)) = uintptr(0) // SQL statement to execute
	var bindArgZero int32 = 0                                 // True to bind apData[0] to sql var no. nData
	var bindArgOne int32 = 0                                  // True to bind apData[1] to sql var no. 1
	var i int32                                               // Counter variable used by for loops

	// Ticket #3083 - make sure we always start a transaction prior to
	// making any changes to a virtual table

	if simulateVtabError(tls, pVtab, ts+32716 /* "xUpdate" */) != 0 {
		return 1
	}

	// If apData[0] is an integer and nData>1 then do an UPDATE
	if (nData > 1) && (sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(apData + uintptr(0)*8))) == 1) {
		var zSep uintptr = ts + 32724 /* " SET" */
		*(*uintptr)(unsafe.Pointer(bp + 96 /* z */)) = sqlite3.Xsqlite3_mprintf(tls, ts+32729 /* "UPDATE %Q" */, crt.VaList(bp, (*echo_vtab)(unsafe.Pointer(pVtab)).FzTableName))
		if !(*(*uintptr)(unsafe.Pointer(bp + 96 /* z */)) != 0) {
			*(*int32)(unsafe.Pointer(bp + 104 /* rc */)) = 7
		}

		bindArgOne = (crt.Bool32((*(*uintptr)(unsafe.Pointer(apData + uintptr(1)*8)) != 0) && (sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(apData + uintptr(1)*8))) == 1)))
		bindArgZero = 1

		if bindArgOne != 0 {
			string_concat(tls, bp+96 /* &z */, ts+32739 /* " SET rowid=?1 " */, 0, bp+104 /* &rc */)
			zSep = ts + 4261 /* "," */
		}
		for i = 2; i < nData; i++ {
			if *(*uintptr)(unsafe.Pointer(apData + uintptr(i)*8)) == uintptr(0) {
				continue
			}
			string_concat(tls, bp+96 /* &z */, sqlite3.Xsqlite3_mprintf(tls,
				ts+32754 /* "%s %Q=?%d" */, crt.VaList(bp+8, zSep, *(*uintptr)(unsafe.Pointer((*echo_vtab)(unsafe.Pointer(pVtab)).FaCol + uintptr((i-2))*8)), i)), 1, bp+104 /* &rc */)
			zSep = ts + 4261 /* "," */
		}
		string_concat(tls, bp+96 /* &z */, sqlite3.Xsqlite3_mprintf(tls, ts+32764 /* " WHERE rowid=?%d" */, crt.VaList(bp+32, nData)), 1, bp+104 /* &rc */)
	} else if (nData == 1) && (sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(apData + uintptr(0)*8))) == 1) {
		*(*uintptr)(unsafe.Pointer(bp + 96 /* z */)) = sqlite3.Xsqlite3_mprintf(tls, ts+32781 /* "DELETE FROM %Q W..." */, crt.VaList(bp+40, (*echo_vtab)(unsafe.Pointer(pVtab)).FzTableName))
		if !(*(*uintptr)(unsafe.Pointer(bp + 96 /* z */)) != 0) {
			*(*int32)(unsafe.Pointer(bp + 104 /* rc */)) = 7
		}
		bindArgZero = 1
	} else if (nData > 2) && (sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(apData + uintptr(0)*8))) == 5) {
		var ii int32
		*(*uintptr)(unsafe.Pointer(bp + 112 /* zInsert */)) = uintptr(0)
		*(*uintptr)(unsafe.Pointer(bp + 120 /* zValues */)) = uintptr(0)

		*(*uintptr)(unsafe.Pointer(bp + 112 /* zInsert */)) = sqlite3.Xsqlite3_mprintf(tls, ts+32813 /* "INSERT INTO %Q (" */, crt.VaList(bp+48, (*echo_vtab)(unsafe.Pointer(pVtab)).FzTableName))
		if !(*(*uintptr)(unsafe.Pointer(bp + 112 /* zInsert */)) != 0) {
			*(*int32)(unsafe.Pointer(bp + 104 /* rc */)) = 7
		}
		if sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(apData + uintptr(1)*8))) == 1 {
			bindArgOne = 1
			*(*uintptr)(unsafe.Pointer(bp + 120 /* zValues */)) = sqlite3.Xsqlite3_mprintf(tls, ts+2682 /* "?" */, 0)
			string_concat(tls, bp+112 /* &zInsert */, ts+32611 /* "rowid" */, 0, bp+104 /* &rc */)
		}

		for ii = 2; ii < nData; ii++ {
			string_concat(tls, bp+112, /* &zInsert */
				sqlite3.Xsqlite3_mprintf(tls, ts+32830 /* "%s%Q" */, crt.VaList(bp+56, func() uintptr {
					if *(*uintptr)(unsafe.Pointer(bp + 120 /* zValues */)) != 0 {
						return ts + 359 /* ", " */
					}
					return ts + 792 /* "" */
				}(), *(*uintptr)(unsafe.Pointer((*echo_vtab)(unsafe.Pointer(pVtab)).FaCol + uintptr((ii-2))*8)))), 1, bp+104 /* &rc */)
			string_concat(tls, bp+120, /* &zValues */
				sqlite3.Xsqlite3_mprintf(tls, ts+32835 /* "%s?%d" */, crt.VaList(bp+72, func() uintptr {
					if *(*uintptr)(unsafe.Pointer(bp + 120 /* zValues */)) != 0 {
						return ts + 359 /* ", " */
					}
					return ts + 792 /* "" */
				}(), ii)), 1, bp+104 /* &rc */)
		}

		string_concat(tls, bp+96 /* &z */, *(*uintptr)(unsafe.Pointer(bp + 112 /* zInsert */)), 1, bp+104 /* &rc */)
		string_concat(tls, bp+96 /* &z */, ts+32841 /* ") VALUES(" */, 0, bp+104 /* &rc */)
		string_concat(tls, bp+96 /* &z */, *(*uintptr)(unsafe.Pointer(bp + 120 /* zValues */)), 1, bp+104 /* &rc */)
		string_concat(tls, bp+96 /* &z */, ts+793 /* ")" */, 0, bp+104 /* &rc */)
	} else {

		return 1
	}

	if *(*int32)(unsafe.Pointer(bp + 104 /* rc */)) == 0 {
		*(*int32)(unsafe.Pointer(bp + 104 /* rc */)) = sqlite3.Xsqlite3_prepare(tls, db, *(*uintptr)(unsafe.Pointer(bp + 96 /* z */)), -1, bp+128 /* &pStmt */, uintptr(0))
	}

	sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(bp + 96 /* z */)))
	if *(*int32)(unsafe.Pointer(bp + 104 /* rc */)) == 0 {
		if bindArgZero != 0 {
			sqlite3.Xsqlite3_bind_value(tls, *(*uintptr)(unsafe.Pointer(bp + 128 /* pStmt */)), nData, *(*uintptr)(unsafe.Pointer(apData + uintptr(0)*8)))
		}
		if bindArgOne != 0 {
			sqlite3.Xsqlite3_bind_value(tls, *(*uintptr)(unsafe.Pointer(bp + 128 /* pStmt */)), 1, *(*uintptr)(unsafe.Pointer(apData + uintptr(1)*8)))
		}
		for i = 2; (i < nData) && (*(*int32)(unsafe.Pointer(bp + 104 /* rc */)) == 0); i++ {
			if *(*uintptr)(unsafe.Pointer(apData + uintptr(i)*8)) != 0 {
				*(*int32)(unsafe.Pointer(bp + 104 /* rc */)) = sqlite3.Xsqlite3_bind_value(tls, *(*uintptr)(unsafe.Pointer(bp + 128 /* pStmt */)), i, *(*uintptr)(unsafe.Pointer(apData + uintptr(i)*8)))
			}
		}
		if *(*int32)(unsafe.Pointer(bp + 104 /* rc */)) == 0 {
			sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 128 /* pStmt */)))
			*(*int32)(unsafe.Pointer(bp + 104 /* rc */)) = sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 128 /* pStmt */)))
		} else {
			sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 128 /* pStmt */)))
		}
	}

	if (pRowid != 0) && (*(*int32)(unsafe.Pointer(bp + 104 /* rc */)) == 0) {
		*(*sqlite_int64)(unsafe.Pointer(pRowid)) = sqlite3.Xsqlite3_last_insert_rowid(tls, db)
	}
	if *(*int32)(unsafe.Pointer(bp + 104 /* rc */)) != 0 {
		(*sqlite3_vtab)(unsafe.Pointer(tab)).FzErrMsg = sqlite3.Xsqlite3_mprintf(tls, ts+32217 /* "echo-vtab-error:..." */, crt.VaList(bp+88, sqlite3.Xsqlite3_errmsg(tls, db)))
	}

	return *(*int32)(unsafe.Pointer(bp + 104 /* rc */))
}

// xBegin, xSync, xCommit and xRollback callbacks for echo module
// virtual tables. Do nothing other than add the name of the callback
// to the $::echo_module Tcl variable.
func echoTransactionCall(tls *crt.TLS, tab uintptr, zCall uintptr) int32 { /* test8.c:1101:12: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var z uintptr
	var pVtab uintptr = tab
	z = sqlite3.Xsqlite3_mprintf(tls, ts+32851 /* "echo(%s)" */, crt.VaList(bp, (*echo_vtab)(unsafe.Pointer(pVtab)).FzTableName))
	if z == uintptr(0) {
		return 7
	}
	appendToEchoModule(tls, (*echo_vtab)(unsafe.Pointer(pVtab)).Finterp, zCall)
	appendToEchoModule(tls, (*echo_vtab)(unsafe.Pointer(pVtab)).Finterp, z)
	sqlite3.Xsqlite3_free(tls, z)
	return 0
}
func echoBegin(tls *crt.TLS, tab uintptr) int32 { /* test8.c:1111:12: */
	var rc int32
	var pVtab uintptr = tab
	var interp uintptr = (*echo_vtab)(unsafe.Pointer(pVtab)).Finterp
	var zVal uintptr

	// Ticket #3083 - do not start a transaction if we are already in
	// a transaction

	if simulateVtabError(tls, pVtab, ts+32860 /* "xBegin" */) != 0 {
		return 1
	}

	rc = echoTransactionCall(tls, tab, ts+32860 /* "xBegin" */)

	if rc == 0 {
		// Check if the $::echo_module_begin_fail variable is defined. If it is,
		// and it is set to the name of the real table underlying this virtual
		// echo module table, then cause this xSync operation to fail.
		zVal = tcl.XTcl_GetVar2(tls, interp, ts+32867 /* "echo_module_begi..." */, uintptr(0), 1)
		if (zVal != 0) && (0 == crt.Xstrcmp(tls, zVal, (*echo_vtab)(unsafe.Pointer(pVtab)).FzTableName)) {
			rc = 1
		}
	}
	if rc == 0 {
		(*echo_vtab)(unsafe.Pointer(pVtab)).FinTransaction = 1
	}
	return rc
}
func echoSync(tls *crt.TLS, tab uintptr) int32 { /* test8.c:1142:12: */
	var rc int32
	var pVtab uintptr = tab
	var interp uintptr = (*echo_vtab)(unsafe.Pointer(pVtab)).Finterp
	var zVal uintptr

	// Ticket #3083 - Only call xSync if we have previously started a
	// transaction

	if simulateVtabError(tls, pVtab, ts+32890 /* "xSync" */) != 0 {
		return 1
	}

	rc = echoTransactionCall(tls, tab, ts+32890 /* "xSync" */)

	if rc == 0 {
		// Check if the $::echo_module_sync_fail variable is defined. If it is,
		// and it is set to the name of the real table underlying this virtual
		// echo module table, then cause this xSync operation to fail.
		zVal = tcl.XTcl_GetVar2(tls, interp, ts+32896 /* "echo_module_sync..." */, uintptr(0), 1)
		if (zVal != 0) && (0 == crt.Xstrcmp(tls, zVal, (*echo_vtab)(unsafe.Pointer(pVtab)).FzTableName)) {
			rc = -1
		}
	}
	return rc
}
func echoCommit(tls *crt.TLS, tab uintptr) int32 { /* test8.c:1170:12: */
	var pVtab uintptr = tab
	var rc int32

	// Ticket #3083 - Only call xCommit if we have previously started
	// a transaction

	if simulateVtabError(tls, pVtab, ts+32918 /* "xCommit" */) != 0 {
		return 1
	}

	sqlite3.Xsqlite3BeginBenignMalloc(tls)
	rc = echoTransactionCall(tls, tab, ts+32918 /* "xCommit" */)
	sqlite3.Xsqlite3EndBenignMalloc(tls)
	(*echo_vtab)(unsafe.Pointer(pVtab)).FinTransaction = 0
	return rc
}
func echoRollback(tls *crt.TLS, tab uintptr) int32 { /* test8.c:1188:12: */
	var rc int32
	var pVtab uintptr = tab

	// Ticket #3083 - Only call xRollback if we have previously started
	// a transaction

	rc = echoTransactionCall(tls, tab, ts+32926 /* "xRollback" */)
	(*echo_vtab)(unsafe.Pointer(pVtab)).FinTransaction = 0
	return rc
}

// Implementation of "GLOB" function on the echo module.  Pass
// all arguments to the ::echo_glob_overload procedure of TCL
// and return the result of that procedure as a string.
func overloadedGlobFunction(tls *crt.TLS, pContext uintptr, nArg int32, apArg uintptr) { /* test8.c:1206:13: */
	bp := tls.Alloc(216)
	defer tls.Free(216)

	var interp uintptr = sqlite3.Xsqlite3_user_data(tls, pContext)
	// var str Tcl_DString at bp, 216

	var i int32
	var rc int32
	tcl.XTcl_DStringInit(tls, bp /* &str */)
	tcl.XTcl_DStringAppendElement(tls, bp /* &str */, ts+32936 /* "::echo_glob_over..." */)
	for i = 0; i < nArg; i++ {
		tcl.XTcl_DStringAppendElement(tls, bp /* &str */, sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(apArg + uintptr(i)*8))))
	}
	rc = tcl.XTcl_Eval(tls, interp, (*Tcl_DString)(unsafe.Pointer(bp /* &str */)).Fstring)
	tcl.XTcl_DStringFree(tls, bp /* &str */)
	if rc != 0 {
		sqlite3.Xsqlite3_result_error(tls, pContext, tcl.XTcl_GetStringResult(tls, interp), -1)
	} else {
		sqlite3.Xsqlite3_result_text(tls, pContext, tcl.XTcl_GetStringResult(tls, interp),
			-1, crt.UintptrFromInt32(-1))
	}
	tcl.XTcl_ResetResult(tls, interp)
}

// This is the xFindFunction implementation for the echo module.
// SQLite calls this routine when the first argument of a function
// is a column of an echo virtual table.  This routine can optionally
// override the implementation of that function.  It will choose to
// do so if the function is named "glob", and a TCL command named
// ::echo_glob_overload exists.
func echoFindFunction(tls *crt.TLS, vtab uintptr, nArg int32, zFuncName uintptr, pxFunc uintptr, ppArg uintptr) int32 { /* test8.c:1239:12: */
	bp := tls.Alloc(64)
	defer tls.Free(64)

	var pVtab uintptr = vtab
	var interp uintptr = (*echo_vtab)(unsafe.Pointer(pVtab)).Finterp
	// var info Tcl_CmdInfo at bp, 64

	if crt.Xstrcmp(tls, zFuncName, ts+32639 /* "glob" */) != 0 {
		return 0
	}
	if tcl.XTcl_GetCommandInfo(tls, interp, ts+32936 /* "::echo_glob_over..." */, bp /* &info */) == 0 {
		return 0
	}
	*(*uintptr)(unsafe.Pointer(pxFunc)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, int32, uintptr)
	}{overloadedGlobFunction}))
	*(*uintptr)(unsafe.Pointer(ppArg)) = interp
	return 1
}

func echoRename(tls *crt.TLS, vtab uintptr, zNewName uintptr) int32 { /* test8.c:1260:12: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	var rc int32 = 0
	var p uintptr = vtab

	if simulateVtabError(tls, p, ts+32957 /* "xRename" */) != 0 {
		return 1
	}

	if (*echo_vtab)(unsafe.Pointer(p)).FisPattern != 0 {
		var nThis int32 = int32(crt.Xstrlen(tls, (*echo_vtab)(unsafe.Pointer(p)).FzThis))
		var zSql uintptr = sqlite3.Xsqlite3_mprintf(tls, ts+32965, /* "ALTER TABLE %s R..." */
			crt.VaList(bp, (*echo_vtab)(unsafe.Pointer(p)).FzTableName, zNewName, ((*echo_vtab)(unsafe.Pointer(p)).FzTableName+uintptr(nThis))))
		rc = sqlite3.Xsqlite3_exec(tls, (*echo_vtab)(unsafe.Pointer(p)).Fdb, zSql, uintptr(0), uintptr(0), uintptr(0))
		sqlite3.Xsqlite3_free(tls, zSql)
	}

	return rc
}

func echoSavepoint(tls *crt.TLS, pVTab uintptr, iSavepoint int32) int32 { /* test8.c:1280:12: */

	return 0
}

func echoRelease(tls *crt.TLS, pVTab uintptr, iSavepoint int32) int32 { /* test8.c:1285:12: */

	return 0
}

func echoRollbackTo(tls *crt.TLS, pVTab uintptr, iSavepoint int32) int32 { /* test8.c:1290:12: */

	return 0
}

// A virtual table module that merely "echos" the contents of another
// table (like an SQL VIEW).
var echoModule = sqlite3_module{FiVersion: 1, FxCreate: // iVersion
0, FxConnect:                                           0, FxBestIndex: 0, FxDisconnect: 0, FxDestroy: 0, FxOpen: 0, FxClose: // xOpen - open a cursor
0, FxFilter:// xClose - close a cursor
0, FxNext:// xFilter - configure scan constraints
0, FxEof:// xNext - advance a cursor
0, FxColumn:// xEof
0, FxRowid:// xColumn - read data
0, FxUpdate:// xRowid - read data
0, FxBegin:// xUpdate - write data
0, FxSync:// xBegin - begin transaction
0, FxCommit:// xSync - sync transaction
0, FxRollback:// xCommit - commit transaction
0, FxFindFunction:// xRollback - rollback transaction
0, FxRename:// xFindFunction - function overloading
0, // xRename - rename the table
} /* test8.c:1299:23 */

var echoModuleV2 = sqlite3_module{FiVersion: 2, FxCreate: // iVersion
0, FxConnect:                                             0, FxBestIndex: 0, FxDisconnect: 0, FxDestroy: 0, FxOpen: 0, FxClose: // xOpen - open a cursor
0, FxFilter:// xClose - close a cursor
0, FxNext:// xFilter - configure scan constraints
0, FxEof:// xNext - advance a cursor
0, FxColumn:// xEof
0, FxRowid:// xColumn - read data
0, FxUpdate:// xRowid - read data
0, FxBegin:// xUpdate - write data
0, FxSync:// xBegin - begin transaction
0, FxCommit:// xSync - sync transaction
0, FxRollback:// xCommit - commit transaction
0, FxFindFunction:// xRollback - rollback transaction
0, FxRename:// xFindFunction - function overloading
0, FxSavepoint:// xRename - rename the table
0, FxRelease: 0, FxRollbackTo: 0,
} /* test8.c:1322:23 */

func moduleDestroy(tls *crt.TLS, p uintptr) { /* test8.c:1354:13: */
	sqlite3.Xsqlite3_free(tls, p)
}

// Register the echo virtual table module.
func register_echo_module(tls *crt.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test8.c:1361:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var rc int32
	// var db uintptr at bp, 8

	var pMod uintptr
	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+2452 /* "DB" */)
		return 1
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), bp /* &db */) != 0 {
		return 1
	}

	// Virtual table module "echo"
	pMod = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(EchoModule{})))
	(*EchoModule)(unsafe.Pointer(pMod)).Finterp = interp
	rc = sqlite3.Xsqlite3_create_module_v2(tls,
		*(*uintptr)(unsafe.Pointer(bp /* db */)), ts+32995 /* "echo" */, uintptr(unsafe.Pointer(&echoModule)), pMod, *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, uintptr) }{moduleDestroy})))

	// Virtual table module "echo_v2"
	if rc == 0 {
		pMod = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(EchoModule{})))
		(*EchoModule)(unsafe.Pointer(pMod)).Finterp = interp
		rc = sqlite3.Xsqlite3_create_module_v2(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), ts+33000, /* "echo_v2" */
			uintptr(unsafe.Pointer(&echoModuleV2)), pMod, *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, uintptr) }{moduleDestroy})))
	}

	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))
	return 0
}

// Tcl interface to sqlite3_declare_vtab, invoked as follows from Tcl:
//
// sqlite3_declare_vtab DB SQL
func declare_vtab(tls *crt.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test8.c:1401:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// var db uintptr at bp, 8

	var rc int32
	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+33008 /* "DB SQL" */)
		return 1
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), bp /* &db */) != 0 {
		return 1
	}
	rc = sqlite3.Xsqlite3_declare_vtab(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8))))
	if rc != 0 {
		tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3_errmsg(tls, *(*uintptr)(unsafe.Pointer(bp /* db */))), uintptr(1))
		return 1
	}
	return 0
}

// Register commands with the TCL interpreter.
func Sqlitetest8_Init(tls *crt.TLS, interp uintptr) int32 { /* test8.c:1427:5: */
	var i int32
	for i = 0; uint64(i) < (uint64(unsafe.Sizeof(aObjCmd2)) / uint64(unsafe.Sizeof(struct {
		FzName      uintptr
		FxProc      uintptr
		FclientData uintptr
	}{}))); i++ {
		tcl.XTcl_CreateObjCommand(tls, interp, aObjCmd2[i].FzName,
			aObjCmd2[i].FxProc, aObjCmd2[i].FclientData, uintptr(0))
	}
	return 0
}

var aObjCmd2 = [2]struct {
	FzName      uintptr
	FxProc      uintptr
	FclientData uintptr
}{
	{FzName: ts + 33015 /* "register_echo_mo..." */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 33036 /* "sqlite3_declare_..." */, FxProc: 0, FclientData: uintptr(0)},
} /* test8.c:1433:5 */

// end block for C++

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:
// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.20 General utilities	<stdlib.h>

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.21 String handling	<string.h>

// c_collation_test
func c_collation_test(tls *crt.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test9.c:29:26: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var zErrFunction uintptr
	// var db uintptr at bp+24, 8

	var rc int32
	zErrFunction = ts + 33057 /* "N/A" */
	if !(objc != 1) {
		goto __1
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+792 /* "" */)
	return 1
__1:
	;

	// Open a database.
	rc = sqlite3.Xsqlite3_open(tls, ts+2108 /* ":memory:" */, bp+24 /* &db */)
	if !(rc != 0) {
		goto __2
	}
	zErrFunction = ts + 27426 /* "sqlite3_open" */
	goto error_out
__2:
	;

	rc = sqlite3.Xsqlite3_create_collation(tls, *(*uintptr)(unsafe.Pointer(bp + 24 /* db */)), ts+20084 /* "collate" */, 456, uintptr(0), uintptr(0))
	if !(rc != 21) {
		goto __3
	}
	sqlite3.Xsqlite3_close(tls, *(*uintptr)(unsafe.Pointer(bp + 24 /* db */)))
	zErrFunction = ts + 33061 /* "sqlite3_create_c..." */
	goto error_out
__3:
	;

	sqlite3.Xsqlite3_close(tls, *(*uintptr)(unsafe.Pointer(bp + 24 /* db */)))
	return 0

error_out:
	tcl.XTcl_ResetResult(tls, interp)
	tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+33086 /* "Error testing fu..." */, zErrFunction, 0))
	return 1
}

// c_realloc_test
func c_realloc_test(tls *crt.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test9.c:70:26: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	var p uintptr
	var zErrFunction uintptr
	zErrFunction = ts + 33057 /* "N/A" */

	if !(objc != 1) {
		goto __1
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+792 /* "" */)
	return 1
__1:
	;

	p = sqlite3.Xsqlite3_malloc(tls, 5)
	if !(!(p != 0)) {
		goto __2
	}
	zErrFunction = ts + 33111 /* "sqlite3_malloc" */
	goto error_out
__2:
	;

	// Test that realloc()ing a block of memory to a negative size is
	// the same as free()ing that memory.
	p = sqlite3.Xsqlite3_realloc(tls, p, -1)
	if !(p != 0) {
		goto __3
	}
	zErrFunction = ts + 33126 /* "sqlite3_realloc" */
	goto error_out
__3:
	;

	return 0

error_out:
	tcl.XTcl_ResetResult(tls, interp)
	tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+33086 /* "Error testing fu..." */, zErrFunction, 0))
	return 1
}

// c_misuse_test
func c_misuse_test(tls *crt.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test9.c:111:26: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	var zErrFunction uintptr
	// var db uintptr at bp+24, 8

	// var pStmt uintptr at bp+32, 8

	var rc int32
	zErrFunction = ts + 33057 /* "N/A" */
	*(*uintptr)(unsafe.Pointer(bp + 24 /* db */)) = uintptr(0)

	if !(objc != 1) {
		goto __1
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+792 /* "" */)
	return 1
__1:
	;

	// Open a database. Then close it again. We need to do this so that
	// we have a "closed database handle" to pass to various API functions.
	rc = sqlite3.Xsqlite3_open(tls, ts+2108 /* ":memory:" */, bp+24 /* &db */)
	if !(rc != 0) {
		goto __2
	}
	zErrFunction = ts + 27426 /* "sqlite3_open" */
	goto error_out
__2:
	;
	sqlite3.Xsqlite3_close(tls, *(*uintptr)(unsafe.Pointer(bp + 24 /* db */)))

	rc = sqlite3.Xsqlite3_errcode(tls, *(*uintptr)(unsafe.Pointer(bp + 24 /* db */)))
	if !(rc != 21) {
		goto __3
	}
	zErrFunction = ts + 27353 /* "sqlite3_errcode" */
	goto error_out
__3:
	;

	*(*uintptr)(unsafe.Pointer(bp + 32 /* pStmt */)) = uintptr(1234)
	rc = sqlite3.Xsqlite3_prepare(tls, *(*uintptr)(unsafe.Pointer(bp + 24 /* db */)), uintptr(0), 0, bp+32 /* &pStmt */, uintptr(0))
	if !(rc != 21) {
		goto __4
	}
	zErrFunction = ts + 27507 /* "sqlite3_prepare" */
	goto error_out
__4:
	;
	// Verify that pStmt is zeroed even on a MISUSE error

	*(*uintptr)(unsafe.Pointer(bp + 32 /* pStmt */)) = uintptr(1234)
	rc = sqlite3.Xsqlite3_prepare_v2(tls, *(*uintptr)(unsafe.Pointer(bp + 24 /* db */)), uintptr(0), 0, bp+32 /* &pStmt */, uintptr(0))
	if !(rc != 21) {
		goto __5
	}
	zErrFunction = ts + 27541 /* "sqlite3_prepare_..." */
	goto error_out
__5:
	;

	return 0

error_out:
	tcl.XTcl_ResetResult(tls, interp)
	tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+33086 /* "Error testing fu..." */, zErrFunction, 0))
	return 1
}

// Register commands with the TCL interpreter.
func Sqlitetest9_Init(tls *crt.TLS, interp uintptr) int32 { /* test9.c:188:5: */
	var i int32
	for i = 0; uint64(i) < (uint64(unsafe.Sizeof(aObjCmd3)) / uint64(unsafe.Sizeof(struct {
		FzName      uintptr
		FxProc      uintptr
		FclientData uintptr
	}{}))); i++ {
		tcl.XTcl_CreateObjCommand(tls, interp, aObjCmd3[i].FzName,
			aObjCmd3[i].FxProc, aObjCmd3[i].FclientData, uintptr(0))
	}
	return 0
}

var aObjCmd3 = [3]struct {
	FzName      uintptr
	FxProc      uintptr
	FclientData uintptr
}{
	{FzName: ts + 33142 /* "c_misuse_test" */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 33156 /* "c_realloc_test" */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 33171 /* "c_collation_test" */, FxProc: 0, FclientData: uintptr(0)},
} /* test9.c:193:5 */

// end block for C++

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:

// This routine registers the custom TCL commands defined in this
// module.  This should be the only procedure visible from outside
// of this module.
func Sqlitetestasync_Init(tls *crt.TLS, interp uintptr) int32 { /* test_async.c:238:5: */
	return 0
}

// The following macros redefine the API routines so that they are
// redirected through the global sqlite3_api structure.
//
// This header file is also used by the loadext.c source file
// (part of the main SQLite library - not an extension) so that
// it can get access to the sqlite3_api_routines structure
// definition.  But the main library does not want to redefine
// the API.  So the redefinition macros are only valid if the
// SQLITE_CORE macros is undefined.

// This case when the file is being statically linked into the
// application

// tclcmd:   sqlite3_reset_auto_extension
//
// Reset all auto-extensions
func resetAutoExtObjCmd(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_autoext.c:196:26: */
	sqlite3.Xsqlite3_reset_auto_extension(tls)
	return 0
}

// This procedure registers the TCL procs defined in this file.
func Sqlitetest_autoext_Init(tls *crt.TLS, interp uintptr) int32 { /* test_autoext.c:210:5: */
	tcl.XTcl_CreateObjCommand(tls, interp, ts+33188, /* "sqlite3_reset_au..." */
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
		}{resetAutoExtObjCmd})), uintptr(0), uintptr(0))
	return 0
}

func backupTestCmd(tls *crt.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_backup.c:33:26: */
	bp := tls.Alloc(196)
	defer tls.Free(196)

	const ( /* test_backup.c:39:3: */
		BACKUP_STEP      = 0
		BACKUP_FINISH    = 1
		BACKUP_REMAINING = 2
		BACKUP_PAGECOUNT = 3
	)
	*(*[5]BackupSubCommand)(unsafe.Pointer(bp /* aSub */)) = [5]BackupSubCommand{
		{FzCmd: ts + 16502 /* "step" */, FeCmd: BACKUP_STEP, FnArg: 1, FzArg: ts + 33217 /* "npage" */},
		{FzCmd: ts + 33223 /* "finish" */, FeCmd: BACKUP_FINISH, FnArg: 0, FzArg: ts + 792 /* "" */},
		{FzCmd: ts + 33230 /* "remaining" */, FeCmd: BACKUP_REMAINING, FnArg: 0, FzArg: ts + 792 /* "" */},
		{FzCmd: ts + 33240 /* "pagecount" */, FeCmd: BACKUP_PAGECOUNT, FnArg: 0, FzArg: ts + 792 /* "" */},
		{FzCmd: uintptr(0), FeCmd: uint32(0), FnArg: 0, FzArg: uintptr(0)},
	}

	var p uintptr = clientData
	// var iCmd int32 at bp+120, 4

	var rc int32

	rc = tcl.XTcl_GetIndexFromObjStruct(tls,
		interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)), bp /* &aSub[0] */, int32(unsafe.Sizeof(BackupSubCommand{})), ts+18405 /* "option" */, 0, bp+120 /* &iCmd */)
	if rc != 0 {
		return rc
	}
	if objc != (2 + (*BackupSubCommand)(unsafe.Pointer(bp /* &aSub */ +uintptr(*(*int32)(unsafe.Pointer(bp + 120 /* iCmd */)))*24)).FnArg) {
		tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, (*BackupSubCommand)(unsafe.Pointer(bp /* &aSub */ +uintptr(*(*int32)(unsafe.Pointer(bp + 120 /* iCmd */)))*24)).FzArg)
		return 1
	}

	switch (*BackupSubCommand)(unsafe.Pointer(bp /* &aSub */ + uintptr(*(*int32)(unsafe.Pointer(bp + 120 /* iCmd */)))*24)).FeCmd {

	case BACKUP_FINISH:
		{
			var zCmdName uintptr
			// var cmdInfo Tcl_CmdInfo at bp+128, 64

			zCmdName = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(0)*8)))
			tcl.XTcl_GetCommandInfo(tls, interp, zCmdName, bp+128 /* &cmdInfo */)
			(*Tcl_CmdInfo)(unsafe.Pointer(bp + 128 /* &cmdInfo */)).FdeleteProc = uintptr(0)
			tcl.XTcl_SetCommandInfo(tls, interp, zCmdName, bp+128 /* &cmdInfo */)
			tcl.XTcl_DeleteCommand(tls, interp, zCmdName)

			rc = sqlite3.Xsqlite3_backup_finish(tls, p)
			tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))
			break
		}

	case BACKUP_STEP:
		{
			// var nPage int32 at bp+192, 4

			if 0 != tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)), bp+192 /* &nPage */) {
				return 1
			}
			rc = sqlite3.Xsqlite3_backup_step(tls, p, *(*int32)(unsafe.Pointer(bp + 192 /* nPage */)))
			tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))
			break
		}

	case BACKUP_REMAINING:
		tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, sqlite3.Xsqlite3_backup_remaining(tls, p)))
		break

	case BACKUP_PAGECOUNT:
		tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, sqlite3.Xsqlite3_backup_pagecount(tls, p)))
		break
	}

	return 0
}

type BackupSubCommand = struct {
	FzCmd uintptr
	FeCmd uint32
	FnArg int32
	FzArg uintptr
}

func backupTestFinish(tls *crt.TLS, clientData ClientData) { /* test_backup.c:108:27: */
	var pBackup uintptr = clientData
	sqlite3.Xsqlite3_backup_finish(tls, pBackup)
}

//     sqlite3_backup CMDNAME DESTHANDLE DESTNAME SRCHANDLE SRCNAME
//
func backupTestInit(tls *crt.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_backup.c:117:26: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var pBackup uintptr
	// var pDestDb uintptr at bp+16, 8

	// var pSrcDb uintptr at bp+24, 8

	var zDestName uintptr
	var zSrcName uintptr
	var zCmd uintptr

	if objc != 6 {
		tcl.XTcl_WrongNumArgs(tls,
			interp, 1, objv, ts+33250 /* "CMDNAME DESTHAND..." */)
		return 1
	}

	zCmd = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)))
	getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8))), bp+16 /* &pDestDb */)
	zDestName = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(3)*8)))
	getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(4)*8))), bp+24 /* &pSrcDb */)
	zSrcName = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(5)*8)))

	pBackup = sqlite3.Xsqlite3_backup_init(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* pDestDb */)), zDestName, *(*uintptr)(unsafe.Pointer(bp + 24 /* pSrcDb */)), zSrcName)
	if !(pBackup != 0) {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+33296 /* "sqlite3_backup_i..." */, 0))
		return 1
	}

	tcl.XTcl_CreateObjCommand(tls, interp, zCmd, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
	}{backupTestCmd})), pBackup, *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, ClientData) }{backupTestFinish})))
	tcl.XTcl_SetObjResult(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)))
	return 0
}

func Sqlitetestbackup_Init(tls *crt.TLS, interp uintptr) int32 { /* test_backup.c:154:5: */
	tcl.XTcl_CreateObjCommand(tls, interp, ts+33325 /* "sqlite3_backup" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
	}{backupTestInit})), uintptr(0), uintptr(0))
	return 0
}

// end block for C++

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:

type tcl_vtab1 = struct {
	Fbase   sqlite3_vtab
	Finterp uintptr
	FpCmd   uintptr
	Fdb     uintptr
}

// end block for C++

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:

type tcl_vtab = tcl_vtab1 /* test_bestindex.c:104:25 */
type tcl_cursor1 = struct {
	Fbase  sqlite3_vtab_cursor
	FpStmt uintptr
}

type tcl_cursor = tcl_cursor1 /* test_bestindex.c:105:27 */

// Dequote string z in place.
func tclDequote(tls *crt.TLS, z uintptr) { /* test_bestindex.c:126:13: */
	var q int8 = *(*int8)(unsafe.Pointer(z + uintptr(0)))

	// Set stack variable q to the close-quote character
	if (((int32(q) == '[') || (int32(q) == '\'')) || (int32(q) == '"')) || (int32(q) == '`') {
		var iIn int32 = 1
		var iOut int32 = 0
		if int32(q) == '[' {
			q = int8(']')
		}

		for *(*int8)(unsafe.Pointer(z + uintptr(iIn))) != 0 {
			if int32(*(*int8)(unsafe.Pointer(z + uintptr(iIn)))) == int32(q) {
				if int32(*(*int8)(unsafe.Pointer(z + uintptr((iIn + 1))))) != int32(q) {
					// Character iIn was the close quote.
					iIn++
					break
				} else {
					// Character iIn and iIn+1 form an escaped quote character. Skip
					// the input cursor past both and copy a single quote character
					// to the output buffer.
					iIn = iIn + (2)
					*(*int8)(unsafe.Pointer(z + uintptr(crt.PostIncInt32(&iOut, 1)))) = q
				}
			} else {
				*(*int8)(unsafe.Pointer(z + uintptr(crt.PostIncInt32(&iOut, 1)))) = *(*int8)(unsafe.Pointer(z + uintptr(crt.PostIncInt32(&iIn, 1))))
			}
		}

		*(*int8)(unsafe.Pointer(z + uintptr(iOut))) = int8(0)
	}
}

// This function is the implementation of both the xConnect and xCreate
// methods of the fs virtual table.
//
// The argv[] array contains the following:
//
//   argv[0]   -> module name  ("fs")
//   argv[1]   -> database name
//   argv[2]   -> table name
//   argv[...] -> other module argument fields.
func tclConnect(tls *crt.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVtab uintptr, pzErr uintptr) int32 { /* test_bestindex.c:168:12: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var interp uintptr = pAux
	var pTab uintptr = uintptr(0)
	var zCmd uintptr = uintptr(0)
	var pScript uintptr = uintptr(0)
	var rc int32 = 0

	if argc != 4 {
		*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+33340 /* "wrong number of ..." */, 0)
		return 1
	}

	zCmd = sqlite3.Xsqlite3_malloc64(tls, (uint64(crt.Xstrlen(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(3)*8))) + uint64(1))))
	pTab = sqlite3.Xsqlite3_malloc64(tls, uint64(unsafe.Sizeof(tcl_vtab{})))
	if (zCmd != 0) && (pTab != 0) {
		crt.Xmemcpy(tls, zCmd, *(*uintptr)(unsafe.Pointer(argv + uintptr(3)*8)), (crt.Xstrlen(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(3)*8))) + uint64(1)))
		tclDequote(tls, zCmd)
		crt.Xmemset(tls, pTab, 0, uint64(unsafe.Sizeof(tcl_vtab{})))

		(*tcl_vtab)(unsafe.Pointer(pTab)).FpCmd = tcl.XTcl_NewStringObj(tls, zCmd, -1)
		(*tcl_vtab)(unsafe.Pointer(pTab)).Finterp = interp
		(*tcl_vtab)(unsafe.Pointer(pTab)).Fdb = db
		(*Tcl_Obj)(unsafe.Pointer((*tcl_vtab)(unsafe.Pointer(pTab)).FpCmd)).FrefCount++

		pScript = tcl.XTcl_DuplicateObj(tls, (*tcl_vtab)(unsafe.Pointer(pTab)).FpCmd)
		(*Tcl_Obj)(unsafe.Pointer(pScript)).FrefCount++
		tcl.XTcl_ListObjAppendElement(tls, interp, pScript, tcl.XTcl_NewStringObj(tls, ts+32411 /* "xConnect" */, -1))

		rc = tcl.XTcl_EvalObjEx(tls, interp, pScript, 0x020000)
		if rc != 0 {
			*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+130 /* "%s" */, crt.VaList(bp, tcl.XTcl_GetStringResult(tls, interp)))
			rc = 1
		} else {
			rc = sqlite3.Xsqlite3_declare_vtab(tls, db, tcl.XTcl_GetStringResult(tls, interp))
		}

		if rc != 0 {
			sqlite3.Xsqlite3_free(tls, pTab)
			pTab = uintptr(0)
		}
	} else {
		rc = 7
	}

	sqlite3.Xsqlite3_free(tls, zCmd)
	*(*uintptr)(unsafe.Pointer(ppVtab)) = (pTab /* &.base */)
	return rc
}

// The xDisconnect and xDestroy methods are also the same
func tclDisconnect(tls *crt.TLS, pVtab uintptr) int32 { /* test_bestindex.c:224:12: */
	var pTab uintptr = pVtab
	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = (*tcl_vtab)(unsafe.Pointer(pTab)).FpCmd
		if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	sqlite3.Xsqlite3_free(tls, pTab)
	return 0
}

// Open a new tcl cursor.
func tclOpen(tls *crt.TLS, pVTab uintptr, ppCursor uintptr) int32 { /* test_bestindex.c:234:12: */
	var pCur uintptr
	pCur = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(tcl_cursor{})))
	if pCur == uintptr(0) {
		return 7
	}
	crt.Xmemset(tls, pCur, 0, uint64(unsafe.Sizeof(tcl_cursor{})))
	*(*uintptr)(unsafe.Pointer(ppCursor)) = (pCur /* &.base */)
	return 0
}

// Close a tcl cursor.
func tclClose(tls *crt.TLS, cur uintptr) int32 { /* test_bestindex.c:246:12: */
	var pCur uintptr = cur
	if pCur != 0 {
		sqlite3.Xsqlite3_finalize(tls, (*tcl_cursor)(unsafe.Pointer(pCur)).FpStmt)
		sqlite3.Xsqlite3_free(tls, pCur)
	}
	return 0
}

func tclNext(tls *crt.TLS, pVtabCursor uintptr) int32 { /* test_bestindex.c:255:12: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var pCsr uintptr = pVtabCursor
	if (*tcl_cursor)(unsafe.Pointer(pCsr)).FpStmt != 0 {
		var pTab uintptr = (*sqlite3_vtab_cursor)(unsafe.Pointer(pVtabCursor)).FpVtab
		var rc int32 = sqlite3.Xsqlite3_step(tls, (*tcl_cursor)(unsafe.Pointer(pCsr)).FpStmt)
		if rc != 100 {
			var zErr uintptr
			rc = sqlite3.Xsqlite3_finalize(tls, (*tcl_cursor)(unsafe.Pointer(pCsr)).FpStmt)
			(*tcl_cursor)(unsafe.Pointer(pCsr)).FpStmt = uintptr(0)
			if rc != 0 {
				zErr = sqlite3.Xsqlite3_errmsg(tls, (*tcl_vtab)(unsafe.Pointer(pTab)).Fdb)
				(*tcl_vtab)(unsafe.Pointer(pTab)).Fbase.FzErrMsg = sqlite3.Xsqlite3_mprintf(tls, ts+130 /* "%s" */, crt.VaList(bp, zErr))
			}
		}
	}
	return 0
}

func tclFilter(tls *crt.TLS, pVtabCursor uintptr, idxNum int32, idxStr uintptr, argc int32, argv uintptr) int32 { /* test_bestindex.c:273:12: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var pCsr uintptr = pVtabCursor
	var pTab uintptr = (*sqlite3_vtab_cursor)(unsafe.Pointer(pVtabCursor)).FpVtab
	var interp uintptr = (*tcl_vtab)(unsafe.Pointer(pTab)).Finterp
	var pScript uintptr
	var pArg uintptr
	var ii int32
	var rc int32

	pScript = tcl.XTcl_DuplicateObj(tls, (*tcl_vtab)(unsafe.Pointer(pTab)).FpCmd)
	(*Tcl_Obj)(unsafe.Pointer(pScript)).FrefCount++
	tcl.XTcl_ListObjAppendElement(tls, interp, pScript, tcl.XTcl_NewStringObj(tls, ts+32482 /* "xFilter" */, -1))
	tcl.XTcl_ListObjAppendElement(tls, interp, pScript, tcl.XTcl_NewIntObj(tls, idxNum))
	if idxStr != 0 {
		tcl.XTcl_ListObjAppendElement(tls, interp, pScript, tcl.XTcl_NewStringObj(tls, idxStr, -1))
	} else {
		tcl.XTcl_ListObjAppendElement(tls, interp, pScript, tcl.XTcl_NewStringObj(tls, ts+792 /* "" */, -1))
	}

	pArg = tcl.XTcl_NewObj(tls)
	(*Tcl_Obj)(unsafe.Pointer(pArg)).FrefCount++
	for ii = 0; ii < argc; ii++ {
		var zVal uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(ii)*8)))
		var pVal uintptr
		if zVal == uintptr(0) {
			pVal = tcl.XTcl_NewObj(tls)
		} else {
			pVal = tcl.XTcl_NewStringObj(tls, zVal, -1)
		}
		tcl.XTcl_ListObjAppendElement(tls, interp, pArg, pVal)
	}
	tcl.XTcl_ListObjAppendElement(tls, interp, pScript, pArg)
	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = pArg
		if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}

	rc = tcl.XTcl_EvalObjEx(tls, interp, pScript, 0x020000)
	if rc != 0 {
		var zErr uintptr = tcl.XTcl_GetStringResult(tls, interp)
		rc = 1
		(*tcl_vtab)(unsafe.Pointer(pTab)).Fbase.FzErrMsg = sqlite3.Xsqlite3_mprintf(tls, ts+130 /* "%s" */, crt.VaList(bp, zErr))
	} else {
		// Analyze the scripts return value. The return value should be a tcl
		// list object with an even number of elements. The first element of each
		// pair must be one of:
		//
		//   "sql"          (SQL statement to return data)
		var pRes uintptr = tcl.XTcl_GetObjResult(tls, interp)
		*(*uintptr)(unsafe.Pointer(bp + 40 /* apElem */)) = uintptr(0)
		// var nElem int32 at bp+32, 4

		rc = tcl.XTcl_ListObjGetElements(tls, interp, pRes, bp+32 /* &nElem */, bp+40 /* &apElem */)
		if rc != 0 {
			var zErr uintptr = tcl.XTcl_GetStringResult(tls, interp)
			rc = 1
			(*tcl_vtab)(unsafe.Pointer(pTab)).Fbase.FzErrMsg = sqlite3.Xsqlite3_mprintf(tls, ts+130 /* "%s" */, crt.VaList(bp+8, zErr))
		} else {
			for ii = 0; (rc == 0) && (ii < *(*int32)(unsafe.Pointer(bp + 32 /* nElem */))); ii = ii + (2) {
				var zCmd uintptr = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 40 /* apElem */)) + uintptr(ii)*8)))
				var p uintptr = *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 40 /* apElem */)) + uintptr((ii+1))*8))
				if sqlite3.Xsqlite3_stricmp(tls, ts+2254 /* "sql" */, zCmd) == 0 {
					var zSql uintptr = tcl.XTcl_GetString(tls, p)
					rc = sqlite3.Xsqlite3_prepare_v2(tls, (*tcl_vtab)(unsafe.Pointer(pTab)).Fdb, zSql, -1, (pCsr + 8 /* &.pStmt */), uintptr(0))
					if rc != 0 {
						var zErr uintptr = sqlite3.Xsqlite3_errmsg(tls, (*tcl_vtab)(unsafe.Pointer(pTab)).Fdb)
						(*tcl_vtab)(unsafe.Pointer(pTab)).Fbase.FzErrMsg = sqlite3.Xsqlite3_mprintf(tls, ts+33366 /* "unexpected: %s" */, crt.VaList(bp+16, zErr))
					}
				} else {
					rc = 1
					(*tcl_vtab)(unsafe.Pointer(pTab)).Fbase.FzErrMsg = sqlite3.Xsqlite3_mprintf(tls, ts+33366 /* "unexpected: %s" */, crt.VaList(bp+24, zCmd))
				}
			}
		}
	}

	if rc == 0 {
		rc = tclNext(tls, pVtabCursor)
	}
	return rc
}

func tclColumn(tls *crt.TLS, pVtabCursor uintptr, ctx uintptr, i int32) int32 { /* test_bestindex.c:356:12: */
	var pCsr uintptr = pVtabCursor
	sqlite3.Xsqlite3_result_value(tls, ctx, sqlite3.Xsqlite3_column_value(tls, (*tcl_cursor)(unsafe.Pointer(pCsr)).FpStmt, (i+1)))
	return 0
}

func tclRowid(tls *crt.TLS, pVtabCursor uintptr, pRowid uintptr) int32 { /* test_bestindex.c:366:12: */
	var pCsr uintptr = pVtabCursor
	*(*sqlite_int64)(unsafe.Pointer(pRowid)) = sqlite3.Xsqlite3_column_int64(tls, (*tcl_cursor)(unsafe.Pointer(pCsr)).FpStmt, 0)
	return 0
}

func tclEof(tls *crt.TLS, pVtabCursor uintptr) int32 { /* test_bestindex.c:372:12: */
	var pCsr uintptr = pVtabCursor
	return (crt.Bool32((*tcl_cursor)(unsafe.Pointer(pCsr)).FpStmt == uintptr(0)))
}

func tclBestIndex(tls *crt.TLS, tab uintptr, pIdxInfo uintptr) int32 { /* test_bestindex.c:377:12: */
	bp := tls.Alloc(76)
	defer tls.Free(76)

	var pTab uintptr = tab
	var interp uintptr = (*tcl_vtab)(unsafe.Pointer(pTab)).Finterp
	var pArg uintptr
	var pScript uintptr
	var ii int32
	var rc int32 = 0

	pScript = tcl.XTcl_DuplicateObj(tls, (*tcl_vtab)(unsafe.Pointer(pTab)).FpCmd)
	(*Tcl_Obj)(unsafe.Pointer(pScript)).FrefCount++
	tcl.XTcl_ListObjAppendElement(tls, interp, pScript, tcl.XTcl_NewStringObj(tls, ts+32536 /* "xBestIndex" */, -1))

	pArg = tcl.XTcl_NewObj(tls)
	(*Tcl_Obj)(unsafe.Pointer(pArg)).FrefCount++
	for ii = 0; ii < (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnConstraint; ii++ {
		var pCons uintptr = ((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraint + uintptr(ii)*12)
		var pElem uintptr = tcl.XTcl_NewObj(tls)
		var zOp uintptr = ts + 2682 /* "?" */

		(*Tcl_Obj)(unsafe.Pointer(pElem)).FrefCount++

		switch int32((*sqlite3_index_constraint)(unsafe.Pointer(pCons)).Fop) {
		case 2:
			zOp = ts + 33381 /* "eq" */
			break
		case 4:
			zOp = ts + 33384 /* "gt" */
			break
		case 8:
			zOp = ts + 33387 /* "le" */
			break
		case 16:
			zOp = ts + 33390 /* "lt" */
			break
		case 32:
			zOp = ts + 33393 /* "ge" */
			break
		case 64:
			zOp = ts + 33396 /* "match" */
			break
		case 65:
			zOp = ts + 32634 /* "like" */
			break
		case 66:
			zOp = ts + 32639 /* "glob" */
			break
		case 67:
			zOp = ts + 6216 /* "regexp" */
			break
		case 68:
			zOp = ts + 33402 /* "ne" */
			break
		case 69:
			zOp = ts + 33405 /* "isnot" */
			break
		case 70:
			zOp = ts + 33411 /* "isnotnull" */
			break
		case 71:
			zOp = ts + 33421 /* "isnull" */
			break
		case 72:
			zOp = ts + 5499 /* "is" */
			break
		}

		tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pElem, tcl.XTcl_NewStringObj(tls, ts+33428 /* "op" */, -1))
		tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pElem, tcl.XTcl_NewStringObj(tls, zOp, -1))
		tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pElem, tcl.XTcl_NewStringObj(tls, ts+33431 /* "column" */, -1))
		tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pElem, tcl.XTcl_NewIntObj(tls, (*sqlite3_index_constraint)(unsafe.Pointer(pCons)).FiColumn))
		tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pElem, tcl.XTcl_NewStringObj(tls, ts+33438 /* "usable" */, -1))
		tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pElem, tcl.XTcl_NewIntObj(tls, int32((*sqlite3_index_constraint)(unsafe.Pointer(pCons)).Fusable)))

		tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pArg, pElem)
		for ok := true; ok; ok = 0 != 0 {
			var _objPtr uintptr = pElem
			if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
	}

	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pScript, pArg)
	for ok1 := true; ok1; ok1 = 0 != 0 {
		var _objPtr uintptr = pArg
		if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}

	pArg = tcl.XTcl_NewObj(tls)
	(*Tcl_Obj)(unsafe.Pointer(pArg)).FrefCount++
	for ii = 0; ii < (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnOrderBy; ii++ {
		var pOrder uintptr = ((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaOrderBy + uintptr(ii)*8)
		var pElem uintptr = tcl.XTcl_NewObj(tls)
		(*Tcl_Obj)(unsafe.Pointer(pElem)).FrefCount++

		tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pElem, tcl.XTcl_NewStringObj(tls, ts+33431 /* "column" */, -1))
		tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pElem, tcl.XTcl_NewIntObj(tls, (*sqlite3_index_orderby)(unsafe.Pointer(pOrder)).FiColumn))
		tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pElem, tcl.XTcl_NewStringObj(tls, ts+33445 /* "desc" */, -1))
		tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pElem, tcl.XTcl_NewIntObj(tls, int32((*sqlite3_index_orderby)(unsafe.Pointer(pOrder)).Fdesc)))

		tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pArg, pElem)
		for ok2 := true; ok2; ok2 = 0 != 0 {
			var _objPtr uintptr = pElem
			if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
	}

	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pScript, pArg)
	for ok3 := true; ok3; ok3 = 0 != 0 {
		var _objPtr uintptr = pArg
		if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}

	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pScript, tcl.XTcl_NewWideIntObj(tls, int64((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FcolUsed)))

	rc = tcl.XTcl_EvalObjEx(tls, interp, pScript, 0x020000)
	for ok4 := true; ok4; ok4 = 0 != 0 {
		var _objPtr uintptr = pScript
		if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	if rc != 0 {
		var zErr uintptr = tcl.XTcl_GetStringResult(tls, interp)
		rc = 1
		(*tcl_vtab)(unsafe.Pointer(pTab)).Fbase.FzErrMsg = sqlite3.Xsqlite3_mprintf(tls, ts+130 /* "%s" */, crt.VaList(bp, zErr))
	} else {
		// Analyze the scripts return value. The return value should be a tcl
		// list object with an even number of elements. The first element of each
		// pair must be one of:
		//
		//   "orderby"          (value of orderByConsumed flag)
		//   "cost"             (value of estimatedCost field)
		//   "rows"             (value of estimatedRows field)
		//   "use"              (index of used constraint in aConstraint[])
		//   "idxnum"           (value of idxNum field)
		//   "idxstr"           (value of idxStr field)
		//   "omit"             (index of omitted constraint in aConstraint[])
		var pRes uintptr = tcl.XTcl_GetObjResult(tls, interp)
		*(*uintptr)(unsafe.Pointer(bp + 56 /* apElem */)) = uintptr(0)
		// var nElem int32 at bp+48, 4

		rc = tcl.XTcl_ListObjGetElements(tls, interp, pRes, bp+48 /* &nElem */, bp+56 /* &apElem */)
		if rc != 0 {
			var zErr uintptr = tcl.XTcl_GetStringResult(tls, interp)
			rc = 1
			(*tcl_vtab)(unsafe.Pointer(pTab)).Fbase.FzErrMsg = sqlite3.Xsqlite3_mprintf(tls, ts+130 /* "%s" */, crt.VaList(bp+8, zErr))
		} else {
			var iArgv int32 = 1
			for ii = 0; (rc == 0) && (ii < *(*int32)(unsafe.Pointer(bp + 48 /* nElem */))); ii = ii + (2) {
				var zCmd uintptr = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 56 /* apElem */)) + uintptr(ii)*8)))
				var p uintptr = *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 56 /* apElem */)) + uintptr((ii+1))*8))
				if sqlite3.Xsqlite3_stricmp(tls, ts+33450 /* "cost" */, zCmd) == 0 {
					rc = tcl.XTcl_GetDoubleFromObj(tls, interp, p, (pIdxInfo + 64 /* &.estimatedCost */))
				} else if sqlite3.Xsqlite3_stricmp(tls, ts+33455 /* "orderby" */, zCmd) == 0 {
					rc = tcl.XTcl_GetIntFromObj(tls, interp, p, (pIdxInfo + 60 /* &.orderByConsumed */))
				} else if sqlite3.Xsqlite3_stricmp(tls, ts+33463 /* "idxnum" */, zCmd) == 0 {
					rc = tcl.XTcl_GetIntFromObj(tls, interp, p, (pIdxInfo + 40 /* &.idxNum */))
				} else if sqlite3.Xsqlite3_stricmp(tls, ts+33470 /* "idxstr" */, zCmd) == 0 {
					sqlite3.Xsqlite3_free(tls, (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxStr)
					(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxStr = sqlite3.Xsqlite3_mprintf(tls, ts+130 /* "%s" */, crt.VaList(bp+16, tcl.XTcl_GetString(tls, p)))
					(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FneedToFreeIdxStr = 1
				} else if sqlite3.Xsqlite3_stricmp(tls, ts+33477 /* "rows" */, zCmd) == 0 {
					*(*Tcl_WideInt)(unsafe.Pointer(bp + 64 /* x */)) = int64(0)
					rc = tcl.XTcl_GetWideIntFromObj(tls, interp, p, bp+64 /* &x */)
					(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedRows = sqlite3_int64(tRowcnt(*(*Tcl_WideInt)(unsafe.Pointer(bp + 64 /* x */))))
				} else if (sqlite3.Xsqlite3_stricmp(tls, ts+33482 /* "use" */, zCmd) == 0) ||
					(sqlite3.Xsqlite3_stricmp(tls, ts+33486 /* "omit" */, zCmd) == 0) {
					// var iCons int32 at bp+72, 4

					rc = tcl.XTcl_GetIntFromObj(tls, interp, p, bp+72 /* &iCons */)
					if rc == 0 {
						if (*(*int32)(unsafe.Pointer(bp + 72 /* iCons */)) < 0) || (*(*int32)(unsafe.Pointer(bp + 72 /* iCons */)) >= (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnConstraint) {
							rc = 1
							(*tcl_vtab)(unsafe.Pointer(pTab)).Fbase.FzErrMsg = sqlite3.Xsqlite3_mprintf(tls, ts+33491 /* "unexpected: %d" */, crt.VaList(bp+24, *(*int32)(unsafe.Pointer(bp + 72 /* iCons */))))
						} else {
							var bOmit int32 = (crt.Bool32((int32(*(*int8)(unsafe.Pointer(zCmd + uintptr(0)))) == 'o') || (int32(*(*int8)(unsafe.Pointer(zCmd + uintptr(0)))) == 'O')))
							(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(*(*int32)(unsafe.Pointer(bp + 72 /* iCons */)))*8)).FargvIndex = crt.PostIncInt32(&iArgv, 1)
							(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(*(*int32)(unsafe.Pointer(bp + 72 /* iCons */)))*8)).Fomit = uint8(bOmit)
						}
					}
				} else {
					rc = 1
					(*tcl_vtab)(unsafe.Pointer(pTab)).Fbase.FzErrMsg = sqlite3.Xsqlite3_mprintf(tls, ts+33366 /* "unexpected: %s" */, crt.VaList(bp+32, zCmd))
				}
				if (rc != 0) && ((*tcl_vtab)(unsafe.Pointer(pTab)).Fbase.FzErrMsg == uintptr(0)) {
					var zErr uintptr = tcl.XTcl_GetStringResult(tls, interp)
					(*tcl_vtab)(unsafe.Pointer(pTab)).Fbase.FzErrMsg = sqlite3.Xsqlite3_mprintf(tls, ts+130 /* "%s" */, crt.VaList(bp+40, zErr))
				}
			}
		}
	}

	return rc
}

// A virtual table module that provides read-only access to a
// Tcl global variable namespace.
var tclModule = sqlite3_module{FiVersion: 0, FxCreate: // iVersion
0, FxConnect:                                          0, FxBestIndex: 0, FxDisconnect: 0, FxDestroy: 0, FxOpen: 0, FxClose: // xOpen - open a cursor
0, FxFilter:// xClose - close a cursor
0, FxNext:// xFilter - configure scan constraints
0, FxEof:// xNext - advance a cursor
0, FxColumn:// xEof - check for end of scan
0, FxRowid:// xColumn - read data
0, FxUpdate:// xRowid - read data
uintptr(0), FxBegin:// xUpdate
uintptr(0), FxSync:// xBegin
uintptr(0), FxCommit:// xSync
uintptr(0), FxRollback:// xCommit
uintptr(0), FxFindFunction:// xRollback
uintptr(0), FxRename:// xFindMethod
uintptr(0), // xRename
} /* test_bestindex.c:549:23 */

// Register the echo virtual table module.
func register_tcl_module(tls *crt.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_bestindex.c:580:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// var db uintptr at bp, 8

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+2452 /* "DB" */)
		return 1
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), bp /* &db */) != 0 {
		return 1
	}
	sqlite3.Xsqlite3_create_module(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), ts+33506 /* "tcl" */, uintptr(unsafe.Pointer(&tclModule)), interp)
	return 0
}

// Register commands with the TCL interpreter.
func Sqlitetesttcl_Init(tls *crt.TLS, interp uintptr) int32 { /* test_bestindex.c:604:5: */
	var i int32
	for i = 0; uint64(i) < (uint64(unsafe.Sizeof(aObjCmd4)) / uint64(unsafe.Sizeof(struct {
		FzName      uintptr
		FxProc      uintptr
		FclientData uintptr
	}{}))); i++ {
		tcl.XTcl_CreateObjCommand(tls, interp, aObjCmd4[i].FzName,
			aObjCmd4[i].FxProc, aObjCmd4[i].FclientData, uintptr(0))
	}
	return 0
}

var aObjCmd4 = [1]struct {
	FzName      uintptr
	FxProc      uintptr
	FclientData uintptr
}{
	{FzName: ts + 33510 /* "register_tcl_mod..." */, FxProc: 0, FclientData: uintptr(0)},
} /* test_bestindex.c:610:5 */

// Return a pointer to a buffer containing a text representation of the
// pointer passed as the only argument. The original pointer may be extracted
// from the text using sqlite3TestTextToPtr().
func ptrToText(tls *crt.TLS, p uintptr) uintptr { /* test_blob.c:37:13: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	sqlite3.Xsqlite3_snprintf(tls, (int32(uint64(unsafe.Sizeof(buf)) - uint64(1))), uintptr(unsafe.Pointer(&buf)), ts+20002 /* "%p" */, crt.VaList(bp, p))
	return uintptr(unsafe.Pointer(&buf))
}

var buf [100]int8 /* test_blob.c:38:15: */

// Attempt to extract a blob handle (type sqlite3_blob*) from the Tcl
// object passed as the second argument. If successful, set *ppBlob to
// point to the blob handle and return TCL_OK. Otherwise, store an error
// message in the tcl interpreter and return TCL_ERROR. The final value
// of *ppBlob is undefined in this case.
//
// If the object contains a string that begins with "incrblob_", then it
// is assumed to be the name of a Tcl channel opened using the [db incrblob]
// command (see tclsqlite.c). Otherwise, it is assumed to be a pointer
// encoded using the ptrToText() routine or similar.
func blobHandleFromObj1(tls *crt.TLS, interp uintptr, pObj uintptr, ppBlob uintptr) int32 { /* test_blob.c:55:12: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var z uintptr
	// var n int32 at bp, 4

	z = tcl.XTcl_GetStringFromObj(tls, pObj, bp /* &n */)
	if *(*int32)(unsafe.Pointer(bp /* n */)) == 0 {
		*(*uintptr)(unsafe.Pointer(ppBlob)) = uintptr(0)
	} else if (*(*int32)(unsafe.Pointer(bp /* n */)) > 9) && (0 == crt.Xmemcmp(tls, ts+33530 /* "incrblob_" */, z, uint64(9))) {
		// var notUsed int32 at bp+4, 4

		var channel Tcl_Channel
		var instanceData ClientData

		channel = tcl.XTcl_GetChannel(tls, interp, z, bp+4 /* &notUsed */)
		if !(channel != 0) {
			return 1
		}

		tcl.XTcl_Flush(tls, channel)
		tcl.XTcl_Seek(tls, channel, int64(0), 0)

		instanceData = tcl.XTcl_GetChannelInstanceData(tls, channel)
		*(*uintptr)(unsafe.Pointer(ppBlob)) = *(*uintptr)(unsafe.Pointer(instanceData))
	} else {
		*(*uintptr)(unsafe.Pointer(ppBlob)) = sqlite3TestTextToPtr(tls, z)
	}

	return 0
}

// Like Tcl_GetString(), except that if the string is 0 bytes in size, a
// NULL Pointer is returned.
func blobStringFromObj(tls *crt.TLS, pObj uintptr) uintptr { /* test_blob.c:90:13: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	// var n int32 at bp, 4

	var z uintptr
	z = tcl.XTcl_GetStringFromObj(tls, pObj, bp /* &n */)
	return func() uintptr {
		if *(*int32)(unsafe.Pointer(bp /* n */)) != 0 {
			return z
		}
		return uintptr(0)
	}()
}

// sqlite3_blob_open DB DATABASE TABLE COLUMN ROWID FLAGS VARNAME
//
// Tcl test harness for the sqlite3_blob_open() function.
func test_blob_open(tls *crt.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_blob.c:102:26: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	// var db uintptr at bp+8, 8

	var zDb uintptr
	var zTable uintptr
	var zColumn uintptr
	// var iRowid Tcl_WideInt at bp+16, 8

	// var flags int32 at bp, 4

	var zVarname uintptr
	// var nVarname int32 at bp+24, 4

	*(*uintptr)(unsafe.Pointer(bp + 32 /* pBlob */)) = bp /* &flags */ // Non-zero initialization
	var rc int32

	if objc != 8 {
		var zUsage uintptr = ts + 33540 /* "DB DATABASE TABL..." */
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, zUsage)
		return 1
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), bp+8 /* &db */) != 0 {
		return 1
	}
	zDb = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)))
	zTable = blobStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(3)*8)))
	zColumn = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(4)*8)))
	if tcl.XTcl_GetWideIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(5)*8)), bp+16 /* &iRowid */) != 0 {
		return 1
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(6)*8)), bp /* &flags */) != 0 {
		return 1
	}
	zVarname = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(7)*8)), bp+24 /* &nVarname */)

	if *(*int32)(unsafe.Pointer(bp + 24 /* nVarname */)) > 0 {
		rc = sqlite3.Xsqlite3_blob_open(tls, *(*uintptr)(unsafe.Pointer(bp + 8 /* db */)), zDb, zTable, zColumn, int64(*(*Tcl_WideInt)(unsafe.Pointer(bp + 16 /* iRowid */))), *(*int32)(unsafe.Pointer(bp /* flags */)), bp+32 /* &pBlob */)
		tcl.XTcl_SetVar2(tls, interp, zVarname, uintptr(0), ptrToText(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* pBlob */))), 0)
	} else {
		rc = sqlite3.Xsqlite3_blob_open(tls, *(*uintptr)(unsafe.Pointer(bp + 8 /* db */)), zDb, zTable, zColumn, int64(*(*Tcl_WideInt)(unsafe.Pointer(bp + 16 /* iRowid */))), *(*int32)(unsafe.Pointer(bp /* flags */)), uintptr(0))
	}

	if rc == 0 {
		tcl.XTcl_ResetResult(tls, interp)
	} else {
		tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(1))
		return 1
	}
	return 0
}

// sqlite3_blob_close  HANDLE
func test_blob_close(tls *crt.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_blob.c:153:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// var pBlob uintptr at bp, 8

	var rc int32

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+33585 /* "HANDLE" */)
		return 1
	}

	if blobHandleFromObj1(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)), bp /* &pBlob */) != 0 {
		return 1
	}
	rc = sqlite3.Xsqlite3_blob_close(tls, *(*uintptr)(unsafe.Pointer(bp /* pBlob */)))

	if rc != 0 {
		tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(1))
	} else {
		tcl.XTcl_ResetResult(tls, interp)
	}
	return 0
}

// sqlite3_blob_bytes  HANDLE
func test_blob_bytes(tls *crt.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_blob.c:181:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// var pBlob uintptr at bp, 8

	var nByte int32

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+33585 /* "HANDLE" */)
		return 1
	}

	if blobHandleFromObj1(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)), bp /* &pBlob */) != 0 {
		return 1
	}
	nByte = sqlite3.Xsqlite3_blob_bytes(tls, *(*uintptr)(unsafe.Pointer(bp /* pBlob */)))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, nByte))

	return 0
}

// sqlite3_blob_read  CHANNEL OFFSET N
//
//   This command is used to test the sqlite3_blob_read() in ways that
//   the Tcl channel interface does not. The first argument should
//   be the name of a valid channel created by the [incrblob] method
//   of a database handle. This function calls sqlite3_blob_read()
//   to read N bytes from offset OFFSET from the underlying SQLite
//   blob handle.
//
//   On success, a byte-array object containing the read data is
//   returned. On failure, the interpreter result is set to the
//   text representation of the returned error code (i.e. "SQLITE_NOMEM")
//   and a Tcl exception is thrown.
func test_blob_read(tls *crt.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_blob.c:217:26: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	// var pBlob uintptr at bp+16, 8

	// var nByte int32 at bp+28, 4

	// var iOffset int32 at bp+24, 4

	var zBuf uintptr = uintptr(0)
	var rc int32

	if objc != 4 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+33592 /* "CHANNEL OFFSET N" */)
		return 1
	}

	if blobHandleFromObj1(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)), bp+16 /* &pBlob */) != 0 {
		return 1
	}
	if (0 != tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)), bp+24 /* &iOffset */)) ||
		(0 != tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(3)*8)), bp+28 /* &nByte */)) {
		return 1
	}

	if *(*int32)(unsafe.Pointer(bp + 28 /* nByte */)) > 0 {
		zBuf = tcl.XTcl_AttemptAlloc(tls, uint32(*(*int32)(unsafe.Pointer(bp + 28 /* nByte */))))
		if zBuf == uintptr(0) {
			tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+33609 /* "out of memory in..." */, 0))
			return 1
		}
	}
	rc = sqlite3.Xsqlite3_blob_read(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* pBlob */)), zBuf, *(*int32)(unsafe.Pointer(bp + 28 /* nByte */)), *(*int32)(unsafe.Pointer(bp + 24 /* iOffset */)))
	if rc == 0 {
		tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewByteArrayObj(tls, zBuf, *(*int32)(unsafe.Pointer(bp + 28 /* nByte */))))
	} else {
		tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(1))
	}
	tcl.XTcl_Free(tls, zBuf)

	return func() int32 {
		if rc == 0 {
			return 0
		}
		return 1
	}()
}

// sqlite3_blob_write HANDLE OFFSET DATA ?NDATA?
//
//   This command is used to test the sqlite3_blob_write() in ways that
//   the Tcl channel interface does not. The first argument should
//   be the name of a valid channel created by the [incrblob] method
//   of a database handle. This function calls sqlite3_blob_write()
//   to write the DATA byte-array to the underlying SQLite blob handle.
//   at offset OFFSET.
//
//   On success, an empty string is returned. On failure, the interpreter
//   result is set to the text representation of the returned error code
//   (i.e. "SQLITE_NOMEM") and a Tcl exception is thrown.
func test_blob_write(tls *crt.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_blob.c:273:26: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	// var pBlob uintptr at bp, 8

	// var iOffset int32 at bp+8, 4

	var rc int32
	var zBuf uintptr
	// var nBuf int32 at bp+12, 4

	if (objc != 4) && (objc != 5) {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+33670 /* "HANDLE OFFSET DA..." */)
		return 1
	}

	if blobHandleFromObj1(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)), bp /* &pBlob */) != 0 {
		return 1
	}
	if 0 != tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)), bp+8 /* &iOffset */) {
		return 1
	}

	zBuf = tcl.XTcl_GetByteArrayFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(3)*8)), bp+12 /* &nBuf */)
	if (objc == 5) && (tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(4)*8)), bp+12 /* &nBuf */) != 0) {
		return 1
	}
	rc = sqlite3.Xsqlite3_blob_write(tls, *(*uintptr)(unsafe.Pointer(bp /* pBlob */)), zBuf, *(*int32)(unsafe.Pointer(bp + 12 /* nBuf */)), *(*int32)(unsafe.Pointer(bp + 8 /* iOffset */)))
	if rc != 0 {
		tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(1))
	}

	return func() int32 {
		if rc == 0 {
			return 0
		}
		return 1
	}()
}

// Register commands with the TCL interpreter.
func Sqlitetest_blob_Init(tls *crt.TLS, interp uintptr) int32 { /* test_blob.c:312:5: */
	var i int32
	for i = 0; uint64(i) < (uint64(unsafe.Sizeof(aObjCmd5)) / uint64(unsafe.Sizeof(struct {
		FzName uintptr
		FxProc uintptr
	}{}))); i++ {
		tcl.XTcl_CreateObjCommand(tls, interp, aObjCmd5[i].FzName, aObjCmd5[i].FxProc, uintptr(0), uintptr(0))
	}
	return 0
}

var aObjCmd5 = [5]struct {
	FzName uintptr
	FxProc uintptr
}{
	{FzName: ts + 33697 /* "sqlite3_blob_ope..." */, FxProc: 0},
	{FzName: ts + 33715 /* "sqlite3_blob_clo..." */, FxProc: 0},
	{FzName: ts + 33734 /* "sqlite3_blob_byt..." */, FxProc: 0},
	{FzName: ts + 33753 /* "sqlite3_blob_rea..." */, FxProc: 0},
	{FzName: ts + 33771 /* "sqlite3_blob_wri..." */, FxProc: 0},
} /* test_blob.c:317:5 */

// end block for C++

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:

// Usage: sqlite3_shared_cache_report
//
// Return a list of file that are shared and the number of
// references to each file.
func sqlite3BtreeSharedCacheReport(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_btree.c:29:19: */
	var pBt uintptr
	var pRet uintptr = tcl.XTcl_NewObj(tls)
	for pBt = sqlite3.Xsqlite3SharedCacheList; pBt != 0; pBt = (*BtShared)(unsafe.Pointer(pBt)).FpNext {
		var zFile uintptr = sqlite3.Xsqlite3PagerFilename(tls, (*BtShared)(unsafe.Pointer(pBt)).FpPager, 1)
		tcl.XTcl_ListObjAppendElement(tls, interp, pRet, tcl.XTcl_NewStringObj(tls, zFile, -1))
		tcl.XTcl_ListObjAppendElement(tls, interp, pRet, tcl.XTcl_NewIntObj(tls, (*BtShared)(unsafe.Pointer(pBt)).FnRef))
	}
	tcl.XTcl_SetObjResult(tls, interp, pRet)
	return 0
}

// Print debugging information about all cursors to standard output.
func sqlite3BtreeCursorList(tls *crt.TLS, p uintptr) { /* test_btree.c:52:6: */
}

// end block for C++

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:
// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.20 General utilities	<stdlib.h>

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.21 String handling	<string.h>

// Macro to stringify the results of the evaluation a pre-processor
// macro. i.e. so that STRINGVALUE(SQLITE_NOMEM) -> "7".

// This routine sets entries in the global ::sqlite_options() array variable
// according to the compile-time configuration of the database.  Test
// procedures use this to determine when tests should be omitted.
func set_options(tls *crt.TLS, interp uintptr) { /* test_config.c:47:13: */
	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+33805 /* "malloc_usable_si..." */, ts+8293, /* "0" */
		1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+33824 /* "rowid32" */, ts+8293 /* "0" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+33832 /* "casesensitivelik..." */, ts+8293 /* "0" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+33850 /* "curdir" */, ts+33857 /* "1" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+33859 /* "win32malloc" */, ts+8293 /* "0" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+33871 /* "debug" */, ts+8293 /* "0" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+33877 /* "default_ckptfull..." */, ts+8293 /* "0" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+33899 /* "direct_read" */, ts+8293 /* "0" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+33911 /* "dirsync" */, ts+33857 /* "1" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+33919 /* "lfs" */, ts+33857 /* "1" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+33923 /* "pagecache_overfl..." */, ts+33857 /* "1" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+33948 /* "mmap" */, ts+33857 /* "1" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+33953, /* "worker_threads" */
		ts+33968 /* "8" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+33970 /* "memdebug" */, ts+8293 /* "0" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+33979 /* "8_3_names" */, ts+8293 /* "0" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+33989 /* "cursorhints" */, ts+8293 /* "0" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+34001 /* "hiddencolumns" */, ts+8293 /* "0" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+20142 /* "deserialize" */, ts+8293 /* "0" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+34015 /* "mem3" */, ts+8293 /* "0" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+34020 /* "mem5" */, ts+8293 /* "0" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+34025 /* "offset_sql_func" */, ts+8293 /* "0" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+20250 /* "preupdate" */, ts+8293 /* "0" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+34041 /* "snapshot" */, ts+8293 /* "0" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+34050 /* "mutex" */, ts+33857 /* "1" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+34056 /* "mutex_noop" */, ts+33857 /* "1" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+34067 /* "altertable" */, ts+33857 /* "1" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+2264 /* "analyze" */, ts+33857 /* "1" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+34078 /* "api_armor" */, ts+8293 /* "0" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+34088 /* "atomicwrite" */, ts+8293 /* "0" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+34100 /* "json1" */, ts+8293 /* "0" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+34106 /* "has_codec" */, ts+8293 /* "0" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+34116 /* "like_match_blobs" */, ts+8293 /* "0" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+34133 /* "attach" */, ts+33857 /* "1" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+34140 /* "auth" */, ts+33857 /* "1" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+34145 /* "autoinc" */, ts+33857 /* "1" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+19726 /* "autoindex" */, ts+33857 /* "1" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+34153 /* "autoreset" */, ts+33857 /* "1" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+34163 /* "autovacuum" */, ts+33857 /* "1" */, 1)
	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+34174, /* "default_autovacu..." */
		ts+8293 /* "0" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+34193 /* "between_opt" */, ts+33857 /* "1" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+34205 /* "builtin_test" */, ts+33857 /* "1" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+34218 /* "bloblit" */, ts+33857 /* "1" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+34226 /* "cast" */, ts+33857 /* "1" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+34231 /* "check" */, ts+33857 /* "1" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+34237 /* "cte" */, ts+33857 /* "1" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+34241 /* "columnmetadata" */, ts+8293 /* "0" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+34256 /* "oversize_cell_ch..." */, ts+8293, /* "0" */
		1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+34276 /* "compileoption_di..." */, ts+33857 /* "1" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+20121 /* "complete" */, ts+33857 /* "1" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+34296 /* "compound" */, ts+33857 /* "1" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+34305 /* "conflict" */, ts+33857 /* "1" */, 1)
	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+34314 /* "crashtest" */, ts+33857 /* "1" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+34324 /* "datetime" */, ts+33857 /* "1" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+34333 /* "decltype" */, ts+8293 /* "0" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+34342 /* "deprecated" */, ts+33857 /* "1" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+34353 /* "diskio" */, ts+33857 /* "1" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+4515 /* "explain" */, ts+33857 /* "1" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+34360 /* "floatingpoint" */, ts+33857 /* "1" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+34374 /* "foreignkey" */, ts+33857 /* "1" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+34385 /* "fts1" */, ts+8293 /* "0" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+34390 /* "fts2" */, ts+8293 /* "0" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+34395 /* "fts3" */, ts+8293 /* "0" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+34400 /* "fts5" */, ts+8293 /* "0" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+34405 /* "fts3_unicode" */, ts+8293 /* "0" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+34418 /* "fts4_deferred" */, ts+33857 /* "1" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+34432 /* "gettable" */, ts+33857 /* "1" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+34441 /* "icu" */, ts+8293 /* "0" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+34445 /* "icu_collations" */, ts+8293 /* "0" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+17096 /* "incrblob" */, ts+33857 /* "1" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+34460 /* "integrityck" */, ts+33857 /* "1" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+34472 /* "legacyformat" */, ts+8293 /* "0" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+34485 /* "like_opt" */, ts+33857 /* "1" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+34494 /* "load_ext" */, ts+8293 /* "0" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+34503 /* "localtime" */, ts+33857 /* "1" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+34513 /* "lookaside" */, ts+33857 /* "1" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+34523, /* "long_double" */
		func() uintptr {
			if uint64(unsafe.Sizeof(float64(0))) > uint64(unsafe.Sizeof(float64(0))) {
				return ts + 33857 /* "1" */
			}
			return ts + 8293 /* "0" */
		}(),
		1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+34535 /* "memorydb" */, ts+33857 /* "1" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+34544 /* "memorymanage" */, ts+8293 /* "0" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+34557 /* "mergesort" */, ts+33857 /* "1" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+34567 /* "null_trim" */, ts+8293 /* "0" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+34577 /* "or_opt" */, ts+33857 /* "1" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+34584 /* "rbu" */, ts+8293 /* "0" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+34588 /* "pager_pragmas" */, ts+33857 /* "1" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+34602 /* "pragma" */, ts+33857 /* "1" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+16581 /* "progress" */, ts+8293 /* "0" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+34609 /* "reindex" */, ts+33857 /* "1" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+34617 /* "rtree" */, ts+8293 /* "0" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+34623 /* "rtree_int_only" */, ts+8293 /* "0" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+34638 /* "schema_pragmas" */, ts+33857 /* "1" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+34653 /* "schema_version" */, ts+33857 /* "1" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+34668 /* "session" */, ts+8293 /* "0" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+25034 /* "stat4" */, ts+8293 /* "0" */, 1)
	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+34676 /* "stmtvtab" */, ts+8293 /* "0" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+34685 /* "scanstatus" */, ts+8293 /* "0" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+34696 /* "lock_proxy_pragm..." */, ts+8293 /* "0" */, 1)
	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+34715 /* "prefer_proxy_loc..." */, ts+8293 /* "0" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+34736 /* "shared_cache" */, ts+33857 /* "1" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+34749 /* "subquery" */, ts+33857 /* "1" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+34758 /* "tclvar" */, ts+33857 /* "1" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+34765, /* "threadsafe" */
		func() uintptr {
			if 2 != 0 {
				return ts + 33857 /* "1" */
			}
			return ts + 8293 /* "0" */
		}(), 1)
	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+34776, /* "threadsafe1" */
		func() uintptr {
			if 2 == 1 {
				return ts + 33857 /* "1" */
			}
			return ts + 8293 /* "0" */
		}(), 1)
	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+34788, /* "threadsafe2" */
		func() uintptr {
			if 2 == 2 {
				return ts + 33857 /* "1" */
			}
			return ts + 8293 /* "0" */
		}(), 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+34800 /* "tempdb" */, ts+33857 /* "1" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+20335 /* "trace" */, ts+33857 /* "1" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+34807 /* "trigger" */, ts+33857 /* "1" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+34815 /* "truncate_opt" */, ts+33857 /* "1" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+22357 /* "utf16" */, ts+8293 /* "0" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+15560 /* "vacuum" */, ts+33857 /* "1" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+34828 /* "view" */, ts+33857 /* "1" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+34833 /* "vtab" */, ts+33857 /* "1" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+34838 /* "wal" */, ts+33857 /* "1" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+34842 /* "wsd" */, ts+33857 /* "1" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+34846 /* "update_delete_li..." */, ts+8293 /* "0" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+20362 /* "unlock_notify" */, ts+33857 /* "1" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+34866 /* "fast_secure_dele..." */, ts+8293 /* "0" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+34885 /* "secure_delete" */, ts+8293 /* "0" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+34899 /* "userauth" */, ts+8293 /* "0" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+34908 /* "multiplex_ext_ov..." */, ts+8293 /* "0" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+34932 /* "yytrackmaxstackd..." */, ts+8293 /* "0" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+34953 /* "sqllog" */, ts+8293 /* "0" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+34960 /* "uri_00_error" */, ts+8293 /* "0" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+34973 /* "normalize" */, ts+8293 /* "0" */, 1)

	tcl.XTcl_SetVar2(tls, interp, ts+33790 /* "sqlite_options" */, ts+34983 /* "windowfunc" */, ts+33857 /* "1" */, 1)

	{
		tcl.XTcl_LinkVar(tls, interp, ts+34994 /* "SQLITE_MAX_LENGT..." */, uintptr(unsafe.Pointer(&cv_MAX_LENGTH)), (1 | 0x80))
	}

	{
		tcl.XTcl_LinkVar(tls, interp, ts+35012 /* "SQLITE_MAX_COLUM..." */, uintptr(unsafe.Pointer(&cv_MAX_COLUMN)), (1 | 0x80))
	}

	{
		tcl.XTcl_LinkVar(tls, interp, ts+35030 /* "SQLITE_MAX_SQL_L..." */, uintptr(unsafe.Pointer(&cv_MAX_SQL_LENGTH)), (1 | 0x80))
	}

	{
		tcl.XTcl_LinkVar(tls, interp, ts+35052 /* "SQLITE_MAX_EXPR_..." */, uintptr(unsafe.Pointer(&cv_MAX_EXPR_DEPTH)), (1 | 0x80))
	}

	{
		tcl.XTcl_LinkVar(tls, interp, ts+35074 /* "SQLITE_MAX_COMPO..." */, uintptr(unsafe.Pointer(&cv_MAX_COMPOUND_SELECT)), (1 | 0x80))
	}

	{
		tcl.XTcl_LinkVar(tls, interp, ts+35101 /* "SQLITE_MAX_VDBE_..." */, uintptr(unsafe.Pointer(&cv_MAX_VDBE_OP)), (1 | 0x80))
	}

	{
		tcl.XTcl_LinkVar(tls, interp, ts+35120 /* "SQLITE_MAX_FUNCT..." */, uintptr(unsafe.Pointer(&cv_MAX_FUNCTION_ARG)), (1 | 0x80))
	}

	{
		tcl.XTcl_LinkVar(tls, interp, ts+35144 /* "SQLITE_MAX_VARIA..." */, uintptr(unsafe.Pointer(&cv_MAX_VARIABLE_NUMBER)), (1 | 0x80))
	}

	{
		tcl.XTcl_LinkVar(tls, interp, ts+35171 /* "SQLITE_MAX_PAGE_..." */, uintptr(unsafe.Pointer(&cv_MAX_PAGE_SIZE)), (1 | 0x80))
	}

	{
		tcl.XTcl_LinkVar(tls, interp, ts+35192 /* "SQLITE_MAX_PAGE_..." */, uintptr(unsafe.Pointer(&cv_MAX_PAGE_COUNT)), (1 | 0x80))
	}

	{
		tcl.XTcl_LinkVar(tls, interp, ts+35214 /* "SQLITE_MAX_LIKE_..." */, uintptr(unsafe.Pointer(&cv_MAX_LIKE_PATTERN_LENGTH)), (1 | 0x80))
	}

	{
		tcl.XTcl_LinkVar(tls, interp, ts+35245 /* "SQLITE_MAX_TRIGG..." */, uintptr(unsafe.Pointer(&cv_MAX_TRIGGER_DEPTH)), (1 | 0x80))
	}

	{
		tcl.XTcl_LinkVar(tls, interp, ts+35270 /* "SQLITE_DEFAULT_C..." */, uintptr(unsafe.Pointer(&cv_DEFAULT_CACHE_SIZE)), (1 | 0x80))
	}

	{
		tcl.XTcl_LinkVar(tls, interp, ts+35296 /* "SQLITE_DEFAULT_P..." */, uintptr(unsafe.Pointer(&cv_DEFAULT_PAGE_SIZE)), (1 | 0x80))
	}

	{
		tcl.XTcl_LinkVar(tls, interp, ts+35321 /* "SQLITE_DEFAULT_F..." */, uintptr(unsafe.Pointer(&cv_DEFAULT_FILE_FORMAT)), (1 | 0x80))
	}

	{
		tcl.XTcl_LinkVar(tls, interp, ts+35348 /* "SQLITE_DEFAULT_S..." */, uintptr(unsafe.Pointer(&cv_DEFAULT_SYNCHRONOUS)), (1 | 0x80))
	}

	{
		tcl.XTcl_LinkVar(tls, interp, ts+35375 /* "SQLITE_DEFAULT_W..." */, uintptr(unsafe.Pointer(&cv_DEFAULT_WAL_SYNCHRONOUS)), (1 | 0x80))
	}

	{
		tcl.XTcl_LinkVar(tls, interp, ts+35406 /* "SQLITE_MAX_ATTAC..." */, uintptr(unsafe.Pointer(&cv_MAX_ATTACHED)), (1 | 0x80))
	}

	{
		tcl.XTcl_LinkVar(tls, interp, ts+35426 /* "SQLITE_MAX_DEFAU..." */, uintptr(unsafe.Pointer(&cv_MAX_DEFAULT_PAGE_SIZE)), (1 | 0x80))
	}

	{
		tcl.XTcl_LinkVar(tls, interp, ts+35455 /* "SQLITE_MAX_WORKE..." */, uintptr(unsafe.Pointer(&cv_MAX_WORKER_THREADS)), (1 | 0x80))
	}

	{
		tcl.XTcl_LinkVar(tls, interp, ts+35481 /* "TEMP_STORE" */, uintptr(unsafe.Pointer(&cv_TEMP_STORE)),
			(1 | 0x80))
	}

}

var cv_MAX_LENGTH int32 = 1000000000         /* test_config.c:772:3 */
var cv_MAX_COLUMN int32 = 2000               /* test_config.c:773:3 */
var cv_MAX_SQL_LENGTH int32 = 1000000000     /* test_config.c:774:3 */
var cv_MAX_EXPR_DEPTH int32 = 0              /* test_config.c:775:3 */
var cv_MAX_COMPOUND_SELECT int32 = 500       /* test_config.c:776:3 */
var cv_MAX_VDBE_OP int32 = 250000000         /* test_config.c:777:3 */
var cv_MAX_FUNCTION_ARG int32 = 127          /* test_config.c:778:3 */
var cv_MAX_VARIABLE_NUMBER int32 = 32766     /* test_config.c:779:3 */
var cv_MAX_PAGE_SIZE int32 = 65536           /* test_config.c:780:3 */
var cv_MAX_PAGE_COUNT int32 = 1073741823     /* test_config.c:781:3 */
var cv_MAX_LIKE_PATTERN_LENGTH int32 = 50000 /* test_config.c:782:3 */
var cv_MAX_TRIGGER_DEPTH int32 = 1000        /* test_config.c:783:3 */
var cv_DEFAULT_CACHE_SIZE int32 = -2000      /* test_config.c:784:3 */
var cv_DEFAULT_PAGE_SIZE int32 = 4096        /* test_config.c:785:3 */
var cv_DEFAULT_FILE_FORMAT int32 = 4         /* test_config.c:786:3 */
var cv_DEFAULT_SYNCHRONOUS int32 = 2         /* test_config.c:787:3 */
var cv_DEFAULT_WAL_SYNCHRONOUS int32 = 1     /* test_config.c:788:3 */
var cv_MAX_ATTACHED int32 = 10               /* test_config.c:789:3 */
var cv_MAX_DEFAULT_PAGE_SIZE int32 = 8192    /* test_config.c:790:3 */
var cv_MAX_WORKER_THREADS int32 = 8          /* test_config.c:791:3 */
var cv_TEMP_STORE int32 = 1                  /* test_config.c:794:22 */

// Register commands with the TCL interpreter.
func Sqliteconfig_Init(tls *crt.TLS, interp uintptr) int32 { /* test_config.c:819:5: */
	set_options(tls, interp)
	return 0
}

//
// END OF REGISTRATION API
//

//******* End of fts5.h ********

// The following #defines are copied from test_multiplex.c

// This routine is a copy of (most of) the code from SQLite function
// sqlite3FileSuffix3(). It modifies the filename in buffer z in the
// same way as SQLite does when in 8.3 filenames mode.
func sqlite3Delete83Name(tls *crt.TLS, z uintptr) { /* test_delete.c:46:13: */
	var i int32
	var sz int32
	sz = int32(crt.Xstrlen(tls, z))
	for i = (sz - 1); ((i > 0) && (int32(*(*int8)(unsafe.Pointer(z + uintptr(i)))) != '/')) && (int32(*(*int8)(unsafe.Pointer(z + uintptr(i)))) != '.'); i-- {
	}
	if (int32(*(*int8)(unsafe.Pointer(z + uintptr(i)))) == '.') && (sz > (i + 4)) {
		crt.Xmemmove(tls, (z + uintptr((i + 1))), (z + uintptr((sz - 3))), uint64(4))
	}
}

// zFile is a filename. Assuming no error occurs, if this file exists,
// set *pbExists to true and unlink it. Or, if the file does not exist,
// set *pbExists to false before returning.
//
// If an error occurs, non-zero is returned. Or, if no error occurs, zero.
func sqlite3DeleteUnlinkIfExists(tls *crt.TLS, pVfs uintptr, zFile uintptr, pbExists uintptr) int32 { /* test_delete.c:60:12: */
	var rc int32 = 1
	if !(pVfs == uintptr(0)) {
		crt.X__assert_fail(tls, ts+35492 /* "pVfs==0" */, ts+35500 /* "testdata/sqlite-..." */, uint32(76), uintptr(unsafe.Pointer(&__func__101)))
	}
	rc = crt.Xaccess(tls, zFile, 0)
	if rc != 0 {
		if (*(*int32)(unsafe.Pointer(crt.X__errno_location(tls)))) == 2 {
			if pbExists != 0 {
				*(*int32)(unsafe.Pointer(pbExists)) = 0
			}
			rc = 0
		}
	} else {
		if pbExists != 0 {
			*(*int32)(unsafe.Pointer(pbExists)) = 1
		}
		rc = crt.Xunlink(tls, zFile)
	}
	return rc
}

var __func__101 = *(*[28]int8)(unsafe.Pointer(ts + 35546 /* "sqlite3DeleteUnl..." */)) /* test_delete.c:64:2 */

// Delete the database file identified by the string argument passed to this
// function. The string must contain a filename, not an SQLite URI.
func sqlite3_delete_database(tls *crt.TLS, zFile uintptr) int32 { /* test_delete.c:95:16: */
	bp := tls.Alloc(156)
	defer tls.Free(156)

	var zBuf uintptr // Buffer to sprintf() filenames to
	var nBuf int32   // Size of buffer in bytes
	var rc int32 = 0 // System error code
	var i int32      // Iterate through azFmt[] and aMFile[]

	*(*[4]uintptr)(unsafe.Pointer(bp + 24 /* azFmt */)) = [4]uintptr{ts + 130 /* "%s" */, ts + 35574 /* "%s-journal" */, ts + 14141 /* "%s-wal" */, ts + 35585 /* "%s-shm" */}

	*(*[6]MFile)(unsafe.Pointer(bp + 56 /* aMFile */)) = [6]MFile{
		{FzFmt: ts + 35592 /* "%s%03d" */, FiOffset: 0, Fb83: 0},
		{FzFmt: ts + 35599 /* "%s-journal%03d" */, FiOffset: 0, Fb83: 0},
		{FzFmt: ts + 35614 /* "%s-wal%03d" */, FiOffset: 0, Fb83: 0},
		{FzFmt: ts + 35592 /* "%s%03d" */, FiOffset: 0, Fb83: 1},
		{FzFmt: ts + 35599 /* "%s-journal%03d" */, FiOffset: 400, Fb83: 1},
		{FzFmt: ts + 35614 /* "%s-wal%03d" */, FiOffset: 700, Fb83: 1},
	}

	var pVfs uintptr = uintptr(0)

	// Allocate a buffer large enough for any of the files that need to be
	// deleted.
	nBuf = (int32(crt.Xstrlen(tls, zFile)) + 100)
	zBuf = sqlite3.Xsqlite3_malloc(tls, nBuf)
	if zBuf == uintptr(0) {
		return 7
	}

	// Delete both the regular and 8.3 filenames versions of the database,
	// journal, wal and shm files.
	for i = 0; (rc == 0) && (uint64(i) < (uint64(unsafe.Sizeof([4]uintptr{})) / uint64(unsafe.Sizeof(uintptr(0))))); i++ {
		sqlite3.Xsqlite3_snprintf(tls, nBuf, zBuf, *(*uintptr)(unsafe.Pointer(bp + 24 /* &azFmt[0] */ + uintptr(i)*8)), crt.VaList(bp, zFile))
		rc = sqlite3DeleteUnlinkIfExists(tls, pVfs, zBuf, uintptr(0))
		if (rc == 0) && (i != 0) {
			sqlite3Delete83Name(tls, zBuf)
			rc = sqlite3DeleteUnlinkIfExists(tls, pVfs, zBuf, uintptr(0))
		}
	}

	// Delete any multiplexor files
	for i = 0; (rc == 0) && (uint64(i) < (uint64(unsafe.Sizeof([6]MFile{})) / uint64(unsafe.Sizeof(MFile{})))); i++ {
		var p uintptr = (bp + 56 /* &aMFile */ + uintptr(i)*16)
		var iChunk int32
		for iChunk = 1; iChunk <= 299; iChunk++ {
			// var bExists int32 at bp+152, 4

			sqlite3.Xsqlite3_snprintf(tls, nBuf, zBuf, (*MFile)(unsafe.Pointer(p)).FzFmt, crt.VaList(bp+8, zFile, (iChunk+(*MFile)(unsafe.Pointer(p)).FiOffset)))
			if (*MFile)(unsafe.Pointer(p)).Fb83 != 0 {
				sqlite3Delete83Name(tls, zBuf)
			}
			rc = sqlite3DeleteUnlinkIfExists(tls, pVfs, zBuf, bp+152 /* &bExists */)
			if (*(*int32)(unsafe.Pointer(bp + 152 /* bExists */)) == 0) || (rc != 0) {
				break
			}
		}
	}

	sqlite3.Xsqlite3_free(tls, zBuf)
	return func() int32 {
		if rc != 0 {
			return 1
		}
		return 0
	}()
}

type MFile = struct {
	FzFmt    uintptr
	FiOffset int32
	Fb83     int32
}

// end block for C++

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:

func Sqlitetest_demovfs_Init(tls *crt.TLS, interp uintptr) int32 { /* test_demovfs.c:686:5: */ return 0 }

// Maximum pathname length supported by the devsym backend.

// Name used to identify this VFS.

type devsym_file1 = struct {
	Fbase  sqlite3_file
	FpReal uintptr
}

// Maximum pathname length supported by the devsym backend.

// Name used to identify this VFS.

type devsym_file = devsym_file1 /* test_devsym.c:33:28 */

type DevsymGlobal = struct {
	FpVfs        uintptr
	FiDeviceChar int32
	FiSectorSize int32
	FnWriteCrash int32
	_            [4]byte
}

var g1 = DevsymGlobal{FpVfs: uintptr(0), FiDeviceChar: 0, FiSectorSize: 512, FnWriteCrash: 0} /* test_devsym.c:82:21 */

// Close an devsym-file.
func devsymClose(tls *crt.TLS, pFile uintptr) int32 { /* test_devsym.c:87:12: */
	var p uintptr = pFile
	sqlite3.Xsqlite3OsClose(tls, (*devsym_file)(unsafe.Pointer(p)).FpReal)
	return 0
}

// Read data from an devsym-file.
func devsymRead(tls *crt.TLS, pFile uintptr, zBuf uintptr, iAmt int32, iOfst sqlite_int64) int32 { /* test_devsym.c:96:12: */
	var p uintptr = pFile
	return sqlite3.Xsqlite3OsRead(tls, (*devsym_file)(unsafe.Pointer(p)).FpReal, zBuf, iAmt, iOfst)
}

// Write data to an devsym-file.
func devsymWrite(tls *crt.TLS, pFile uintptr, zBuf uintptr, iAmt int32, iOfst sqlite_int64) int32 { /* test_devsym.c:109:12: */
	var p uintptr = pFile
	return sqlite3.Xsqlite3OsWrite(tls, (*devsym_file)(unsafe.Pointer(p)).FpReal, zBuf, iAmt, iOfst)
}

// Truncate an devsym-file.
func devsymTruncate(tls *crt.TLS, pFile uintptr, size sqlite_int64) int32 { /* test_devsym.c:122:12: */
	var p uintptr = pFile
	return sqlite3.Xsqlite3OsTruncate(tls, (*devsym_file)(unsafe.Pointer(p)).FpReal, size)
}

// Sync an devsym-file.
func devsymSync(tls *crt.TLS, pFile uintptr, flags int32) int32 { /* test_devsym.c:130:12: */
	var p uintptr = pFile
	return sqlite3.Xsqlite3OsSync(tls, (*devsym_file)(unsafe.Pointer(p)).FpReal, flags)
}

// Return the current file-size of an devsym-file.
func devsymFileSize(tls *crt.TLS, pFile uintptr, pSize uintptr) int32 { /* test_devsym.c:138:12: */
	var p uintptr = pFile
	return sqlite3.Xsqlite3OsFileSize(tls, (*devsym_file)(unsafe.Pointer(p)).FpReal, pSize)
}

// Lock an devsym-file.
func devsymLock(tls *crt.TLS, pFile uintptr, eLock int32) int32 { /* test_devsym.c:146:12: */
	var p uintptr = pFile
	return sqlite3.Xsqlite3OsLock(tls, (*devsym_file)(unsafe.Pointer(p)).FpReal, eLock)
}

// Unlock an devsym-file.
func devsymUnlock(tls *crt.TLS, pFile uintptr, eLock int32) int32 { /* test_devsym.c:154:12: */
	var p uintptr = pFile
	return sqlite3.Xsqlite3OsUnlock(tls, (*devsym_file)(unsafe.Pointer(p)).FpReal, eLock)
}

// Check if another file-handle holds a RESERVED lock on an devsym-file.
func devsymCheckReservedLock(tls *crt.TLS, pFile uintptr, pResOut uintptr) int32 { /* test_devsym.c:162:12: */
	var p uintptr = pFile
	return sqlite3.Xsqlite3OsCheckReservedLock(tls, (*devsym_file)(unsafe.Pointer(p)).FpReal, pResOut)
}

// File control method. For custom operations on an devsym-file.
func devsymFileControl(tls *crt.TLS, pFile uintptr, op int32, pArg uintptr) int32 { /* test_devsym.c:170:12: */
	var p uintptr = pFile
	return sqlite3.Xsqlite3OsFileControl(tls, (*devsym_file)(unsafe.Pointer(p)).FpReal, op, pArg)
}

// Return the sector-size in bytes for an devsym-file.
func devsymSectorSize(tls *crt.TLS, pFile uintptr) int32 { /* test_devsym.c:178:12: */
	return g1.FiSectorSize
}

// Return the device characteristic flags supported by an devsym-file.
func devsymDeviceCharacteristics(tls *crt.TLS, pFile uintptr) int32 { /* test_devsym.c:185:12: */
	return g1.FiDeviceChar
}

// Shared-memory methods are all pass-thrus.
func devsymShmLock(tls *crt.TLS, pFile uintptr, ofst int32, n int32, flags int32) int32 { /* test_devsym.c:192:12: */
	var p uintptr = pFile
	return sqlite3.Xsqlite3OsShmLock(tls, (*devsym_file)(unsafe.Pointer(p)).FpReal, ofst, n, flags)
}
func devsymShmMap(tls *crt.TLS, pFile uintptr, iRegion int32, szRegion int32, isWrite int32, pp uintptr) int32 { /* test_devsym.c:196:12: */
	var p uintptr = pFile
	return sqlite3.Xsqlite3OsShmMap(tls, (*devsym_file)(unsafe.Pointer(p)).FpReal, iRegion, szRegion, isWrite, pp)
}
func devsymShmBarrier(tls *crt.TLS, pFile uintptr) { /* test_devsym.c:206:13: */
	var p uintptr = pFile
	sqlite3.Xsqlite3OsShmBarrier(tls, (*devsym_file)(unsafe.Pointer(p)).FpReal)
}
func devsymShmUnmap(tls *crt.TLS, pFile uintptr, delFlag int32) int32 { /* test_devsym.c:210:12: */
	var p uintptr = pFile
	return sqlite3.Xsqlite3OsShmUnmap(tls, (*devsym_file)(unsafe.Pointer(p)).FpReal, delFlag)
}

// Open an devsym file handle.
func devsymOpen(tls *crt.TLS, pVfs uintptr, zName uintptr, pFile uintptr, flags int32, pOutFlags uintptr) int32 { /* test_devsym.c:220:12: */
	var rc int32
	var p uintptr = pFile
	(*devsym_file)(unsafe.Pointer(p)).FpReal = (p + uintptr(1)*16)
	rc = sqlite3.Xsqlite3OsOpen(tls, g1.FpVfs, zName, (*devsym_file)(unsafe.Pointer(p)).FpReal, flags, pOutFlags)
	if (*sqlite3_file)(unsafe.Pointer((*devsym_file)(unsafe.Pointer(p)).FpReal)).FpMethods != 0 {
		(*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods = uintptr(unsafe.Pointer(&devsym_io_methods))
	}
	return rc
}

var devsym_io_methods = sqlite3_io_methods{FiVersion: 2, FxClose: // iVersion
0, FxRead:// xClose
0, FxWrite:// xRead
0, FxTruncate:// xWrite
0, FxSync:// xTruncate
0, FxFileSize:// xSync
0, FxLock:// xFileSize
0, FxUnlock:// xLock
0, FxCheckReservedLock:// xUnlock
0, FxFileControl:// xCheckReservedLock
0, FxSectorSize:// xFileControl
0, FxDeviceCharacteristics:// xSectorSize
0, FxShmMap:// xDeviceCharacteristics
0, FxShmLock:// xShmMap
0, FxShmBarrier:// xShmLock
0, FxShmUnmap:// xShmBarrier
0, // xShmUnmap
} /* test_devsym.c:227:27 */

// Delete the file located at zPath. If the dirSync argument is true,
// ensure the file-system modifications are synced to disk before
// returning.
func devsymDelete(tls *crt.TLS, pVfs uintptr, zPath uintptr, dirSync int32) int32 { /* test_devsym.c:262:12: */
	return sqlite3.Xsqlite3OsDelete(tls, g1.FpVfs, zPath, dirSync)
}

// Test for access permissions. Return true if the requested permission
// is available, or false otherwise.
func devsymAccess(tls *crt.TLS, pVfs uintptr, zPath uintptr, flags int32, pResOut uintptr) int32 { /* test_devsym.c:270:12: */
	return sqlite3.Xsqlite3OsAccess(tls, g1.FpVfs, zPath, flags, pResOut)
}

// Populate buffer zOut with the full canonical pathname corresponding
// to the pathname in zPath. zOut is guaranteed to point to a buffer
// of at least (DEVSYM_MAX_PATHNAME+1) bytes.
func devsymFullPathname(tls *crt.TLS, pVfs uintptr, zPath uintptr, nOut int32, zOut uintptr) int32 { /* test_devsym.c:284:12: */
	return sqlite3.Xsqlite3OsFullPathname(tls, g1.FpVfs, zPath, nOut, zOut)
}

// Populate the buffer pointed to by zBufOut with nByte bytes of
// random data.
func devsymRandomness(tls *crt.TLS, pVfs uintptr, nByte int32, zBufOut uintptr) int32 { /* test_devsym.c:329:12: */
	return sqlite3.Xsqlite3OsRandomness(tls, g1.FpVfs, nByte, zBufOut)
}

// Sleep for nMicro microseconds. Return the number of microseconds
// actually slept.
func devsymSleep(tls *crt.TLS, pVfs uintptr, nMicro int32) int32 { /* test_devsym.c:337:12: */
	return sqlite3.Xsqlite3OsSleep(tls, g1.FpVfs, nMicro)
}

// Return the current time as a Julian Day number in *pTimeOut.
func devsymCurrentTime(tls *crt.TLS, pVfs uintptr, pTimeOut uintptr) int32 { /* test_devsym.c:344:12: */
	return (*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer((g1.FpVfs + 120 /* &.xCurrentTime */))))(tls, g1.FpVfs, pTimeOut)
}

// Return the sector-size in bytes for an writecrash-file.
func writecrashSectorSize(tls *crt.TLS, pFile uintptr) int32 { /* test_devsym.c:351:12: */
	var p uintptr = pFile
	return sqlite3.Xsqlite3OsSectorSize(tls, (*devsym_file)(unsafe.Pointer(p)).FpReal)
}

// Return the device characteristic flags supported by an writecrash-file.
func writecrashDeviceCharacteristics(tls *crt.TLS, pFile uintptr) int32 { /* test_devsym.c:359:12: */
	var p uintptr = pFile
	return sqlite3.Xsqlite3OsDeviceCharacteristics(tls, (*devsym_file)(unsafe.Pointer(p)).FpReal)
}

// Write data to an writecrash-file.
func writecrashWrite(tls *crt.TLS, pFile uintptr, zBuf uintptr, iAmt int32, iOfst sqlite_int64) int32 { /* test_devsym.c:367:12: */
	var p uintptr = pFile
	if g1.FnWriteCrash > 0 {
		g1.FnWriteCrash--
		if g1.FnWriteCrash == 0 {
			crt.Xabort(tls)
		}
	}
	return sqlite3.Xsqlite3OsWrite(tls, (*devsym_file)(unsafe.Pointer(p)).FpReal, zBuf, iAmt, iOfst)
}

// Open an writecrash file handle.
func writecrashOpen(tls *crt.TLS, pVfs uintptr, zName uintptr, pFile uintptr, flags int32, pOutFlags uintptr) int32 { /* test_devsym.c:384:12: */
	var rc int32
	var p uintptr = pFile
	(*devsym_file)(unsafe.Pointer(p)).FpReal = (p + uintptr(1)*16)
	rc = sqlite3.Xsqlite3OsOpen(tls, g1.FpVfs, zName, (*devsym_file)(unsafe.Pointer(p)).FpReal, flags, pOutFlags)
	if (*sqlite3_file)(unsafe.Pointer((*devsym_file)(unsafe.Pointer(p)).FpReal)).FpMethods != 0 {
		(*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods = uintptr(unsafe.Pointer(&writecrash_io_methods))
	}
	return rc
}

var writecrash_io_methods = sqlite3_io_methods{FiVersion: 2, FxClose: // iVersion
0, FxRead:// xClose
0, FxWrite:// xRead
0, FxTruncate:// xWrite
0, FxSync:// xTruncate
0, FxFileSize:// xSync
0, FxLock:// xFileSize
0, FxUnlock:// xLock
0, FxCheckReservedLock:// xUnlock
0, FxFileControl:// xCheckReservedLock
0, FxSectorSize:// xFileControl
0, FxDeviceCharacteristics:// xSectorSize
0, FxShmMap:// xDeviceCharacteristics
0, FxShmLock:// xShmMap
0, FxShmBarrier:// xShmLock
0, FxShmUnmap:// xShmBarrier
0, // xShmUnmap
} /* test_devsym.c:391:27 */

var devsym_vfs = sqlite3_vfs{FiVersion: 2, FszOsFile: // iVersion
int32(unsafe.Sizeof(devsym_file{})), FmxPathname:// szOsFile
512, FpNext:// mxPathname
uintptr(0), FzName:// pNext
ts + 35625, /* "devsym" */ FpAppData:// zName
uintptr(0), FxOpen:// pAppData
0, FxDelete:// xOpen
0, FxAccess:// xDelete
0, FxFullPathname:// xAccess
0, FxDlOpen:// xFullPathname
uintptr(0), FxDlError:// xDlOpen
uintptr(0), FxDlSym:// xDlError
uintptr(0), FxDlClose:// xDlSym
uintptr(0), FxRandomness:// xDlClose
0, FxSleep:// xRandomness
0, FxCurrentTime:// xSleep
0, FxGetLastError:// xCurrentTime
uintptr(0), FxCurrentTimeInt64:// xGetLastError
uintptr(0), // xCurrentTimeInt64
} /* test_devsym.c:421:20 */

var writecrash_vfs = sqlite3_vfs{FiVersion: 2, FszOsFile: // iVersion
int32(unsafe.Sizeof(devsym_file{})), FmxPathname:// szOsFile
512, FpNext:// mxPathname
uintptr(0), FzName:// pNext
ts + 35632, /* "writecrash" */ FpAppData:// zName
uintptr(0), FxOpen:// pAppData
0, FxDelete:// xOpen
0, FxAccess:// xDelete
0, FxFullPathname:// xAccess
0, FxDlOpen:// xFullPathname
uintptr(0), FxDlError:// xDlOpen
uintptr(0), FxDlSym:// xDlError
uintptr(0), FxDlClose:// xDlSym
uintptr(0), FxRandomness:// xDlClose
0, FxSleep:// xRandomness
0, FxCurrentTime:// xSleep
0, FxGetLastError:// xCurrentTime
uintptr(0), FxCurrentTimeInt64:// xGetLastError
uintptr(0), // xCurrentTimeInt64
} /* test_devsym.c:450:20 */

// This procedure registers the devsym vfs with SQLite. If the argument is
// true, the devsym vfs becomes the new default vfs. It is the only publicly
// available function in this file.
func devsym_register(tls *crt.TLS, iDeviceChar int32, iSectorSize int32) { /* test_devsym.c:485:6: */

	if g1.FpVfs == uintptr(0) {
		g1.FpVfs = sqlite3.Xsqlite3_vfs_find(tls, uintptr(0))
		*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&devsym_vfs)) + 4 /* &.szOsFile */)) += ((*sqlite3_vfs)(unsafe.Pointer(g1.FpVfs)).FszOsFile)
		*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&writecrash_vfs)) + 4 /* &.szOsFile */)) += ((*sqlite3_vfs)(unsafe.Pointer(g1.FpVfs)).FszOsFile)
		sqlite3.Xsqlite3_vfs_register(tls, uintptr(unsafe.Pointer(&devsym_vfs)), 0)
		sqlite3.Xsqlite3_vfs_register(tls, uintptr(unsafe.Pointer(&writecrash_vfs)), 0)
	}
	if iDeviceChar >= 0 {
		g1.FiDeviceChar = iDeviceChar
	} else {
		g1.FiDeviceChar = 0
	}
	if iSectorSize >= 0 {
		g1.FiSectorSize = iSectorSize
	} else {
		g1.FiSectorSize = 512
	}
}

func devsym_unregister(tls *crt.TLS) { /* test_devsym.c:506:6: */
	sqlite3.Xsqlite3_vfs_unregister(tls, uintptr(unsafe.Pointer(&devsym_vfs)))
	sqlite3.Xsqlite3_vfs_unregister(tls, uintptr(unsafe.Pointer(&writecrash_vfs)))
	g1.FpVfs = uintptr(0)
	g1.FiDeviceChar = 0
	g1.FiSectorSize = 0
}

func devsym_crash_on_write(tls *crt.TLS, nWrite int32) { /* test_devsym.c:514:6: */
	if g1.FpVfs == uintptr(0) {
		g1.FpVfs = sqlite3.Xsqlite3_vfs_find(tls, uintptr(0))
		*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&devsym_vfs)) + 4 /* &.szOsFile */)) += ((*sqlite3_vfs)(unsafe.Pointer(g1.FpVfs)).FszOsFile)
		*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&writecrash_vfs)) + 4 /* &.szOsFile */)) += ((*sqlite3_vfs)(unsafe.Pointer(g1.FpVfs)).FszOsFile)
		sqlite3.Xsqlite3_vfs_register(tls, uintptr(unsafe.Pointer(&devsym_vfs)), 0)
		sqlite3.Xsqlite3_vfs_register(tls, uintptr(unsafe.Pointer(&writecrash_vfs)), 0)
	}
	g1.FnWriteCrash = nWrite
}

type Tcl_StatBuf = struct {
	Fst_dev           uint64
	Fst_ino           uint64
	Fst_nlink         uint64
	Fst_mode          uint32
	Fst_uid           uint32
	Fst_gid           uint32
	F__pad0           int32
	Fst_rdev          uint64
	Fst_size          int64
	Fst_blksize       int64
	Fst_blocks        int64
	Fst_atime         int64
	Fst_atimensec     uint64
	Fst_mtime         int64
	Fst_mtimensec     uint64
	Fst_ctime         int64
	Fst_ctimensec     uint64
	F__glibc_reserved [3]int64
} /* tcl.h:470:25 */

// Note stat64 has the same shape as stat for x86-64.
type stat64 = struct {
	Fst_dev           uint64
	Fst_ino           uint64
	Fst_nlink         uint64
	Fst_mode          uint32
	Fst_uid           uint32
	Fst_gid           uint32
	F__pad0           int32
	Fst_rdev          uint64
	Fst_size          int64
	Fst_blksize       int64
	Fst_blocks        int64
	Fst_atime         int64
	Fst_atimensec     uint64
	Fst_mtime         int64
	Fst_mtimensec     uint64
	Fst_ctime         int64
	Fst_ctimensec     uint64
	F__glibc_reserved [3]int64
}

type fs_vtab1 = struct {
	Fbase sqlite3_vtab
	Fdb   uintptr
	FzDb  uintptr
	FzTbl uintptr
}

type fs_vtab = fs_vtab1 /* test_fs.c:96:24 */
type fs_cursor1 = struct {
	Fbase   sqlite3_vtab_cursor
	FpStmt  uintptr
	FzBuf   uintptr
	FnBuf   int32
	FnAlloc int32
}

type fs_cursor = fs_cursor1 /* test_fs.c:97:26 */

// ************************************************************************
//
// Start of fsdir implementation.
type FsdirVtab1 = struct{ Fbase sqlite3_vtab }

// ************************************************************************
//
// Start of fsdir implementation.
type FsdirVtab = FsdirVtab1 /* test_fs.c:121:26 */
type FsdirCsr1 = struct {
	Fbase   sqlite3_vtab_cursor
	FzDir   uintptr
	FpDir   uintptr
	FiRowid sqlite3_int64
	FpEntry uintptr
}

type FsdirCsr = FsdirCsr1 /* test_fs.c:122:25 */

// This function is the implementation of both the xConnect and xCreate
// methods of the fsdir virtual table.
//
// The argv[] array contains the following:
//
//   argv[0]   -> module name  ("fs")
//   argv[1]   -> database name
//   argv[2]   -> table name
//   argv[...] -> other module argument fields.
func fsdirConnect1(tls *crt.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVtab uintptr, pzErr uintptr) int32 { /* test_fs.c:146:12: */
	var pTab uintptr

	if argc != 3 {
		*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+33340 /* "wrong number of ..." */, 0)
		return 1
	}

	pTab = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(FsdirVtab{})))
	if !(pTab != 0) {
		return 7
	}
	crt.Xmemset(tls, pTab, 0, uint64(unsafe.Sizeof(FsdirVtab{})))

	*(*uintptr)(unsafe.Pointer(ppVtab)) = (pTab /* &.base */)
	sqlite3.Xsqlite3_declare_vtab(tls, db, ts+35643 /* "CREATE TABLE xyz..." */)

	return 0
}

// xDestroy/xDisconnect implementation.
func fsdirDisconnect1(tls *crt.TLS, pVtab uintptr) int32 { /* test_fs.c:173:12: */
	sqlite3.Xsqlite3_free(tls, pVtab)
	return 0
}

// xBestIndex implementation. The only constraint supported is:
//
//   (dir = ?)
func fsdirBestIndex1(tls *crt.TLS, tab uintptr, pIdxInfo uintptr) int32 { /* test_fs.c:183:12: */
	var ii int32

	(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = 1000000000.0

	for ii = 0; ii < (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnConstraint; ii++ {
		var p uintptr = ((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraint + uintptr(ii)*12)
		if (((*sqlite3_index_constraint)(unsafe.Pointer(p)).FiColumn == 0) && ((*sqlite3_index_constraint)(unsafe.Pointer(p)).Fusable != 0)) && (int32((*sqlite3_index_constraint)(unsafe.Pointer(p)).Fop) == 2) {
			var pUsage uintptr
			pUsage = ((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(ii)*8)
			(*sqlite3_index_constraint_usage)(unsafe.Pointer(pUsage)).Fomit = uint8(1)
			(*sqlite3_index_constraint_usage)(unsafe.Pointer(pUsage)).FargvIndex = 1
			(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxNum = 1
			(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = 1.0
			break
		}
	}

	return 0
}

// xOpen implementation.
//
// Open a new fsdir cursor.
func fsdirOpen1(tls *crt.TLS, pVTab uintptr, ppCursor uintptr) int32 { /* test_fs.c:209:12: */
	var pCur uintptr
	// Allocate an extra 256 bytes because it is undefined how big dirent.d_name
	// is and we need enough space.  Linux provides plenty already, but
	// Solaris only provides one byte.
	pCur = sqlite3.Xsqlite3_malloc(tls, (int32(uint64(unsafe.Sizeof(FsdirCsr{})) + uint64(256))))
	if pCur == uintptr(0) {
		return 7
	}
	crt.Xmemset(tls, pCur, 0, uint64(unsafe.Sizeof(FsdirCsr{})))
	*(*uintptr)(unsafe.Pointer(ppCursor)) = (pCur /* &.base */)
	return 0
}

// Close a fsdir cursor.
func fsdirClose1(tls *crt.TLS, cur uintptr) int32 { /* test_fs.c:224:12: */
	var pCur uintptr = cur
	if (*FsdirCsr)(unsafe.Pointer(pCur)).FpDir != 0 {
		crt.Xclosedir(tls, (*FsdirCsr)(unsafe.Pointer(pCur)).FpDir)
	}
	sqlite3.Xsqlite3_free(tls, (*FsdirCsr)(unsafe.Pointer(pCur)).FzDir)
	sqlite3.Xsqlite3_free(tls, pCur)
	return 0
}

// Skip the cursor to the next entry.
func fsdirNext1(tls *crt.TLS, cur uintptr) int32 { /* test_fs.c:235:12: */
	var pCsr uintptr = cur

	if (*FsdirCsr)(unsafe.Pointer(pCsr)).FpDir != 0 {
		(*FsdirCsr)(unsafe.Pointer(pCsr)).FpEntry = crt.Xreaddir64(tls, (*FsdirCsr)(unsafe.Pointer(pCsr)).FpDir)
		if (*FsdirCsr)(unsafe.Pointer(pCsr)).FpEntry == uintptr(0) {
			crt.Xclosedir(tls, (*FsdirCsr)(unsafe.Pointer(pCsr)).FpDir)
			(*FsdirCsr)(unsafe.Pointer(pCsr)).FpDir = uintptr(0)
		}
		(*FsdirCsr)(unsafe.Pointer(pCsr)).FiRowid++
	}

	return 0
}

// xFilter method implementation.
func fsdirFilter1(tls *crt.TLS, pVtabCursor uintptr, idxNum int32, idxStr uintptr, argc int32, argv uintptr) int32 { /* test_fs.c:253:12: */
	var pCsr uintptr = pVtabCursor
	var zDir uintptr
	var nDir int32

	if (idxNum != 1) || (argc != 1) {
		return 1
	}

	(*FsdirCsr)(unsafe.Pointer(pCsr)).FiRowid = int64(0)
	sqlite3.Xsqlite3_free(tls, (*FsdirCsr)(unsafe.Pointer(pCsr)).FzDir)
	if (*FsdirCsr)(unsafe.Pointer(pCsr)).FpDir != 0 {
		crt.Xclosedir(tls, (*FsdirCsr)(unsafe.Pointer(pCsr)).FpDir)
		(*FsdirCsr)(unsafe.Pointer(pCsr)).FpDir = uintptr(0)
	}

	zDir = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)))
	nDir = sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)))
	(*FsdirCsr)(unsafe.Pointer(pCsr)).FzDir = sqlite3.Xsqlite3_malloc(tls, (nDir + 1))
	if (*FsdirCsr)(unsafe.Pointer(pCsr)).FzDir == uintptr(0) {
		return 7
	}
	crt.Xmemcpy(tls, (*FsdirCsr)(unsafe.Pointer(pCsr)).FzDir, zDir, (uint64(nDir + 1)))

	(*FsdirCsr)(unsafe.Pointer(pCsr)).FpDir = crt.Xopendir(tls, (*FsdirCsr)(unsafe.Pointer(pCsr)).FzDir)
	return fsdirNext1(tls, pVtabCursor)
}

// xEof method implementation.
func fsdirEof1(tls *crt.TLS, cur uintptr) int32 { /* test_fs.c:287:12: */
	var pCsr uintptr = cur
	return (crt.Bool32((*FsdirCsr)(unsafe.Pointer(pCsr)).FpDir == uintptr(0)))
}

// xColumn method implementation.
func fsdirColumn1(tls *crt.TLS, cur uintptr, ctx uintptr, i int32) int32 { /* test_fs.c:295:12: */
	var pCsr uintptr = cur
	switch i {
	case 0: // dir
		sqlite3.Xsqlite3_result_text(tls, ctx, (*FsdirCsr)(unsafe.Pointer(pCsr)).FzDir, -1, uintptr(0))
		break

	case 1: // name
		sqlite3.Xsqlite3_result_text(tls, ctx, (*FsdirCsr)(unsafe.Pointer(pCsr)).FpEntry+19 /* &.d_name */, -1, crt.UintptrFromInt32(-1))
		break

	default:
	}

	return 0
}

// xRowid method implementation.
func fsdirRowid1(tls *crt.TLS, cur uintptr, pRowid uintptr) int32 { /* test_fs.c:316:12: */
	var pCsr uintptr = cur
	*(*sqlite_int64)(unsafe.Pointer(pRowid)) = (*FsdirCsr)(unsafe.Pointer(pCsr)).FiRowid
	return 0
}

//
// End of fsdir implementation.
//

// ************************************************************************
//
// Start of fstree implementation.
type FstreeVtab1 = struct {
	Fbase sqlite3_vtab
	Fdb   uintptr
}

//
// End of fsdir implementation.
//

// ************************************************************************
//
// Start of fstree implementation.
type FstreeVtab = FstreeVtab1 /* test_fs.c:328:27 */
type FstreeCsr1 = struct {
	Fbase  sqlite3_vtab_cursor
	FpStmt uintptr
	Ffd    int32
	_      [4]byte
}

type FstreeCsr = FstreeCsr1 /* test_fs.c:329:26 */

// This function is the implementation of both the xConnect and xCreate
// methods of the fstree virtual table.
//
// The argv[] array contains the following:
//
//   argv[0]   -> module name  ("fs")
//   argv[1]   -> database name
//   argv[2]   -> table name
//   argv[...] -> other module argument fields.
func fstreeConnect(tls *crt.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVtab uintptr, pzErr uintptr) int32 { /* test_fs.c:352:12: */
	var pTab uintptr

	if argc != 3 {
		*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+33340 /* "wrong number of ..." */, 0)
		return 1
	}

	pTab = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(FstreeVtab{})))
	if !(pTab != 0) {
		return 7
	}
	crt.Xmemset(tls, pTab, 0, uint64(unsafe.Sizeof(FstreeVtab{})))
	(*FstreeVtab)(unsafe.Pointer(pTab)).Fdb = db

	*(*uintptr)(unsafe.Pointer(ppVtab)) = (pTab /* &.base */)
	sqlite3.Xsqlite3_declare_vtab(tls, db, ts+35672 /* "CREATE TABLE xyz..." */)

	return 0
}

// xDestroy/xDisconnect implementation.
func fstreeDisconnect(tls *crt.TLS, pVtab uintptr) int32 { /* test_fs.c:380:12: */
	sqlite3.Xsqlite3_free(tls, pVtab)
	return 0
}

// xBestIndex implementation. The only constraint supported is:
//
//   (dir = ?)
func fstreeBestIndex(tls *crt.TLS, tab uintptr, pIdxInfo uintptr) int32 { /* test_fs.c:390:12: */
	var ii int32

	for ii = 0; ii < (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnConstraint; ii++ {
		var p uintptr = ((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraint + uintptr(ii)*12)
		if (((*sqlite3_index_constraint)(unsafe.Pointer(p)).FiColumn == 0) && ((*sqlite3_index_constraint)(unsafe.Pointer(p)).Fusable != 0)) && (((int32((*sqlite3_index_constraint)(unsafe.Pointer(p)).Fop) == 66) ||
			(int32((*sqlite3_index_constraint)(unsafe.Pointer(p)).Fop) == 65)) ||
			(int32((*sqlite3_index_constraint)(unsafe.Pointer(p)).Fop) == 2)) {
			var pUsage uintptr
			pUsage = ((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(ii)*8)
			(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxNum = int32((*sqlite3_index_constraint)(unsafe.Pointer(p)).Fop)
			(*sqlite3_index_constraint_usage)(unsafe.Pointer(pUsage)).FargvIndex = 1
			(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = 100000.0
			return 0
		}
	}

	(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = 1000000000.0
	return 0
}

// xOpen implementation.
//
// Open a new fstree cursor.
func fstreeOpen(tls *crt.TLS, pVTab uintptr, ppCursor uintptr) int32 { /* test_fs.c:418:12: */
	var pCur uintptr
	pCur = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(FstreeCsr{})))
	if pCur == uintptr(0) {
		return 7
	}
	crt.Xmemset(tls, pCur, 0, uint64(unsafe.Sizeof(FstreeCsr{})))
	(*FstreeCsr)(unsafe.Pointer(pCur)).Ffd = -1
	*(*uintptr)(unsafe.Pointer(ppCursor)) = (pCur /* &.base */)
	return 0
}

func fstreeCloseFd(tls *crt.TLS, pCsr uintptr) { /* test_fs.c:428:13: */
	if (*FstreeCsr)(unsafe.Pointer(pCsr)).Ffd >= 0 {
		crt.Xclose(tls, (*FstreeCsr)(unsafe.Pointer(pCsr)).Ffd)
		(*FstreeCsr)(unsafe.Pointer(pCsr)).Ffd = -1
	}
}

// Close a fstree cursor.
func fstreeClose(tls *crt.TLS, cur uintptr) int32 { /* test_fs.c:438:12: */
	var pCsr uintptr = cur
	sqlite3.Xsqlite3_finalize(tls, (*FstreeCsr)(unsafe.Pointer(pCsr)).FpStmt)
	fstreeCloseFd(tls, pCsr)
	sqlite3.Xsqlite3_free(tls, pCsr)
	return 0
}

// Skip the cursor to the next entry.
func fstreeNext(tls *crt.TLS, cur uintptr) int32 { /* test_fs.c:449:12: */
	var pCsr uintptr = cur
	var rc int32

	fstreeCloseFd(tls, pCsr)
	rc = sqlite3.Xsqlite3_step(tls, (*FstreeCsr)(unsafe.Pointer(pCsr)).FpStmt)
	if rc != 100 {
		rc = sqlite3.Xsqlite3_finalize(tls, (*FstreeCsr)(unsafe.Pointer(pCsr)).FpStmt)
		(*FstreeCsr)(unsafe.Pointer(pCsr)).FpStmt = uintptr(0)
	} else {
		rc = 0
		(*FstreeCsr)(unsafe.Pointer(pCsr)).Ffd = crt.Xopen64(tls, sqlite3.Xsqlite3_column_text(tls, (*FstreeCsr)(unsafe.Pointer(pCsr)).FpStmt, 0), 00, 0)
	}

	return rc
}

// xFilter method implementation.
func fstreeFilter(tls *crt.TLS, pVtabCursor uintptr, idxNum int32, idxStr uintptr, argc int32, argv uintptr) int32 { /* test_fs.c:469:12: */
	bp := tls.Alloc(2)
	defer tls.Free(2)

	var pCsr uintptr = pVtabCursor
	var pTab uintptr = (*FstreeCsr)(unsafe.Pointer(pCsr)).Fbase.FpVtab
	var rc int32
	var zSql uintptr = ts + 35708 /* "WITH r(d) AS (  ..." */
	var zRoot uintptr
	var nRoot int32
	var zPrefix uintptr
	var nPrefix int32
	var zDir uintptr
	var nDir int32
	*(*[2]int8)(unsafe.Pointer(bp /* aWild */)) = [2]int8{int8(0), int8(0)}

	zRoot = ts + 35940 /* "/" */
	nRoot = 1
	zPrefix = ts + 792 /* "" */
	nPrefix = 0

	zDir = zRoot
	nDir = nRoot

	fstreeCloseFd(tls, pCsr)
	sqlite3.Xsqlite3_finalize(tls, (*FstreeCsr)(unsafe.Pointer(pCsr)).FpStmt)
	(*FstreeCsr)(unsafe.Pointer(pCsr)).FpStmt = uintptr(0)
	rc = sqlite3.Xsqlite3_prepare_v2(tls, (*FstreeVtab)(unsafe.Pointer(pTab)).Fdb, zSql, -1, (pCsr + 8 /* &.pStmt */), uintptr(0))
	if rc != 0 {
		return rc
	}

	if idxNum != 0 {
		var zQuery uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)))
		switch idxNum {
		case 66:
			*(*int8)(unsafe.Pointer(bp /* &aWild[0] */ + uintptr(0))) = int8('*')
			*(*int8)(unsafe.Pointer(bp /* &aWild[0] */ + uintptr(1))) = int8('?')
			break
			fallthrough
		case 65:
			*(*int8)(unsafe.Pointer(bp /* &aWild[0] */ + uintptr(0))) = int8('_')
			*(*int8)(unsafe.Pointer(bp /* &aWild[0] */ + uintptr(1))) = int8('%')
			break
		}

		if sqlite3.Xsqlite3_strnicmp(tls, zQuery, zPrefix, nPrefix) == 0 {
			var i int32
			for i = nPrefix; *(*int8)(unsafe.Pointer(zQuery + uintptr(i))) != 0; i++ {
				if (int32(*(*int8)(unsafe.Pointer(zQuery + uintptr(i)))) == int32(*(*int8)(unsafe.Pointer(bp /* &aWild[0] */ + uintptr(0))))) || (int32(*(*int8)(unsafe.Pointer(zQuery + uintptr(i)))) == int32(*(*int8)(unsafe.Pointer(bp /* &aWild[0] */ + uintptr(1))))) {
					break
				}
				if int32(*(*int8)(unsafe.Pointer(zQuery + uintptr(i)))) == '/' {
					nDir = i
				}
			}
			zDir = zQuery
		}
	}
	if nDir == 0 {
		nDir = 1
	}

	sqlite3.Xsqlite3_bind_text(tls, (*FstreeCsr)(unsafe.Pointer(pCsr)).FpStmt, 1, zDir, nDir, crt.UintptrFromInt32(-1))
	sqlite3.Xsqlite3_bind_text(tls, (*FstreeCsr)(unsafe.Pointer(pCsr)).FpStmt, 2, zRoot, nRoot, crt.UintptrFromInt32(-1))
	sqlite3.Xsqlite3_bind_text(tls, (*FstreeCsr)(unsafe.Pointer(pCsr)).FpStmt, 3, zPrefix, nPrefix, crt.UintptrFromInt32(-1))

	return fstreeNext(tls, pVtabCursor)
}

// xEof method implementation.
func fstreeEof(tls *crt.TLS, cur uintptr) int32 { /* test_fs.c:557:12: */
	var pCsr uintptr = cur
	return (crt.Bool32((*FstreeCsr)(unsafe.Pointer(pCsr)).FpStmt == uintptr(0)))
}

// xColumn method implementation.
func fstreeColumn(tls *crt.TLS, cur uintptr, ctx uintptr, i int32) int32 { /* test_fs.c:565:12: */
	bp := tls.Alloc(144)
	defer tls.Free(144)

	var pCsr uintptr = cur
	if i == 0 { // path
		sqlite3.Xsqlite3_result_value(tls, ctx, sqlite3.Xsqlite3_column_value(tls, (*FstreeCsr)(unsafe.Pointer(pCsr)).FpStmt, 0))
	} else {
		// var sBuf stat64 at bp, 144

		crt.Xfstat64(tls, (*FstreeCsr)(unsafe.Pointer(pCsr)).Ffd, bp /* &sBuf */)

		if (((*stat64)(unsafe.Pointer(bp /* &sBuf */)).Fst_mode) & uint32(0170000)) == (uint32(0100000)) {
			if i == 1 {
				sqlite3.Xsqlite3_result_int64(tls, ctx, int64((*stat64)(unsafe.Pointer(bp /* &sBuf */)).Fst_size))
			} else {
				var nRead int32
				var aBuf uintptr = sqlite3.Xsqlite3_malloc(tls, (int32((*stat64)(unsafe.Pointer(bp /* &sBuf */)).Fst_mode + uint32(1))))
				if !(aBuf != 0) {
					return 7
				}
				nRead = int32(crt.Xread(tls, (*FstreeCsr)(unsafe.Pointer(pCsr)).Ffd, aBuf, uint64((*stat64)(unsafe.Pointer(bp /* &sBuf */)).Fst_mode)))
				if uint32(nRead) != (*stat64)(unsafe.Pointer(bp /* &sBuf */)).Fst_mode {
					return 10
				}
				sqlite3.Xsqlite3_result_blob(tls, ctx, aBuf, nRead, crt.UintptrFromInt32(-1))
				sqlite3.Xsqlite3_free(tls, aBuf)
			}
		}
	}

	return 0
}

// xRowid method implementation.
func fstreeRowid(tls *crt.TLS, cur uintptr, pRowid uintptr) int32 { /* test_fs.c:596:12: */
	*(*sqlite_int64)(unsafe.Pointer(pRowid)) = int64(0)
	return 0
}

//
// End of fstree implementation.
//

// This function is the implementation of both the xConnect and xCreate
// methods of the fs virtual table.
//
// The argv[] array contains the following:
//
//   argv[0]   -> module name  ("fs")
//   argv[1]   -> database name
//   argv[2]   -> table name
//   argv[...] -> other module argument fields.
func fsConnect(tls *crt.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVtab uintptr, pzErr uintptr) int32 { /* test_fs.c:618:12: */
	var pVtab uintptr
	var nByte int32
	var zTbl uintptr
	var zDb uintptr = *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8))

	if argc != 4 {
		*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+33340 /* "wrong number of ..." */, 0)
		return 1
	}
	zTbl = *(*uintptr)(unsafe.Pointer(argv + uintptr(3)*8))

	nByte = (int32((((uint64(unsafe.Sizeof(fs_vtab{})) + uint64(int32(crt.Xstrlen(tls, zTbl)))) + uint64(1)) + uint64(int32(crt.Xstrlen(tls, zDb)))) + uint64(1)))
	pVtab = sqlite3.Xsqlite3MallocZero(tls, uint64(nByte))
	if !(pVtab != 0) {
		return 7
	}

	(*fs_vtab)(unsafe.Pointer(pVtab)).FzTbl = (pVtab + uintptr(1)*48)
	(*fs_vtab)(unsafe.Pointer(pVtab)).FzDb = ((*fs_vtab)(unsafe.Pointer(pVtab)).FzTbl + uintptr((crt.Xstrlen(tls, zTbl) + uint64(1))))
	(*fs_vtab)(unsafe.Pointer(pVtab)).Fdb = db
	crt.Xmemcpy(tls, (*fs_vtab)(unsafe.Pointer(pVtab)).FzTbl, zTbl, crt.Xstrlen(tls, zTbl))
	crt.Xmemcpy(tls, (*fs_vtab)(unsafe.Pointer(pVtab)).FzDb, zDb, crt.Xstrlen(tls, zDb))
	*(*uintptr)(unsafe.Pointer(ppVtab)) = (pVtab /* &.base */)
	sqlite3.Xsqlite3_declare_vtab(tls, db, ts+35942 /* "CREATE TABLE x(p..." */)

	return 0
}

// Note that for this virtual table, the xCreate and xConnect
// methods are identical.

func fsDisconnect(tls *crt.TLS, pVtab uintptr) int32 { /* test_fs.c:653:12: */
	sqlite3.Xsqlite3_free(tls, pVtab)
	return 0
}

// The xDisconnect and xDestroy methods are also the same

// Open a new fs cursor.
func fsOpen(tls *crt.TLS, pVTab uintptr, ppCursor uintptr) int32 { /* test_fs.c:662:12: */
	var pCur uintptr
	pCur = sqlite3.Xsqlite3MallocZero(tls, uint64(unsafe.Sizeof(fs_cursor{})))
	*(*uintptr)(unsafe.Pointer(ppCursor)) = (pCur /* &.base */)
	return 0
}

// Close a fs cursor.
func fsClose(tls *crt.TLS, cur uintptr) int32 { /* test_fs.c:672:12: */
	var pCur uintptr = cur
	sqlite3.Xsqlite3_finalize(tls, (*fs_cursor)(unsafe.Pointer(pCur)).FpStmt)
	sqlite3.Xsqlite3_free(tls, (*fs_cursor)(unsafe.Pointer(pCur)).FzBuf)
	sqlite3.Xsqlite3_free(tls, pCur)
	return 0
}

func fsNext(tls *crt.TLS, cur uintptr) int32 { /* test_fs.c:680:12: */
	var pCur uintptr = cur
	var rc int32

	rc = sqlite3.Xsqlite3_step(tls, (*fs_cursor)(unsafe.Pointer(pCur)).FpStmt)
	if (rc == 100) || (rc == 101) {
		rc = 0
	}

	return rc
}

func fsFilter(tls *crt.TLS, pVtabCursor uintptr, idxNum int32, idxStr uintptr, argc int32, argv uintptr) int32 { /* test_fs.c:690:12: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var rc int32
	var pCur uintptr = pVtabCursor
	var p uintptr = (*sqlite3_vtab_cursor)(unsafe.Pointer(pVtabCursor)).FpVtab

	if idxNum == 1 {
		var zStmt uintptr = sqlite3.Xsqlite3_mprintf(tls,
			ts+35979 /* "SELECT * FROM %Q..." */, crt.VaList(bp, (*fs_vtab)(unsafe.Pointer(p)).FzDb, (*fs_vtab)(unsafe.Pointer(p)).FzTbl))
		if !(zStmt != 0) {
			return 7
		}
		rc = sqlite3.Xsqlite3_prepare_v2(tls, (*fs_vtab)(unsafe.Pointer(p)).Fdb, zStmt, -1, (pCur + 8 /* &.pStmt */), uintptr(0))
		sqlite3.Xsqlite3_free(tls, zStmt)
		if rc == 0 {
			sqlite3.Xsqlite3_bind_value(tls, (*fs_cursor)(unsafe.Pointer(pCur)).FpStmt, 1, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)))
		}
	} else {
		var zStmt uintptr = sqlite3.Xsqlite3_mprintf(tls, ts+2684 /* "SELECT * FROM %Q..." */, crt.VaList(bp+16, (*fs_vtab)(unsafe.Pointer(p)).FzDb, (*fs_vtab)(unsafe.Pointer(p)).FzTbl))
		if !(zStmt != 0) {
			return 7
		}
		rc = sqlite3.Xsqlite3_prepare_v2(tls, (*fs_vtab)(unsafe.Pointer(p)).Fdb, zStmt, -1, (pCur + 8 /* &.pStmt */), uintptr(0))
		sqlite3.Xsqlite3_free(tls, zStmt)
	}

	if rc == 0 {
		rc = fsNext(tls, pVtabCursor)
	}
	return rc
}

func fsColumn(tls *crt.TLS, cur uintptr, ctx uintptr, i int32) int32 { /* test_fs.c:722:12: */
	bp := tls.Alloc(144)
	defer tls.Free(144)

	var pCur uintptr = cur

	if i == 0 {
		sqlite3.Xsqlite3_result_value(tls, ctx, sqlite3.Xsqlite3_column_value(tls, (*fs_cursor)(unsafe.Pointer(pCur)).FpStmt, 0))
	} else {
		var zFile uintptr = sqlite3.Xsqlite3_column_text(tls, (*fs_cursor)(unsafe.Pointer(pCur)).FpStmt, 1)
		// var sbuf stat64 at bp, 144

		var fd int32
		var n int32
		fd = crt.Xopen64(tls, zFile, 00, 0)
		if fd < 0 {
			return 10
		}
		crt.Xfstat64(tls, fd, bp /* &sbuf */)

		if (*stat64)(unsafe.Pointer(bp /* &sbuf */)).Fst_size >= int64((*fs_cursor)(unsafe.Pointer(pCur)).FnAlloc) {
			var nNew sqlite3_int64 = (sqlite3_int64((*stat64)(unsafe.Pointer(bp /* &sbuf */)).Fst_size * int64(2)))
			var zNew uintptr
			if nNew < int64(1024) {
				nNew = int64(1024)
			}

			zNew = sqlite3.Xsqlite3Realloc(tls, (*fs_cursor)(unsafe.Pointer(pCur)).FzBuf, uint64(nNew))
			if zNew == uintptr(0) {
				crt.Xclose(tls, fd)
				return 7
			}
			(*fs_cursor)(unsafe.Pointer(pCur)).FzBuf = zNew
			(*fs_cursor)(unsafe.Pointer(pCur)).FnAlloc = int32(nNew)
		}

		n = int32(crt.Xread(tls, fd, (*fs_cursor)(unsafe.Pointer(pCur)).FzBuf, uint64((*stat64)(unsafe.Pointer(bp /* &sbuf */)).Fst_size)))
		crt.Xclose(tls, fd)
		if int64(n) != (*stat64)(unsafe.Pointer(bp /* &sbuf */)).Fst_size {
			return 1
		}
		(*fs_cursor)(unsafe.Pointer(pCur)).FnBuf = int32((*stat64)(unsafe.Pointer(bp /* &sbuf */)).Fst_size)
		*(*int8)(unsafe.Pointer((*fs_cursor)(unsafe.Pointer(pCur)).FzBuf + uintptr((*fs_cursor)(unsafe.Pointer(pCur)).FnBuf))) = int8(0)

		sqlite3.Xsqlite3_result_text(tls, ctx, (*fs_cursor)(unsafe.Pointer(pCur)).FzBuf, -1, crt.UintptrFromInt32(-1))
	}
	return 0
}

func fsRowid(tls *crt.TLS, cur uintptr, pRowid uintptr) int32 { /* test_fs.c:763:12: */
	var pCur uintptr = cur
	*(*sqlite_int64)(unsafe.Pointer(pRowid)) = sqlite3.Xsqlite3_column_int64(tls, (*fs_cursor)(unsafe.Pointer(pCur)).FpStmt, 0)
	return 0
}

func fsEof(tls *crt.TLS, cur uintptr) int32 { /* test_fs.c:769:12: */
	var pCur uintptr = cur
	return (crt.Bool32(sqlite3.Xsqlite3_data_count(tls, (*fs_cursor)(unsafe.Pointer(pCur)).FpStmt) == 0))
}

func fsBestIndex(tls *crt.TLS, tab uintptr, pIdxInfo uintptr) int32 { /* test_fs.c:774:12: */
	var ii int32

	for ii = 0; ii < (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnConstraint; ii++ {
		var pCons uintptr = ((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraint + uintptr(ii)*12)
		if (((*sqlite3_index_constraint)(unsafe.Pointer(pCons)).FiColumn < 0) && ((*sqlite3_index_constraint)(unsafe.Pointer(pCons)).Fusable != 0)) &&
			(int32((*sqlite3_index_constraint)(unsafe.Pointer(pCons)).Fop) == 2) {
			var pUsage uintptr
			pUsage = ((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(ii)*8)
			(*sqlite3_index_constraint_usage)(unsafe.Pointer(pUsage)).Fomit = uint8(0)
			(*sqlite3_index_constraint_usage)(unsafe.Pointer(pUsage)).FargvIndex = 1
			(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxNum = 1
			(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = 1.0
			break
		}
	}

	return 0
}

// A virtual table module that provides read-only access to a
// Tcl global variable namespace.
var fsModule = sqlite3_module{FiVersion: 0, FxCreate: // iVersion
0, FxConnect:                                         0, FxBestIndex: 0, FxDisconnect: 0, FxDestroy: 0, FxOpen: 0, FxClose: // xOpen - open a cursor
0, FxFilter:// xClose - close a cursor
0, FxNext:// xFilter - configure scan constraints
0, FxEof:// xNext - advance a cursor
0, FxColumn:// xEof - check for end of scan
0, FxRowid:// xColumn - read data
0, FxUpdate:// xRowid - read data
uintptr(0), FxBegin:// xUpdate
uintptr(0), FxSync:// xBegin
uintptr(0), FxCommit:// xSync
uintptr(0), FxRollback:// xCommit
uintptr(0), FxFindFunction:// xRollback
uintptr(0), FxRename:// xFindMethod
uintptr(0), // xRename
} /* test_fs.c:798:23 */

var fsdirModule = sqlite3_module{FiVersion: 0, FxCreate: // iVersion
0, FxConnect:// xCreate
0, FxBestIndex:// xConnect
0, FxDisconnect:// xBestIndex
0, FxDestroy:// xDisconnect
0, FxOpen:// xDestroy
0, FxClose:// xOpen - open a cursor
0, FxFilter:// xClose - close a cursor
0, FxNext:// xFilter - configure scan constraints
0, FxEof:// xNext - advance a cursor
0, FxColumn:// xEof - check for end of scan
0, FxRowid:// xColumn - read data
0, FxUpdate:// xRowid - read data
uintptr(0), FxBegin:// xUpdate
uintptr(0), FxSync:// xBegin
uintptr(0), FxCommit:// xSync
uintptr(0), FxRollback:// xCommit
uintptr(0), FxFindFunction:// xRollback
uintptr(0), FxRename:// xFindMethod
uintptr(0), // xRename
} /* test_fs.c:821:23 */

var fstreeModule = sqlite3_module{FiVersion: 0, FxCreate: // iVersion
0, FxConnect:// xCreate
0, FxBestIndex:// xConnect
0, FxDisconnect:// xBestIndex
0, FxDestroy:// xDisconnect
0, FxOpen:// xDestroy
0, FxClose:// xOpen - open a cursor
0, FxFilter:// xClose - close a cursor
0, FxNext:// xFilter - configure scan constraints
0, FxEof:// xNext - advance a cursor
0, FxColumn:// xEof - check for end of scan
0, FxRowid:// xColumn - read data
0, FxUpdate:// xRowid - read data
uintptr(0), FxBegin:// xUpdate
uintptr(0), FxSync:// xBegin
uintptr(0), FxCommit:// xSync
uintptr(0), FxRollback:// xCommit
uintptr(0), FxFindFunction:// xRollback
uintptr(0), FxRename:// xFindMethod
uintptr(0), // xRename
} /* test_fs.c:844:23 */

// Register the echo virtual table module.
func register_fs_module(tls *crt.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_fs.c:875:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// var db uintptr at bp, 8

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+2452 /* "DB" */)
		return 1
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), bp /* &db */) != 0 {
		return 1
	}
	sqlite3.Xsqlite3_create_module(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), ts+36013 /* "fs" */, uintptr(unsafe.Pointer(&fsModule)), interp)
	sqlite3.Xsqlite3_create_module(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), ts+4961 /* "fsdir" */, uintptr(unsafe.Pointer(&fsdirModule)), uintptr(0))
	sqlite3.Xsqlite3_create_module(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), ts+36016 /* "fstree" */, uintptr(unsafe.Pointer(&fstreeModule)), uintptr(0))
	return 0
}

// Register commands with the TCL interpreter.
func Sqlitetestfs_Init(tls *crt.TLS, interp uintptr) int32 { /* test_fs.c:901:5: */
	var i int32
	for i = 0; uint64(i) < (uint64(unsafe.Sizeof(aObjCmd6)) / uint64(unsafe.Sizeof(struct {
		FzName      uintptr
		FxProc      uintptr
		FclientData uintptr
	}{}))); i++ {
		tcl.XTcl_CreateObjCommand(tls, interp, aObjCmd6[i].FzName,
			aObjCmd6[i].FxProc, aObjCmd6[i].FclientData, uintptr(0))
	}
	return 0
}

var aObjCmd6 = [1]struct {
	FzName      uintptr
	FxProc      uintptr
	FclientData uintptr
}{
	{FzName: ts + 36023 /* "register_fs_modu..." */, FxProc: 0, FclientData: uintptr(0)},
} /* test_fs.c:907:5 */

// Some versions of <linux/posix_types.h> define this macros.
// It's easier to assume 8-bit bytes than to get CHAR_BIT.

// fd_set for select and pselect.
type fd_set2 = struct{ F__fds_bits [16]int64 } /* select.h:70:5 */

// Allocate nByte bytes of space using sqlite3_malloc(). If the
// allocation fails, call sqlite3_result_error_nomem() to notify
// the database handle that malloc() has failed.
func testContextMalloc(tls *crt.TLS, context uintptr, nByte int32) uintptr { /* test_func.c:33:13: */
	var z uintptr = sqlite3.Xsqlite3_malloc(tls, nByte)
	if !(z != 0) && (nByte > 0) {
		sqlite3.Xsqlite3_result_error_nomem(tls, context)
	}
	return z
}

// This function generates a string of random characters.  Used for
// generating test data.
func randStr(tls *crt.TLS, context uintptr, argc int32, argv uintptr) { /* test_func.c:45:13: */
	bp := tls.Alloc(1004)
	defer tls.Free(1004)

	var iMin int32
	var iMax int32
	var n int32
	// var r int32 at bp, 4

	var i int32
	// var zBuf [1000]uint8 at bp+4, 1000

	// It used to be possible to call randstr() with any number of arguments,
	// but now it is registered with SQLite as requiring exactly 2.

	iMin = sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)))
	if iMin < 0 {
		iMin = 0
	}
	if uint64(iMin) >= uint64(unsafe.Sizeof([1000]uint8{})) {
		iMin = (int32(uint64(unsafe.Sizeof([1000]uint8{})) - uint64(1)))
	}
	iMax = sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)))
	if iMax < iMin {
		iMax = iMin
	}
	if uint64(iMax) >= uint64(unsafe.Sizeof([1000]uint8{})) {
		iMax = (int32(uint64(unsafe.Sizeof([1000]uint8{})) - uint64(1)))
	}
	n = iMin
	if iMax > iMin {
		sqlite3.Xsqlite3_randomness(tls, int32(unsafe.Sizeof(int32(0))), bp /* &r */)
		*(*int32)(unsafe.Pointer(bp /* r */)) &= 0x7fffffff
		n = n + (*(*int32)(unsafe.Pointer(bp /* r */)) % ((iMax + 1) - iMin))
	}

	sqlite3.Xsqlite3_randomness(tls, n, bp+4 /* &zBuf[0] */)
	for i = 0; i < n; i++ {
		*(*uint8)(unsafe.Pointer(bp + 4 /* &zBuf[0] */ + uintptr(i))) = zSrc[(uint64(*(*uint8)(unsafe.Pointer(bp + 4 /* &zBuf[0] */ + uintptr(i)))) % (uint64(unsafe.Sizeof(zSrc)) - uint64(1)))]
	}
	*(*uint8)(unsafe.Pointer(bp + 4 /* &zBuf[0] */ + uintptr(n))) = uint8(0)
	sqlite3.Xsqlite3_result_text(tls, context, bp+4 /* zBuf */, n, crt.UintptrFromInt32(-1))
}

var zSrc = *(*[79]uint8)(unsafe.Pointer(ts + 36042 /* "abcdefghijklmnop..." */)) /* test_func.c:46:30 */

// The following two SQL functions are used to test returning a text
// result with a destructor. Function 'test_destructor' takes one argument
// and returns the same argument interpreted as TEXT. A destructor is
// passed with the sqlite3_result_text() call.
//
// SQL function 'test_destructor_count' returns the number of outstanding
// allocations made by 'test_destructor';
//
// WARNING: Not threadsafe.
var test_destructor_count_var int32 = 0 /* test_func.c:91:12 */
func destructor(tls *crt.TLS, p uintptr) { /* test_func.c:92:13: */
	var zVal uintptr = p

	zVal--
	sqlite3.Xsqlite3_free(tls, zVal)
	test_destructor_count_var--
}
func test_destructor(tls *crt.TLS, pCtx uintptr, nArg int32, argv uintptr) { /* test_func.c:99:13: */
	var zVal uintptr
	var len int32

	test_destructor_count_var++

	if sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8))) == 5 {
		return
	}
	len = sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)))
	zVal = testContextMalloc(tls, pCtx, (len + 3))
	if !(zVal != 0) {
		return
	}
	*(*int8)(unsafe.Pointer(zVal + uintptr((len + 1)))) = int8(0)
	*(*int8)(unsafe.Pointer(zVal + uintptr((len + 2)))) = int8(0)
	zVal++
	crt.Xmemcpy(tls, zVal, sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8))), uint64(len))
	sqlite3.Xsqlite3_result_text(tls, pCtx, zVal, -1, *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, uintptr) }{destructor})))
}
func test_destructor_count(tls *crt.TLS, pCtx uintptr, nArg int32, argv uintptr) { /* test_func.c:145:13: */
	sqlite3.Xsqlite3_result_int(tls, pCtx, test_destructor_count_var)
}
func test_agg_errmsg16_step(tls *crt.TLS, a uintptr, b int32, c uintptr) { /* test_func.c:165:13: */
}
func test_agg_errmsg16_final(tls *crt.TLS, ctx uintptr) { /* test_func.c:167:13: */
}

// Routines for testing the sqlite3_get_auxdata() and sqlite3_set_auxdata()
// interface.
//
// The test_auxdata() SQL function attempts to register each of its arguments
// as auxiliary data.  If there are no prior registrations of aux data for
// that argument (meaning the argument is not a constant or this is its first
// call) then the result for that argument is 0.  If there is a prior
// registration, the result for that argument is 1.  The overall result
// is the individual argument results separated by spaces.
func free_test_auxdata(tls *crt.TLS, p uintptr) { /* test_func.c:188:13: */
	sqlite3.Xsqlite3_free(tls, p)
}
func test_auxdata(tls *crt.TLS, pCtx uintptr, nArg int32, argv uintptr) { /* test_func.c:189:13: */
	var i int32
	var zRet uintptr = testContextMalloc(tls, pCtx, (nArg * 2))
	if !(zRet != 0) {
		return
	}
	crt.Xmemset(tls, zRet, 0, (uint64(nArg * 2)))
	for i = 0; i < nArg; i++ {
		var z uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8)))
		if z != 0 {
			var n int32
			var zAux uintptr = sqlite3.Xsqlite3_get_auxdata(tls, pCtx, i)
			if zAux != 0 {
				*(*int8)(unsafe.Pointer(zRet + uintptr((i * 2)))) = int8('1')
			} else {
				*(*int8)(unsafe.Pointer(zRet + uintptr((i * 2)))) = int8('0')
			}
			n = (int32(crt.Xstrlen(tls, z)) + 1)
			zAux = testContextMalloc(tls, pCtx, n)
			if zAux != 0 {
				crt.Xmemcpy(tls, zAux, z, uint64(n))
				sqlite3.Xsqlite3_set_auxdata(tls, pCtx, i, zAux, *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, uintptr) }{free_test_auxdata})))
			}
			*(*int8)(unsafe.Pointer(zRet + uintptr(((i * 2) + 1)))) = int8(' ')
		}
	}
	sqlite3.Xsqlite3_result_text(tls, pCtx, zRet, ((2 * nArg) - 1), *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, uintptr) }{free_test_auxdata})))
}

// A function to test error reporting from user functions. This function
// returns a copy of its first argument as the error message.  If the
// second argument exists, it becomes the error code.
func test_error(tls *crt.TLS, pCtx uintptr, nArg int32, argv uintptr) { /* test_func.c:226:13: */
	sqlite3.Xsqlite3_result_error(tls, pCtx, sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8))), -1)
	if nArg == 2 {
		sqlite3.Xsqlite3_result_error_code(tls, pCtx, sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8))))
	}
}

// Implementation of the counter(X) function.  If X is an integer
// constant, then the first invocation will return X.  The second X+1.
// and so forth.  Can be used (for example) to provide a sequence number
// in a result set.
func counterFunc(tls *crt.TLS, pCtx uintptr, nArg int32, argv uintptr) { /* test_func.c:243:13: */
	var pCounter uintptr = sqlite3.Xsqlite3_get_auxdata(tls, pCtx, 0)
	if pCounter == uintptr(0) {
		pCounter = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(int32(0))))
		if pCounter == uintptr(0) {
			sqlite3.Xsqlite3_result_error_nomem(tls, pCtx)
			return
		}
		*(*int32)(unsafe.Pointer(pCounter)) = sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)))
		sqlite3.Xsqlite3_set_auxdata(tls, pCtx, 0, pCounter, *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, uintptr) }{sqlite3.Xsqlite3_free})))
	} else {
		*(*int32)(unsafe.Pointer(pCounter))++
	}
	sqlite3.Xsqlite3_result_int(tls, pCtx, *(*int32)(unsafe.Pointer(pCounter)))
}

// This function takes two arguments.  It performance UTF-8/16 type
// conversions on the first argument then returns a copy of the second
// argument.
//
// This function is used in cases such as the following:
//
//      SELECT test_isolation(x,x) FROM t1;
//
// We want to verify that the type conversions that occur on the
// first argument do not invalidate the second argument.
func test_isolation(tls *crt.TLS, pCtx uintptr, nArg int32, argv uintptr) { /* test_func.c:276:13: */
	sqlite3.Xsqlite3_result_value(tls, pCtx, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)))
}

// Invoke an SQL statement recursively.  The function result is the
// first column of the first row of the result set.
func test_eval(tls *crt.TLS, pCtx uintptr, nArg int32, argv uintptr) { /* test_func.c:294:13: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	// var pStmt uintptr at bp+8, 8

	var rc int32
	var db uintptr = sqlite3.Xsqlite3_context_db_handle(tls, pCtx)
	var zSql uintptr

	zSql = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)))
	rc = sqlite3.Xsqlite3_prepare_v2(tls, db, zSql, -1, bp+8 /* &pStmt */, uintptr(0))
	if rc == 0 {
		rc = sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 8 /* pStmt */)))
		if rc == 100 {
			sqlite3.Xsqlite3_result_value(tls, pCtx, sqlite3.Xsqlite3_column_value(tls, *(*uintptr)(unsafe.Pointer(bp + 8 /* pStmt */)), 0))
		}
		rc = sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 8 /* pStmt */)))
	}
	if rc != 0 {
		var zErr uintptr

		zErr = sqlite3.Xsqlite3_mprintf(tls, ts+36121 /* "sqlite3_prepare_..." */, crt.VaList(bp, sqlite3.Xsqlite3_errmsg(tls, db)))
		sqlite3.Xsqlite3_result_text(tls, pCtx, zErr, -1, *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, uintptr) }{sqlite3.Xsqlite3_free})))
		sqlite3.Xsqlite3_result_error_code(tls, pCtx, rc)
	}
}

// convert one character from hex to binary
func testHexChar(tls *crt.TLS, c int8) int32 { /* test_func.c:326:12: */
	if (int32(c) >= '0') && (int32(c) <= '9') {
		return (int32(c) - '0')
	} else if (int32(c) >= 'a') && (int32(c) <= 'f') {
		return ((int32(c) - 'a') + 10)
	} else if (int32(c) >= 'A') && (int32(c) <= 'F') {
		return ((int32(c) - 'A') + 10)
	}
	return 0
}

// Convert hex to binary.
func testHexToBin(tls *crt.TLS, zIn uintptr, zOut uintptr) { /* test_func.c:340:13: */
	for (*(*int8)(unsafe.Pointer(zIn + uintptr(0))) != 0) && (*(*int8)(unsafe.Pointer(zIn + uintptr(1))) != 0) {
		*(*int8)(unsafe.Pointer(crt.PostIncUintptr(&zOut, 1))) = (int8((testHexChar(tls, *(*int8)(unsafe.Pointer(zIn + uintptr(0)))) << 4) + testHexChar(tls, *(*int8)(unsafe.Pointer(zIn + uintptr(1))))))
		zIn += uintptr(2)
	}
}

//      hex_to_utf16be(HEX)
//
// Convert the input string from HEX into binary.  Then return the
// result using sqlite3_result_text16le().

//      hex_to_utf8(HEX)
//
// Convert the input string from HEX into binary.  Then return the
// result using sqlite3_result_text16le().
func testHexToUtf8(tls *crt.TLS, pCtx uintptr, nArg int32, argv uintptr) { /* test_func.c:381:13: */
	var n int32
	var zIn uintptr
	var zOut uintptr

	n = sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)))
	zIn = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)))
	zOut = sqlite3.Xsqlite3_malloc(tls, (n / 2))
	if zOut == uintptr(0) {
		sqlite3.Xsqlite3_result_error_nomem(tls, pCtx)
	} else {
		testHexToBin(tls, zIn, zOut)
		sqlite3.Xsqlite3_result_text(tls, pCtx, zOut, (n / 2), *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, uintptr) }{sqlite3.Xsqlite3_free})))
	}
}

//      hex_to_utf16le(HEX)
//
// Convert the input string from HEX into binary.  Then return the
// result using sqlite3_result_text16le().

// SQL function:   real2hex(X)
//
// If argument X is a real number, then convert it into a string which is
// the big-endian hexadecimal representation of the ieee754 encoding of
// that number.  If X is not a real number, return NULL.
func real2hex(tls *crt.TLS, context uintptr, argc int32, argv uintptr) { /* test_func.c:436:13: */
	bp := tls.Alloc(28)
	defer tls.Free(28)

	// var v struct {Fi sqlite3_uint64;} at bp, 8

	// var zOut [20]int8 at bp+8, 20

	var i int32
	var bigEndian int32
	*(*sqlite3_uint64)(unsafe.Pointer(bp /* &v */)) = uint64(1)
	bigEndian = (crt.Bool32(int32(*(*uint8)(unsafe.Pointer((bp /* &v */ /* &.x */) + uintptr(0)))) == 0))
	*(*float64)(unsafe.Pointer(bp /* &v */)) = sqlite3.Xsqlite3_value_double(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)))
	for i = 0; i < 8; i++ {
		if bigEndian != 0 {
			*(*int8)(unsafe.Pointer(bp + 8 /* &zOut[0] */ + uintptr((i * 2)))) = *(*int8)(unsafe.Pointer(ts + 36152 /* "0123456789abcdef" */ + uintptr((int32(*(*uint8)(unsafe.Pointer((bp /* &v */ /* &.x */) + uintptr(i)))) >> 4))))
			*(*int8)(unsafe.Pointer(bp + 8 /* &zOut[0] */ + uintptr(((i * 2) + 1)))) = *(*int8)(unsafe.Pointer(ts + 36152 /* "0123456789abcdef" */ + uintptr((int32(*(*uint8)(unsafe.Pointer((bp /* &v */ /* &.x */) + uintptr(i)))) & 0xf))))
		} else {
			*(*int8)(unsafe.Pointer(bp + 8 /* &zOut[0] */ + uintptr((14 - (i * 2))))) = *(*int8)(unsafe.Pointer(ts + 36152 /* "0123456789abcdef" */ + uintptr((int32(*(*uint8)(unsafe.Pointer((bp /* &v */ /* &.x */) + uintptr(i)))) >> 4))))
			*(*int8)(unsafe.Pointer(bp + 8 /* &zOut[0] */ + uintptr(((14 - (i * 2)) + 1)))) = *(*int8)(unsafe.Pointer(ts + 36152 /* "0123456789abcdef" */ + uintptr((int32(*(*uint8)(unsafe.Pointer((bp /* &v */ /* &.x */) + uintptr(i)))) & 0xf))))
		}
	}
	*(*int8)(unsafe.Pointer(bp + 8 /* &zOut[0] */ + uintptr(16))) = int8(0)
	sqlite3.Xsqlite3_result_text(tls, context, bp+8 /* &zOut[0] */, -1, crt.UintptrFromInt32(-1))
}

//     test_extract(record, field)
//
// This function implements an SQL user-function that accepts a blob
// containing a formatted database record as the first argument. The
// second argument is the index of the field within that record to
// extract and return.
func test_extract(tls *crt.TLS, context uintptr, argc int32, argv uintptr) { /* test_func.c:473:13: */
	bp := tls.Alloc(72)
	defer tls.Free(72)

	var db uintptr = sqlite3.Xsqlite3_context_db_handle(tls, context)
	var pRec uintptr
	var pEndHdr uintptr // Points to one byte past record header
	var pHdr uintptr    // Current point in record header
	var pBody uintptr   // Current point in record data
	// var nHdr u64 at bp, 8
	// Bytes in record header
	var iIdx int32         // Required field
	var iCurrent int32 = 0 // Current field

	pRec = sqlite3.Xsqlite3_value_blob(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)))
	iIdx = sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)))

	pHdr = (pRec + uintptr(sqlite3.Xsqlite3GetVarint(tls, pRec, bp /* &nHdr */)))
	pBody = crt.AssignUintptr(&pEndHdr, (pRec + uintptr(*(*u64)(unsafe.Pointer(bp /* nHdr */)))))

	for iCurrent = 0; (pHdr < pEndHdr) && (iCurrent <= iIdx); iCurrent++ {
		// var iSerialType u64 at bp+64, 8

		// var mem Mem at bp+8, 56

		crt.Xmemset(tls, bp+8 /* &mem */, 0, uint64(unsafe.Sizeof(Mem{})))
		(*Mem)(unsafe.Pointer(bp + 8 /* &mem */)).Fdb = db
		(*Mem)(unsafe.Pointer(bp + 8 /* &mem */)).Fenc = (*sqlite31)(unsafe.Pointer(db)).Fenc
		pHdr += uintptr(sqlite3.Xsqlite3GetVarint(tls, pHdr, bp+64 /* &iSerialType */))
		pBody += uintptr(sqlite3.Xsqlite3VdbeSerialGet(tls, pBody, u32(*(*u64)(unsafe.Pointer(bp + 64 /* iSerialType */))), bp+8 /* &mem */))

		if iCurrent == iIdx {
			sqlite3.Xsqlite3_result_value(tls, context, bp+8 /* &mem */)
		}

		if (*Mem)(unsafe.Pointer(bp+8 /* &mem */)).FszMalloc != 0 {
			sqlite3.Xsqlite3DbFree(tls, db, (*Mem)(unsafe.Pointer(bp+8 /* &mem */)).FzMalloc)
		}
	}
}

//      test_decode(record)
//
// This function implements an SQL user-function that accepts a blob
// containing a formatted database record as its only argument. It returns
// a tcl list (type SQLITE_TEXT) containing each of the values stored
// in the record.
func test_decode(tls *crt.TLS, context uintptr, argc int32, argv uintptr) { /* test_func.c:520:13: */
	bp := tls.Alloc(123)
	defer tls.Free(123)

	var db uintptr = sqlite3.Xsqlite3_context_db_handle(tls, context)
	var pRec uintptr
	var pEndHdr uintptr // Points to one byte past record header
	var pHdr uintptr    // Current point in record header
	var pBody uintptr   // Current point in record data
	// var nHdr u64 at bp+32, 8
	// Bytes in record header
	var pRet uintptr // Return value

	pRet = tcl.XTcl_NewObj(tls)
	(*Tcl_Obj)(unsafe.Pointer(pRet)).FrefCount++

	pRec = sqlite3.Xsqlite3_value_blob(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)))

	pHdr = (pRec + uintptr(sqlite3.Xsqlite3GetVarint(tls, pRec, bp+32 /* &nHdr */)))
	pBody = crt.AssignUintptr(&pEndHdr, (pRec + uintptr(*(*u64)(unsafe.Pointer(bp + 32 /* nHdr */)))))
	for pHdr < pEndHdr {
		var pVal uintptr = uintptr(0)
		// var iSerialType u64 at bp+96, 8

		// var mem Mem at bp+40, 56

		crt.Xmemset(tls, bp+40 /* &mem */, 0, uint64(unsafe.Sizeof(Mem{})))
		(*Mem)(unsafe.Pointer(bp + 40 /* &mem */)).Fdb = db
		(*Mem)(unsafe.Pointer(bp + 40 /* &mem */)).Fenc = (*sqlite31)(unsafe.Pointer(db)).Fenc
		pHdr += uintptr(sqlite3.Xsqlite3GetVarint(tls, pHdr, bp+96 /* &iSerialType */))
		pBody += uintptr(sqlite3.Xsqlite3VdbeSerialGet(tls, pBody, u32(*(*u64)(unsafe.Pointer(bp + 96 /* iSerialType */))), bp+40 /* &mem */))

		switch sqlite3.Xsqlite3_value_type(tls, bp+40 /* &mem */) {
		case 3:
			pVal = tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3_value_text(tls, bp+40 /* &mem */), -1)
			break

		case 4:
			{
				*(*[16]int8)(unsafe.Pointer(bp + 107 /* hexdigit */)) = [16]int8{
					int8('0'), int8('1'), int8('2'), int8('3'), int8('4'), int8('5'), int8('6'), int8('7'),
					int8('8'), int8('9'), int8('a'), int8('b'), int8('c'), int8('d'), int8('e'), int8('f'),
				}
				var n int32 = sqlite3.Xsqlite3_value_bytes(tls, bp+40 /* &mem */)
				var z uintptr = sqlite3.Xsqlite3_value_blob(tls, bp+40 /* &mem */)
				var i int32
				pVal = tcl.XTcl_NewStringObj(tls, ts+36169 /* "x'" */, -1)
				for i = 0; i < n; i++ {
					// var hex [3]int8 at bp+104, 3

					*(*int8)(unsafe.Pointer(bp + 104 /* &hex[0] */ + uintptr(0))) = *(*int8)(unsafe.Pointer(bp + 107 /* &hexdigit[0] */ + uintptr(((int32(*(*u8)(unsafe.Pointer(z + uintptr(i)))) >> 4) & 0x0F))))
					*(*int8)(unsafe.Pointer(bp + 104 /* &hex[0] */ + uintptr(1))) = *(*int8)(unsafe.Pointer(bp + 107 /* &hexdigit[0] */ + uintptr((int32(*(*u8)(unsafe.Pointer(z + uintptr(i)))) & 0x0F))))
					*(*int8)(unsafe.Pointer(bp + 104 /* &hex[0] */ + uintptr(2))) = int8(0)
					tcl.XTcl_AppendStringsToObj(tls, pVal, crt.VaList(bp, bp+104 /* &hex[0] */, 0))
				}
				tcl.XTcl_AppendStringsToObj(tls, pVal, crt.VaList(bp+16, ts+5272 /* "'" */, 0))
				break
			}

		case 2:
			pVal = tcl.XTcl_NewDoubleObj(tls, sqlite3.Xsqlite3_value_double(tls, bp+40 /* &mem */))
			break

		case 1:
			pVal = tcl.XTcl_NewWideIntObj(tls, int64(sqlite3.Xsqlite3_value_int64(tls, bp+40 /* &mem */)))
			break

		case 5:
			pVal = tcl.XTcl_NewStringObj(tls, ts+5494 /* "NULL" */, -1)
			break

		default:
		}

		tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pRet, pVal)

		if (*Mem)(unsafe.Pointer(bp+40 /* &mem */)).FszMalloc != 0 {
			sqlite3.Xsqlite3DbFree(tls, db, (*Mem)(unsafe.Pointer(bp+40 /* &mem */)).FzMalloc)
		}
	}

	sqlite3.Xsqlite3_result_text(tls, context, tcl.XTcl_GetString(tls, pRet), -1, crt.UintptrFromInt32(-1))
	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = pRet
		if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
}

//       test_zeroblob(N)
//
// The implementation of scalar SQL function "test_zeroblob()". This is
// similar to the built-in zeroblob() function, except that it does not
// check that the integer parameter is within range before passing it
// to sqlite3_result_zeroblob().
func test_zeroblob(tls *crt.TLS, context uintptr, argc int32, argv uintptr) { /* test_func.c:612:13: */
	var nZero int32 = sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)))
	sqlite3.Xsqlite3_result_zeroblob(tls, context, nZero)
}

// test_getsubtype(V)
//
// Return the subtype for value V.
func test_getsubtype(tls *crt.TLS, context uintptr, argc int32, argv uintptr) { /* test_func.c:625:13: */
	sqlite3.Xsqlite3_result_int(tls, context, int32(sqlite3.Xsqlite3_value_subtype(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)))))
}

// test_frombind(A,B,C,...)
//
// Return an integer bitmask that has a bit set for every argument
// (up to the first 63 arguments) that originates from a bind a parameter.
func test_frombind(tls *crt.TLS, context uintptr, argc int32, argv uintptr) { /* test_func.c:638:13: */
	var m sqlite3_uint64 = uint64(0)
	var i int32
	for i = 0; (i < argc) && (i < 63); i++ {
		if sqlite3.Xsqlite3_value_frombind(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8))) != 0 {
			m = m | (sqlite3_uint64((uint64(1))) << i)
		}
	}
	sqlite3.Xsqlite3_result_int64(tls, context, sqlite3_int64(m))
}

// test_setsubtype(V, T)
//
// Return the value V with its subtype changed to T
func test_setsubtype(tls *crt.TLS, context uintptr, argc int32, argv uintptr) { /* test_func.c:655:13: */
	sqlite3.Xsqlite3_result_value(tls, context, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)))
	sqlite3.Xsqlite3_result_subtype(tls, context, uint32(sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)))))
}

func registerTestFunctions(tls *crt.TLS, db uintptr, pzErrMsg uintptr, pThunk uintptr) int32 { /* test_func.c:664:12: */
	var i int32

	for i = 0; uint64(i) < (uint64(unsafe.Sizeof(aFuncs)) / uint64(unsafe.Sizeof(struct {
		FzName    uintptr
		FnArg     int8
		FeTextRep uint32
		FxFunc    uintptr
	}{}))); i++ {
		sqlite3.Xsqlite3_create_function(tls, db, aFuncs[i].FzName, int32(aFuncs[i].FnArg),
			int32(aFuncs[i].FeTextRep), uintptr(0), aFuncs[i].FxFunc, uintptr(0), uintptr(0))
	}

	sqlite3.Xsqlite3_create_function(tls, db, ts+36172 /* "test_agg_errmsg1..." */, 0, 5, uintptr(0), uintptr(0),
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*crt.TLS, uintptr, int32, uintptr)
		}{test_agg_errmsg16_step})), *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, uintptr) }{test_agg_errmsg16_final})))

	return 0
}

var aFuncs = [17]struct {
	FzName    uintptr
	FnArg     int8
	FeTextRep uint32
	FxFunc    uintptr
}{
	{FzName: ts + 36190 /* "randstr" */, FnArg: int8(2), FeTextRep: uint32(1), FxFunc: 0},
	{FzName: ts + 36198 /* "test_destructor" */, FnArg: int8(1), FeTextRep: uint32(1), FxFunc: 0},
	{FzName: ts + 36214 /* "hex_to_utf8" */, FnArg: int8(1), FeTextRep: uint32(1), FxFunc: 0},
	{FzName: ts + 36226 /* "test_destructor_..." */, FnArg: int8(0), FeTextRep: uint32(1), FxFunc: 0},
	{FzName: ts + 36248 /* "test_auxdata" */, FnArg: int8(-1), FeTextRep: uint32(1), FxFunc: 0},
	{FzName: ts + 36261 /* "test_error" */, FnArg: int8(1), FeTextRep: uint32(1), FxFunc: 0},
	{FzName: ts + 36261 /* "test_error" */, FnArg: int8(2), FeTextRep: uint32(1), FxFunc: 0},
	{FzName: ts + 36272 /* "test_eval" */, FnArg: int8(1), FeTextRep: uint32(1), FxFunc: 0},
	{FzName: ts + 36282 /* "test_isolation" */, FnArg: int8(2), FeTextRep: uint32(1), FxFunc: 0},
	{FzName: ts + 36297 /* "test_counter" */, FnArg: int8(1), FeTextRep: uint32(1), FxFunc: 0},
	{FzName: ts + 36310 /* "real2hex" */, FnArg: int8(1), FeTextRep: uint32(1), FxFunc: 0},
	{FzName: ts + 36319 /* "test_decode" */, FnArg: int8(1), FeTextRep: uint32(1), FxFunc: 0},
	{FzName: ts + 36331 /* "test_extract" */, FnArg: int8(2), FeTextRep: uint32(1), FxFunc: 0},
	{FzName: ts + 36344 /* "test_zeroblob" */, FnArg: int8(1), FeTextRep: (uint32(1 | 0x000000800)), FxFunc: 0},
	{FzName: ts + 36358 /* "test_getsubtype" */, FnArg: int8(1), FeTextRep: uint32(1), FxFunc: 0},
	{FzName: ts + 36374 /* "test_setsubtype" */, FnArg: int8(2), FeTextRep: uint32(1), FxFunc: 0},
	{FzName: ts + 36390 /* "test_frombind" */, FnArg: int8(-1), FeTextRep: uint32(1), FxFunc: 0},
} /* test_func.c:674:5 */

// TCLCMD:  autoinstall_test_functions
//
// Invoke this TCL command to use sqlite3_auto_extension() to cause
// the standard set of test functions to be loaded into each new
// database connection.
func autoinstall_test_funcs(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_func.c:718:26: */
	var rc int32 = sqlite3.Xsqlite3_auto_extension(tls, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, uintptr) int32
	}{registerTestFunctions})))
	if rc == 0 {
		rc = sqlite3.Xsqlite3_auto_extension(tls, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*crt.TLS, uintptr, uintptr, uintptr) int32
		}{Md5_Register})))
	}
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, rc))
	return 0
}

// A bogus step function and finalizer function.
func tStep(tls *crt.TLS, a uintptr, b int32, c uintptr) { /* test_func.c:736:13: */
}
func tFinal(tls *crt.TLS, a uintptr) { /* test_func.c:737:13: */
}

// tclcmd:  abuse_create_function
//
// Make various calls to sqlite3_create_function that do not have valid
// parameters.  Verify that the error condition is detected and reported.
func abuse_create_function(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_func.c:746:26: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	// var db uintptr at bp+16, 8

	var rc int32
	var mxArg int32

	if !(getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), bp+16 /* &db */) != 0) {
		goto __1
	}
	return 1
__1:
	;

	rc = sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* db */)), ts+36404 /* "tx" */, 1, 1, uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, int32, uintptr)
	}{tStep})), *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, int32, uintptr)
	}{tStep})), *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, uintptr) }{tFinal})))
	if !(rc != 21) {
		goto __2
	}
	goto abuse_err
__2:
	;

	rc = sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* db */)), ts+36404 /* "tx" */, 1, 1, uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, int32, uintptr)
	}{tStep})), *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, int32, uintptr)
	}{tStep})), uintptr(0))
	if !(rc != 21) {
		goto __3
	}
	goto abuse_err
__3:
	;

	rc = sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* db */)), ts+36404 /* "tx" */, 1, 1, uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, int32, uintptr)
	}{tStep})), uintptr(0), *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, uintptr) }{tFinal})))
	if !(rc != 21) {
		goto __4
	}
	goto abuse_err
__4:
	;

	rc = sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* db */)), ts+36404 /* "tx" */, 1, 1, uintptr(0), uintptr(0), uintptr(0), *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, uintptr) }{tFinal})))
	if !(rc != 21) {
		goto __5
	}
	goto abuse_err
__5:
	;

	rc = sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* db */)), ts+36404 /* "tx" */, 1, 1, uintptr(0), uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, int32, uintptr)
	}{tStep})), uintptr(0))
	if !(rc != 21) {
		goto __6
	}
	goto abuse_err
__6:
	;

	rc = sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* db */)), ts+36404 /* "tx" */, -2, 1, uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, int32, uintptr)
	}{tStep})), uintptr(0), uintptr(0))
	if !(rc != 21) {
		goto __7
	}
	goto abuse_err
__7:
	;

	rc = sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* db */)), ts+36404 /* "tx" */, 128, 1, uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, int32, uintptr)
	}{tStep})), uintptr(0), uintptr(0))
	if !(rc != 21) {
		goto __8
	}
	goto abuse_err
__8:
	;

	rc = sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* db */)),

		ts+36407, /* "funcxx_123456789..." */
		1, 1, uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
			f func(*crt.TLS, uintptr, int32, uintptr)
		}{tStep})), uintptr(0), uintptr(0))
	if !(rc != 21) {
		goto __9
	}
	goto abuse_err
__9:
	;

	// This last function registration should actually work.  Generate
	// a no-op function (that always returns NULL) and which has the
	// maximum-length function name and the maximum number of parameters.
	sqlite3.Xsqlite3_limit(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* db */)), 6, 10000)
	mxArg = sqlite3.Xsqlite3_limit(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* db */)), 6, -1)
	rc = sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* db */)),

		ts+36664, /* "nullx_123456789_..." */
		mxArg, 1, uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
			f func(*crt.TLS, uintptr, int32, uintptr)
		}{tStep})), uintptr(0), uintptr(0))
	if !(rc != 0) {
		goto __10
	}
	goto abuse_err
__10:
	;

	return 0

abuse_err:
	tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+36920, /* "sqlite3_create_f..." */
		uintptr(0)))
	return 1
}

// SQLite user defined function to use with matchinfo() to calculate the
// relevancy of an FTS match. The value returned is the relevancy score
// (a real value greater than or equal to zero). A larger value indicates
// a more relevant document.
//
// The overall relevancy returned is the sum of the relevancies of each
// column value in the FTS table. The relevancy of a column value is the
// sum of the following for each reportable phrase in the FTS query:
//
//   (<hit count> / <global hit count>) * <column weight>
//
// where <hit count> is the number of instances of the phrase in the
// column value of the current row and <global hit count> is the number
// of instances of the phrase in the same column of all rows in the FTS
// table. The <column weight> is a weighting factor assigned to each
// column by the caller (see below).
//
// The first argument to this function must be the return value of the FTS
// matchinfo() function. Following this must be one argument for each column
// of the FTS table containing a numeric weight factor for the corresponding
// column. Example:
//
//     CREATE VIRTUAL TABLE documents USING fts3(title, content)
//
// The following query returns the docids of documents that match the full-text
// query <query> sorted from most to least relevant. When calculating
// relevance, query term instances in the 'title' column are given twice the
// weighting of those in the 'content' column.
//
//     SELECT docid FROM documents
//     WHERE documents MATCH <query>
//     ORDER BY rank(matchinfo(documents), 1.0, 0.5) DESC
func rankfunc(tls *crt.TLS, pCtx uintptr, nVal int32, apVal uintptr) { /* test_func.c:847:13: */
	var aMatchinfo uintptr // Return value of matchinfo()
	var nMatchinfo int32   // Number of elements in aMatchinfo[]
	var nCol int32         // Number of columns in the table
	var nPhrase int32      // Number of phrases in the query
	var iPhrase int32      // Current phrase
	var score float64
	var nHitCount int32
	var nGlobalHitCount int32
	var weight float64
	var iCol int32 // Current column

	// Now iterate through each column in the users query. For each column,
	// increment the relevancy score by:
	//
	//   (<hit count> / <global hit count>) * <column weight>
	//
	// aPhraseinfo[] points to the start of the data for phrase iPhrase. So
	// the hit count and global hit counts for each column are found in
	// aPhraseinfo[iCol*3] and aPhraseinfo[iCol*3+1], respectively.
	var aPhraseinfo uintptr
	nCol = 0
	nPhrase = 0
	score = 0.0 // Value to return

	// Check that the number of arguments passed to this function is correct.
	// If not, jump to wrong_number_args. Set aMatchinfo to point to the array
	// of unsigned integer values returned by FTS function matchinfo. Set
	// nPhrase to contain the number of reportable phrases in the users full-text
	// query, and nCol to the number of columns in the table. Then check that the
	// size of the matchinfo blob is as expected. Return an error if it is not.
	if !(nVal < 1) {
		goto __1
	}
	goto wrong_number_args
__1:
	;
	aMatchinfo = sqlite3.Xsqlite3_value_blob(tls, *(*uintptr)(unsafe.Pointer(apVal + uintptr(0)*8)))
	nMatchinfo = (int32(uint64(sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(apVal + uintptr(0)*8)))) / uint64(unsafe.Sizeof(int32(0)))))
	if !(nMatchinfo >= 2) {
		goto __2
	}
	nPhrase = *(*int32)(unsafe.Pointer(aMatchinfo + uintptr(0)*4))
	nCol = *(*int32)(unsafe.Pointer(aMatchinfo + uintptr(1)*4))
__2:
	;
	if !(nMatchinfo != (2 + ((3 * nCol) * nPhrase))) {
		goto __3
	}
	sqlite3.Xsqlite3_result_error(tls, pCtx,
		ts+36963 /* "invalid matchinf..." */, -1)
	return
__3:
	;
	if !(nVal != (1 + nCol)) {
		goto __4
	}
	goto wrong_number_args
__4:
	;

	// Iterate through each phrase in the users query.
	iPhrase = 0
__5:
	if !(iPhrase < nPhrase) {
		goto __7
	} // Current column

	// Now iterate through each column in the users query. For each column,
	// increment the relevancy score by:
	//
	//   (<hit count> / <global hit count>) * <column weight>
	//
	// aPhraseinfo[] points to the start of the data for phrase iPhrase. So
	// the hit count and global hit counts for each column are found in
	// aPhraseinfo[iCol*3] and aPhraseinfo[iCol*3+1], respectively.
	aPhraseinfo = (aMatchinfo + uintptr((2+((iPhrase*nCol)*3)))*4)
	iCol = 0
__8:
	if !(iCol < nCol) {
		goto __10
	}
	nHitCount = *(*int32)(unsafe.Pointer(aPhraseinfo + uintptr((3*iCol))*4))
	nGlobalHitCount = *(*int32)(unsafe.Pointer(aPhraseinfo + uintptr(((3*iCol)+1))*4))
	weight = sqlite3.Xsqlite3_value_double(tls, *(*uintptr)(unsafe.Pointer(apVal + uintptr((iCol+1))*8)))
	if !(nHitCount > 0) {
		goto __11
	}
	score = score + ((float64(nHitCount) / float64(nGlobalHitCount)) * weight)
__11:
	;
	goto __9
__9:
	iCol++
	goto __8
	goto __10
__10:
	;
	goto __6
__6:
	iPhrase++
	goto __5
	goto __7
__7:
	;

	sqlite3.Xsqlite3_result_double(tls, pCtx, score)
	return

	// Jump here if the wrong number of arguments are passed to this function
wrong_number_args:
	sqlite3.Xsqlite3_result_error(tls, pCtx, ts+37012 /* "wrong number of ..." */, -1)
}

func install_fts3_rank_function(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_func.c:910:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// var db uintptr at bp, 8

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+2452 /* "DB" */)
		return 1
	}

	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), bp /* &db */) != 0 {
		return 1
	}
	sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), ts+37057 /* "rank" */, -1, 1, uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, int32, uintptr)
	}{rankfunc})), uintptr(0), uintptr(0))
	return 0
}

// Register commands with the TCL interpreter.
func Sqlitetest_func_Init(tls *crt.TLS, interp uintptr) int32 { /* test_func.c:933:5: */
	var i int32

	for i = 0; uint64(i) < (uint64(unsafe.Sizeof(aObjCmd7)) / uint64(unsafe.Sizeof(struct {
		FzName uintptr
		FxProc uintptr
	}{}))); i++ {
		tcl.XTcl_CreateObjCommand(tls, interp, aObjCmd7[i].FzName, aObjCmd7[i].FxProc, uintptr(0), uintptr(0))
	}
	sqlite3.Xsqlite3_initialize(tls)
	sqlite3.Xsqlite3_auto_extension(tls, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, uintptr) int32
	}{registerTestFunctions})))
	sqlite3.Xsqlite3_auto_extension(tls, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, uintptr) int32
	}{Md5_Register})))
	return 0
}

var aObjCmd7 = [3]struct {
	FzName uintptr
	FxProc uintptr
}{
	{FzName: ts + 37062 /* "autoinstall_test..." */, FxProc: 0},
	{FzName: ts + 37089 /* "abuse_create_fun..." */, FxProc: 0},
	{FzName: ts + 37111 /* "install_fts3_ran..." */, FxProc: 0},
} /* test_func.c:937:5 */

// end block for C++

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:
// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.20 General utilities	<stdlib.h>

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.21 String handling	<string.h>

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.2 Diagnostics	<assert.h>

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// void assert (int expression);
//
//   If NDEBUG is defined, do nothing.
//   If not, and EXPRESSION is zero, print an error message and abort.

// void assert_perror (int errnum);
//
//   If NDEBUG is defined, do nothing.  If not, and ERRNUM is not zero, print an
//   error message with the error text for ERRNUM and abort.
//   (This is a GNU extension.)

// Convert binary to hex.  The input zBuf[] contains N bytes of
// binary data.  zBuf[] is 2*n+1 bytes long.  Overwrite zBuf[]
// with a hexadecimal representation of its original binary input.
func sqlite3TestBinToHex(tls *crt.TLS, zBuf uintptr, N int32) { /* test_hexio.c:36:6: */
	bp := tls.Alloc(17)
	defer tls.Free(17)

	*(*[17]uint8)(unsafe.Pointer(bp /* zHex */)) = *(*[17]uint8)(unsafe.Pointer(ts + 37138 /* "0123456789ABCDEF" */))
	var i int32
	var j int32
	var c uint8
	i = (N * 2)
	*(*uint8)(unsafe.Pointer(zBuf + uintptr(crt.PostDecInt32(&i, 1)))) = uint8(0)
	for j = (N - 1); j >= 0; j-- {
		c = *(*uint8)(unsafe.Pointer(zBuf + uintptr(j)))
		*(*uint8)(unsafe.Pointer(zBuf + uintptr(crt.PostDecInt32(&i, 1)))) = *(*uint8)(unsafe.Pointer(bp /* &zHex[0] */ + uintptr((int32(c) & 0xf))))
		*(*uint8)(unsafe.Pointer(zBuf + uintptr(crt.PostDecInt32(&i, 1)))) = *(*uint8)(unsafe.Pointer(bp /* &zHex[0] */ + uintptr((int32(c) >> 4))))
	}

}

// Convert hex to binary.  The input zIn[] contains N bytes of
// hexadecimal.  Convert this into binary and write aOut[] with
// the binary data.  Spaces in the original input are ignored.
// Return the number of bytes of binary rendered.
func sqlite3TestHexToBin(tls *crt.TLS, zIn uintptr, N int32, aOut uintptr) int32 { /* test_hexio.c:56:5: */
	bp := tls.Alloc(256)
	defer tls.Free(256)

	*(*[256]uint8)(unsafe.Pointer(bp /* aMap */)) = [256]uint8{
		uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0),
		uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0),
		uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0),
		uint8(1), uint8(2), uint8(3), uint8(4), uint8(5), uint8(6), uint8(7), uint8(8), uint8(9), uint8(10), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0),
		uint8(0), uint8(11), uint8(12), uint8(13), uint8(14), uint8(15), uint8(16), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0),
		uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0),
		uint8(0), uint8(11), uint8(12), uint8(13), uint8(14), uint8(15), uint8(16), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0),
		uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0),
		uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0),
		uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0),
		uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0),
		uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0),
		uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0),
		uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0),
		uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0),
		uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0),
	}
	var i int32
	var j int32
	var hi int32 = 1
	var c uint8

	for i = crt.AssignInt32(&j, 0); i < N; i++ {
		c = *(*uint8)(unsafe.Pointer(bp /* &aMap[0] */ + uintptr(*(*uint8)(unsafe.Pointer(zIn + uintptr(i))))))
		if int32(c) == 0 {
			continue
		}
		if hi != 0 {
			*(*uint8)(unsafe.Pointer(aOut + uintptr(j))) = (uint8((int32(c) - 1) << 4))
			hi = 0
		} else {
			*(*uint8)(unsafe.Pointer(aOut + uintptr(crt.PostIncInt32(&j, 1)))) |= uint8((int32(c) - 1))
			hi = 1
		}
	}
	return j
}

// Usage:   hexio_read  FILENAME  OFFSET  AMT
//
// Read AMT bytes from file FILENAME beginning at OFFSET from the
// beginning of the file.  Convert that information to hexadecimal
// and return the resulting HEX string.
func hexio_read(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_hexio.c:101:26: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	// var offset int32 at bp+40, 4

	// var amt int32 at bp+44, 4

	var got int32
	var zFile uintptr
	var zBuf uintptr
	var in uintptr

	if objc != 4 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+37155 /* "FILENAME OFFSET ..." */)
		return 1
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)), bp+40 /* &offset */) != 0 {
		return 1
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(3)*8)), bp+44 /* &amt */) != 0 {
		return 1
	}
	zFile = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)))
	zBuf = sqlite3.Xsqlite3_malloc(tls, ((*(*int32)(unsafe.Pointer(bp + 44 /* amt */)) * 2) + 1))
	if zBuf == uintptr(0) {
		return 1
	}
	in = crt.Xfopen64(tls, zFile, ts+3756 /* "rb" */)
	if in == uintptr(0) {
		in = crt.Xfopen64(tls, zFile, ts+37175 /* "r" */)
	}
	if in == uintptr(0) {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+37177 /* "cannot open inpu..." */, zFile, 0))
		return 1
	}
	crt.Xfseek(tls, in, int64(*(*int32)(unsafe.Pointer(bp + 40 /* offset */))), 0)
	got = int32(crt.Xfread(tls, zBuf, uint64(1), uint64(*(*int32)(unsafe.Pointer(bp + 44 /* amt */))), in))
	crt.Xfclose(tls, in)
	if got < 0 {
		got = 0
	}
	sqlite3TestBinToHex(tls, zBuf, got)
	tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+24, zBuf, 0))
	sqlite3.Xsqlite3_free(tls, zBuf)
	return 0
}

// Usage:   hexio_write  FILENAME  OFFSET  DATA
//
// Write DATA into file FILENAME beginning at OFFSET from the
// beginning of the file.  DATA is expressed in hexadecimal.
func hexio_write(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_hexio.c:151:26: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	// var offset int32 at bp+24, 4

	// var nIn int32 at bp+28, 4

	var nOut int32
	var written int32
	var zFile uintptr
	var zIn uintptr
	var aOut uintptr
	var out uintptr

	if objc != 4 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+37201 /* "FILENAME OFFSET ..." */)
		return 1
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)), bp+24 /* &offset */) != 0 {
		return 1
	}
	zFile = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)))
	zIn = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(3)*8)), bp+28 /* &nIn */)
	aOut = sqlite3.Xsqlite3_malloc(tls, (*(*int32)(unsafe.Pointer(bp + 28 /* nIn */)) / 2))
	if aOut == uintptr(0) {
		return 1
	}
	nOut = sqlite3TestHexToBin(tls, zIn, *(*int32)(unsafe.Pointer(bp + 28 /* nIn */)), aOut)
	out = crt.Xfopen64(tls, zFile, ts+37225 /* "r+b" */)
	if out == uintptr(0) {
		out = crt.Xfopen64(tls, zFile, ts+37229 /* "r+" */)
	}
	if out == uintptr(0) {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+37232 /* "cannot open outp..." */, zFile, 0))
		return 1
	}
	crt.Xfseek(tls, out, int64(*(*int32)(unsafe.Pointer(bp + 24 /* offset */))), 0)
	written = int32(crt.Xfwrite(tls, aOut, uint64(1), uint64(nOut), out))
	sqlite3.Xsqlite3_free(tls, aOut)
	crt.Xfclose(tls, out)
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, written))
	return 0
}

// USAGE:   hexio_get_int   HEXDATA
//
// Interpret the HEXDATA argument as a big-endian integer.  Return
// the value of that integer.  HEXDATA can contain between 2 and 8
// hexadecimal digits.
func hexio_get_int(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_hexio.c:199:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var val int32
	// var nIn int32 at bp, 4

	var nOut int32
	var zIn uintptr
	var aOut uintptr
	// var aNum [4]uint8 at bp+4, 4

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+37257 /* "HEXDATA" */)
		return 1
	}
	zIn = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)), bp /* &nIn */)
	aOut = sqlite3.Xsqlite3_malloc(tls, (*(*int32)(unsafe.Pointer(bp /* nIn */)) / 2))
	if aOut == uintptr(0) {
		return 1
	}
	nOut = sqlite3TestHexToBin(tls, zIn, *(*int32)(unsafe.Pointer(bp /* nIn */)), aOut)
	if nOut >= 4 {
		crt.Xmemcpy(tls, bp+4 /* &aNum[0] */, aOut, uint64(4))
	} else {
		crt.Xmemset(tls, bp+4 /* &aNum[0] */, 0, uint64(unsafe.Sizeof([4]uint8{})))
		crt.Xmemcpy(tls, (bp + 4 /* &aNum */ + uintptr((4 - nOut))), aOut, uint64(nOut))
	}
	sqlite3.Xsqlite3_free(tls, aOut)
	val = ((((int32(*(*uint8)(unsafe.Pointer(bp + 4 /* &aNum[0] */ + uintptr(0)))) << 24) | (int32(*(*uint8)(unsafe.Pointer(bp + 4 /* &aNum[0] */ + uintptr(1)))) << 16)) | (int32(*(*uint8)(unsafe.Pointer(bp + 4 /* &aNum[0] */ + uintptr(2)))) << 8)) | int32(*(*uint8)(unsafe.Pointer(bp + 4 /* &aNum[0] */ + uintptr(3)))))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, val))
	return 0
}

// USAGE:   hexio_render_int16   INTEGER
//
// Render INTEGER has a 16-bit big-endian integer in hexadecimal.
func hexio_render_int16(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_hexio.c:239:26: */
	bp := tls.Alloc(14)
	defer tls.Free(14)

	// var val int32 at bp, 4

	// var aNum [10]uint8 at bp+4, 10

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+11332 /* "INTEGER" */)
		return 1
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)), bp /* &val */) != 0 {
		return 1
	}
	*(*uint8)(unsafe.Pointer(bp + 4 /* &aNum[0] */ + uintptr(0))) = (uint8(*(*int32)(unsafe.Pointer(bp /* val */)) >> 8))
	*(*uint8)(unsafe.Pointer(bp + 4 /* &aNum[0] */ + uintptr(1))) = uint8(*(*int32)(unsafe.Pointer(bp /* val */)))
	sqlite3TestBinToHex(tls, bp+4 /* &aNum[0] */, 2)
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, bp+4 /* aNum */, 4))
	return 0
}

// USAGE:   hexio_render_int32   INTEGER
//
// Render INTEGER has a 32-bit big-endian integer in hexadecimal.
func hexio_render_int32(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_hexio.c:266:26: */
	bp := tls.Alloc(14)
	defer tls.Free(14)

	// var val int32 at bp, 4

	// var aNum [10]uint8 at bp+4, 10

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+11332 /* "INTEGER" */)
		return 1
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)), bp /* &val */) != 0 {
		return 1
	}
	*(*uint8)(unsafe.Pointer(bp + 4 /* &aNum[0] */ + uintptr(0))) = (uint8(*(*int32)(unsafe.Pointer(bp /* val */)) >> 24))
	*(*uint8)(unsafe.Pointer(bp + 4 /* &aNum[0] */ + uintptr(1))) = (uint8(*(*int32)(unsafe.Pointer(bp /* val */)) >> 16))
	*(*uint8)(unsafe.Pointer(bp + 4 /* &aNum[0] */ + uintptr(2))) = (uint8(*(*int32)(unsafe.Pointer(bp /* val */)) >> 8))
	*(*uint8)(unsafe.Pointer(bp + 4 /* &aNum[0] */ + uintptr(3))) = uint8(*(*int32)(unsafe.Pointer(bp /* val */)))
	sqlite3TestBinToHex(tls, bp+4 /* &aNum[0] */, 4)
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, bp+4 /* aNum */, 8))
	return 0
}

// USAGE:  utf8_to_utf8  HEX
//
// The argument is a UTF8 string represented in hexadecimal.
// The UTF8 might not be well-formed.  Run this string through
// sqlite3Utf8to8() convert it back to hex and return the result.
func utf8_to_utf8(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_hexio.c:296:26: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	tcl.XTcl_AppendResult(tls, interp,
		crt.VaList(bp, ts+37265 /* "[utf8_to_utf8] u..." */, 0))
	return 1
}

func getFts3Varint(tls *crt.TLS, p uintptr, v uintptr) int32 { /* test_hexio.c:328:12: */
	var q uintptr = p
	var x sqlite_uint64 = uint64(0)
	var y sqlite_uint64 = uint64(1)
	for (int32(*(*uint8)(unsafe.Pointer(q))) & 0x80) == 0x80 {
		x = x + (y * (sqlite_uint64(int32(*(*uint8)(unsafe.Pointer(crt.PostIncUintptr(&q, 1)))) & 0x7f)))
		y <<= 7
	}
	x = x + (y * (sqlite_uint64(*(*uint8)(unsafe.Pointer(crt.PostIncUintptr(&q, 1))))))
	*(*sqlite_int64)(unsafe.Pointer(v)) = sqlite_int64(x)
	return (int32((int64(q) - int64(p)) / 1))
}

func putFts3Varint(tls *crt.TLS, p uintptr, v sqlite_int64) int32 { /* test_hexio.c:340:12: */
	var q uintptr = p
	var vu sqlite_uint64 = sqlite_uint64(v)
	for ok := true; ok; ok = (vu != uint64(0)) {
		*(*uint8)(unsafe.Pointer(crt.PostIncUintptr(&q, 1))) = (uint8((vu & uint64(0x7f)) | uint64(0x80)))
		vu >>= 7
	}
	*(*uint8)(unsafe.Pointer(q + crt.UintptrFromInt32(-1))) &= uint8((0x7f)) // turn off high bit in final byte

	return (int32((int64(q) - int64(p)) / 1))
}

// USAGE:  read_fts3varint BLOB VARNAME
//
// Read a varint from the start of BLOB. Set variable VARNAME to contain
// the interpreted value. Return the number of bytes of BLOB consumed.
func read_fts3varint(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_hexio.c:358:26: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	// var nBlob int32 at bp, 4

	var zBlob uintptr
	// var iVal sqlite3_int64 at bp+8, 8

	var nVal int32

	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+37319 /* "BLOB VARNAME" */)
		return 1
	}
	zBlob = tcl.XTcl_GetByteArrayFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)), bp /* &nBlob */)

	nVal = getFts3Varint(tls, zBlob, bp+8 /* &iVal */)
	tcl.XTcl_ObjSetVar2(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)), uintptr(0), tcl.XTcl_NewWideIntObj(tls, int64(*(*sqlite3_int64)(unsafe.Pointer(bp + 8 /* iVal */)))), 0)
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, nVal))
	return 0
}

// USAGE:  make_fts3record ARGLIST
func make_fts3record(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_hexio.c:384:26: */
	bp := tls.Alloc(28)
	defer tls.Free(28)

	*(*uintptr)(unsafe.Pointer(bp + 8 /* aArg */)) = uintptr(0)
	*(*int32)(unsafe.Pointer(bp /* nArg */)) = 0
	var aOut uintptr = uintptr(0)
	var nOut int32 = 0
	var nAlloc int32 = 0
	var i int32

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+37332 /* "LIST" */)
		return 1
	}
	if tcl.XTcl_ListObjGetElements(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)), bp /* &nArg */, bp+8 /* &aArg */) != 0 {
		return 1
	}

	for i = 0; i < *(*int32)(unsafe.Pointer(bp /* nArg */)); i++ {
		// var iVal sqlite3_int64 at bp+16, 8

		if 0 == tcl.XTcl_GetWideIntFromObj(tls, uintptr(0), *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8 /* aArg */)) + uintptr(i)*8)), bp+16 /* &iVal */) {
			if (nOut + 10) > nAlloc {
				var nNew int32
				if nAlloc != 0 {
					nNew = (nAlloc * 2)
				} else {
					nNew = 128
				}
				var aNew uintptr = sqlite3.Xsqlite3_realloc(tls, aOut, nNew)
				if aNew == uintptr(0) {
					sqlite3.Xsqlite3_free(tls, aOut)
					return 1
				}
				aOut = aNew
				nAlloc = nNew
			}
			nOut = nOut + (putFts3Varint(tls, (aOut + uintptr(nOut)), *(*sqlite3_int64)(unsafe.Pointer(bp + 16 /* iVal */))))
		} else {
			*(*int32)(unsafe.Pointer(bp + 24 /* nVal */)) = 0
			var zVal uintptr = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8 /* aArg */)) + uintptr(i)*8)), bp+24 /* &nVal */)
			for (nOut + *(*int32)(unsafe.Pointer(bp + 24 /* nVal */))) > nAlloc {
				var nNew int32
				if nAlloc != 0 {
					nNew = (nAlloc * 2)
				} else {
					nNew = 128
				}
				var aNew uintptr = sqlite3.Xsqlite3_realloc(tls, aOut, nNew)
				if aNew == uintptr(0) {
					sqlite3.Xsqlite3_free(tls, aOut)
					return 1
				}
				aOut = aNew
				nAlloc = nNew
			}
			crt.Xmemcpy(tls, (aOut + uintptr(nOut)), zVal, uint64(*(*int32)(unsafe.Pointer(bp + 24 /* nVal */))))
			nOut = nOut + (*(*int32)(unsafe.Pointer(bp + 24 /* nVal */)))
		}
	}

	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewByteArrayObj(tls, aOut, nOut))
	sqlite3.Xsqlite3_free(tls, aOut)
	return 0
}

// Register commands with the TCL interpreter.
func Sqlitetest_hexio_Init(tls *crt.TLS, interp uintptr) int32 { /* test_hexio.c:446:5: */
	var i int32
	for i = 0; uint64(i) < (uint64(unsafe.Sizeof(aObjCmd8)) / uint64(unsafe.Sizeof(struct {
		FzName uintptr
		FxProc uintptr
	}{}))); i++ {
		tcl.XTcl_CreateObjCommand(tls, interp, aObjCmd8[i].FzName, aObjCmd8[i].FxProc, uintptr(0), uintptr(0))
	}
	return 0
}

var aObjCmd8 = [8]struct {
	FzName uintptr
	FxProc uintptr
}{
	{FzName: ts + 37337 /* "hexio_read" */, FxProc: 0},
	{FzName: ts + 37348 /* "hexio_write" */, FxProc: 0},
	{FzName: ts + 37360 /* "hexio_get_int" */, FxProc: 0},
	{FzName: ts + 37374 /* "hexio_render_int..." */, FxProc: 0},
	{FzName: ts + 37393 /* "hexio_render_int..." */, FxProc: 0},
	{FzName: ts + 37412 /* "utf8_to_utf8" */, FxProc: 0},
	{FzName: ts + 37425 /* "read_fts3varint" */, FxProc: 0},
	{FzName: ts + 37441 /* "make_fts3record" */, FxProc: 0},
} /* test_hexio.c:450:5 */

// end block for C++

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:

type Wrapped = struct {
	Fpcache      sqlite3_pcache_methods2
	Fmem         sqlite3_mem_methods
	Fmutex       sqlite3_mutex_methods
	Fmem_init    int32
	Fmem_fail    int32
	Fmutex_init  int32
	Fmutex_fail  int32
	Fpcache_init int32
	Fpcache_fail int32
}

// end block for C++

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:

var wrapped Wrapped /* test_init.c:47:3: */

func wrMemInit(tls *crt.TLS, pAppData uintptr) int32 { /* test_init.c:49:12: */
	var rc int32
	if wrapped.Fmem_fail != 0 {
		rc = 1
	} else {
		rc = (*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer((uintptr(unsafe.Pointer(&wrapped)) + 104 /* &.mem */ + 40 /* &.xInit */))))(tls, wrapped.Fmem.FpAppData)
	}
	if rc == 0 {
		wrapped.Fmem_init = 1
	}
	return rc
}
func wrMemShutdown(tls *crt.TLS, pAppData uintptr) { /* test_init.c:61:13: */
	(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((uintptr(unsafe.Pointer(&wrapped)) + 104 /* &.mem */ + 48 /* &.xShutdown */))))(tls, wrapped.Fmem.FpAppData)
	wrapped.Fmem_init = 0
}
func wrMemMalloc(tls *crt.TLS, n int32) uintptr { /* test_init.c:65:13: */
	return (*(*func(*crt.TLS, int32) uintptr)(unsafe.Pointer((uintptr(unsafe.Pointer(&wrapped)) + 104 /* &.mem */ /* &.xMalloc */))))(tls, n)
}
func wrMemFree(tls *crt.TLS, p uintptr) { /* test_init.c:66:13: */
	(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((uintptr(unsafe.Pointer(&wrapped)) + 104 /* &.mem */ + 8 /* &.xFree */))))(tls, p)
}
func wrMemRealloc(tls *crt.TLS, p uintptr, n int32) uintptr { /* test_init.c:67:13: */
	return (*(*func(*crt.TLS, uintptr, int32) uintptr)(unsafe.Pointer((uintptr(unsafe.Pointer(&wrapped)) + 104 /* &.mem */ + 16 /* &.xRealloc */))))(tls, p, n)
}
func wrMemSize(tls *crt.TLS, p uintptr) int32 { /* test_init.c:68:12: */
	return (*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer((uintptr(unsafe.Pointer(&wrapped)) + 104 /* &.mem */ + 24 /* &.xSize */))))(tls, p)
}
func wrMemRoundup(tls *crt.TLS, n int32) int32 { /* test_init.c:69:12: */
	return (*(*func(*crt.TLS, int32) int32)(unsafe.Pointer((uintptr(unsafe.Pointer(&wrapped)) + 104 /* &.mem */ + 32 /* &.xRoundup */))))(tls, n)
}

func wrMutexInit(tls *crt.TLS) int32 { /* test_init.c:72:12: */
	var rc int32
	if wrapped.Fmutex_fail != 0 {
		rc = 1
	} else {
		rc = (*(*func(*crt.TLS) int32)(unsafe.Pointer((uintptr(unsafe.Pointer(&wrapped)) + 168 /* &.mutex */ /* &.xMutexInit */))))(tls)
	}
	if rc == 0 {
		wrapped.Fmutex_init = 1
	}
	return rc
}
func wrMutexEnd(tls *crt.TLS) int32 { /* test_init.c:84:12: */
	(*(*func(*crt.TLS) int32)(unsafe.Pointer((uintptr(unsafe.Pointer(&wrapped)) + 168 /* &.mutex */ + 8 /* &.xMutexEnd */))))(tls)
	wrapped.Fmutex_init = 0
	return 0
}
func wrMutexAlloc(tls *crt.TLS, e int32) uintptr { /* test_init.c:89:22: */
	return (*(*func(*crt.TLS, int32) uintptr)(unsafe.Pointer((uintptr(unsafe.Pointer(&wrapped)) + 168 /* &.mutex */ + 16 /* &.xMutexAlloc */))))(tls, e)
}
func wrMutexFree(tls *crt.TLS, p uintptr) { /* test_init.c:92:13: */
	(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((uintptr(unsafe.Pointer(&wrapped)) + 168 /* &.mutex */ + 24 /* &.xMutexFree */))))(tls, p)
}
func wrMutexEnter(tls *crt.TLS, p uintptr) { /* test_init.c:95:13: */
	(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((uintptr(unsafe.Pointer(&wrapped)) + 168 /* &.mutex */ + 32 /* &.xMutexEnter */))))(tls, p)
}
func wrMutexTry(tls *crt.TLS, p uintptr) int32 { /* test_init.c:98:12: */
	return (*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer((uintptr(unsafe.Pointer(&wrapped)) + 168 /* &.mutex */ + 40 /* &.xMutexTry */))))(tls, p)
}
func wrMutexLeave(tls *crt.TLS, p uintptr) { /* test_init.c:101:13: */
	(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((uintptr(unsafe.Pointer(&wrapped)) + 168 /* &.mutex */ + 48 /* &.xMutexLeave */))))(tls, p)
}
func wrMutexHeld(tls *crt.TLS, p uintptr) int32 { /* test_init.c:104:12: */
	return (*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer((uintptr(unsafe.Pointer(&wrapped)) + 168 /* &.mutex */ + 56 /* &.xMutexHeld */))))(tls, p)
}
func wrMutexNotheld(tls *crt.TLS, p uintptr) int32 { /* test_init.c:107:12: */
	return (*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer((uintptr(unsafe.Pointer(&wrapped)) + 168 /* &.mutex */ + 64 /* &.xMutexNotheld */))))(tls, p)
}

func wrPCacheInit(tls *crt.TLS, pArg uintptr) int32 { /* test_init.c:113:12: */
	var rc int32
	if wrapped.Fpcache_fail != 0 {
		rc = 1
	} else {
		rc = (*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer((uintptr(unsafe.Pointer(&wrapped)) /* &.pcache */ + 16 /* &.xInit */))))(tls, wrapped.Fpcache.FpArg)
	}
	if rc == 0 {
		wrapped.Fpcache_init = 1
	}
	return rc
}
func wrPCacheShutdown(tls *crt.TLS, pArg uintptr) { /* test_init.c:125:13: */
	(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((uintptr(unsafe.Pointer(&wrapped)) /* &.pcache */ + 24 /* &.xShutdown */))))(tls, wrapped.Fpcache.FpArg)
	wrapped.Fpcache_init = 0
}

func wrPCacheCreate(tls *crt.TLS, a int32, b int32, c int32) uintptr { /* test_init.c:130:23: */
	return (*(*func(*crt.TLS, int32, int32, int32) uintptr)(unsafe.Pointer((uintptr(unsafe.Pointer(&wrapped)) /* &.pcache */ + 32 /* &.xCreate */))))(tls, a, b, c)
}
func wrPCacheCachesize(tls *crt.TLS, p uintptr, n int32) { /* test_init.c:133:13: */
	(*(*func(*crt.TLS, uintptr, int32))(unsafe.Pointer((uintptr(unsafe.Pointer(&wrapped)) /* &.pcache */ + 40 /* &.xCachesize */))))(tls, p, n)
}
func wrPCachePagecount(tls *crt.TLS, p uintptr) int32 { /* test_init.c:136:12: */
	return (*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer((uintptr(unsafe.Pointer(&wrapped)) /* &.pcache */ + 48 /* &.xPagecount */))))(tls, p)
}
func wrPCacheFetch(tls *crt.TLS, p uintptr, a uint32, b int32) uintptr { /* test_init.c:139:28: */
	return (*(*func(*crt.TLS, uintptr, uint32, int32) uintptr)(unsafe.Pointer((uintptr(unsafe.Pointer(&wrapped)) /* &.pcache */ + 56 /* &.xFetch */))))(tls, p, a, b)
}
func wrPCacheUnpin(tls *crt.TLS, p uintptr, a uintptr, b int32) { /* test_init.c:142:13: */
	(*(*func(*crt.TLS, uintptr, uintptr, int32))(unsafe.Pointer((uintptr(unsafe.Pointer(&wrapped)) /* &.pcache */ + 64 /* &.xUnpin */))))(tls, p, a, b)
}
func wrPCacheRekey(tls *crt.TLS, p uintptr, a uintptr, b uint32, c uint32) { /* test_init.c:145:13: */
	(*(*func(*crt.TLS, uintptr, uintptr, uint32, uint32))(unsafe.Pointer((uintptr(unsafe.Pointer(&wrapped)) /* &.pcache */ + 72 /* &.xRekey */))))(tls, p, a, b, c)
}
func wrPCacheTruncate(tls *crt.TLS, p uintptr, a uint32) { /* test_init.c:153:13: */
	(*(*func(*crt.TLS, uintptr, uint32))(unsafe.Pointer((uintptr(unsafe.Pointer(&wrapped)) /* &.pcache */ + 80 /* &.xTruncate */))))(tls, p, a)
}
func wrPCacheDestroy(tls *crt.TLS, p uintptr) { /* test_init.c:156:13: */
	(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((uintptr(unsafe.Pointer(&wrapped)) /* &.pcache */ + 88 /* &.xDestroy */))))(tls, p)
}

func installInitWrappers(tls *crt.TLS) { /* test_init.c:160:13: */
	bp := tls.Alloc(288)
	defer tls.Free(288)

	*(*sqlite3_mutex_methods)(unsafe.Pointer(bp + 48 /* mutexmethods */)) = sqlite3_mutex_methods{FxMutexInit: *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS) int32 }{wrMutexInit})), FxMutexEnd: *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS) int32 }{wrMutexEnd})), FxMutexAlloc: *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, int32) uintptr }{wrMutexAlloc})), FxMutexFree: *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, uintptr) }{wrMutexFree})), FxMutexEnter: *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, uintptr) }{wrMutexEnter})), FxMutexTry: *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, uintptr) int32 }{wrMutexTry})), FxMutexLeave: *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, uintptr) }{wrMutexLeave})), FxMutexHeld: *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, uintptr) int32 }{wrMutexHeld})), FxMutexNotheld: *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, uintptr) int32 }{wrMutexNotheld}))}
	*(*sqlite3_pcache_methods2)(unsafe.Pointer(bp + 184 /* pcachemethods */)) = sqlite3_pcache_methods2{FiVersion: 1, FpArg: uintptr(0), FxInit: *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, uintptr) int32 }{wrPCacheInit})), FxShutdown: *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, uintptr) }{wrPCacheShutdown})), FxCreate: *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, int32, int32, int32) uintptr
	}{wrPCacheCreate})), FxCachesize: *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, int32)
	}{wrPCacheCachesize})), FxPagecount: *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, uintptr) int32 }{wrPCachePagecount})), FxFetch: *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uint32, int32) uintptr
	}{wrPCacheFetch})), FxUnpin: *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32)
	}{wrPCacheUnpin})), FxRekey: *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, uint32, uint32)
	}{wrPCacheRekey})), FxTruncate: *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uint32)
	}{wrPCacheTruncate})), FxDestroy: *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, uintptr) }{wrPCacheDestroy})),
	}
	*(*sqlite3_mem_methods)(unsafe.Pointer(bp + 120 /* memmethods */)) = sqlite3_mem_methods{FxMalloc: *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, int32) uintptr }{wrMemMalloc})), FxFree: *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, uintptr) }{wrMemFree})), FxRealloc: *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, int32) uintptr
	}{wrMemRealloc})), FxSize: *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, uintptr) int32 }{wrMemSize})), FxRoundup: *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, int32) int32 }{wrMemRoundup})), FxInit: *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, uintptr) int32 }{wrMemInit})), FxShutdown: *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, uintptr) }{wrMemShutdown})), FpAppData: uintptr(0),
	}

	crt.Xmemset(tls, uintptr(unsafe.Pointer(&wrapped)), 0, uint64(unsafe.Sizeof(wrapped)))

	sqlite3.Xsqlite3_shutdown(tls)
	sqlite3.Xsqlite3_config(tls, 11, crt.VaList(bp, (uintptr(unsafe.Pointer(&wrapped))+168 /* &.mutex */)))
	sqlite3.Xsqlite3_config(tls, 5, crt.VaList(bp+8, (uintptr(unsafe.Pointer(&wrapped))+104 /* &.mem */)))
	sqlite3.Xsqlite3_config(tls, 19, crt.VaList(bp+16, (uintptr(unsafe.Pointer(&wrapped)) /* &.pcache */)))
	sqlite3.Xsqlite3_config(tls, 10, crt.VaList(bp+24, bp+48 /* &mutexmethods */))
	sqlite3.Xsqlite3_config(tls, 4, crt.VaList(bp+32, bp+120 /* &memmethods */))
	sqlite3.Xsqlite3_config(tls, 18, crt.VaList(bp+40, bp+184 /* &pcachemethods */))
}

func init_wrapper_install(tls *crt.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_init.c:191:26: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	var i int32
	installInitWrappers(tls)
	for i = 1; i < objc; i++ {
		var z uintptr = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(i)*8)))
		if crt.Xstrcmp(tls, z, ts+37457 /* "mem" */) == 0 {
			wrapped.Fmem_fail = 1
		} else if crt.Xstrcmp(tls, z, ts+34050 /* "mutex" */) == 0 {
			wrapped.Fmutex_fail = 1
		} else if crt.Xstrcmp(tls, z, ts+37461 /* "pcache" */) == 0 {
			wrapped.Fpcache_fail = 1
		} else {
			tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+37468 /* "Unknown argument..." */, z, ts+18666 /* "\"" */))
			return 1
		}
	}
	return 0
}

func init_wrapper_uninstall(tls *crt.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_init.c:215:26: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	if objc != 1 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+792 /* "" */)
		return 1
	}

	sqlite3.Xsqlite3_shutdown(tls)
	sqlite3.Xsqlite3_config(tls, 10, crt.VaList(bp, (uintptr(unsafe.Pointer(&wrapped))+168 /* &.mutex */)))
	sqlite3.Xsqlite3_config(tls, 4, crt.VaList(bp+8, (uintptr(unsafe.Pointer(&wrapped))+104 /* &.mem */)))
	sqlite3.Xsqlite3_config(tls, 18, crt.VaList(bp+16, (uintptr(unsafe.Pointer(&wrapped)) /* &.pcache */)))
	return 0
}

func init_wrapper_clear(tls *crt.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_init.c:233:26: */
	if objc != 1 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+792 /* "" */)
		return 1
	}

	wrapped.Fmem_fail = 0
	wrapped.Fmutex_fail = 0
	wrapped.Fpcache_fail = 0
	return 0
}

func init_wrapper_query(tls *crt.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_init.c:250:26: */
	var pRet uintptr

	if objc != 1 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+792 /* "" */)
		return 1
	}

	pRet = tcl.XTcl_NewObj(tls)
	if wrapped.Fmutex_init != 0 {
		tcl.XTcl_ListObjAppendElement(tls, interp, pRet, tcl.XTcl_NewStringObj(tls, ts+34050 /* "mutex" */, -1))
	}
	if wrapped.Fmem_init != 0 {
		tcl.XTcl_ListObjAppendElement(tls, interp, pRet, tcl.XTcl_NewStringObj(tls, ts+37457 /* "mem" */, -1))
	}
	if wrapped.Fpcache_init != 0 {
		tcl.XTcl_ListObjAppendElement(tls, interp, pRet, tcl.XTcl_NewStringObj(tls, ts+37461 /* "pcache" */, -1))
	}

	tcl.XTcl_SetObjResult(tls, interp, pRet)
	return 0
}

func Sqlitetest_init_Init(tls *crt.TLS, interp uintptr) int32 { /* test_init.c:278:5: */
	var i int32

	for i = 0; uint64(i) < (uint64(unsafe.Sizeof(aObjCmd9)) / uint64(unsafe.Sizeof(struct {
		FzName uintptr
		FxProc uintptr
	}{}))); i++ {
		tcl.XTcl_CreateObjCommand(tls, interp, aObjCmd9[i].FzName, aObjCmd9[i].FxProc, uintptr(0), uintptr(0))
	}

	return 0
}

var aObjCmd9 = [4]struct {
	FzName uintptr
	FxProc uintptr
}{
	{FzName: ts + 37488 /* "init_wrapper_ins..." */, FxProc: 0},
	{FzName: ts + 37509 /* "init_wrapper_que..." */, FxProc: 0},
	{FzName: ts + 37528 /* "init_wrapper_uni..." */, FxProc: 0},
	{FzName: ts + 37551 /* "init_wrapper_cle..." */, FxProc: 0},
} /* test_init.c:282:5 */

//
// END OF REGISTRATION API
//

//******* End of fts5.h ********

// Make sure we can call this stuff from C++.

// An sqlite3_intarray is an abstract type to stores an instance of
// an integer array.
type sqlite3_intarray1 = struct {
	Fn     int32
	Fa     uintptr
	FxFree uintptr
}

//
// END OF REGISTRATION API
//

//******* End of fts5.h ********

// Make sure we can call this stuff from C++.

// An sqlite3_intarray is an abstract type to stores an instance of
// an integer array.
type sqlite3_intarray = sqlite3_intarray1 /* test_intarray.h:99:33 */

// Objects used internally by the virtual table implementation
type intarray_vtab1 = struct {
	Fbase     sqlite3_vtab
	FpContent uintptr
}

// Objects used internally by the virtual table implementation
type intarray_vtab = intarray_vtab1 /* test_intarray.c:41:30 */
type intarray_cursor1 = struct {
	Fbase sqlite3_vtab_cursor
	Fi    int32
	_     [4]byte
}

type intarray_cursor = intarray_cursor1 /* test_intarray.c:42:32 */

// None of this works unless we have virtual tables.

// Free an sqlite3_intarray object.
func intarrayFree(tls *crt.TLS, p uintptr) { /* test_intarray.c:64:13: */
	if (*sqlite3_intarray)(unsafe.Pointer(p)).FxFree != 0 {
		(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((p + 16 /* &.xFree */))))(tls, (*sqlite3_intarray)(unsafe.Pointer(p)).Fa)
	}
	sqlite3.Xsqlite3_free(tls, p)
}

// Table destructor for the intarray module.
func intarrayDestroy(tls *crt.TLS, p uintptr) int32 { /* test_intarray.c:74:12: */
	var pVtab uintptr = p
	sqlite3.Xsqlite3_free(tls, pVtab)
	return 0
}

// Table constructor for the intarray module.
func intarrayCreate(tls *crt.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVtab uintptr, pzErr uintptr) int32 { /* test_intarray.c:83:12: */
	var rc int32 = 7
	var pVtab uintptr = sqlite3.Xsqlite3_malloc64(tls, uint64(unsafe.Sizeof(intarray_vtab{})))

	if pVtab != 0 {
		crt.Xmemset(tls, pVtab, 0, uint64(unsafe.Sizeof(intarray_vtab{})))
		(*intarray_vtab)(unsafe.Pointer(pVtab)).FpContent = pAux
		rc = sqlite3.Xsqlite3_declare_vtab(tls, db, ts+37570 /* "CREATE TABLE x(v..." */)
	}
	*(*uintptr)(unsafe.Pointer(ppVtab)) = pVtab
	return rc
}

// Open a new cursor on the intarray table.
func intarrayOpen(tls *crt.TLS, pVTab uintptr, ppCursor uintptr) int32 { /* test_intarray.c:106:12: */
	var rc int32 = 7
	var pCur uintptr
	pCur = sqlite3.Xsqlite3_malloc64(tls, uint64(unsafe.Sizeof(intarray_cursor{})))
	if pCur != 0 {
		crt.Xmemset(tls, pCur, 0, uint64(unsafe.Sizeof(intarray_cursor{})))
		*(*uintptr)(unsafe.Pointer(ppCursor)) = pCur
		rc = 0
	}
	return rc
}

// Close a intarray table cursor.
func intarrayClose(tls *crt.TLS, cur uintptr) int32 { /* test_intarray.c:121:12: */
	var pCur uintptr = cur
	sqlite3.Xsqlite3_free(tls, pCur)
	return 0
}

// Retrieve a column of data.
func intarrayColumn(tls *crt.TLS, cur uintptr, ctx uintptr, i int32) int32 { /* test_intarray.c:130:12: */
	var pCur uintptr = cur
	var pVtab uintptr = (*sqlite3_vtab_cursor)(unsafe.Pointer(cur)).FpVtab
	if ((*intarray_cursor)(unsafe.Pointer(pCur)).Fi >= 0) && ((*intarray_cursor)(unsafe.Pointer(pCur)).Fi < (*sqlite3_intarray)(unsafe.Pointer((*intarray_vtab)(unsafe.Pointer(pVtab)).FpContent)).Fn) {
		sqlite3.Xsqlite3_result_int64(tls, ctx, *(*sqlite3_int64)(unsafe.Pointer((*sqlite3_intarray)(unsafe.Pointer((*intarray_vtab)(unsafe.Pointer(pVtab)).FpContent)).Fa + uintptr((*intarray_cursor)(unsafe.Pointer(pCur)).Fi)*8)))
	}
	return 0
}

// Retrieve the current rowid.
func intarrayRowid(tls *crt.TLS, cur uintptr, pRowid uintptr) int32 { /* test_intarray.c:142:12: */
	var pCur uintptr = cur
	*(*sqlite_int64)(unsafe.Pointer(pRowid)) = sqlite_int64((*intarray_cursor)(unsafe.Pointer(pCur)).Fi)
	return 0
}

func intarrayEof(tls *crt.TLS, cur uintptr) int32 { /* test_intarray.c:148:12: */
	var pCur uintptr = cur
	var pVtab uintptr = (*sqlite3_vtab_cursor)(unsafe.Pointer(cur)).FpVtab
	return (crt.Bool32((*intarray_cursor)(unsafe.Pointer(pCur)).Fi >= (*sqlite3_intarray)(unsafe.Pointer((*intarray_vtab)(unsafe.Pointer(pVtab)).FpContent)).Fn))
}

// Advance the cursor to the next row.
func intarrayNext(tls *crt.TLS, cur uintptr) int32 { /* test_intarray.c:157:12: */
	var pCur uintptr = cur
	(*intarray_cursor)(unsafe.Pointer(pCur)).Fi++
	return 0
}

// Reset a intarray table cursor.
func intarrayFilter(tls *crt.TLS, pVtabCursor uintptr, idxNum int32, idxStr uintptr, argc int32, argv uintptr) int32 { /* test_intarray.c:166:12: */
	var pCur uintptr = pVtabCursor
	(*intarray_cursor)(unsafe.Pointer(pCur)).Fi = 0
	return 0
}

// Analyse the WHERE condition.
func intarrayBestIndex(tls *crt.TLS, tab uintptr, pIdxInfo uintptr) int32 { /* test_intarray.c:179:12: */
	return 0
}

// A virtual table module that merely echos method calls into TCL
// variables.
var intarrayModule = sqlite3_module{FiVersion: 0, FxCreate: // iVersion
0, FxConnect:// xCreate - create a new virtual table
0, FxBestIndex:// xConnect - connect to an existing vtab
0, FxDisconnect:// xBestIndex - find the best query index
0, FxDestroy:// xDisconnect - disconnect a vtab
0, FxOpen:// xDestroy - destroy a vtab
0, FxClose:// xOpen - open a cursor
0, FxFilter:// xClose - close a cursor
0, FxNext:// xFilter - configure scan constraints
0, FxEof:// xNext - advance a cursor
0, FxColumn:// xEof
0, FxRowid:// xColumn - read data
0, FxUpdate:// xRowid - read data
uintptr(0), FxBegin:// xUpdate
uintptr(0), FxSync:// xBegin
uintptr(0), FxCommit:// xSync
uintptr(0), FxRollback:// xCommit
uintptr(0), FxFindFunction:// xRollback
uintptr(0), FxRename:// xFindMethod
uintptr(0), // xRename
} /* test_intarray.c:187:23 */

// Invoke this routine to create a specific instance of an intarray object.
// The new intarray object is returned by the 3rd parameter.
//
// Each intarray object corresponds to a virtual table in the TEMP table
// with a name of zName.
//
// Destroy the intarray object by dropping the virtual table.  If not done
// explicitly by the application, the virtual table will be dropped implicitly
// by the system when the database connection is closed.
func sqlite3_intarray_create(tls *crt.TLS, db uintptr, zName uintptr, ppReturn uintptr) int32 { /* test_intarray.c:223:16: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var rc int32 = 0
	var p uintptr

	*(*uintptr)(unsafe.Pointer(ppReturn)) = crt.AssignUintptr(&p, sqlite3.Xsqlite3_malloc64(tls, uint64(unsafe.Sizeof(sqlite3_intarray{}))))
	if p == uintptr(0) {
		return 7
	}
	crt.Xmemset(tls, p, 0, uint64(unsafe.Sizeof(sqlite3_intarray{})))
	rc = sqlite3.Xsqlite3_create_module_v2(tls, db, zName, uintptr(unsafe.Pointer(&intarrayModule)), p,
		*(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, uintptr) }{intarrayFree})))
	if rc == 0 {
		var zSql uintptr
		zSql = sqlite3.Xsqlite3_mprintf(tls, ts+37612, /* "CREATE VIRTUAL T..." */
			crt.VaList(bp, zName, zName))
		rc = sqlite3.Xsqlite3_exec(tls, db, zSql, uintptr(0), uintptr(0), uintptr(0))
		sqlite3.Xsqlite3_free(tls, zSql)
	}
	return rc
}

// Bind a new array array of integers to a specific intarray object.
//
// The array of integers bound must be unchanged for the duration of
// any query against the corresponding virtual table.  If the integer
// array does change or is deallocated undefined behavior will result.
func sqlite3_intarray_bind(tls *crt.TLS, pIntArray uintptr, nElements int32, aElements uintptr, xFree uintptr) int32 { /* test_intarray.c:257:16: */
	if (*sqlite3_intarray)(unsafe.Pointer(pIntArray)).FxFree != 0 {
		(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((pIntArray + 16 /* &.xFree */))))(tls, (*sqlite3_intarray)(unsafe.Pointer(pIntArray)).Fa)
	}
	(*sqlite3_intarray)(unsafe.Pointer(pIntArray)).Fn = nElements
	(*sqlite3_intarray)(unsafe.Pointer(pIntArray)).Fa = aElements
	(*sqlite3_intarray)(unsafe.Pointer(pIntArray)).FxFree = xFree
	return 0
}

//    sqlite3_intarray_create  DB  NAME
//
// Invoke the sqlite3_intarray_create interface.  A string that becomes
// the first parameter to sqlite3_intarray_bind.
func test_intarray_create(tls *crt.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_intarray.c:300:26: */
	bp := tls.Alloc(148)
	defer tls.Free(148)

	// var db uintptr at bp+32, 8

	var zName uintptr
	// var pArray uintptr at bp+40, 8

	var rc int32 = 0
	// var zPtr [100]int8 at bp+48, 100

	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+2452 /* "DB" */)
		return 1
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), bp+32 /* &db */) != 0 {
		return 1
	}
	zName = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)))
	rc = sqlite3_intarray_create(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* db */)), zName, bp+40 /* &pArray */)
	if rc != 0 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0)))
		return 1
	}
	sqlite3TestMakePointerStr(tls, interp, bp+48 /* &zPtr[0] */, *(*uintptr)(unsafe.Pointer(bp + 40 /* pArray */)))
	tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+16, bp+48 /* &zPtr[0] */, uintptr(0)))
	return 0
}

//    sqlite3_intarray_bind  INTARRAY  ?VALUE ...?
//
// Invoke the sqlite3_intarray_bind interface on the given array of integers.
func test_intarray_bind(tls *crt.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_intarray.c:335:26: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	var pArray uintptr
	var rc int32 = 0
	var i int32
	var n int32
	var a uintptr

	if objc < 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+37650 /* "INTARRAY" */)
		return 1
	}
	pArray = sqlite3TestTextToPtr(tls, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))))
	n = (objc - 2)
	a = sqlite3.Xsqlite3_malloc64(tls, (uint64(uint64(unsafe.Sizeof(sqlite3_int64(0))) * uint64(n))))
	if a == uintptr(0) {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+37659 /* "SQLITE_NOMEM" */, uintptr(0)))
		return 1
	}
	for i = 0; i < n; i++ {
		*(*Tcl_WideInt)(unsafe.Pointer(bp + 32 /* x */)) = int64(0)
		tcl.XTcl_GetWideIntFromObj(tls, uintptr(0), *(*uintptr)(unsafe.Pointer(objv + uintptr((i+2))*8)), bp+32 /* &x */)
		*(*sqlite3_int64)(unsafe.Pointer(a + uintptr(i)*8)) = sqlite3_int64(*(*Tcl_WideInt)(unsafe.Pointer(bp + 32 /* x */)))
	}
	rc = sqlite3_intarray_bind(tls, pArray, n, a, *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, uintptr) }{sqlite3.Xsqlite3_free})))
	if rc != 0 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+16, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0)))
		return 1
	}
	return 0
}

// Register commands with the TCL interpreter.
func Sqlitetestintarray_Init(tls *crt.TLS, interp uintptr) int32 { /* test_intarray.c:375:5: */
	var i int32
	for i = 0; uint64(i) < (uint64(unsafe.Sizeof(aObjCmd10)) / uint64(unsafe.Sizeof(struct {
		FzName      uintptr
		FxProc      uintptr
		FclientData uintptr
	}{}))); i++ {
		tcl.XTcl_CreateObjCommand(tls, interp, aObjCmd10[i].FzName,
			aObjCmd10[i].FxProc, aObjCmd10[i].FclientData, uintptr(0))
	}
	return 0
}

var aObjCmd10 = [2]struct {
	FzName      uintptr
	FxProc      uintptr
	FclientData uintptr
}{
	{FzName: ts + 37672 /* "sqlite3_intarray..." */, FxProc: 0, FclientData: uintptr(0)},
	{FzName: ts + 37696 /* "sqlite3_intarray..." */, FxProc: 0, FclientData: uintptr(0)},
} /* test_intarray.c:380:5 */

// Maximum pathname length supported by the jt backend.

// Name used to identify this VFS.

type jt_file1 = struct {
	Fbase      sqlite3_file
	FzName     uintptr
	Fflags     int32
	FeLock     int32
	FnPage     u32
	FnPagesize u32
	FpWritable uintptr
	FaCksum    uintptr
	FnSync     int32
	FiMaxOff   sqlite3_int64
	FpNext     uintptr
	FpReal     uintptr
}

// Maximum pathname length supported by the jt backend.

// Name used to identify this VFS.

type jt_file = jt_file1 /* test_journal.c:111:24 */

var jt_vfs = sqlite3_vfs{FiVersion: 2, FszOsFile: // iVersion
int32(unsafe.Sizeof(jt_file{})), FmxPathname:// szOsFile
512, FpNext:// mxPathname
uintptr(0), FzName:// pNext
ts + 37718, /* "jt" */ FpAppData:// zName
uintptr(0), FxOpen:// pAppData
0, FxDelete:// xOpen
0, FxAccess:// xDelete
0, FxFullPathname:// xAccess
0, FxDlOpen:// xFullPathname
0, FxDlError:// xDlOpen
0, FxDlSym:// xDlError
0, FxDlClose:// xDlSym
0, FxRandomness:// xDlClose
0, FxSleep:// xRandomness
0, FxCurrentTime:// xSleep
0, FxGetLastError:// xCurrentTime
0, FxCurrentTimeInt64:// xGetLastError
0, // xCurrentTimeInt64
} /* test_journal.c:165:20 */

var jt_io_methods = sqlite3_io_methods{FiVersion: 1, FxClose: // iVersion
0, FxRead:// xClose
0, FxWrite:// xRead
0, FxTruncate:// xWrite
0, FxSync:// xTruncate
0, FxFileSize:// xSync
0, FxLock:// xFileSize
0, FxUnlock:// xLock
0, FxCheckReservedLock:// xUnlock
0, FxFileControl:// xCheckReservedLock
0, FxSectorSize:// xFileControl
0, FxDeviceCharacteristics:// xSectorSize
0, // xDeviceCharacteristics
} /* test_journal.c:187:27 */

type JtGlobal = struct {
	FpVfs  uintptr
	FpList uintptr
}

var g2 = JtGlobal{FpVfs: uintptr(0), FpList: uintptr(0)} /* test_journal.c:207:24 */

// Functions to obtain and relinquish a mutex to protect g.pList. The
// STATIC_PRNG mutex is reused, purely for the sake of convenience.
func enterJtMutex(tls *crt.TLS) { /* test_journal.c:213:13: */
	sqlite3.Xsqlite3_mutex_enter(tls, sqlite3.Xsqlite3_mutex_alloc(tls, 5))
}
func leaveJtMutex(tls *crt.TLS) { /* test_journal.c:216:13: */
	sqlite3.Xsqlite3_mutex_leave(tls, sqlite3.Xsqlite3_mutex_alloc(tls, 5))
}
func stop_ioerr_simulation(tls *crt.TLS, piSave uintptr, piSave2 uintptr) { /* test_journal.c:222:13: */
	*(*int32)(unsafe.Pointer(piSave)) = sqlite3.Xsqlite3_io_error_pending
	*(*int32)(unsafe.Pointer(piSave2)) = sqlite3.Xsqlite3_io_error_hit
	sqlite3.Xsqlite3_io_error_pending = -1
	sqlite3.Xsqlite3_io_error_hit = 0
}
func start_ioerr_simulation(tls *crt.TLS, iSave int32, iSave2 int32) { /* test_journal.c:228:13: */
	sqlite3.Xsqlite3_io_error_pending = iSave
	sqlite3.Xsqlite3_io_error_hit = iSave2
}

// The jt_file pointed to by the argument may or may not be a file-handle
// open on a main database file. If it is, and a transaction is currently
// opened on the file, then discard all transaction related data.
func closeTransaction(tls *crt.TLS, p uintptr) { /* test_journal.c:238:13: */
	sqlite3.Xsqlite3BitvecDestroy(tls, (*jt_file)(unsafe.Pointer(p)).FpWritable)
	sqlite3.Xsqlite3_free(tls, (*jt_file)(unsafe.Pointer(p)).FaCksum)
	(*jt_file)(unsafe.Pointer(p)).FpWritable = uintptr(0)
	(*jt_file)(unsafe.Pointer(p)).FaCksum = uintptr(0)
	(*jt_file)(unsafe.Pointer(p)).FnSync = 0
}

// Close an jt-file.
func jtClose(tls *crt.TLS, pFile uintptr) int32 { /* test_journal.c:249:12: */
	var pp uintptr
	var p uintptr = pFile

	closeTransaction(tls, p)
	enterJtMutex(tls)
	if (*jt_file)(unsafe.Pointer(p)).FzName != 0 {
		for pp = (uintptr(unsafe.Pointer(&g2)) + 8 /* &.pList */); *(*uintptr)(unsafe.Pointer(pp)) != p; pp = (*(*uintptr)(unsafe.Pointer(pp)) + 64 /* &.pNext */) {
		}
		*(*uintptr)(unsafe.Pointer(pp)) = (*jt_file)(unsafe.Pointer(p)).FpNext
	}
	leaveJtMutex(tls)
	sqlite3.Xsqlite3OsClose(tls, (*jt_file)(unsafe.Pointer(p)).FpReal)
	return 0
}

// Read data from an jt-file.
func jtRead(tls *crt.TLS, pFile uintptr, zBuf uintptr, iAmt int32, iOfst sqlite_int64) int32 { /* test_journal.c:267:12: */
	var p uintptr = pFile
	return sqlite3.Xsqlite3OsRead(tls, (*jt_file)(unsafe.Pointer(p)).FpReal, zBuf, iAmt, iOfst)
}

//
// Parameter zJournal is the name of a journal file that is currently
// open. This function locates and returns the handle opened on the
// corresponding database file by the pager that currently has the
// journal file opened. This file-handle is identified by the
// following properties:
//
//   a) SQLITE_OPEN_MAIN_DB was specified when the file was opened.
//
//   b) The file-name specified when the file was opened matches
//      all but the final 8 characters of the journal file name.
//
//   c) There is currently a reserved lock on the file. This
//      condition is waived if the noLock argument is non-zero.
//
func locateDatabaseHandle(tls *crt.TLS, zJournal uintptr, noLock int32) uintptr { /* test_journal.c:292:16: */
	var pMain uintptr = uintptr(0)
	enterJtMutex(tls)
	for pMain = g2.FpList; pMain != 0; pMain = (*jt_file)(unsafe.Pointer(pMain)).FpNext {
		var nName int32 = (int32(crt.Xstrlen(tls, zJournal) - crt.Xstrlen(tls, ts+37721 /* "-journal" */)))
		if (((((*jt_file)(unsafe.Pointer(pMain)).Fflags & 0x00000100) != 0) &&
			(int32(crt.Xstrlen(tls, (*jt_file)(unsafe.Pointer(pMain)).FzName)) == nName)) &&
			(0 == crt.Xmemcmp(tls, (*jt_file)(unsafe.Pointer(pMain)).FzName, zJournal, uint64(nName)))) &&
			(((*jt_file)(unsafe.Pointer(pMain)).FeLock >= 2) || (noLock != 0)) {
			break
		}
	}
	leaveJtMutex(tls)
	return pMain
}

// Parameter z points to a buffer of 4 bytes in size containing a
// unsigned 32-bit integer stored in big-endian format. Decode the
// integer and return its value.
func decodeUint32(tls *crt.TLS, z uintptr) u32 { /* test_journal.c:314:12: */
	return (u32((((int32(*(*uint8)(unsafe.Pointer(z + uintptr(0)))) << 24) + (int32(*(*uint8)(unsafe.Pointer(z + uintptr(1)))) << 16)) + (int32(*(*uint8)(unsafe.Pointer(z + uintptr(2)))) << 8)) + int32(*(*uint8)(unsafe.Pointer(z + uintptr(3))))))
}

// Calculate a checksum from the buffer of length n bytes pointed to
// by parameter z.
func genCksum(tls *crt.TLS, z uintptr, n int32) u32 { /* test_journal.c:322:12: */
	var i int32
	var cksum u32 = u32(0)
	for i = 0; i < n; i++ {
		cksum = ((cksum + u32(*(*uint8)(unsafe.Pointer(z + uintptr(i))))) + (cksum << 3))
	}
	return cksum
}

// The first argument, zBuf, points to a buffer containing a 28 byte
// serialized journal header. This function deserializes four of the
// integer fields contained in the journal header and writes their
// values to the output variables.
//
// SQLITE_OK is returned if the journal-header is successfully
// decoded. Otherwise, SQLITE_ERROR.
func decodeJournalHdr(tls *crt.TLS, zBuf uintptr, pnRec uintptr, pnPage uintptr, pnSector uintptr, pnPagesize uintptr) int32 { /* test_journal.c:340:12: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	*(*[8]uint8)(unsafe.Pointer(bp /* aMagic */)) = [8]uint8{uint8(0xd9), uint8(0xd5), uint8(0x05), uint8(0xf9), uint8(0x20), uint8(0xa1), uint8(0x63), uint8(0xd7)}
	if crt.Xmemcmp(tls, bp /* &aMagic[0] */, zBuf, uint64(8)) != 0 {
		return 1
	}
	if pnRec != 0 {
		*(*u32)(unsafe.Pointer(pnRec)) = decodeUint32(tls, (zBuf + uintptr(8)))
	}
	if pnPage != 0 {
		*(*u32)(unsafe.Pointer(pnPage)) = decodeUint32(tls, (zBuf + uintptr(16)))
	}
	if pnSector != 0 {
		*(*u32)(unsafe.Pointer(pnSector)) = decodeUint32(tls, (zBuf + uintptr(20)))
	}
	if pnPagesize != 0 {
		*(*u32)(unsafe.Pointer(pnPagesize)) = decodeUint32(tls, (zBuf + uintptr(24)))
	}
	return 0
}

// This function is called when a new transaction is opened, just after
// the first journal-header is written to the journal file.
func openTransaction(tls *crt.TLS, pMain uintptr, pJournal uintptr) int32 { /* test_journal.c:360:12: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var aData uintptr
	var p uintptr = (*jt_file)(unsafe.Pointer(pMain)).FpReal
	var rc int32 = 0

	closeTransaction(tls, pMain)
	aData = sqlite3.Xsqlite3_malloc(tls, int32((*jt_file)(unsafe.Pointer(pMain)).FnPagesize))
	(*jt_file)(unsafe.Pointer(pMain)).FpWritable = sqlite3.Xsqlite3BitvecCreate(tls, (*jt_file)(unsafe.Pointer(pMain)).FnPage)
	(*jt_file)(unsafe.Pointer(pMain)).FaCksum = sqlite3.Xsqlite3_malloc(tls, (int32(uint64(unsafe.Sizeof(u32(0))) * (uint64((*jt_file)(unsafe.Pointer(pMain)).FnPage + u32(1))))))
	(*jt_file)(unsafe.Pointer(pJournal)).FiMaxOff = int64(0)

	if (!(int32((*jt_file)(unsafe.Pointer(pMain)).FpWritable) != 0) || !(int32((*jt_file)(unsafe.Pointer(pMain)).FaCksum) != 0)) || !(aData != 0) {
		rc = (10 | (int32(12) << 8))
	} else if (*jt_file)(unsafe.Pointer(pMain)).FnPage > u32(0) {
		var iTrunk u32
		// var iSave int32 at bp, 4

		// var iSave2 int32 at bp+4, 4

		stop_ioerr_simulation(tls, bp /* &iSave */, bp+4 /* &iSave2 */)

		// Read the database free-list. Add the page-number for each free-list
		// leaf to the jt_file.pWritable bitvec.
		rc = sqlite3.Xsqlite3OsRead(tls, p, aData, int32((*jt_file)(unsafe.Pointer(pMain)).FnPagesize), int64(0))
		if rc == 0 {
			var nDbsize u32 = decodeUint32(tls, (aData + uintptr(28)))
			if (nDbsize > u32(0)) && (crt.Xmemcmp(tls, (aData+uintptr(24)), (aData+uintptr(92)), uint64(4)) == 0) {
				var iPg u32
				for iPg = (nDbsize + u32(1)); iPg <= (*jt_file)(unsafe.Pointer(pMain)).FnPage; iPg++ {
					sqlite3.Xsqlite3BitvecSet(tls, (*jt_file)(unsafe.Pointer(pMain)).FpWritable, iPg)
				}
			}
		}
		iTrunk = decodeUint32(tls, (aData + uintptr(32)))
		for (rc == 0) && (iTrunk > u32(0)) {
			var nLeaf u32
			var iLeaf u32
			var iOff sqlite3_int64 = ((i64(iTrunk - u32(1))) * i64((*jt_file)(unsafe.Pointer(pMain)).FnPagesize))
			rc = sqlite3.Xsqlite3OsRead(tls, p, aData, int32((*jt_file)(unsafe.Pointer(pMain)).FnPagesize), iOff)
			nLeaf = decodeUint32(tls, (aData + uintptr(4)))
			for iLeaf = u32(0); (rc == 0) && (iLeaf < nLeaf); iLeaf++ {
				var pgno u32 = decodeUint32(tls, (aData + uintptr((u32(8) + (u32(4) * iLeaf)))))
				sqlite3.Xsqlite3BitvecSet(tls, (*jt_file)(unsafe.Pointer(pMain)).FpWritable, pgno)
			}
			iTrunk = decodeUint32(tls, aData)
		}

		// Calculate and store a checksum for each page in the database file.
		if rc == 0 {
			var ii int32
			for ii = 0; (rc == 0) && (ii < int32((*jt_file)(unsafe.Pointer(pMain)).FnPage)); ii++ {
				var iOff i64 = ((i64((*jt_file)(unsafe.Pointer(pMain)).FnPagesize)) * i64(ii))
				if iOff == i64(sqlite3.Xsqlite3PendingByte) {
					continue
				}
				rc = sqlite3.Xsqlite3OsRead(tls, (*jt_file)(unsafe.Pointer(pMain)).FpReal, aData, int32((*jt_file)(unsafe.Pointer(pMain)).FnPagesize), iOff)
				*(*u32)(unsafe.Pointer((*jt_file)(unsafe.Pointer(pMain)).FaCksum + uintptr(ii)*4)) = genCksum(tls, aData, int32((*jt_file)(unsafe.Pointer(pMain)).FnPagesize))
				if ((ii + 1) == int32((*jt_file)(unsafe.Pointer(pMain)).FnPage)) && (rc == (10 | (int32(2) << 8))) {
					rc = 0
				}
			}
		}

		start_ioerr_simulation(tls, *(*int32)(unsafe.Pointer(bp /* iSave */)), *(*int32)(unsafe.Pointer(bp + 4 /* iSave2 */)))
	}

	sqlite3.Xsqlite3_free(tls, aData)
	return rc
}

// The first argument to this function is a handle open on a journal file.
// This function reads the journal file and adds the page number for each
// page in the journal to the Bitvec object passed as the second argument.
func readJournalFile(tls *crt.TLS, p uintptr, pMain uintptr) int32 { /* test_journal.c:433:12: */
	bp := tls.Alloc(52)
	defer tls.Free(52)

	var rc int32
	// var zBuf [28]uint8 at bp+8, 28

	var pReal uintptr
	var iOff sqlite3_int64
	var iSize sqlite3_int64
	var aPage uintptr
	// var iSave int32 at bp, 4

	// var iSave2 int32 at bp+4, 4

	var cksum u32
	_ = cksum
	var pgno u32
	// var nRec u32 at bp+36, 4

	// var nPage u32 at bp+40, 4

	// var nSector u32 at bp+44, 4

	// var nPagesize u32 at bp+48, 4

	var ii u32
	rc = 0
	pReal = (*jt_file)(unsafe.Pointer(p)).FpReal
	iOff = int64(0)
	iSize = (*jt_file)(unsafe.Pointer(p)).FiMaxOff

	aPage = sqlite3.Xsqlite3_malloc(tls, int32((*jt_file)(unsafe.Pointer(pMain)).FnPagesize))
	if !(!(aPage != 0)) {
		goto __1
	}
	return (10 | (int32(12) << 8))
__1:
	;

	stop_ioerr_simulation(tls, bp /* &iSave */, bp+4 /* &iSave2 */)

__2:
	if !((rc == 0) && (iOff < iSize)) {
		goto __3
	}

	// Read and decode the next journal-header from the journal file.
	rc = sqlite3.Xsqlite3OsRead(tls, pReal, bp+8 /* &zBuf[0] */, 28, iOff)
	if !((rc != 0) ||
		(decodeJournalHdr(tls, bp+8 /* &zBuf[0] */, bp+36 /* &nRec */, bp+40 /* &nPage */, bp+44 /* &nSector */, bp+48 /* &nPagesize */) != 0)) {
		goto __4
	}
	goto finish_rjf
__4:
	;
	iOff = iOff + (sqlite3_int64(*(*u32)(unsafe.Pointer(bp + 44 /* nSector */))))

	if !(*(*u32)(unsafe.Pointer(bp + 36 /* nRec */)) == u32(0)) {
		goto __5
	}
	// A trick. There might be another journal-header immediately
	// following this one. In this case, 0 records means 0 records,
	// not "read until the end of the file". See also ticket #2565.
	if !(iSize >= (iOff + sqlite3_int64(*(*u32)(unsafe.Pointer(bp + 44 /* nSector */))))) {
		goto __6
	}
	rc = sqlite3.Xsqlite3OsRead(tls, pReal, bp+8 /* &zBuf[0] */, 28, iOff)
	if !((rc != 0) || (0 == decodeJournalHdr(tls, bp+8 /* &zBuf[0] */, uintptr(0), uintptr(0), uintptr(0), uintptr(0)))) {
		goto __7
	}
	goto __2
__7:
	;
__6:
	;
	*(*u32)(unsafe.Pointer(bp + 36 /* nRec */)) = (u32((iSize - iOff) / (sqlite3_int64((*jt_file)(unsafe.Pointer(pMain)).FnPagesize + u32(8)))))
__5:
	;

	// Read all the records that follow the journal-header just read.
	ii = u32(0)
__8:
	if !(((rc == 0) && (ii < *(*u32)(unsafe.Pointer(bp + 36 /* nRec */)))) && (iOff < iSize)) {
		goto __10
	}
	rc = sqlite3.Xsqlite3OsRead(tls, pReal, bp+8 /* &zBuf[0] */, 4, iOff)
	if !(rc == 0) {
		goto __11
	}
	pgno = decodeUint32(tls, bp+8 /* &zBuf[0] */)
	if !((pgno > u32(0)) && (pgno <= (*jt_file)(unsafe.Pointer(pMain)).FnPage)) {
		goto __12
	}
	if !(0 == sqlite3.Xsqlite3BitvecTest(tls, (*jt_file)(unsafe.Pointer(pMain)).FpWritable, pgno)) {
		goto __13
	}
	rc = sqlite3.Xsqlite3OsRead(tls, pReal, aPage, int32((*jt_file)(unsafe.Pointer(pMain)).FnPagesize), (iOff + int64(4)))
	if !(rc == 0) {
		goto __14
	}
	cksum = genCksum(tls, aPage, int32((*jt_file)(unsafe.Pointer(pMain)).FnPagesize))
__14:
	;
__13:
	;
	sqlite3.Xsqlite3BitvecSet(tls, (*jt_file)(unsafe.Pointer(pMain)).FpWritable, pgno)
__12:
	;
	iOff = iOff + (sqlite3_int64(u32(8) + (*jt_file)(unsafe.Pointer(pMain)).FnPagesize))
__11:
	;
	goto __9
__9:
	ii++
	goto __8
	goto __10
__10:
	;

	iOff = (((iOff + (sqlite3_int64(*(*u32)(unsafe.Pointer(bp + 44 /* nSector */)) - u32(1)))) / sqlite3_int64(*(*u32)(unsafe.Pointer(bp + 44 /* nSector */)))) * sqlite3_int64(*(*u32)(unsafe.Pointer(bp + 44 /* nSector */))))
	goto __2
__3:
	;

finish_rjf:
	start_ioerr_simulation(tls, *(*int32)(unsafe.Pointer(bp /* iSave */)), *(*int32)(unsafe.Pointer(bp + 4 /* iSave2 */)))
	sqlite3.Xsqlite3_free(tls, aPage)
	if !(rc == (10 | (int32(2) << 8))) {
		goto __15
	}
	rc = 0
__15:
	;
	return rc
}

// Write data to an jt-file.
func jtWrite(tls *crt.TLS, pFile uintptr, zBuf uintptr, iAmt int32, iOfst sqlite_int64) int32 { /* test_journal.c:512:12: */
	var rc int32
	var p uintptr = pFile
	if ((*jt_file)(unsafe.Pointer(p)).Fflags & 0x00000800) != 0 {
		if iOfst == int64(0) {
			var pMain uintptr = locateDatabaseHandle(tls, (*jt_file)(unsafe.Pointer(p)).FzName, 0)

			if iAmt == 28 {
				// Zeroing the first journal-file header. This is the end of a
				// transaction.
				closeTransaction(tls, pMain)
			} else if iAmt != 12 {
				// Writing the first journal header to a journal file. This happens
				// when a transaction is first started.
				var z uintptr = zBuf
				(*jt_file)(unsafe.Pointer(pMain)).FnPage = decodeUint32(tls, (z + uintptr(16)))
				(*jt_file)(unsafe.Pointer(pMain)).FnPagesize = decodeUint32(tls, (z + uintptr(24)))
				if 0 != (crt.AssignInt32(&rc, openTransaction(tls, pMain, p))) {
					return rc
				}
			}
		}
		if (*jt_file)(unsafe.Pointer(p)).FiMaxOff < (iOfst + sqlite_int64(iAmt)) {
			(*jt_file)(unsafe.Pointer(p)).FiMaxOff = (iOfst + sqlite_int64(iAmt))
		}
	}

	if (((*jt_file)(unsafe.Pointer(p)).Fflags & 0x00000100) != 0) && ((*jt_file)(unsafe.Pointer(p)).FpWritable != 0) {
		if (((iAmt < int32((*jt_file)(unsafe.Pointer(p)).FnPagesize)) &&
			(((*jt_file)(unsafe.Pointer(p)).FnPagesize % u32(iAmt)) == u32(0))) &&
			(iOfst >= (sqlite_int64(sqlite3.Xsqlite3PendingByte + 512)))) &&
			((iOfst + sqlite_int64(iAmt)) <= (sqlite_int64(u32(sqlite3.Xsqlite3PendingByte) + (*jt_file)(unsafe.Pointer(p)).FnPagesize))) {
		} else {
			var pgno u32 = (u32((iOfst / sqlite_int64((*jt_file)(unsafe.Pointer(p)).FnPagesize)) + int64(1)))
			_ = pgno

			// The following assert() statements may fail if this layer is used
			// with a connection in "PRAGMA synchronous=off" mode. If they
			// fail with sync=normal or sync=full, this may indicate problem.

		}
	}

	rc = sqlite3.Xsqlite3OsWrite(tls, (*jt_file)(unsafe.Pointer(p)).FpReal, zBuf, iAmt, iOfst)
	if (((*jt_file)(unsafe.Pointer(p)).Fflags & 0x00000800) != 0) && (iAmt == 12) {
		var pMain uintptr = locateDatabaseHandle(tls, (*jt_file)(unsafe.Pointer(p)).FzName, 0)
		var rc2 int32 = readJournalFile(tls, p, pMain)
		if rc == 0 {
			rc = rc2
		}
	}
	return rc
}

// Truncate an jt-file.
func jtTruncate(tls *crt.TLS, pFile uintptr, size sqlite_int64) int32 { /* test_journal.c:580:12: */
	var p uintptr = pFile
	if (((*jt_file)(unsafe.Pointer(p)).Fflags & 0x00000800) != 0) && (size == int64(0)) {
		// Truncating a journal file. This is the end of a transaction.
		var pMain uintptr = locateDatabaseHandle(tls, (*jt_file)(unsafe.Pointer(p)).FzName, 0)
		closeTransaction(tls, pMain)
	}
	if (((*jt_file)(unsafe.Pointer(p)).Fflags & 0x00000100) != 0) && ((*jt_file)(unsafe.Pointer(p)).FpWritable != 0) {
		var pgno u32
		var locking_page u32 = ((u32(sqlite3.Xsqlite3PendingByte) / (*jt_file)(unsafe.Pointer(p)).FnPagesize) + u32(1))
		_ = locking_page
		for pgno = (u32((size / sqlite_int64((*jt_file)(unsafe.Pointer(p)).FnPagesize)) + int64(1))); pgno <= (*jt_file)(unsafe.Pointer(p)).FnPage; pgno++ {
		}
	}
	return sqlite3.Xsqlite3OsTruncate(tls, (*jt_file)(unsafe.Pointer(p)).FpReal, size)
}

// Sync an jt-file.
func jtSync(tls *crt.TLS, pFile uintptr, flags int32) int32 { /* test_journal.c:600:12: */
	var p uintptr = pFile

	if ((*jt_file)(unsafe.Pointer(p)).Fflags & 0x00000800) != 0 {
		var rc int32
		var pMain uintptr // The associated database file

		// The journal file is being synced. At this point, we inspect the
		// contents of the file up to this point and set each bit in the
		// jt_file.pWritable bitvec of the main database file associated with
		// this journal file.
		pMain = locateDatabaseHandle(tls, (*jt_file)(unsafe.Pointer(p)).FzName, 0)

		// Set the bitvec values
		if (pMain != 0) && ((*jt_file)(unsafe.Pointer(pMain)).FpWritable != 0) {
			(*jt_file)(unsafe.Pointer(pMain)).FnSync++
			rc = readJournalFile(tls, p, pMain)
			if rc != 0 {
				return rc
			}
		}
	}

	return sqlite3.Xsqlite3OsSync(tls, (*jt_file)(unsafe.Pointer(p)).FpReal, flags)
}

// Return the current file-size of an jt-file.
func jtFileSize(tls *crt.TLS, pFile uintptr, pSize uintptr) int32 { /* test_journal.c:630:12: */
	var p uintptr = pFile
	return sqlite3.Xsqlite3OsFileSize(tls, (*jt_file)(unsafe.Pointer(p)).FpReal, pSize)
}

// Lock an jt-file.
func jtLock(tls *crt.TLS, pFile uintptr, eLock int32) int32 { /* test_journal.c:638:12: */
	var rc int32
	var p uintptr = pFile
	rc = sqlite3.Xsqlite3OsLock(tls, (*jt_file)(unsafe.Pointer(p)).FpReal, eLock)
	if (rc == 0) && (eLock > (*jt_file)(unsafe.Pointer(p)).FeLock) {
		(*jt_file)(unsafe.Pointer(p)).FeLock = eLock
	}
	return rc
}

// Unlock an jt-file.
func jtUnlock(tls *crt.TLS, pFile uintptr, eLock int32) int32 { /* test_journal.c:651:12: */
	var rc int32
	var p uintptr = pFile
	rc = sqlite3.Xsqlite3OsUnlock(tls, (*jt_file)(unsafe.Pointer(p)).FpReal, eLock)
	if (rc == 0) && (eLock < (*jt_file)(unsafe.Pointer(p)).FeLock) {
		(*jt_file)(unsafe.Pointer(p)).FeLock = eLock
	}
	return rc
}

// Check if another file-handle holds a RESERVED lock on an jt-file.
func jtCheckReservedLock(tls *crt.TLS, pFile uintptr, pResOut uintptr) int32 { /* test_journal.c:664:12: */
	var p uintptr = pFile
	return sqlite3.Xsqlite3OsCheckReservedLock(tls, (*jt_file)(unsafe.Pointer(p)).FpReal, pResOut)
}

// File control method. For custom operations on an jt-file.
func jtFileControl(tls *crt.TLS, pFile uintptr, op int32, pArg uintptr) int32 { /* test_journal.c:672:12: */
	var p uintptr = pFile
	return (*(*func(*crt.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer((*jt_file)(unsafe.Pointer(p)).FpReal)).FpMethods + 80 /* &.xFileControl */))))(tls, (*jt_file)(unsafe.Pointer(p)).FpReal, op, pArg)
}

// Return the sector-size in bytes for an jt-file.
func jtSectorSize(tls *crt.TLS, pFile uintptr) int32 { /* test_journal.c:680:12: */
	var p uintptr = pFile
	return sqlite3.Xsqlite3OsSectorSize(tls, (*jt_file)(unsafe.Pointer(p)).FpReal)
}

// Return the device characteristic flags supported by an jt-file.
func jtDeviceCharacteristics(tls *crt.TLS, pFile uintptr) int32 { /* test_journal.c:688:12: */
	var p uintptr = pFile
	return sqlite3.Xsqlite3OsDeviceCharacteristics(tls, (*jt_file)(unsafe.Pointer(p)).FpReal)
}

// Open an jt file handle.
func jtOpen(tls *crt.TLS, pVfs uintptr, zName uintptr, pFile uintptr, flags int32, pOutFlags uintptr) int32 { /* test_journal.c:696:12: */
	var rc int32
	var p uintptr = pFile
	(*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods = uintptr(0)
	(*jt_file)(unsafe.Pointer(p)).FpReal = (p + uintptr(1)*80)
	(*sqlite3_file)(unsafe.Pointer((*jt_file)(unsafe.Pointer(p)).FpReal)).FpMethods = uintptr(0)
	rc = sqlite3.Xsqlite3OsOpen(tls, g2.FpVfs, zName, (*jt_file)(unsafe.Pointer(p)).FpReal, flags, pOutFlags)

	if rc == 0 {
		(*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods = uintptr(unsafe.Pointer(&jt_io_methods))
		(*jt_file)(unsafe.Pointer(p)).FeLock = 0
		(*jt_file)(unsafe.Pointer(p)).FzName = zName
		(*jt_file)(unsafe.Pointer(p)).Fflags = flags
		(*jt_file)(unsafe.Pointer(p)).FpNext = uintptr(0)
		(*jt_file)(unsafe.Pointer(p)).FpWritable = uintptr(0)
		(*jt_file)(unsafe.Pointer(p)).FaCksum = uintptr(0)
		enterJtMutex(tls)
		if zName != 0 {
			(*jt_file)(unsafe.Pointer(p)).FpNext = g2.FpList
			g2.FpList = p
		}
		leaveJtMutex(tls)
	}
	return rc
}

// Delete the file located at zPath. If the dirSync argument is true,
// ensure the file-system modifications are synced to disk before
// returning.
func jtDelete(tls *crt.TLS, pVfs uintptr, zPath uintptr, dirSync int32) int32 { /* test_journal.c:733:12: */
	var nPath int32 = int32(crt.Xstrlen(tls, zPath))
	if (nPath > 8) && (0 == crt.Xstrcmp(tls, ts+37721 /* "-journal" */, (zPath+uintptr((nPath-8))))) {
		// Deleting a journal file. The end of a transaction.
		var pMain uintptr = locateDatabaseHandle(tls, zPath, 0)
		if pMain != 0 {
			closeTransaction(tls, pMain)
		}
	}

	return sqlite3.Xsqlite3OsDelete(tls, g2.FpVfs, zPath, dirSync)
}

// Test for access permissions. Return true if the requested permission
// is available, or false otherwise.
func jtAccess(tls *crt.TLS, pVfs uintptr, zPath uintptr, flags int32, pResOut uintptr) int32 { /* test_journal.c:750:12: */
	return sqlite3.Xsqlite3OsAccess(tls, g2.FpVfs, zPath, flags, pResOut)
}

// Populate buffer zOut with the full canonical pathname corresponding
// to the pathname in zPath. zOut is guaranteed to point to a buffer
// of at least (JT_MAX_PATHNAME+1) bytes.
func jtFullPathname(tls *crt.TLS, pVfs uintptr, zPath uintptr, nOut int32, zOut uintptr) int32 { /* test_journal.c:764:12: */
	return sqlite3.Xsqlite3OsFullPathname(tls, g2.FpVfs, zPath, nOut, zOut)
}

// Open the dynamic library located at zPath and return a handle.
func jtDlOpen(tls *crt.TLS, pVfs uintptr, zPath uintptr) uintptr { /* test_journal.c:776:13: */
	return (*(*func(*crt.TLS, uintptr, uintptr) uintptr)(unsafe.Pointer((g2.FpVfs + 72 /* &.xDlOpen */))))(tls, g2.FpVfs, zPath)
}

// Populate the buffer zErrMsg (size nByte bytes) with a human readable
// utf-8 string describing the most recent error encountered associated
// with dynamic libraries.
func jtDlError(tls *crt.TLS, pVfs uintptr, nByte int32, zErrMsg uintptr) { /* test_journal.c:785:13: */
	(*(*func(*crt.TLS, uintptr, int32, uintptr))(unsafe.Pointer((g2.FpVfs + 80 /* &.xDlError */))))(tls, g2.FpVfs, nByte, zErrMsg)
}

// Return a pointer to the symbol zSymbol in the dynamic library pHandle.
func jtDlSym(tls *crt.TLS, pVfs uintptr, p uintptr, zSym uintptr) uintptr { /* test_journal.c:792:13: */
	return (*(*func(*crt.TLS, uintptr, uintptr, uintptr) uintptr)(unsafe.Pointer((g2.FpVfs + 88 /* &.xDlSym */))))(tls, g2.FpVfs, p, zSym)
}

// Close the dynamic library handle pHandle.
func jtDlClose(tls *crt.TLS, pVfs uintptr, pHandle uintptr) { /* test_journal.c:799:13: */
	(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((g2.FpVfs + 96 /* &.xDlClose */))))(tls, g2.FpVfs, pHandle)
}

// Populate the buffer pointed to by zBufOut with nByte bytes of
// random data.
func jtRandomness(tls *crt.TLS, pVfs uintptr, nByte int32, zBufOut uintptr) int32 { /* test_journal.c:807:12: */
	return sqlite3.Xsqlite3OsRandomness(tls, g2.FpVfs, nByte, zBufOut)
}

// Sleep for nMicro microseconds. Return the number of microseconds
// actually slept.
func jtSleep(tls *crt.TLS, pVfs uintptr, nMicro int32) int32 { /* test_journal.c:815:12: */
	return sqlite3.Xsqlite3OsSleep(tls, g2.FpVfs, nMicro)
}

// Return the current time as a Julian Day number in *pTimeOut.
func jtCurrentTime(tls *crt.TLS, pVfs uintptr, pTimeOut uintptr) int32 { /* test_journal.c:822:12: */
	return (*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer((g2.FpVfs + 120 /* &.xCurrentTime */))))(tls, g2.FpVfs, pTimeOut)
}

// Return the current time as a Julian Day number in *pTimeOut.
func jtCurrentTimeInt64(tls *crt.TLS, pVfs uintptr, pTimeOut uintptr) int32 { /* test_journal.c:828:12: */
	return (*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer((g2.FpVfs + 136 /* &.xCurrentTimeInt64 */))))(tls, g2.FpVfs, pTimeOut)
}

func jtGetLastError(tls *crt.TLS, pVfs uintptr, n int32, z uintptr) int32 { /* test_journal.c:832:12: */
	return (*(*func(*crt.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer((g2.FpVfs + 128 /* &.xGetLastError */))))(tls, g2.FpVfs, n, z)
}

// *************************************************************************
//
// Start of public API.

// Configure the jt VFS as a wrapper around the VFS named by parameter
// zWrap. If the isDefault parameter is true, then the jt VFS is installed
// as the new default VFS for SQLite connections. If isDefault is not
// true, then the jt VFS is installed as non-default. In this case it
// is available via its name, "jt".
func jt_register(tls *crt.TLS, zWrap uintptr, isDefault int32) int32 { /* test_journal.c:847:5: */
	g2.FpVfs = sqlite3.Xsqlite3_vfs_find(tls, zWrap)
	if g2.FpVfs == uintptr(0) {
		return 1
	}
	jt_vfs.FszOsFile = (int32(uint64(unsafe.Sizeof(jt_file{})) + uint64((*sqlite3_vfs)(unsafe.Pointer(g2.FpVfs)).FszOsFile)))
	if (*sqlite3_vfs)(unsafe.Pointer(g2.FpVfs)).FiVersion == 1 {
		jt_vfs.FiVersion = 1
	} else if (*sqlite3_vfs)(unsafe.Pointer(g2.FpVfs)).FxCurrentTimeInt64 == uintptr(0) {
		jt_vfs.FxCurrentTimeInt64 = uintptr(0)
	}
	sqlite3.Xsqlite3_vfs_register(tls, uintptr(unsafe.Pointer(&jt_vfs)), isDefault)
	return 0
}

// Uninstall the jt VFS, if it is installed.
func jt_unregister(tls *crt.TLS) { /* test_journal.c:865:6: */
	sqlite3.Xsqlite3_vfs_unregister(tls, uintptr(unsafe.Pointer(&jt_vfs)))
}

// end block for C++

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:
// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.20 General utilities	<stdlib.h>

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.21 String handling	<string.h>

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.2 Diagnostics	<assert.h>

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// void assert (int expression);
//
//   If NDEBUG is defined, do nothing.
//   If not, and EXPRESSION is zero, print an error message and abort.

// void assert_perror (int errnum);
//
//   If NDEBUG is defined, do nothing.  If not, and ERRNUM is not zero, print an
//   error message with the error text for ERRNUM and abort.
//   (This is a GNU extension.)

// This structure is used to encapsulate the global state variables used
// by malloc() fault simulation.
type MemFault = struct {
	FiCountdown   int32
	FnRepeat      int32
	FnBenign      int32
	FnFail        int32
	FnOkBefore    int32
	FnOkAfter     int32
	Fenable       u8
	FisInstalled  int32
	FisBenignMode int32
	Fm            sqlite3_mem_methods
}

// end block for C++

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:
// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.20 General utilities	<stdlib.h>

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.21 String handling	<string.h>

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.2 Diagnostics	<assert.h>

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// void assert (int expression);
//
//   If NDEBUG is defined, do nothing.
//   If not, and EXPRESSION is zero, print an error message and abort.

// void assert_perror (int errnum);
//
//   If NDEBUG is defined, do nothing.  If not, and ERRNUM is not zero, print an
//   error message with the error text for ERRNUM and abort.
//   (This is a GNU extension.)

// This structure is used to encapsulate the global state variables used
// by malloc() fault simulation.
var memfault MemFault /* test_malloc.c:41:3: */

// This routine exists as a place to set a breakpoint that will
// fire on any simulated malloc() failure.
func sqlite3Fault(tls *crt.TLS) { /* test_malloc.c:47:13: */
	cnt1++
}

var cnt1 int32 = 0 /* test_malloc.c:48:14 */

// This routine exists as a place to set a breakpoint that will
// fire the first time any malloc() fails on a single test case.
// The sqlite3Fault() routine above runs on every malloc() failure.
// This routine only runs on the first such failure.
func sqlite3FirstFault(tls *crt.TLS) { /* test_malloc.c:58:13: */
	cnt2++
}

var cnt2 int32 = 0 /* test_malloc.c:59:14 */

// Check to see if a fault should be simulated.  Return true to simulate
// the fault.  Return false if the fault should not be simulated.
func faultsimStep(tls *crt.TLS) int32 { /* test_malloc.c:67:12: */
	if !(int32(memfault.Fenable) != 0) {
		memfault.FnOkAfter++
		return 0
	}
	if memfault.FiCountdown > 0 {
		memfault.FiCountdown--
		memfault.FnOkBefore++
		return 0
	}
	if memfault.FnFail == 0 {
		sqlite3FirstFault(tls)
	}
	sqlite3Fault(tls)
	memfault.FnFail++
	if memfault.FisBenignMode > 0 {
		memfault.FnBenign++
	}
	memfault.FnRepeat--
	if memfault.FnRepeat <= 0 {
		memfault.Fenable = u8(0)
	}
	return 1
}

// A version of sqlite3_mem_methods.xMalloc() that includes fault simulation
// logic.
func faultsimMalloc(tls *crt.TLS, n int32) uintptr { /* test_malloc.c:94:13: */
	var p uintptr = uintptr(0)
	if !(faultsimStep(tls) != 0) {
		p = (*(*func(*crt.TLS, int32) uintptr)(unsafe.Pointer((uintptr(unsafe.Pointer(&memfault)) + 40 /* &.m */ /* &.xMalloc */))))(tls, n)
	}
	return p
}

// A version of sqlite3_mem_methods.xRealloc() that includes fault simulation
// logic.
func faultsimRealloc(tls *crt.TLS, pOld uintptr, n int32) uintptr { /* test_malloc.c:107:13: */
	var p uintptr = uintptr(0)
	if !(faultsimStep(tls) != 0) {
		p = (*(*func(*crt.TLS, uintptr, int32) uintptr)(unsafe.Pointer((uintptr(unsafe.Pointer(&memfault)) + 40 /* &.m */ + 16 /* &.xRealloc */))))(tls, pOld, n)
	}
	return p
}

// The following method calls are passed directly through to the underlying
// malloc system:
//
//     xFree
//     xSize
//     xRoundup
//     xInit
//     xShutdown
func faultsimFree(tls *crt.TLS, p uintptr) { /* test_malloc.c:125:13: */
	(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((uintptr(unsafe.Pointer(&memfault)) + 40 /* &.m */ + 8 /* &.xFree */))))(tls, p)
}
func faultsimSize(tls *crt.TLS, p uintptr) int32 { /* test_malloc.c:128:12: */
	return (*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer((uintptr(unsafe.Pointer(&memfault)) + 40 /* &.m */ + 24 /* &.xSize */))))(tls, p)
}
func faultsimRoundup(tls *crt.TLS, n int32) int32 { /* test_malloc.c:131:12: */
	return (*(*func(*crt.TLS, int32) int32)(unsafe.Pointer((uintptr(unsafe.Pointer(&memfault)) + 40 /* &.m */ + 32 /* &.xRoundup */))))(tls, n)
}
func faultsimInit(tls *crt.TLS, p uintptr) int32 { /* test_malloc.c:134:12: */
	return (*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer((uintptr(unsafe.Pointer(&memfault)) + 40 /* &.m */ + 40 /* &.xInit */))))(tls, memfault.Fm.FpAppData)
}
func faultsimShutdown(tls *crt.TLS, p uintptr) { /* test_malloc.c:137:13: */
	(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((uintptr(unsafe.Pointer(&memfault)) + 40 /* &.m */ + 48 /* &.xShutdown */))))(tls, memfault.Fm.FpAppData)
}

// This routine configures the malloc failure simulation.  After
// calling this routine, the next nDelay mallocs will succeed, followed
// by a block of nRepeat failures, after which malloc() calls will begin
// to succeed again.
func faultsimConfig(tls *crt.TLS, nDelay int32, nRepeat int32) { /* test_malloc.c:147:13: */
	memfault.FiCountdown = nDelay
	memfault.FnRepeat = nRepeat
	memfault.FnBenign = 0
	memfault.FnFail = 0
	memfault.FnOkBefore = 0
	memfault.FnOkAfter = 0
	memfault.Fenable = (u8(crt.Bool32(nDelay >= 0)))

	// Sometimes, when running multi-threaded tests, the isBenignMode
	// variable is not properly incremented/decremented so that it is
	// 0 when not inside a benign malloc block. This doesn't affect
	// the multi-threaded tests, as they do not use this system. But
	// it does affect OOM tests run later in the same process. So
	// zero the variable here, just to be sure.
	memfault.FisBenignMode = 0
}

// Return the number of faults (both hard and benign faults) that have
// occurred since the injector was last configured.
func faultsimFailures(tls *crt.TLS) int32 { /* test_malloc.c:170:12: */
	return memfault.FnFail
}

// Return the number of benign faults that have occurred since the
// injector was last configured.
func faultsimBenignFailures(tls *crt.TLS) int32 { /* test_malloc.c:178:12: */
	return memfault.FnBenign
}

// Return the number of successes that will occur before the next failure.
// If no failures are scheduled, return -1.
func faultsimPending(tls *crt.TLS) int32 { /* test_malloc.c:186:12: */
	if memfault.Fenable != 0 {
		return memfault.FiCountdown
	} else {
		return -1
	}
	return int32(0)
}

func faultsimBeginBenign(tls *crt.TLS) { /* test_malloc.c:195:13: */
	memfault.FisBenignMode++
}
func faultsimEndBenign(tls *crt.TLS) { /* test_malloc.c:198:13: */
	memfault.FisBenignMode--
}

// Add or remove the fault-simulation layer using sqlite3_config(). If
// the argument is non-zero, the
func faultsimInstall(tls *crt.TLS, install int32) int32 { /* test_malloc.c:206:12: */
	bp := tls.Alloc(136)
	defer tls.Free(136)

	var rc int32

	install = func() int32 {
		if install != 0 {
			return 1
		}
		return 0
	}()

	if install == memfault.FisInstalled {
		return 1
	}

	if install != 0 {
		rc = sqlite3.Xsqlite3_config(tls, 5, crt.VaList(bp, (uintptr(unsafe.Pointer(&memfault))+40 /* &.m */)))

		if rc == 0 {
			rc = sqlite3.Xsqlite3_config(tls, 4, crt.VaList(bp+8, uintptr(unsafe.Pointer(&m))))
		}
		sqlite3.Xsqlite3_test_control(tls, 10,
			crt.VaList(bp+16, *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS) }{faultsimBeginBenign})), *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS) }{faultsimEndBenign}))))
	} else {
		// var m2 sqlite3_mem_methods at bp+72, 64

		// One should be able to reset the default memory allocator by storing
		// a zeroed allocator then calling GETMALLOC.
		crt.Xmemset(tls, bp+72 /* &m2 */, 0, uint64(unsafe.Sizeof(sqlite3_mem_methods{})))
		sqlite3.Xsqlite3_config(tls, 4, crt.VaList(bp+32, bp+72 /* &m2 */))
		sqlite3.Xsqlite3_config(tls, 5, crt.VaList(bp+40, bp+72 /* &m2 */))

		rc = sqlite3.Xsqlite3_config(tls, 4, crt.VaList(bp+48, (uintptr(unsafe.Pointer(&memfault))+40 /* &.m */)))
		sqlite3.Xsqlite3_test_control(tls, 10,
			crt.VaList(bp+56, uintptr(0), uintptr(0)))
	}

	if rc == 0 {
		memfault.FisInstalled = 1
	}
	return rc
}

var m = sqlite3_mem_methods1{FxMalloc: 0, FxFree: // xMalloc
0, FxRealloc:// xFree
0, FxSize:// xRealloc
0, FxRoundup:// xSize
0, FxInit:// xRoundup
0, FxShutdown:// xInit
0, FpAppData:// xShutdown
uintptr(0), // pAppData
} /* test_malloc.c:207:37 */

// Transform pointers to text and back again
func pointerToText(tls *crt.TLS, p uintptr, z uintptr) { /* test_malloc.c:272:13: */
	bp := tls.Alloc(20)
	defer tls.Free(20)
	*(*uintptr)(unsafe.Pointer(bp + 8)) = p

	var i int32
	var k int32
	// var u uint32 at bp+16, 4

	// var n sqlite3_uint64 at bp, 8

	if *(*uintptr)(unsafe.Pointer(bp + 8 /* p */)) == uintptr(0) {
		crt.Xstrcpy(tls, z, ts+8293 /* "0" */)
		return
	}
	if uint64(unsafe.Sizeof(sqlite3_uint64(0))) == uint64(unsafe.Sizeof(uintptr(0))) {
		crt.Xmemcpy(tls, bp /* &n */, bp+8 /* &p */, uint64(unsafe.Sizeof(uintptr(0))))
	} else if uint64(unsafe.Sizeof(uint32(0))) == uint64(unsafe.Sizeof(uintptr(0))) {
		crt.Xmemcpy(tls, bp+16 /* &u */, bp+8 /* &p */, uint64(unsafe.Sizeof(uint32(0))))
		*(*sqlite3_uint64)(unsafe.Pointer(bp /* n */)) = sqlite3_uint64(*(*uint32)(unsafe.Pointer(bp + 16 /* u */)))
	} else {
	}
	i = 0
	k = (int32((uint64(unsafe.Sizeof(uintptr(0))) * uint64(2)) - uint64(1)))
__1:
	if !(uint64(i) < (uint64(unsafe.Sizeof(uintptr(0))) * uint64(2))) {
		goto __3
	}
	{
		*(*int8)(unsafe.Pointer(z + uintptr(k))) = zHex[(*(*sqlite3_uint64)(unsafe.Pointer(bp /* n */)) & uint64(0xf))]
		*(*sqlite3_uint64)(unsafe.Pointer(bp /* n */)) >>= 4
	}
	goto __2
__2:
	i++
	k--
	goto __1
	goto __3
__3:
	;
	*(*int8)(unsafe.Pointer(z + uintptr((uint64(unsafe.Sizeof(uintptr(0))) * uint64(2))))) = int8(0)
}

var zHex = *(*[17]int8)(unsafe.Pointer(ts + 36152 /* "0123456789abcdef" */)) /* test_malloc.c:273:21 */
func hexToInt(tls *crt.TLS, h int32) int32 { /* test_malloc.c:295:12: */
	if (h >= '0') && (h <= '9') {
		return (h - '0')
	} else if (h >= 'a') && (h <= 'f') {
		return ((h - 'a') + 10)
	} else {
		return -1
	}
	return int32(0)
}
func textToPointer(tls *crt.TLS, z uintptr, pp uintptr) int32 { /* test_malloc.c:304:12: */
	bp := tls.Alloc(12)
	defer tls.Free(12)

	*(*sqlite3_uint64)(unsafe.Pointer(bp /* n */)) = uint64(0)
	var i int32
	// var u uint32 at bp+8, 4

	for i = 0; (uint64(i) < (uint64(unsafe.Sizeof(uintptr(0))) * uint64(2))) && (*(*int8)(unsafe.Pointer(z + uintptr(0))) != 0); i++ {
		var v int32
		v = hexToInt(tls, int32(*(*int8)(unsafe.Pointer(crt.PostIncUintptr(&z, 1)))))
		if v < 0 {
			return 1
		}
		*(*sqlite3_uint64)(unsafe.Pointer(bp /* n */)) = ((*(*sqlite3_uint64)(unsafe.Pointer(bp /* n */)) * uint64(16)) + sqlite3_uint64(v))
	}
	if int32(*(*int8)(unsafe.Pointer(z))) != 0 {
		return 1
	}
	if uint64(unsafe.Sizeof(sqlite3_uint64(0))) == uint64(unsafe.Sizeof(uintptr(0))) {
		crt.Xmemcpy(tls, pp, bp /* &n */, uint64(unsafe.Sizeof(sqlite3_uint64(0))))
	} else if uint64(unsafe.Sizeof(uint32(0))) == uint64(unsafe.Sizeof(uintptr(0))) {
		*(*uint32)(unsafe.Pointer(bp + 8 /* u */)) = uint32(*(*sqlite3_uint64)(unsafe.Pointer(bp /* n */)))
		crt.Xmemcpy(tls, pp, bp+8 /* &u */, uint64(unsafe.Sizeof(uint32(0))))
	} else {
	}
	return 0
}

// Usage:    sqlite3_malloc  NBYTES
//
// Raw test interface for sqlite3_malloc().
func test_malloc(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_malloc.c:331:26: */
	bp := tls.Alloc(120)
	defer tls.Free(120)

	// var nByte int32 at bp+16, 4

	var p uintptr
	// var zOut [100]int8 at bp+20, 100

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+37730 /* "NBYTES" */)
		return 1
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)), bp+16 /* &nByte */) != 0 {
		return 1
	}
	p = sqlite3.Xsqlite3_malloc(tls, int32(uint32(*(*int32)(unsafe.Pointer(bp + 16 /* nByte */)))))
	pointerToText(tls, p, bp+20 /* &zOut[0] */)
	tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, bp+20 /* &zOut[0] */, uintptr(0)))
	return 0
}

// Usage:    sqlite3_realloc  PRIOR  NBYTES
//
// Raw test interface for sqlite3_realloc().
func test_realloc(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_malloc.c:356:26: */
	bp := tls.Alloc(156)
	defer tls.Free(156)

	// var nByte int32 at bp+40, 4

	// var pPrior uintptr at bp+48, 8

	var p uintptr
	// var zOut [100]int8 at bp+56, 100

	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+37737 /* "PRIOR NBYTES" */)
		return 1
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)), bp+40 /* &nByte */) != 0 {
		return 1
	}
	if textToPointer(tls, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), bp+48 /* &pPrior */) != 0 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+37750 /* "bad pointer: " */, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), uintptr(0)))
		return 1
	}
	p = sqlite3.Xsqlite3_realloc(tls, *(*uintptr)(unsafe.Pointer(bp + 48 /* pPrior */)), int32(uint32(*(*int32)(unsafe.Pointer(bp + 40 /* nByte */)))))
	pointerToText(tls, p, bp+56 /* &zOut[0] */)
	tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+24, bp+56 /* &zOut[0] */, uintptr(0)))
	return 0
}

// Usage:    sqlite3_free  PRIOR
//
// Raw test interface for sqlite3_free().
func test_free(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_malloc.c:385:26: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	// var pPrior uintptr at bp+24, 8

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+37764 /* "PRIOR" */)
		return 1
	}
	if textToPointer(tls, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), bp+24 /* &pPrior */) != 0 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+37750 /* "bad pointer: " */, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), uintptr(0)))
		return 1
	}
	sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(bp + 24 /* pPrior */)))
	return 0
}

// Usage:    memset  ADDRESS  SIZE  HEX
//
// Set a chunk of memory (obtained from malloc, probably) to a
// specified hex pattern.
func test_memset(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_malloc.c:416:26: */
	bp := tls.Alloc(172)
	defer tls.Free(172)

	// var p uintptr at bp+56, 8

	// var size int32 at bp+64, 4

	// var n int32 at bp+68, 4

	var i int32
	var zHex uintptr
	var zOut uintptr
	// var zBin [100]int8 at bp+72, 100

	if objc != 4 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+37770 /* "ADDRESS SIZE HEX" */)
		return 1
	}
	if textToPointer(tls, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), bp+56 /* &p */) != 0 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+37750 /* "bad pointer: " */, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), uintptr(0)))
		return 1
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)), bp+64 /* &size */) != 0 {
		return 1
	}
	if *(*int32)(unsafe.Pointer(bp + 64 /* size */)) <= 0 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+24, ts+37787 /* "size must be pos..." */, uintptr(0)))
		return 1
	}
	zHex = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(3)*8)), bp+68 /* &n */)
	if uint64(*(*int32)(unsafe.Pointer(bp + 68 /* n */))) > (uint64(unsafe.Sizeof([100]int8{})) * uint64(2)) {
		*(*int32)(unsafe.Pointer(bp + 68 /* n */)) = (int32(uint64(unsafe.Sizeof([100]int8{})) * uint64(2)))
	}
	*(*int32)(unsafe.Pointer(bp + 68 /* n */)) = sqlite3TestHexToBin(tls, zHex, *(*int32)(unsafe.Pointer(bp + 68 /* n */)), bp+72 /* &zBin[0] */)
	if *(*int32)(unsafe.Pointer(bp + 68 /* n */)) == 0 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+40, ts+37809 /* "no data" */, uintptr(0)))
		return 1
	}
	zOut = *(*uintptr)(unsafe.Pointer(bp + 56 /* p */))
	for i = 0; i < *(*int32)(unsafe.Pointer(bp + 64 /* size */)); i++ {
		*(*int8)(unsafe.Pointer(zOut + uintptr(i))) = *(*int8)(unsafe.Pointer(bp + 72 /* &zBin[0] */ + uintptr((i % *(*int32)(unsafe.Pointer(bp + 68 /* n */))))))
	}
	return 0
}

// Usage:    memget  ADDRESS  SIZE
//
// Return memory as hexadecimal text.
func test_memget(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_malloc.c:462:26: */
	bp := tls.Alloc(168)
	defer tls.Free(168)

	// var p uintptr at bp+56, 8

	// var size int32 at bp+64, 4

	var n int32
	var zBin uintptr
	// var zHex [100]int8 at bp+68, 100

	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+37817 /* "ADDRESS SIZE" */)
		return 1
	}
	if textToPointer(tls, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), bp+56 /* &p */) != 0 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+37750 /* "bad pointer: " */, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), uintptr(0)))
		return 1
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)), bp+64 /* &size */) != 0 {
		return 1
	}
	if *(*int32)(unsafe.Pointer(bp + 64 /* size */)) <= 0 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+24, ts+37787 /* "size must be pos..." */, uintptr(0)))
		return 1
	}
	zBin = *(*uintptr)(unsafe.Pointer(bp + 56 /* p */))
	for *(*int32)(unsafe.Pointer(bp + 64 /* size */)) > 0 {
		if uint64(*(*int32)(unsafe.Pointer(bp + 64 /* size */))) > ((uint64(unsafe.Sizeof([100]int8{})) - uint64(1)) / uint64(2)) {
			n = (int32((uint64(unsafe.Sizeof([100]int8{})) - uint64(1)) / uint64(2)))
		} else {
			n = *(*int32)(unsafe.Pointer(bp + 64 /* size */))
		}
		crt.Xmemcpy(tls, bp+68 /* &zHex[0] */, zBin, uint64(n))
		zBin += uintptr(n)
		*(*int32)(unsafe.Pointer(bp + 64 /* size */)) -= n
		sqlite3TestBinToHex(tls, bp+68 /* &zHex[0] */, n)
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+40, bp+68 /* &zHex[0] */, uintptr(0)))
	}
	return 0
}

// Usage:    sqlite3_memory_used
//
// Raw test interface for sqlite3_memory_used().
func test_memory_used(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_malloc.c:509:26: */
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewWideIntObj(tls, int64(sqlite3.Xsqlite3_memory_used(tls))))
	return 0
}

// Usage:    sqlite3_memory_highwater ?RESETFLAG?
//
// Raw test interface for sqlite3_memory_highwater().
func test_memory_highwater(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_malloc.c:524:26: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	*(*int32)(unsafe.Pointer(bp /* resetFlag */)) = 0
	if (objc != 1) && (objc != 2) {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+37830 /* "?RESET?" */)
		return 1
	}
	if objc == 2 {
		if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)), bp /* &resetFlag */) != 0 {
			return 1
		}
	}
	tcl.XTcl_SetObjResult(tls, interp,
		tcl.XTcl_NewWideIntObj(tls, int64(sqlite3.Xsqlite3_memory_highwater(tls, *(*int32)(unsafe.Pointer(bp /* resetFlag */))))))
	return 0
}

// Usage:    sqlite3_memdebug_backtrace DEPTH
//
// Set the depth of backtracing.  If SQLITE_MEMDEBUG is not defined
// then this routine is a no-op.
func test_memdebug_backtrace(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_malloc.c:549:26: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	// var depth int32 at bp, 4

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+37838 /* "DEPT" */)
		return 1
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)), bp /* &depth */) != 0 {
		return 1
	}
	return 0
}

// Usage:    sqlite3_memdebug_dump  FILENAME
//
// Write a summary of unfreed memory to FILENAME.
func test_memdebug_dump(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_malloc.c:575:26: */
	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+37843 /* "FILENAME" */)
		return 1
	}
	return 0
}

// Usage:    sqlite3_memdebug_malloc_count
//
// Return the total number of times malloc() has been called.
func test_memdebug_malloc_count(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_malloc.c:600:26: */
	var nMalloc int32 = -1
	if objc != 1 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+792 /* "" */)
		return 1
	}
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, nMalloc))
	return 0
}

// Usage:    sqlite3_memdebug_fail  COUNTER  ?OPTIONS?
//
// where options are:
//
//     -repeat    <count>
//     -benigncnt <varname>
//
// Arrange for a simulated malloc() failure after COUNTER successes.
// If a repeat count is specified, the fault is repeated that many
// times.
//
// Each call to this routine overrides the prior counter value.
// This routine returns the number of simulated failures that have
// happened since the previous call to this routine.
//
// To disable simulated failures, use a COUNTER of -1.
func test_memdebug_fail(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_malloc.c:640:26: */
	bp := tls.Alloc(36)
	defer tls.Free(36)

	var ii int32
	// var iFail int32 at bp+24, 4

	*(*int32)(unsafe.Pointer(bp + 32 /* nRepeat */)) = 1
	var pBenignCnt uintptr = uintptr(0)
	var nBenign int32
	var nFail int32 = 0

	if objc < 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+37852 /* "COUNTER ?OPTIONS..." */)
		return 1
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)), bp+24 /* &iFail */) != 0 {
		return 1
	}

	for ii = 2; ii < objc; ii = ii + (2) {
		// var nOption int32 at bp+28, 4

		var zOption uintptr = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(ii)*8)), bp+28 /* &nOption */)
		var zErr uintptr = uintptr(0)

		if (*(*int32)(unsafe.Pointer(bp + 28 /* nOption */)) > 1) && (crt.Xstrncmp(tls, zOption, ts+37870 /* "-repeat" */, uint64(*(*int32)(unsafe.Pointer(bp + 28 /* nOption */)))) == 0) {
			if ii == (objc - 1) {
				zErr = ts + 19287 /* "option requires ..." */
			} else {
				if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr((ii+1))*8)), bp+32 /* &nRepeat */) != 0 {
					return 1
				}
			}
		} else if (*(*int32)(unsafe.Pointer(bp + 28 /* nOption */)) > 1) && (crt.Xstrncmp(tls, zOption, ts+37878 /* "-benigncnt" */, uint64(*(*int32)(unsafe.Pointer(bp + 28 /* nOption */)))) == 0) {
			if ii == (objc - 1) {
				zErr = ts + 19287 /* "option requires ..." */
			} else {
				pBenignCnt = *(*uintptr)(unsafe.Pointer(objv + uintptr((ii+1))*8))
			}
		} else {
			zErr = ts + 20916 /* "unknown option: " */
		}

		if zErr != 0 {
			tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, zErr, zOption, 0))
			return 1
		}
	}

	nBenign = faultsimBenignFailures(tls)
	nFail = faultsimFailures(tls)
	faultsimConfig(tls, *(*int32)(unsafe.Pointer(bp + 24 /* iFail */)), *(*int32)(unsafe.Pointer(bp + 32 /* nRepeat */)))

	if pBenignCnt != 0 {
		tcl.XTcl_ObjSetVar2(tls, interp, pBenignCnt, uintptr(0), tcl.XTcl_NewIntObj(tls, nBenign), 0)
	}
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, nFail))
	return 0
}

// Usage:    sqlite3_memdebug_pending
//
// Return the number of malloc() calls that will succeed before a
// simulated failure occurs. A negative return value indicates that
// no malloc() failure is scheduled.
func test_memdebug_pending(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_malloc.c:706:26: */
	var nPending int32
	if objc != 1 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+792 /* "" */)
		return 1
	}
	nPending = faultsimPending(tls)
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, nPending))
	return 0
}

// The following global variable keeps track of the number of tests
// that have run.  This variable is only useful when running in the
// debugger.
var sqlite3_memdebug_title_count int32 = 0 /* test_malloc.c:727:12 */

// Usage:    sqlite3_memdebug_settitle TITLE
//
// Set a title string stored with each allocation.  The TITLE is
// typically the name of the test that was running when the
// allocation occurred.  The TITLE is stored with the allocation
// and can be used to figure out which tests are leaking memory.
//
// Each title overwrite the previous.
func test_memdebug_settitle(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_malloc.c:739:26: */
	sqlite3_memdebug_title_count++
	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+37889 /* "TITLE" */)
		return 1
	}
	return 0
}

var aMallocLog Tcl_HashTable   /* test_malloc.c:765:22: */
var mallocLogEnabled int32 = 0 /* test_malloc.c:766:12 */

type MallocLog1 = struct {
	FnCall int32
	FnByte int32
}

type MallocLog = MallocLog1 /* test_malloc.c:768:26 */

func test_memdebug_log_clear(tls *crt.TLS) { /* test_malloc.c:805:13: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	// var search Tcl_HashSearch at bp, 24

	var pEntry uintptr
	for pEntry = tcl.XTcl_FirstHashEntry(tls, uintptr(unsafe.Pointer(&aMallocLog)), bp /* &search */); pEntry != 0; pEntry = tcl.XTcl_NextHashEntry(tls, bp /* &search */) {
		var pLog uintptr = (*Tcl_HashEntry)(unsafe.Pointer(pEntry)).FclientData
		tcl.XTcl_Free(tls, pLog)
	}
	tcl.XTcl_DeleteHashTable(tls, uintptr(unsafe.Pointer(&aMallocLog)))
	tcl.XTcl_InitHashTable(tls, uintptr(unsafe.Pointer(&aMallocLog)), (int32(uint64(10) * (func() uint64 {
		if uint64(unsafe.Sizeof(int32(0))) >= uint64(unsafe.Sizeof(uintptr(0))) {
			return uint64(1)
		}
		return (uint64(unsafe.Sizeof(uintptr(0))) / uint64(unsafe.Sizeof(int32(0))))
	}()))))
}

func test_memdebug_log(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_malloc.c:820:26: */
	bp := tls.Alloc(128)
	defer tls.Free(128)

	// var iSub int32 at bp, 4

	const ( /* test_malloc.c:830:3: */
		MB_LOG_START = 0
		MB_LOG_STOP  = 1
		MB_LOG_DUMP  = 2
		MB_LOG_CLEAR = 3
		MB_LOG_SYNC  = 4
	)

	if !(isInit != 0) {
		tcl.XTcl_InitHashTable(tls, uintptr(unsafe.Pointer(&aMallocLog)), (int32(uint64(10) * (func() uint64 {
			if uint64(unsafe.Sizeof(int32(0))) >= uint64(unsafe.Sizeof(uintptr(0))) {
				return uint64(1)
			}
			return (uint64(unsafe.Sizeof(uintptr(0))) / uint64(unsafe.Sizeof(int32(0))))
		}()))))
		isInit = 1
	}

	if objc < 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+37895 /* "SUB-COMMAND ..." */)
	}
	if tcl.XTcl_GetIndexFromObjStruct(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)), uintptr(unsafe.Pointer(&MB_strs)), int32(unsafe.Sizeof(uintptr(0))), ts+2321 /* "sub-command" */, 0, bp /* &iSub */) != 0 {
		return 1
	}

	switch uint32(*(*int32)(unsafe.Pointer(bp /* iSub */))) {
	case MB_LOG_START:
		mallocLogEnabled = 1
		break
	case MB_LOG_STOP:
		mallocLogEnabled = 0
		break
	case MB_LOG_DUMP:
		{
			// var search Tcl_HashSearch at bp+8, 24

			var pEntry uintptr
			var pRet uintptr = tcl.XTcl_NewObj(tls)

			for pEntry = tcl.XTcl_FirstHashEntry(tls, uintptr(unsafe.Pointer(&aMallocLog)), bp+8 /* &search */); pEntry != 0; pEntry = tcl.XTcl_NextHashEntry(tls, bp+8 /* &search */) {
				// var apElem [12]uintptr at bp+32, 96

				var pLog uintptr = (*Tcl_HashEntry)(unsafe.Pointer(pEntry)).FclientData
				var aKey uintptr = func() uintptr {
					if ((*Tcl_HashTable)(unsafe.Pointer((uintptr(unsafe.Pointer(&aMallocLog))))).FkeyType == (1)) || ((*Tcl_HashTable)(unsafe.Pointer((uintptr(unsafe.Pointer(&aMallocLog))))).FkeyType == (-1)) {
						return *(*uintptr)(unsafe.Pointer(pEntry + 32 /* &.key */))
					}
					return pEntry + 32 /* &.key */
				}()
				var ii int32

				*(*uintptr)(unsafe.Pointer(bp + 32 /* &apElem[0] */ + uintptr(0)*8)) = tcl.XTcl_NewIntObj(tls, (*MallocLog)(unsafe.Pointer(pLog)).FnCall)
				*(*uintptr)(unsafe.Pointer(bp + 32 /* &apElem[0] */ + uintptr(1)*8)) = tcl.XTcl_NewIntObj(tls, (*MallocLog)(unsafe.Pointer(pLog)).FnByte)
				for ii = 0; ii < 10; ii++ {
					*(*uintptr)(unsafe.Pointer(bp + 32 /* &apElem[0] */ + uintptr((ii+2))*8)) = tcl.XTcl_NewWideIntObj(tls, *(*Tcl_WideInt)(unsafe.Pointer(aKey + uintptr(ii)*8)))
				}

				tcl.XTcl_ListObjAppendElement(tls, interp, pRet,
					tcl.XTcl_NewListObj(tls, (10+2), bp+32 /* &apElem[0] */))
			}

			tcl.XTcl_SetObjResult(tls, interp, pRet)
			break
		}
	case MB_LOG_CLEAR:
		{
			test_memdebug_log_clear(tls)
			break
		}

	case MB_LOG_SYNC:
		{
			break
		}
	}

	return 0
}

var isInit int32 = 0                                                                                                                                    /* test_malloc.c:826:14 */
var MB_strs = [5]uintptr{ts + 37911 /* "start" */, ts + 37917 /* "stop" */, ts + 37922 /* "dump" */, ts + 37927 /* "clear" */, ts + 37933 /* "sync" */} /* test_malloc.c:829:21 */

// Usage:    sqlite3_config_pagecache SIZE N
//
// Set the page-cache memory buffer using SQLITE_CONFIG_PAGECACHE.
// The buffer is static and is of limited size.  N might be
// adjusted downward as needed to accommodate the requested size.
// The revised value of N is returned.
//
// A negative SIZE causes the buffer pointer to be NULL.
func test_config_pagecache(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_malloc.c:918:26: */
	bp := tls.Alloc(56)
	defer tls.Free(56)

	// var sz int32 at bp+48, 4

	// var N int32 at bp+52, 4

	var pRes uintptr
	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+37938 /* "SIZE N" */)
		return 1
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)), bp+48 /* &sz */) != 0 {
		return 1
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)), bp+52 /* &N */) != 0 {
		return 1
	}
	crt.Xfree(tls, buf1)
	buf1 = uintptr(0)

	// Set the return value
	pRes = tcl.XTcl_NewObj(tls)
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pRes, tcl.XTcl_NewIntObj(tls, sqlite3.Xsqlite3Config.FszPage))
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pRes, tcl.XTcl_NewIntObj(tls, sqlite3.Xsqlite3Config.FnPage))
	tcl.XTcl_SetObjResult(tls, interp, pRes)

	if *(*int32)(unsafe.Pointer(bp + 48 /* sz */)) < 0 {
		sqlite3.Xsqlite3_config(tls, 7, crt.VaList(bp, uintptr(0), 0, 0))
	} else {
		buf1 = crt.Xmalloc(tls, (uint64(*(*int32)(unsafe.Pointer(bp + 48 /* sz */)) * *(*int32)(unsafe.Pointer(bp + 52 /* N */)))))
		sqlite3.Xsqlite3_config(tls, 7, crt.VaList(bp+24, buf1, *(*int32)(unsafe.Pointer(bp + 48 /* sz */)), *(*int32)(unsafe.Pointer(bp + 52 /* N */))))
	}
	return 0
}

var buf1 uintptr = uintptr(0) /* test_malloc.c:926:15 */

// Usage:    sqlite3_config_alt_pcache INSTALL_FLAG DISCARD_CHANCE PRNG_SEED
//
// Set up the alternative test page cache.  Install if INSTALL_FLAG is
// true and uninstall (reverting to the default page cache) if INSTALL_FLAG
// is false.  DISCARD_CHANGE is an integer between 0 and 100 inclusive
// which determines the chance of discarding a page when unpinned.  100
// is certainty.  0 is never.  PRNG_SEED is the pseudo-random number generator
// seed.
func test_alt_pcache(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_malloc.c:961:26: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	// var installFlag int32 at bp+16, 4

	*(*int32)(unsafe.Pointer(bp + 20 /* discardChance */)) = 0
	*(*int32)(unsafe.Pointer(bp + 24 /* prngSeed */)) = 0
	*(*int32)(unsafe.Pointer(bp + 28 /* highStress */)) = 0
	if (objc < 2) || (objc > 5) {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv,
			ts+37945 /* "INSTALLFLAG DISC..." */)
		return 1
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)), bp+16 /* &installFlag */) != 0 {
		return 1
	}
	if (objc >= 3) && (tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)), bp+20 /* &discardChance */) != 0) {
		return 1
	}
	if (objc >= 4) && (tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(3)*8)), bp+24 /* &prngSeed */) != 0) {
		return 1
	}
	if (objc >= 5) && (tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(4)*8)), bp+28 /* &highStress */) != 0) {
		return 1
	}
	if (*(*int32)(unsafe.Pointer(bp + 20 /* discardChance */)) < 0) || (*(*int32)(unsafe.Pointer(bp + 20 /* discardChance */)) > 100) {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+37992, /* "discard-chance s..." */
			uintptr(0)))
		return 1
	}
	installTestPCache(tls, *(*int32)(unsafe.Pointer(bp + 16 /* installFlag */)), uint32(*(*int32)(unsafe.Pointer(bp + 20 /* discardChance */))), uint32(*(*int32)(unsafe.Pointer(bp + 24 /* prngSeed */))),
		uint32(*(*int32)(unsafe.Pointer(bp + 28 /* highStress */))))
	return 0
}

// Usage:    sqlite3_config_memstatus BOOLEAN
//
// Enable or disable memory status reporting using SQLITE_CONFIG_MEMSTATUS.
func test_config_memstatus(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_malloc.c:1002:26: */
	bp := tls.Alloc(12)
	defer tls.Free(12)

	// var enable int32 at bp+8, 4

	var rc int32
	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+38035 /* "BOOLEAN" */)
		return 1
	}
	if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)), bp+8 /* &enable */) != 0 {
		return 1
	}
	rc = sqlite3.Xsqlite3_config(tls, 9, crt.VaList(bp, *(*int32)(unsafe.Pointer(bp + 8 /* enable */))))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, rc))
	return 0
}

// Usage:    sqlite3_config_lookaside  SIZE  COUNT
//
func test_config_lookaside(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_malloc.c:1023:26: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	// var sz int32 at bp+16, 4

	// var cnt int32 at bp+20, 4

	var pRet uintptr
	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+38043 /* "SIZE COUNT" */)
		return 1
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)), bp+16 /* &sz */) != 0 {
		return 1
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)), bp+20 /* &cnt */) != 0 {
		return 1
	}
	pRet = tcl.XTcl_NewObj(tls)
	tcl.XTcl_ListObjAppendElement(tls,
		interp, pRet, tcl.XTcl_NewIntObj(tls, sqlite3.Xsqlite3Config.FszLookaside))
	tcl.XTcl_ListObjAppendElement(tls,
		interp, pRet, tcl.XTcl_NewIntObj(tls, sqlite3.Xsqlite3Config.FnLookaside))
	sqlite3.Xsqlite3_config(tls, 13, crt.VaList(bp, *(*int32)(unsafe.Pointer(bp + 16 /* sz */)), *(*int32)(unsafe.Pointer(bp + 20 /* cnt */))))
	tcl.XTcl_SetObjResult(tls, interp, pRet)
	return 0
}

// Usage:    sqlite3_db_config_lookaside  CONNECTION  BUFID  SIZE  COUNT
//
// There are two static buffers with BUFID 1 and 2.   Each static buffer
// is 10KB in size.  A BUFID of 0 indicates that the buffer should be NULL
// which will cause sqlite3_db_config() to allocate space on its own.
func test_db_config_lookaside(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_malloc.c:1057:26: */
	bp := tls.Alloc(84)
	defer tls.Free(84)

	var rc int32
	// var sz int32 at bp+76, 4

	// var cnt int32 at bp+80, 4

	// var db uintptr at bp+64, 8

	// var bufid int32 at bp+72, 4

	if objc != 5 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+38054 /* "BUFID SIZE COUNT" */)
		return 1
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), bp+64 /* &db */) != 0 {
		return 1
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)), bp+72 /* &bufid */) != 0 {
		return 1
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(3)*8)), bp+76 /* &sz */) != 0 {
		return 1
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(4)*8)), bp+80 /* &cnt */) != 0 {
		return 1
	}
	if *(*int32)(unsafe.Pointer(bp + 72 /* bufid */)) == 0 {
		rc = sqlite3.Xsqlite3_db_config(tls, *(*uintptr)(unsafe.Pointer(bp + 64 /* db */)), 1001, crt.VaList(bp, uintptr(0), *(*int32)(unsafe.Pointer(bp + 76 /* sz */)), *(*int32)(unsafe.Pointer(bp + 80 /* cnt */))))
	} else if ((*(*int32)(unsafe.Pointer(bp + 72 /* bufid */)) >= 1) && (*(*int32)(unsafe.Pointer(bp + 72 /* bufid */)) <= 2)) && ((uint64(*(*int32)(unsafe.Pointer(bp + 76 /* sz */)) * *(*int32)(unsafe.Pointer(bp + 80 /* cnt */)))) <= uint64(unsafe.Sizeof([10000]int8{}))) {
		rc = sqlite3.Xsqlite3_db_config(tls, *(*uintptr)(unsafe.Pointer(bp + 64 /* db */)), 1001, crt.VaList(bp+24, (uintptr(unsafe.Pointer(&azBuf))+uintptr(*(*int32)(unsafe.Pointer(bp + 72 /* bufid */)))*10000), *(*int32)(unsafe.Pointer(bp + 76 /* sz */)), *(*int32)(unsafe.Pointer(bp + 80 /* cnt */))))
	} else {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+48, ts+38071 /* "illegal argument..." */, uintptr(0)))
		return 1
	}
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, rc))
	return 0
}

var azBuf [2][10000]int8 /* test_malloc.c:1067:15: */

// Usage:    sqlite3_config_heap NBYTE NMINALLOC
func test_config_heap(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_malloc.c:1092:26: */
	bp := tls.Alloc(56)
	defer tls.Free(56)
	// Use this memory
	// var nByte int32 at bp+48, 4
	// Size of buffer to pass to sqlite3_config()
	// var nMinAlloc int32 at bp+52, 4
	// Size of minimum allocation
	var rc int32 // Return code of sqlite3_config()

	var aArg uintptr = (objv + uintptr(1)*8)
	var nArg int32 = (objc - 1)

	if nArg != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+38109 /* "NBYTE NMINALLOC" */)
		return 1
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(aArg + uintptr(0)*8)), bp+48 /* &nByte */) != 0 {
		return 1
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(aArg + uintptr(1)*8)), bp+52 /* &nMinAlloc */) != 0 {
		return 1
	}

	if *(*int32)(unsafe.Pointer(bp + 48 /* nByte */)) == 0 {
		crt.Xfree(tls, zBuf)
		zBuf = uintptr(0)
		rc = sqlite3.Xsqlite3_config(tls, 8, crt.VaList(bp, uintptr(0), 0, 0))
	} else {
		zBuf = crt.Xrealloc(tls, zBuf, uint64(*(*int32)(unsafe.Pointer(bp + 48 /* nByte */))))
		rc = sqlite3.Xsqlite3_config(tls, 8, crt.VaList(bp+24, zBuf, *(*int32)(unsafe.Pointer(bp + 48 /* nByte */)), *(*int32)(unsafe.Pointer(bp + 52 /* nMinAlloc */))))
	}

	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(1))
	return 0
}

var zBuf uintptr /* test_malloc.c:1098:15: */

// Usage:    sqlite3_config_heap_size NBYTE
func test_config_heap_size(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_malloc.c:1129:26: */
	bp := tls.Alloc(12)
	defer tls.Free(12)

	// var nByte int32 at bp+8, 4
	// Size to pass to sqlite3_config()
	var rc int32 // Return code of sqlite3_config()

	var aArg uintptr = (objv + uintptr(1)*8)
	var nArg int32 = (objc - 1)

	if nArg != 1 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+22849 /* "NBYTE" */)
		return 1
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(aArg + uintptr(0)*8)), bp+8 /* &nByte */) != 0 {
		return 1
	}

	rc = sqlite3.Xsqlite3_config(tls, 23, crt.VaList(bp, *(*int32)(unsafe.Pointer(bp + 8 /* nByte */))))

	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(1))
	return 0
}

// Usage:    sqlite3_config_error  [DB]
//
// Invoke sqlite3_config() or sqlite3_db_config() with invalid
// opcodes and verify that they return errors.
func test_config_error(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_malloc.c:1159:26: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	// var db uintptr at bp+32, 8

	if (objc != 2) && (objc != 1) {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+38125 /* "[DB]" */)
		return 1
	}
	if objc == 2 {
		if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), bp+32 /* &db */) != 0 {
			return 1
		}
		if sqlite3.Xsqlite3_db_config(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* db */)), 99999, 0) != 1 {
			tcl.XTcl_AppendResult(tls, interp,
				crt.VaList(bp, ts+38130, /* "sqlite3_db_confi..." */
					uintptr(0)))
			return 1
		}
	} else {
		if sqlite3.Xsqlite3_config(tls, 99999, 0) != 1 {
			tcl.XTcl_AppendResult(tls, interp,
				crt.VaList(bp+16, ts+38188, /* "sqlite3_config(9..." */
					uintptr(0)))
			return 1
		}
	}
	return 0
}

// Usage:    sqlite3_config_uri  BOOLEAN
//
// Enables or disables interpretation of URI parameters by default using
// SQLITE_CONFIG_URI.
func test_config_uri(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_malloc.c:1197:26: */
	bp := tls.Alloc(12)
	defer tls.Free(12)

	var rc int32
	// var bOpenUri int32 at bp+8, 4

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+25175 /* "BOOL" */)
		return 1
	}
	if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)), bp+8 /* &bOpenUri */) != 0 {
		return 1
	}

	rc = sqlite3.Xsqlite3_config(tls, 17, crt.VaList(bp, *(*int32)(unsafe.Pointer(bp + 8 /* bOpenUri */))))
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(1))

	return 0
}

// Usage:    sqlite3_config_cis  BOOLEAN
//
// Enables or disables the use of the covering-index scan optimization.
// SQLITE_CONFIG_COVERING_INDEX_SCAN.
func test_config_cis(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_malloc.c:1226:26: */
	bp := tls.Alloc(12)
	defer tls.Free(12)

	var rc int32
	// var bUseCis int32 at bp+8, 4

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+25175 /* "BOOL" */)
		return 1
	}
	if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)), bp+8 /* &bUseCis */) != 0 {
		return 1
	}

	rc = sqlite3.Xsqlite3_config(tls, 20, crt.VaList(bp, *(*int32)(unsafe.Pointer(bp + 8 /* bUseCis */))))
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(1))

	return 0
}

// Usage:    sqlite3_config_pmasz  INTEGER
//
// Set the minimum PMA size.
func test_config_pmasz(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_malloc.c:1254:26: */
	bp := tls.Alloc(12)
	defer tls.Free(12)

	var rc int32
	// var iPmaSz int32 at bp+8, 4

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+25175 /* "BOOL" */)
		return 1
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)), bp+8 /* &iPmaSz */) != 0 {
		return 1
	}

	rc = sqlite3.Xsqlite3_config(tls, 25, crt.VaList(bp, *(*int32)(unsafe.Pointer(bp + 8 /* iPmaSz */))))
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(1))

	return 0
}

// Usage:    sqlite3_dump_memsys3  FILENAME
//           sqlite3_dump_memsys5  FILENAME
//
// Write a summary of unfreed memsys3 allocations to FILENAME.
func test_dump_memsys3(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_malloc.c:1284:26: */
	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+37843 /* "FILENAME" */)
		return 1
	}

	switch int32(clientData) {
	case 3:
		{
		}
		fallthrough
	case 5:
		{
		}
	}
	return 0
}

// Usage:    sqlite3_status  OPCODE  RESETFLAG
//
// Return a list of three elements which are the sqlite3_status() return
// code, the current value, and the high-water mark value.
func test_status(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_malloc.c:1320:26: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var rc int32
	// var iValue int32 at bp+8, 4

	// var mxValue int32 at bp+12, 4

	var i int32
	*(*int32)(unsafe.Pointer(bp /* op */)) = 0
	// var resetFlag int32 at bp+4, 4

	var zOpName uintptr
	var pResult uintptr
	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+38239 /* "PARAMETER RESETF..." */)
		return 1
	}
	zOpName = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)))
	for i = 0; i < (int32(uint64(unsafe.Sizeof(aOp1)) / uint64(unsafe.Sizeof(struct {
		FzName uintptr
		Fop    int32
		_      [4]byte
	}{})))); i++ {
		if crt.Xstrcmp(tls, aOp1[i].FzName, zOpName) == 0 {
			*(*int32)(unsafe.Pointer(bp /* op */)) = aOp1[i].Fop
			break
		}
	}
	if i >= (int32(uint64(unsafe.Sizeof(aOp1)) / uint64(unsafe.Sizeof(struct {
		FzName uintptr
		Fop    int32
		_      [4]byte
	}{})))) {
		if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)), bp /* &op */) != 0 {
			return 1
		}
	}
	if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)), bp+4 /* &resetFlag */) != 0 {
		return 1
	}
	*(*int32)(unsafe.Pointer(bp + 8 /* iValue */)) = 0
	*(*int32)(unsafe.Pointer(bp + 12 /* mxValue */)) = 0
	rc = sqlite3.Xsqlite3_status(tls, *(*int32)(unsafe.Pointer(bp /* op */)), bp+8 /* &iValue */, bp+12 /* &mxValue */, *(*int32)(unsafe.Pointer(bp + 4 /* resetFlag */)))
	pResult = tcl.XTcl_NewObj(tls)
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pResult, tcl.XTcl_NewIntObj(tls, rc))
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pResult, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 8 /* iValue */))))
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pResult, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 12 /* mxValue */))))
	tcl.XTcl_SetObjResult(tls, interp, pResult)
	return 0
}

var aOp1 = [10]struct {
	FzName uintptr
	Fop    int32
	_      [4]byte
}{
	{FzName: ts + 38259 /* "SQLITE_STATUS_ME..." */, Fop: 0},
	{FzName: ts + 38285 /* "SQLITE_STATUS_MA..." */, Fop: 5},
	{FzName: ts + 38311 /* "SQLITE_STATUS_PA..." */, Fop: 1},
	{FzName: ts + 38340 /* "SQLITE_STATUS_PA..." */, Fop: 2},
	{FzName: ts + 38373 /* "SQLITE_STATUS_PA..." */, Fop: 7},
	{FzName: ts + 38402 /* "SQLITE_STATUS_SC..." */, Fop: 3},
	{FzName: ts + 38429 /* "SQLITE_STATUS_SC..." */, Fop: 4},
	{FzName: ts + 38460 /* "SQLITE_STATUS_SC..." */, Fop: 8},
	{FzName: ts + 38487 /* "SQLITE_STATUS_PA..." */, Fop: 6},
	{FzName: ts + 38514 /* "SQLITE_STATUS_MA..." */, Fop: 9},
} /* test_malloc.c:1332:5 */

// Usage:    sqlite3_db_status  DATABASE  OPCODE  RESETFLAG
//
// Return a list of three elements which are the sqlite3_db_status() return
// code, the current value, and the high-water mark value.
func test_db_status(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_malloc.c:1377:26: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	var rc int32
	// var iValue int32 at bp+16, 4

	// var mxValue int32 at bp+20, 4

	var i int32
	*(*int32)(unsafe.Pointer(bp + 8 /* op */)) = 0
	// var resetFlag int32 at bp+12, 4

	var zOpName uintptr
	// var db uintptr at bp, 8

	var pResult uintptr
	if objc != 4 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+38541 /* "DB PARAMETER RES..." */)
		return 1
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), bp /* &db */) != 0 {
		return 1
	}
	zOpName = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)))
	if crt.Xmemcmp(tls, zOpName, ts+38564 /* "SQLITE_" */, uint64(7)) == 0 {
		zOpName += uintptr(7)
	}
	if crt.Xmemcmp(tls, zOpName, ts+38572 /* "DBSTATUS_" */, uint64(9)) == 0 {
		zOpName += uintptr(9)
	}
	for i = 0; i < (int32(uint64(unsafe.Sizeof(aOp2)) / uint64(unsafe.Sizeof(struct {
		FzName uintptr
		Fop    int32
		_      [4]byte
	}{})))); i++ {
		if crt.Xstrcmp(tls, aOp2[i].FzName, zOpName) == 0 {
			*(*int32)(unsafe.Pointer(bp + 8 /* op */)) = aOp2[i].Fop
			break
		}
	}
	if i >= (int32(uint64(unsafe.Sizeof(aOp2)) / uint64(unsafe.Sizeof(struct {
		FzName uintptr
		Fop    int32
		_      [4]byte
	}{})))) {
		if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)), bp+8 /* &op */) != 0 {
			return 1
		}
	}
	if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(3)*8)), bp+12 /* &resetFlag */) != 0 {
		return 1
	}
	*(*int32)(unsafe.Pointer(bp + 16 /* iValue */)) = 0
	*(*int32)(unsafe.Pointer(bp + 20 /* mxValue */)) = 0
	rc = sqlite3.Xsqlite3_db_status(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), *(*int32)(unsafe.Pointer(bp + 8 /* op */)), bp+16 /* &iValue */, bp+20 /* &mxValue */, *(*int32)(unsafe.Pointer(bp + 12 /* resetFlag */)))
	pResult = tcl.XTcl_NewObj(tls)
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pResult, tcl.XTcl_NewIntObj(tls, rc))
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pResult, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 16 /* iValue */))))
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pResult, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 20 /* mxValue */))))
	tcl.XTcl_SetObjResult(tls, interp, pResult)
	return 0
}

var aOp2 = [13]struct {
	FzName uintptr
	Fop    int32
	_      [4]byte
}{
	{FzName: ts + 38582 /* "LOOKASIDE_USED" */, Fop: 0},
	{FzName: ts + 38597 /* "CACHE_USED" */, Fop: 1},
	{FzName: ts + 38608 /* "SCHEMA_USED" */, Fop: 2},
	{FzName: ts + 38620 /* "STMT_USED" */, Fop: 3},
	{FzName: ts + 38630 /* "LOOKASIDE_HIT" */, Fop: 4},
	{FzName: ts + 38644 /* "LOOKASIDE_MISS_S..." */, Fop: 5},
	{FzName: ts + 38664 /* "LOOKASIDE_MISS_F..." */, Fop: 6},
	{FzName: ts + 38684 /* "CACHE_HIT" */, Fop: 7},
	{FzName: ts + 38694 /* "CACHE_MISS" */, Fop: 8},
	{FzName: ts + 38705 /* "CACHE_WRITE" */, Fop: 9},
	{FzName: ts + 38717 /* "DEFERRED_FKS" */, Fop: 10},
	{FzName: ts + 38730 /* "CACHE_USED_SHARE..." */, Fop: 11},
	{FzName: ts + 38748 /* "CACHE_SPILL" */, Fop: 12},
} /* test_malloc.c:1391:5 */

// install_malloc_faultsim BOOLEAN
func test_install_malloc_faultsim(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_malloc.c:1439:26: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var rc int32
	// var isInstall int32 at bp, 4

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+38035 /* "BOOLEAN" */)
		return 1
	}
	if 0 != tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)), bp /* &isInstall */) {
		return 1
	}
	rc = faultsimInstall(tls, *(*int32)(unsafe.Pointer(bp /* isInstall */)))
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(1))
	return 0
}

// sqlite3_install_memsys3
func test_install_memsys3(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_malloc.c:1463:26: */
	var rc int32 = 21
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(1))
	return 0
}

func test_vfs_oom_test(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_malloc.c:1478:26: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	if objc > 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+38760 /* "?INTEGER?" */)
		return 1
	} else if objc == 2 {
		// var iNew int32 at bp, 4

		if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)), bp /* &iNew */) != 0 {
			return 1
		}
		sqlite3.Xsqlite3_memdebug_vfs_oom_test = *(*int32)(unsafe.Pointer(bp /* iNew */))
	}
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, sqlite3.Xsqlite3_memdebug_vfs_oom_test))
	return 0
}

// Register commands with the TCL interpreter.
func Sqlitetest_malloc_Init(tls *crt.TLS, interp uintptr) int32 { /* test_malloc.c:1500:5: */
	var i int32
	for i = 0; uint64(i) < (uint64(unsafe.Sizeof(aObjCmd11)) / uint64(unsafe.Sizeof(struct {
		FzName      uintptr
		FxProc      uintptr
		FclientData int32
		_           [4]byte
	}{}))); i++ {
		var c ClientData = uintptr(int64(aObjCmd11[i].FclientData))
		tcl.XTcl_CreateObjCommand(tls, interp, aObjCmd11[i].FzName, aObjCmd11[i].FxProc, c, uintptr(0))
	}
	return 0
}

var aObjCmd11 = [32]struct {
	FzName      uintptr
	FxProc      uintptr
	FclientData int32
	_           [4]byte
}{
	{FzName: ts + 33111 /* "sqlite3_malloc" */, FxProc: 0, FclientData: 0},
	{FzName: ts + 33126 /* "sqlite3_realloc" */, FxProc: 0, FclientData: 0},
	{FzName: ts + 38770 /* "sqlite3_free" */, FxProc: 0, FclientData: 0},
	{FzName: ts + 38783 /* "memset" */, FxProc: 0, FclientData: 0},
	{FzName: ts + 38790 /* "memget" */, FxProc: 0, FclientData: 0},
	{FzName: ts + 38797 /* "sqlite3_memory_u..." */, FxProc: 0, FclientData: 0},
	{FzName: ts + 38817 /* "sqlite3_memory_h..." */, FxProc: 0, FclientData: 0},
	{FzName: ts + 38842 /* "sqlite3_memdebug..." */, FxProc: 0, FclientData: 0},
	{FzName: ts + 38869 /* "sqlite3_memdebug..." */, FxProc: 0, FclientData: 0},
	{FzName: ts + 38891 /* "sqlite3_memdebug..." */, FxProc: 0, FclientData: 0},
	{FzName: ts + 38913 /* "sqlite3_memdebug..." */, FxProc: 0, FclientData: 0},
	{FzName: ts + 38938 /* "sqlite3_memdebug..." */, FxProc: 0, FclientData: 0},
	{FzName: ts + 38964 /* "sqlite3_memdebug..." */, FxProc: 0, FclientData: 0},
	{FzName: ts + 38994 /* "sqlite3_memdebug..." */, FxProc: 0, FclientData: 0},
	{FzName: ts + 39015 /* "sqlite3_config_p..." */, FxProc: 0, FclientData: 0},
	{FzName: ts + 39040 /* "sqlite3_config_a..." */, FxProc: 0, FclientData: 0},
	{FzName: ts + 39066 /* "sqlite3_status" */, FxProc: 0, FclientData: 0},
	{FzName: ts + 39081 /* "sqlite3_db_statu..." */, FxProc: 0, FclientData: 0},
	{FzName: ts + 39099 /* "install_malloc_f..." */, FxProc: 0, FclientData: 0},
	{FzName: ts + 39123 /* "sqlite3_config_h..." */, FxProc: 0, FclientData: 0},
	{FzName: ts + 39143 /* "sqlite3_config_h..." */, FxProc: 0, FclientData: 0},
	{FzName: ts + 39168 /* "sqlite3_config_m..." */, FxProc: 0, FclientData: 0},
	{FzName: ts + 39193 /* "sqlite3_config_l..." */, FxProc: 0, FclientData: 0},
	{FzName: ts + 39218 /* "sqlite3_config_e..." */, FxProc: 0, FclientData: 0},
	{FzName: ts + 39239 /* "sqlite3_config_u..." */, FxProc: 0, FclientData: 0},
	{FzName: ts + 39258 /* "sqlite3_config_c..." */, FxProc: 0, FclientData: 0},
	{FzName: ts + 39277 /* "sqlite3_config_p..." */, FxProc: 0, FclientData: 0},
	{FzName: ts + 39298 /* "sqlite3_db_confi..." */, FxProc: 0, FclientData: 0},
	{FzName: ts + 39326 /* "sqlite3_dump_mem..." */, FxProc: 0, FclientData: 3},
	{FzName: ts + 39347 /* "sqlite3_dump_mem..." */, FxProc: 0, FclientData: 5},
	{FzName: ts + 39368 /* "sqlite3_install_..." */, FxProc: 0, FclientData: 0},
	{FzName: ts + 39392 /* "sqlite3_memdebug..." */, FxProc: 0, FclientData: 0},
} /* test_malloc.c:1505:5 */

// end block for C++

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:

// This code implements the MD5 message-digest algorithm.
// The algorithm is due to Ron Rivest.  This code was
// written by Colin Plumb in 1993, no copyright is claimed.
// This code is in the public domain; do with it what you wish.
//
// Equivalent code is available from RSA Data Security, Inc.
// This code has been tested against that, and is equivalent,
// except that you don't need to include two pages of legalese
// with every copy.
//
// To compute the message digest of a chunk of bytes, declare an
// MD5Context structure, pass it to MD5Init, call MD5Update as
// needed on buffers full of bytes, and then call MD5Final, which
// will fill a supplied 16-byte array with the digest.

// If compiled on a machine that doesn't have a 32-bit integer,
// you just set "uint32" to the appropriate datatype for an
// unsigned 32-bit integer.  For example:
//
//       cc -Duint32='unsigned long' md5.c
//

type MD5Context1 = struct {
	FisInit int32
	Fbuf    [4]uint32
	Fbits   [2]uint32
	Fin     [64]uint8
}

type MD5Context = MD5Context1 /* test_md5.c:63:27 */

// Note: this code is harmless on little-endian machines.
func byteReverse(tls *crt.TLS, buf uintptr, longs uint32) { /* test_md5.c:68:13: */
	var t uint32
	for ok := true; ok; ok = crt.PreDecUint32(&longs, 1) != 0 {
		t = ((((uint32(*(*uint8)(unsafe.Pointer(buf + uintptr(3)))) << 8) | uint32(*(*uint8)(unsafe.Pointer(buf + uintptr(2))))) << 16) | ((uint32(*(*uint8)(unsafe.Pointer(buf + uintptr(1)))) << 8) | uint32(*(*uint8)(unsafe.Pointer(buf + uintptr(0))))))
		*(*uint32)(unsafe.Pointer(buf)) = t
		buf += uintptr(4)
	}
}

// The four core functions - F1 is optimized somewhat

// #define F1(x, y, z) (x & y | ~x & z)

// This is the central step in the MD5 algorithm.

// The core of the MD5 algorithm, this alters an existing MD5 hash to
// reflect the addition of 16 longwords of new data.  MD5Update blocks
// the data and converts bytes into longwords for this routine.
func MD5Transform(tls *crt.TLS, buf uintptr, in uintptr) { /* test_md5.c:94:13: */
	var a uint32
	var b uint32
	var c uint32
	var d uint32

	a = *(*uint32)(unsafe.Pointer(buf + uintptr(0)*4))
	b = *(*uint32)(unsafe.Pointer(buf + uintptr(1)*4))
	c = *(*uint32)(unsafe.Pointer(buf + uintptr(2)*4))
	d = *(*uint32)(unsafe.Pointer(buf + uintptr(3)*4))

	a = a + (((d ^ (b & (c ^ d))) + *(*uint32)(unsafe.Pointer(in + uintptr(0)*4))) + 0xd76aa478)
	a = ((a << 7) | (a >> (32 - 7)))
	a = a + (b)
	d = d + (((c ^ (a & (b ^ c))) + *(*uint32)(unsafe.Pointer(in + uintptr(1)*4))) + 0xe8c7b756)
	d = ((d << 12) | (d >> (32 - 12)))
	d = d + (a)
	c = c + (((b ^ (d & (a ^ b))) + *(*uint32)(unsafe.Pointer(in + uintptr(2)*4))) + uint32(0x242070db))
	c = ((c << 17) | (c >> (32 - 17)))
	c = c + (d)
	b = b + (((a ^ (c & (d ^ a))) + *(*uint32)(unsafe.Pointer(in + uintptr(3)*4))) + 0xc1bdceee)
	b = ((b << 22) | (b >> (32 - 22)))
	b = b + (c)
	a = a + (((d ^ (b & (c ^ d))) + *(*uint32)(unsafe.Pointer(in + uintptr(4)*4))) + 0xf57c0faf)
	a = ((a << 7) | (a >> (32 - 7)))
	a = a + (b)
	d = d + (((c ^ (a & (b ^ c))) + *(*uint32)(unsafe.Pointer(in + uintptr(5)*4))) + uint32(0x4787c62a))
	d = ((d << 12) | (d >> (32 - 12)))
	d = d + (a)
	c = c + (((b ^ (d & (a ^ b))) + *(*uint32)(unsafe.Pointer(in + uintptr(6)*4))) + 0xa8304613)
	c = ((c << 17) | (c >> (32 - 17)))
	c = c + (d)
	b = b + (((a ^ (c & (d ^ a))) + *(*uint32)(unsafe.Pointer(in + uintptr(7)*4))) + 0xfd469501)
	b = ((b << 22) | (b >> (32 - 22)))
	b = b + (c)
	a = a + (((d ^ (b & (c ^ d))) + *(*uint32)(unsafe.Pointer(in + uintptr(8)*4))) + uint32(0x698098d8))
	a = ((a << 7) | (a >> (32 - 7)))
	a = a + (b)
	d = d + (((c ^ (a & (b ^ c))) + *(*uint32)(unsafe.Pointer(in + uintptr(9)*4))) + 0x8b44f7af)
	d = ((d << 12) | (d >> (32 - 12)))
	d = d + (a)
	c = c + (((b ^ (d & (a ^ b))) + *(*uint32)(unsafe.Pointer(in + uintptr(10)*4))) + 0xffff5bb1)
	c = ((c << 17) | (c >> (32 - 17)))
	c = c + (d)
	b = b + (((a ^ (c & (d ^ a))) + *(*uint32)(unsafe.Pointer(in + uintptr(11)*4))) + 0x895cd7be)
	b = ((b << 22) | (b >> (32 - 22)))
	b = b + (c)
	a = a + (((d ^ (b & (c ^ d))) + *(*uint32)(unsafe.Pointer(in + uintptr(12)*4))) + uint32(0x6b901122))
	a = ((a << 7) | (a >> (32 - 7)))
	a = a + (b)
	d = d + (((c ^ (a & (b ^ c))) + *(*uint32)(unsafe.Pointer(in + uintptr(13)*4))) + 0xfd987193)
	d = ((d << 12) | (d >> (32 - 12)))
	d = d + (a)
	c = c + (((b ^ (d & (a ^ b))) + *(*uint32)(unsafe.Pointer(in + uintptr(14)*4))) + 0xa679438e)
	c = ((c << 17) | (c >> (32 - 17)))
	c = c + (d)
	b = b + (((a ^ (c & (d ^ a))) + *(*uint32)(unsafe.Pointer(in + uintptr(15)*4))) + uint32(0x49b40821))
	b = ((b << 22) | (b >> (32 - 22)))
	b = b + (c)

	a = a + (((c ^ (d & (b ^ c))) + *(*uint32)(unsafe.Pointer(in + uintptr(1)*4))) + 0xf61e2562)
	a = ((a << 5) | (a >> (32 - 5)))
	a = a + (b)
	d = d + (((b ^ (c & (a ^ b))) + *(*uint32)(unsafe.Pointer(in + uintptr(6)*4))) + 0xc040b340)
	d = ((d << 9) | (d >> (32 - 9)))
	d = d + (a)
	c = c + (((a ^ (b & (d ^ a))) + *(*uint32)(unsafe.Pointer(in + uintptr(11)*4))) + uint32(0x265e5a51))
	c = ((c << 14) | (c >> (32 - 14)))
	c = c + (d)
	b = b + (((d ^ (a & (c ^ d))) + *(*uint32)(unsafe.Pointer(in + uintptr(0)*4))) + 0xe9b6c7aa)
	b = ((b << 20) | (b >> (32 - 20)))
	b = b + (c)
	a = a + (((c ^ (d & (b ^ c))) + *(*uint32)(unsafe.Pointer(in + uintptr(5)*4))) + 0xd62f105d)
	a = ((a << 5) | (a >> (32 - 5)))
	a = a + (b)
	d = d + (((b ^ (c & (a ^ b))) + *(*uint32)(unsafe.Pointer(in + uintptr(10)*4))) + uint32(0x02441453))
	d = ((d << 9) | (d >> (32 - 9)))
	d = d + (a)
	c = c + (((a ^ (b & (d ^ a))) + *(*uint32)(unsafe.Pointer(in + uintptr(15)*4))) + 0xd8a1e681)
	c = ((c << 14) | (c >> (32 - 14)))
	c = c + (d)
	b = b + (((d ^ (a & (c ^ d))) + *(*uint32)(unsafe.Pointer(in + uintptr(4)*4))) + 0xe7d3fbc8)
	b = ((b << 20) | (b >> (32 - 20)))
	b = b + (c)
	a = a + (((c ^ (d & (b ^ c))) + *(*uint32)(unsafe.Pointer(in + uintptr(9)*4))) + uint32(0x21e1cde6))
	a = ((a << 5) | (a >> (32 - 5)))
	a = a + (b)
	d = d + (((b ^ (c & (a ^ b))) + *(*uint32)(unsafe.Pointer(in + uintptr(14)*4))) + 0xc33707d6)
	d = ((d << 9) | (d >> (32 - 9)))
	d = d + (a)
	c = c + (((a ^ (b & (d ^ a))) + *(*uint32)(unsafe.Pointer(in + uintptr(3)*4))) + 0xf4d50d87)
	c = ((c << 14) | (c >> (32 - 14)))
	c = c + (d)
	b = b + (((d ^ (a & (c ^ d))) + *(*uint32)(unsafe.Pointer(in + uintptr(8)*4))) + uint32(0x455a14ed))
	b = ((b << 20) | (b >> (32 - 20)))
	b = b + (c)
	a = a + (((c ^ (d & (b ^ c))) + *(*uint32)(unsafe.Pointer(in + uintptr(13)*4))) + 0xa9e3e905)
	a = ((a << 5) | (a >> (32 - 5)))
	a = a + (b)
	d = d + (((b ^ (c & (a ^ b))) + *(*uint32)(unsafe.Pointer(in + uintptr(2)*4))) + 0xfcefa3f8)
	d = ((d << 9) | (d >> (32 - 9)))
	d = d + (a)
	c = c + (((a ^ (b & (d ^ a))) + *(*uint32)(unsafe.Pointer(in + uintptr(7)*4))) + uint32(0x676f02d9))
	c = ((c << 14) | (c >> (32 - 14)))
	c = c + (d)
	b = b + (((d ^ (a & (c ^ d))) + *(*uint32)(unsafe.Pointer(in + uintptr(12)*4))) + 0x8d2a4c8a)
	b = ((b << 20) | (b >> (32 - 20)))
	b = b + (c)

	a = a + ((((b ^ c) ^ d) + *(*uint32)(unsafe.Pointer(in + uintptr(5)*4))) + 0xfffa3942)
	a = ((a << 4) | (a >> (32 - 4)))
	a = a + (b)
	d = d + ((((a ^ b) ^ c) + *(*uint32)(unsafe.Pointer(in + uintptr(8)*4))) + 0x8771f681)
	d = ((d << 11) | (d >> (32 - 11)))
	d = d + (a)
	c = c + ((((d ^ a) ^ b) + *(*uint32)(unsafe.Pointer(in + uintptr(11)*4))) + uint32(0x6d9d6122))
	c = ((c << 16) | (c >> (32 - 16)))
	c = c + (d)
	b = b + ((((c ^ d) ^ a) + *(*uint32)(unsafe.Pointer(in + uintptr(14)*4))) + 0xfde5380c)
	b = ((b << 23) | (b >> (32 - 23)))
	b = b + (c)
	a = a + ((((b ^ c) ^ d) + *(*uint32)(unsafe.Pointer(in + uintptr(1)*4))) + 0xa4beea44)
	a = ((a << 4) | (a >> (32 - 4)))
	a = a + (b)
	d = d + ((((a ^ b) ^ c) + *(*uint32)(unsafe.Pointer(in + uintptr(4)*4))) + uint32(0x4bdecfa9))
	d = ((d << 11) | (d >> (32 - 11)))
	d = d + (a)
	c = c + ((((d ^ a) ^ b) + *(*uint32)(unsafe.Pointer(in + uintptr(7)*4))) + 0xf6bb4b60)
	c = ((c << 16) | (c >> (32 - 16)))
	c = c + (d)
	b = b + ((((c ^ d) ^ a) + *(*uint32)(unsafe.Pointer(in + uintptr(10)*4))) + 0xbebfbc70)
	b = ((b << 23) | (b >> (32 - 23)))
	b = b + (c)
	a = a + ((((b ^ c) ^ d) + *(*uint32)(unsafe.Pointer(in + uintptr(13)*4))) + uint32(0x289b7ec6))
	a = ((a << 4) | (a >> (32 - 4)))
	a = a + (b)
	d = d + ((((a ^ b) ^ c) + *(*uint32)(unsafe.Pointer(in + uintptr(0)*4))) + 0xeaa127fa)
	d = ((d << 11) | (d >> (32 - 11)))
	d = d + (a)
	c = c + ((((d ^ a) ^ b) + *(*uint32)(unsafe.Pointer(in + uintptr(3)*4))) + 0xd4ef3085)
	c = ((c << 16) | (c >> (32 - 16)))
	c = c + (d)
	b = b + ((((c ^ d) ^ a) + *(*uint32)(unsafe.Pointer(in + uintptr(6)*4))) + uint32(0x04881d05))
	b = ((b << 23) | (b >> (32 - 23)))
	b = b + (c)
	a = a + ((((b ^ c) ^ d) + *(*uint32)(unsafe.Pointer(in + uintptr(9)*4))) + 0xd9d4d039)
	a = ((a << 4) | (a >> (32 - 4)))
	a = a + (b)
	d = d + ((((a ^ b) ^ c) + *(*uint32)(unsafe.Pointer(in + uintptr(12)*4))) + 0xe6db99e5)
	d = ((d << 11) | (d >> (32 - 11)))
	d = d + (a)
	c = c + ((((d ^ a) ^ b) + *(*uint32)(unsafe.Pointer(in + uintptr(15)*4))) + uint32(0x1fa27cf8))
	c = ((c << 16) | (c >> (32 - 16)))
	c = c + (d)
	b = b + ((((c ^ d) ^ a) + *(*uint32)(unsafe.Pointer(in + uintptr(2)*4))) + 0xc4ac5665)
	b = ((b << 23) | (b >> (32 - 23)))
	b = b + (c)

	a = a + (((c ^ (b | ^d)) + *(*uint32)(unsafe.Pointer(in + uintptr(0)*4))) + 0xf4292244)
	a = ((a << 6) | (a >> (32 - 6)))
	a = a + (b)
	d = d + (((b ^ (a | ^c)) + *(*uint32)(unsafe.Pointer(in + uintptr(7)*4))) + uint32(0x432aff97))
	d = ((d << 10) | (d >> (32 - 10)))
	d = d + (a)
	c = c + (((a ^ (d | ^b)) + *(*uint32)(unsafe.Pointer(in + uintptr(14)*4))) + 0xab9423a7)
	c = ((c << 15) | (c >> (32 - 15)))
	c = c + (d)
	b = b + (((d ^ (c | ^a)) + *(*uint32)(unsafe.Pointer(in + uintptr(5)*4))) + 0xfc93a039)
	b = ((b << 21) | (b >> (32 - 21)))
	b = b + (c)
	a = a + (((c ^ (b | ^d)) + *(*uint32)(unsafe.Pointer(in + uintptr(12)*4))) + uint32(0x655b59c3))
	a = ((a << 6) | (a >> (32 - 6)))
	a = a + (b)
	d = d + (((b ^ (a | ^c)) + *(*uint32)(unsafe.Pointer(in + uintptr(3)*4))) + 0x8f0ccc92)
	d = ((d << 10) | (d >> (32 - 10)))
	d = d + (a)
	c = c + (((a ^ (d | ^b)) + *(*uint32)(unsafe.Pointer(in + uintptr(10)*4))) + 0xffeff47d)
	c = ((c << 15) | (c >> (32 - 15)))
	c = c + (d)
	b = b + (((d ^ (c | ^a)) + *(*uint32)(unsafe.Pointer(in + uintptr(1)*4))) + 0x85845dd1)
	b = ((b << 21) | (b >> (32 - 21)))
	b = b + (c)
	a = a + (((c ^ (b | ^d)) + *(*uint32)(unsafe.Pointer(in + uintptr(8)*4))) + uint32(0x6fa87e4f))
	a = ((a << 6) | (a >> (32 - 6)))
	a = a + (b)
	d = d + (((b ^ (a | ^c)) + *(*uint32)(unsafe.Pointer(in + uintptr(15)*4))) + 0xfe2ce6e0)
	d = ((d << 10) | (d >> (32 - 10)))
	d = d + (a)
	c = c + (((a ^ (d | ^b)) + *(*uint32)(unsafe.Pointer(in + uintptr(6)*4))) + 0xa3014314)
	c = ((c << 15) | (c >> (32 - 15)))
	c = c + (d)
	b = b + (((d ^ (c | ^a)) + *(*uint32)(unsafe.Pointer(in + uintptr(13)*4))) + uint32(0x4e0811a1))
	b = ((b << 21) | (b >> (32 - 21)))
	b = b + (c)
	a = a + (((c ^ (b | ^d)) + *(*uint32)(unsafe.Pointer(in + uintptr(4)*4))) + 0xf7537e82)
	a = ((a << 6) | (a >> (32 - 6)))
	a = a + (b)
	d = d + (((b ^ (a | ^c)) + *(*uint32)(unsafe.Pointer(in + uintptr(11)*4))) + 0xbd3af235)
	d = ((d << 10) | (d >> (32 - 10)))
	d = d + (a)
	c = c + (((a ^ (d | ^b)) + *(*uint32)(unsafe.Pointer(in + uintptr(2)*4))) + uint32(0x2ad7d2bb))
	c = ((c << 15) | (c >> (32 - 15)))
	c = c + (d)
	b = b + (((d ^ (c | ^a)) + *(*uint32)(unsafe.Pointer(in + uintptr(9)*4))) + 0xeb86d391)
	b = ((b << 21) | (b >> (32 - 21)))
	b = b + (c)

	*(*uint32)(unsafe.Pointer(buf + uintptr(0)*4)) += (a)
	*(*uint32)(unsafe.Pointer(buf + uintptr(1)*4)) += (b)
	*(*uint32)(unsafe.Pointer(buf + uintptr(2)*4)) += (c)
	*(*uint32)(unsafe.Pointer(buf + uintptr(3)*4)) += (d)
}

// Start MD5 accumulation.  Set bit count to 0 and buffer to mysterious
// initialization constants.
func MD5Init(tls *crt.TLS, ctx uintptr) { /* test_md5.c:180:13: */
	(*MD5Context)(unsafe.Pointer(ctx)).FisInit = 1
	*(*uint32)(unsafe.Pointer((ctx + 4 /* &.buf */) + uintptr(0)*4)) = uint32(0x67452301)
	*(*uint32)(unsafe.Pointer((ctx + 4 /* &.buf */) + uintptr(1)*4)) = 0xefcdab89
	*(*uint32)(unsafe.Pointer((ctx + 4 /* &.buf */) + uintptr(2)*4)) = 0x98badcfe
	*(*uint32)(unsafe.Pointer((ctx + 4 /* &.buf */) + uintptr(3)*4)) = uint32(0x10325476)
	*(*uint32)(unsafe.Pointer((ctx + 20 /* &.bits */) + uintptr(0)*4)) = uint32(0)
	*(*uint32)(unsafe.Pointer((ctx + 20 /* &.bits */) + uintptr(1)*4)) = uint32(0)
}

// Update context to reflect the concatenation of another buffer full
// of bytes.
func MD5Update(tls *crt.TLS, ctx uintptr, buf uintptr, len uint32) { /* test_md5.c:195:6: */
	var t uint32

	// Update bitcount

	t = *(*uint32)(unsafe.Pointer((ctx + 20 /* &.bits */) + uintptr(0)*4))
	if (crt.AssignPtrUint32((ctx+20 /* &.bits */)+uintptr(0)*4, (t + (len << 3)))) < t {
		*(*uint32)(unsafe.Pointer((ctx + 20 /* &.bits */) + uintptr(1)*4))++
	} // Carry from low to high
	*(*uint32)(unsafe.Pointer((ctx + 20 /* &.bits */) + uintptr(1)*4)) += (len >> 29)

	t = ((t >> 3) & uint32(0x3f)) // Bytes already in shsInfo->data

	// Handle any leading odd-sized chunks

	if t != 0 {
		var p uintptr = (ctx + 28 /* &.in */ + uintptr(t))

		t = (uint32(64) - t)
		if len < t {
			crt.Xmemcpy(tls, p, buf, uint64(len))
			return
		}
		crt.Xmemcpy(tls, p, buf, uint64(t))
		byteReverse(tls, ctx+28 /* &.in */, uint32(16))
		MD5Transform(tls, ctx+4 /* &.buf */, ctx+28 /* &.in */)
		buf += uintptr(t)
		len = len - (t)
	}

	// Process data in 64-byte chunks

	for len >= uint32(64) {
		crt.Xmemcpy(tls, ctx+28 /* &.in */, buf, uint64(64))
		byteReverse(tls, ctx+28 /* &.in */, uint32(16))
		MD5Transform(tls, ctx+4 /* &.buf */, ctx+28 /* &.in */)
		buf += uintptr(64)
		len = len - (uint32(64))
	}

	// Handle any remaining bytes of data.

	crt.Xmemcpy(tls, ctx+28 /* &.in */, buf, uint64(len))
}

// Final wrapup - pad to 64-byte boundary with the bit pattern
// 1 0* (64-bit count of bits processed, MSB-first)
func MD5Final(tls *crt.TLS, digest uintptr, ctx uintptr) { /* test_md5.c:243:13: */
	var count uint32
	var p uintptr

	// Compute number of bytes mod 64
	count = ((*(*uint32)(unsafe.Pointer((ctx + 20 /* &.bits */) + uintptr(0)*4)) >> 3) & uint32(0x3F))

	// Set the first char of padding to 0x80.  This is safe since there is
	//           always at least one byte free
	p = ((ctx + 28 /* &.in */) + uintptr(count))
	*(*uint8)(unsafe.Pointer(crt.PostIncUintptr(&p, 1))) = uint8(0x80)

	// Bytes of padding needed to make 64 bytes
	count = ((uint32(64 - 1)) - count)

	// Pad out to 56 mod 64
	if count < uint32(8) {
		// Two lots of padding:  Pad the first block to 64 bytes
		crt.Xmemset(tls, p, 0, uint64(count))
		byteReverse(tls, ctx+28 /* &.in */, uint32(16))
		MD5Transform(tls, ctx+4 /* &.buf */, ctx+28 /* &.in */)

		// Now fill the next block with 56 bytes
		crt.Xmemset(tls, ctx+28 /* &.in */, 0, uint64(56))
	} else {
		// Pad block to 56 bytes
		crt.Xmemset(tls, p, 0, (uint64(count - uint32(8))))
	}
	byteReverse(tls, ctx+28 /* &.in */, uint32(14))

	// Append length in bits and transform
	crt.Xmemcpy(tls, ((ctx + 28 /* &.in */) + uintptr((14 * 4))), ctx+20 /* &.bits */, uint64(8))

	MD5Transform(tls, ctx+4 /* &.buf */, ctx+28 /* &.in */)
	byteReverse(tls, ctx+4 /* &.buf */, uint32(4))
	crt.Xmemcpy(tls, digest, ctx+4 /* &.buf */, uint64(16))
}

// Convert a 128-bit MD5 digest into a 32-digit base-16 number.
func MD5DigestToBase16(tls *crt.TLS, digest uintptr, zBuf uintptr) { /* test_md5.c:284:13: */
	var i int32
	var j int32

	for j = crt.AssignInt32(&i, 0); i < 16; i++ {
		var a int32 = int32(*(*uint8)(unsafe.Pointer(digest + uintptr(i))))
		*(*int8)(unsafe.Pointer(zBuf + uintptr(crt.PostIncInt32(&j, 1)))) = zEncode[((a >> 4) & 0xf)]
		*(*int8)(unsafe.Pointer(zBuf + uintptr(crt.PostIncInt32(&j, 1)))) = zEncode[(a & 0xf)]
	}
	*(*int8)(unsafe.Pointer(zBuf + uintptr(j))) = int8(0)
}

var zEncode = *(*[17]int8)(unsafe.Pointer(ts + 36152 /* "0123456789abcdef" */)) /* test_md5.c:285:21 */

// Convert a 128-bit MD5 digest into sequency of eight 5-digit integers
// each representing 16 bits of the digest and separated from each
// other by a "-" character.
func MD5DigestToBase10x8(tls *crt.TLS, digest uintptr, zDigest uintptr) { /* test_md5.c:302:13: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var i int32
	var j int32
	var x uint32
	for i = crt.AssignInt32(&j, 0); i < 16; i = i + (2) {
		x = (uint32((int32(*(*uint8)(unsafe.Pointer(digest + uintptr(i)))) * 256) + int32(*(*uint8)(unsafe.Pointer(digest + uintptr((i + 1)))))))
		if i > 0 {
			*(*int8)(unsafe.Pointer(zDigest + uintptr(crt.PostIncInt32(&j, 1)))) = int8('-')
		}
		sqlite3.Xsqlite3_snprintf(tls, (50 - j), (zDigest + uintptr(j)), ts+39422 /* "%05u" */, crt.VaList(bp, x))
		j = j + (5)
	}
	*(*int8)(unsafe.Pointer(zDigest + uintptr(j))) = int8(0)
}

// A TCL command for md5.  The argument is the text to be hashed.  The
// Result is the hash in base64.
func md5_cmd(tls *crt.TLS, cd uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test_md5.c:318:26: */
	bp := tls.Alloc(206)
	defer tls.Free(206)

	// var ctx MD5Context at bp+48, 92

	// var digest [16]uint8 at bp+140, 16

	// var zBuf [50]int8 at bp+156, 50

	var converter uintptr

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
			ts+21931 /* " TEXT\"" */, uintptr(0)))
		return 1
	}
	MD5Init(tls, bp+48 /* &ctx */)
	MD5Update(tls, bp+48 /* &ctx */, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), uint32(crt.Xstrlen(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)))))
	MD5Final(tls, bp+140 /* &digest[0] */, bp+48 /* &ctx */)
	converter = cd
	(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer(&converter)))(tls, bp+140 /* &digest[0] */, bp+156 /* &zBuf[0] */)
	tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+32, bp+156 /* &zBuf[0] */, uintptr(0)))
	return 0
}

// A TCL command to take the md5 hash of a file.  The argument is the
// name of the file.
func md5file_cmd(tls *crt.TLS, cd uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test_md5.c:347:26: */
	bp := tls.Alloc(10428)
	defer tls.Free(10428)

	var in uintptr
	var ofst int32
	var amt int32
	// var ctx MD5Context at bp+80, 92

	var converter uintptr
	// var digest [16]uint8 at bp+10412, 16

	// var zBuf [10240]int8 at bp+172, 10240

	if (argc != 2) && (argc != 4) {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
			ts+39427 /* " FILENAME [OFFSE..." */, uintptr(0)))
		return 1
	}
	if argc == 4 {
		ofst = crt.Xatoi(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8)))
		amt = crt.Xatoi(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(3)*8)))
	} else {
		ofst = 0
		amt = 2147483647
	}
	in = crt.Xfopen(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), ts+3756 /* "rb" */)
	if in == uintptr(0) {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+32, ts+39451 /* "unable to open f..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)),
			ts+39473 /* "\" for reading" */, uintptr(0)))
		return 1
	}
	crt.Xfseek(tls, in, int64(ofst), 0)
	MD5Init(tls, bp+80 /* &ctx */)
	for amt > 0 {
		var n int32
		n = int32(crt.Xfread(tls, bp+172 /* &zBuf[0] */, uint64(1), func() uint64 {
			if uint64(unsafe.Sizeof([10240]int8{})) <= uint64(amt) {
				return uint64(unsafe.Sizeof([10240]int8{}))
			}
			return uint64(amt)
		}(), in))
		if n <= 0 {
			break
		}
		MD5Update(tls, bp+80 /* &ctx */, bp+172 /* zBuf */, uint32(n))
		amt = amt - (n)
	}
	crt.Xfclose(tls, in)
	MD5Final(tls, bp+10412 /* &digest[0] */, bp+80 /* &ctx */)
	converter = cd
	(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer(&converter)))(tls, bp+10412 /* &digest[0] */, bp+172 /* &zBuf[0] */)
	tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+64, bp+172 /* &zBuf[0] */, uintptr(0)))
	return 0
}

// Register the four new TCL commands for generating MD5 checksums
// with the TCL interpreter.
func Md5_Init(tls *crt.TLS, interp uintptr) int32 { /* test_md5.c:400:5: */
	tcl.XTcl_CreateCommand(tls, interp, ts+39487 /* "md5" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{md5_cmd})),
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*crt.TLS, uintptr, uintptr)
		}{MD5DigestToBase16})), uintptr(0))
	tcl.XTcl_CreateCommand(tls, interp, ts+39491 /* "md5-10x8" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{md5_cmd})),
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*crt.TLS, uintptr, uintptr)
		}{MD5DigestToBase10x8})), uintptr(0))
	tcl.XTcl_CreateCommand(tls, interp, ts+39500 /* "md5file" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{md5file_cmd})),
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*crt.TLS, uintptr, uintptr)
		}{MD5DigestToBase16})), uintptr(0))
	tcl.XTcl_CreateCommand(tls, interp, ts+39508 /* "md5file-10x8" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{md5file_cmd})),
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*crt.TLS, uintptr, uintptr)
		}{MD5DigestToBase10x8})), uintptr(0))
	return 0
}

// During testing, the special md5sum() aggregate function is available.
// inside SQLite.  The following routines implement that function.
func md5step(tls *crt.TLS, context uintptr, argc int32, argv uintptr) { /* test_md5.c:416:13: */
	var p uintptr
	var i int32
	if argc < 1 {
		return
	}
	p = sqlite3.Xsqlite3_aggregate_context(tls, context, int32(unsafe.Sizeof(MD5Context{})))
	if p == uintptr(0) {
		return
	}
	if !((*MD5Context)(unsafe.Pointer(p)).FisInit != 0) {
		MD5Init(tls, p)
	}
	for i = 0; i < argc; i++ {
		var zData uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8)))
		if zData != 0 {
			MD5Update(tls, p, zData, uint32(int32(crt.Xstrlen(tls, zData))))
		}
	}
}
func md5finalize(tls *crt.TLS, context uintptr) { /* test_md5.c:432:13: */
	bp := tls.Alloc(49)
	defer tls.Free(49)

	var p uintptr
	// var digest [16]uint8 at bp, 16

	// var zBuf [33]int8 at bp+16, 33

	p = sqlite3.Xsqlite3_aggregate_context(tls, context, int32(unsafe.Sizeof(MD5Context{})))
	MD5Final(tls, bp /* &digest[0] */, p)
	MD5DigestToBase16(tls, bp /* &digest[0] */, bp+16 /* &zBuf[0] */)
	sqlite3.Xsqlite3_result_text(tls, context, bp+16 /* &zBuf[0] */, -1, crt.UintptrFromInt32(-1))
}
func Md5_Register(tls *crt.TLS, db uintptr, pzErrMsg uintptr, pThunk uintptr) int32 { /* test_md5.c:441:5: */
	var rc int32 = sqlite3.Xsqlite3_create_function(tls, db, ts+39521 /* "md5sum" */, -1, 1, uintptr(0), uintptr(0),
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*crt.TLS, uintptr, int32, uintptr)
		}{md5step})), *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, uintptr) }{md5finalize})))
	sqlite3.Xsqlite3_overload_function(tls, db, ts+39521 /* "md5sum" */, -1) // To exercise this API
	return rc
}

// The following macros redefine the API routines so that they are
// redirected through the global sqlite3_api structure.
//
// This header file is also used by the loadext.c source file
// (part of the main SQLite library - not an extension) so that
// it can get access to the sqlite3_api_routines structure
// definition.  But the main library does not want to redefine
// the API.  So the redefinition macros are only valid if the
// SQLITE_CORE macros is undefined.

// This case when the file is being statically linked into the
// application

// These should be defined to be the same as the values in
// sqliteInt.h.  They are defined separately here so that
// the multiplex VFS shim can be built as a loadable
// module.

// Maximum chunk number

// First chunk for rollback journal files

//*********************** Shim Definitions *****************************

// This is the limit on the chunk size.  It may be changed by calling
// the xFileControl() interface.  It will be rounded up to a
// multiple of MAX_PAGE_SIZE.  We default it here to 2GiB less 64KiB.

// This used to be the default limit on number of chunks, but
// it is no longer enforced. There is currently no limit to the
// number of chunks.
//
// May be changed by calling the xFileControl() interface.

//*********************** Object Definitions *****************************

// Forward declaration of all object types
type multiplexGroup1 = struct {
	FaReal     uintptr
	FnReal     int32
	FzName     uintptr
	FnName     int32
	Fflags     int32
	FszChunk   uint32
	FbEnabled  uint8
	FbTruncate uint8
	_          [2]byte
}

// The following macros redefine the API routines so that they are
// redirected through the global sqlite3_api structure.
//
// This header file is also used by the loadext.c source file
// (part of the main SQLite library - not an extension) so that
// it can get access to the sqlite3_api_routines structure
// definition.  But the main library does not want to redefine
// the API.  So the redefinition macros are only valid if the
// SQLITE_CORE macros is undefined.

// This case when the file is being statically linked into the
// application

// These should be defined to be the same as the values in
// sqliteInt.h.  They are defined separately here so that
// the multiplex VFS shim can be built as a loadable
// module.

// Maximum chunk number

// First chunk for rollback journal files

//*********************** Shim Definitions *****************************

// This is the limit on the chunk size.  It may be changed by calling
// the xFileControl() interface.  It will be rounded up to a
// multiple of MAX_PAGE_SIZE.  We default it here to 2GiB less 64KiB.

// This used to be the default limit on number of chunks, but
// it is no longer enforced. There is currently no limit to the
// number of chunks.
//
// May be changed by calling the xFileControl() interface.

//*********************** Object Definitions *****************************

// Forward declaration of all object types
type multiplexGroup = multiplexGroup1 /* test_multiplex.c:106:31 */
type multiplexConn1 = struct {
	Fbase   sqlite3_file
	FpGroup uintptr
}

type multiplexConn = multiplexConn1 /* test_multiplex.c:107:30 */

// A "multiplex group" is a collection of files that collectively
// makeup a single SQLite DB file.  This allows the size of the DB
// to exceed the limits imposed by the file system.
//
// There is an instance of the following object for each defined multiplex
// group.
type multiplexReal = struct {
	Fp uintptr
	Fz uintptr
}

//************************ Global Variables *********************************
// All global variables used by this file are containing within the following
// gMultiplex structure.
var gMultiplex struct {
	FpOrigVfs      uintptr
	FsThisVfs      sqlite3_vfs
	FsIoMethodsV1  sqlite3_io_methods
	FsIoMethodsV2  sqlite3_io_methods
	FisInitialized int32
	_              [4]byte
} /* test_multiplex.c:176:3: */

//************************ Utility Routines ********************************
// Compute a string length that is limited to what can be stored in
// lower 30 bits of a 32-bit signed integer.
//
// The value returned will never be negative.  Nor will it ever be greater
// than the actual length of the string.  For very long strings (greater
// than 1GiB) the value returned might be less than the true string length.
func multiplexStrlen30(tls *crt.TLS, z uintptr) int32 { /* test_multiplex.c:187:12: */
	var z2 uintptr = z
	if z == uintptr(0) {
		return 0
	}
	for *(*int8)(unsafe.Pointer(z2)) != 0 {
		z2++
	}
	return (0x3fffffff & (int32((int64(z2) - int64(z)) / 1)))
}

// Generate the file-name for chunk iChunk of the group with base name
// zBase. The file-name is written to buffer zOut before returning. Buffer
// zOut must be allocated by the caller so that it is at least (nBase+5)
// bytes in size, where nBase is the length of zBase, not including the
// nul-terminator.
//
// If iChunk is 0 (or 400 - the number for the first journal file chunk),
// the output is a copy of the input string. Otherwise, if
// SQLITE_ENABLE_8_3_NAMES is not defined or the input buffer does not contain
// a "." character, then the output is a copy of the input string with the
// three-digit zero-padded decimal representation if iChunk appended to it.
// For example:
//
//   zBase="test.db", iChunk=4  ->  zOut="test.db004"
//
// Or, if SQLITE_ENABLE_8_3_NAMES is defined and the input buffer contains
// a "." character, then everything after the "." is replaced by the
// three-digit representation of iChunk.
//
//   zBase="test.db", iChunk=4  ->  zOut="test.004"
//
// The output buffer string is terminated by 2 0x00 bytes. This makes it safe
// to pass to sqlite3_uri_parameter() and similar.
func multiplexFilename(tls *crt.TLS, zBase uintptr, nBase int32, flags int32, iChunk int32, zOut uintptr) { /* test_multiplex.c:219:13: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var n int32 = nBase
	crt.Xmemcpy(tls, zOut, zBase, (uint64(n + 1)))
	if (iChunk != 0) && (iChunk <= 299) {
		sqlite3.Xsqlite3_snprintf(tls, 4, (zOut + uintptr(n)), ts+39528 /* "%03d" */, crt.VaList(bp, iChunk))
		n = n + (3)
	}

	if !(int32(*(*int8)(unsafe.Pointer(zOut + uintptr(n)))) == 0) {
		crt.X__assert_fail(tls, ts+39533 /* "zOut[n]=='\\0'" */, ts+39547 /* "testdata/sqlite-..." */, uint32(250), uintptr(unsafe.Pointer(&__func__102)))
	}
	*(*int8)(unsafe.Pointer(zOut + uintptr((n + 1)))) = int8(0)
}

var __func__102 = *(*[18]int8)(unsafe.Pointer(ts + 39596 /* "multiplexFilenam..." */)) /* test_multiplex.c:225:2 */

// Compute the filename for the iChunk-th chunk
func multiplexSubFilename(tls *crt.TLS, pGroup uintptr, iChunk int32) int32 { /* test_multiplex.c:256:12: */
	if iChunk >= (*multiplexGroup)(unsafe.Pointer(pGroup)).FnReal {
		var p uintptr
		p = sqlite3.Xsqlite3_realloc64(tls, (*multiplexGroup)(unsafe.Pointer(pGroup)).FaReal, (uint64((uint64(iChunk + 1)) * uint64(unsafe.Sizeof(multiplexReal{})))))
		if p == uintptr(0) {
			return 7
		}
		crt.Xmemset(tls, (p + uintptr((*multiplexGroup)(unsafe.Pointer(pGroup)).FnReal)*16), 0, (uint64(unsafe.Sizeof(multiplexReal{})) * (uint64((iChunk + 1) - (*multiplexGroup)(unsafe.Pointer(pGroup)).FnReal))))
		(*multiplexGroup)(unsafe.Pointer(pGroup)).FaReal = p
		(*multiplexGroup)(unsafe.Pointer(pGroup)).FnReal = (iChunk + 1)
	}
	if ((*multiplexGroup)(unsafe.Pointer(pGroup)).FzName != 0) && ((*multiplexReal)(unsafe.Pointer((*multiplexGroup)(unsafe.Pointer(pGroup)).FaReal+uintptr(iChunk)*16)).Fz == uintptr(0)) {
		var z uintptr
		var n int32 = (*multiplexGroup)(unsafe.Pointer(pGroup)).FnName
		z = sqlite3.Xsqlite3_malloc64(tls, (uint64(n + 5)))
		if z == uintptr(0) {
			return 7
		}
		multiplexFilename(tls, (*multiplexGroup)(unsafe.Pointer(pGroup)).FzName, (*multiplexGroup)(unsafe.Pointer(pGroup)).FnName, (*multiplexGroup)(unsafe.Pointer(pGroup)).Fflags, iChunk, z)
		(*multiplexReal)(unsafe.Pointer((*multiplexGroup)(unsafe.Pointer(pGroup)).FaReal + uintptr(iChunk)*16)).Fz = sqlite3.Xsqlite3_create_filename(tls, z, ts+792 /* "" */, ts+792 /* "" */, 0, uintptr(0))
		sqlite3.Xsqlite3_free(tls, z)
		if (*multiplexReal)(unsafe.Pointer((*multiplexGroup)(unsafe.Pointer(pGroup)).FaReal+uintptr(iChunk)*16)).Fz == uintptr(0) {
			return 7
		}
	}
	return 0
}

// Translate an sqlite3_file* that is really a multiplexGroup* into
// the sqlite3_file* for the underlying original VFS.
//
// For chunk 0, the pGroup->flags determines whether or not a new file
// is created if it does not already exist.  For chunks 1 and higher, the
// file is created only if createFlag is 1.
func multiplexSubOpen(tls *crt.TLS, pGroup uintptr, iChunk int32, rc uintptr, pOutFlags uintptr, createFlag int32) uintptr { /* test_multiplex.c:289:21: */
	bp := tls.Alloc(20)
	defer tls.Free(20)

	var pSubOpen uintptr = uintptr(0)
	var pOrigVfs uintptr = gMultiplex.FpOrigVfs // Real VFS

	*(*int32)(unsafe.Pointer(rc)) = multiplexSubFilename(tls, pGroup, iChunk)
	if ((*(*int32)(unsafe.Pointer(rc))) == 0) && ((crt.AssignUintptr(&pSubOpen, (*multiplexReal)(unsafe.Pointer((*multiplexGroup)(unsafe.Pointer(pGroup)).FaReal+uintptr(iChunk)*16)).Fp)) == uintptr(0)) {
		var flags int32
		// var bExists int32 at bp+16, 4

		flags = (*multiplexGroup)(unsafe.Pointer(pGroup)).Fflags
		if createFlag != 0 {
			flags = flags | (0x00000004)
		} else if iChunk == 0 {
		} else if (*multiplexReal)(unsafe.Pointer((*multiplexGroup)(unsafe.Pointer(pGroup)).FaReal+uintptr(iChunk)*16)).Fz == uintptr(0) {
			return uintptr(0)
		} else {
			*(*int32)(unsafe.Pointer(rc)) = (*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer((pOrigVfs + 56 /* &.xAccess */))))(tls, pOrigVfs, (*multiplexReal)(unsafe.Pointer((*multiplexGroup)(unsafe.Pointer(pGroup)).FaReal+uintptr(iChunk)*16)).Fz,
				0, bp+16 /* &bExists */)
			if (*(*int32)(unsafe.Pointer(rc)) != 0) || !(*(*int32)(unsafe.Pointer(bp + 16 /* bExists */)) != 0) {
				if *(*int32)(unsafe.Pointer(rc)) != 0 {
					sqlite3.Xsqlite3_log(tls, *(*int32)(unsafe.Pointer(rc)), ts+39614, /* "multiplexor.xAcc..." */
						crt.VaList(bp, (*multiplexReal)(unsafe.Pointer((*multiplexGroup)(unsafe.Pointer(pGroup)).FaReal+uintptr(iChunk)*16)).Fz))
				}
				return uintptr(0)
			}
			flags = flags & (^int32(crt.Int32FromInt32(0x00000004)))
		}
		pSubOpen = sqlite3.Xsqlite3_malloc64(tls, uint64((*sqlite3_vfs)(unsafe.Pointer(pOrigVfs)).FszOsFile))
		if pSubOpen == uintptr(0) {
			*(*int32)(unsafe.Pointer(rc)) = (10 | (int32(12) << 8))
			return uintptr(0)
		}
		(*multiplexReal)(unsafe.Pointer((*multiplexGroup)(unsafe.Pointer(pGroup)).FaReal + uintptr(iChunk)*16)).Fp = pSubOpen
		*(*int32)(unsafe.Pointer(rc)) = (*(*func(*crt.TLS, uintptr, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer((pOrigVfs + 40 /* &.xOpen */))))(tls, pOrigVfs, (*multiplexReal)(unsafe.Pointer((*multiplexGroup)(unsafe.Pointer(pGroup)).FaReal+uintptr(iChunk)*16)).Fz, pSubOpen,
			flags, pOutFlags)
		if (*(*int32)(unsafe.Pointer(rc))) != 0 {
			sqlite3.Xsqlite3_log(tls, *(*int32)(unsafe.Pointer(rc)), ts+39648, /* "multiplexor.xOpe..." */
				crt.VaList(bp+8, (*multiplexReal)(unsafe.Pointer((*multiplexGroup)(unsafe.Pointer(pGroup)).FaReal+uintptr(iChunk)*16)).Fz))
			sqlite3.Xsqlite3_free(tls, pSubOpen)
			(*multiplexReal)(unsafe.Pointer((*multiplexGroup)(unsafe.Pointer(pGroup)).FaReal + uintptr(iChunk)*16)).Fp = uintptr(0)
			return uintptr(0)
		}
	}
	return pSubOpen
}

// Return the size, in bytes, of chunk number iChunk.  If that chunk
// does not exist, then return 0.  This function does not distingish between
// non-existant files and zero-length files.
func multiplexSubSize(tls *crt.TLS, pGroup uintptr, iChunk int32, rc uintptr) sqlite3_int64 { /* test_multiplex.c:357:22: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var pSub uintptr
	*(*sqlite3_int64)(unsafe.Pointer(bp /* sz */)) = int64(0)

	if *(*int32)(unsafe.Pointer(rc)) != 0 {
		return int64(0)
	}
	pSub = multiplexSubOpen(tls, pGroup, iChunk, rc, uintptr(0), 0)
	if pSub == uintptr(0) {
		return int64(0)
	}
	*(*int32)(unsafe.Pointer(rc)) = (*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pSub)).FpMethods + 48 /* &.xFileSize */))))(tls, pSub, bp /* &sz */)
	return *(*sqlite3_int64)(unsafe.Pointer(bp /* sz */))
}

// This is the implementation of the multiplex_control() SQL function.
func multiplexControlFunc(tls *crt.TLS, context uintptr, argc int32, argv uintptr) { /* test_multiplex.c:375:13: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var rc int32 = 0
	var db uintptr = sqlite3.Xsqlite3_context_db_handle(tls, context)
	var op int32 = 0
	// var iVal int32 at bp, 4

	if !(db != 0) || (argc != 2) {
		rc = 1
	} else {
		// extract params
		op = sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)))
		*(*int32)(unsafe.Pointer(bp /* iVal */)) = sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)))
		// map function op to file_control op
		switch op {
		case 1:
			op = 214014
			break
			fallthrough
		case 2:
			op = 214015
			break
			fallthrough
		case 3:
			op = 214016
			break
			fallthrough
		default:
			rc = 12
			break
		}
	}
	if rc == 0 {
		rc = sqlite3.Xsqlite3_file_control(tls, db, uintptr(0), op, bp /* &iVal */)
	}
	sqlite3.Xsqlite3_result_error_code(tls, context, rc)
}

// This is the entry point to register the auto-extension for the
// multiplex_control() function.
func multiplexFuncInit(tls *crt.TLS, db uintptr, pzErrMsg uintptr, pApi uintptr) int32 { /* test_multiplex.c:417:12: */
	var rc int32
	rc = sqlite3.Xsqlite3_create_function(tls, db, ts+39680 /* "multiplex_contro..." */, 2, 5,
		uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
			f func(*crt.TLS, uintptr, int32, uintptr)
		}{multiplexControlFunc})), uintptr(0), uintptr(0))
	return rc
}

// Close a single sub-file in the connection group.
func multiplexSubClose(tls *crt.TLS, pGroup uintptr, iChunk int32, pOrigVfs uintptr) { /* test_multiplex.c:431:13: */
	var pSubOpen uintptr = (*multiplexReal)(unsafe.Pointer((*multiplexGroup)(unsafe.Pointer(pGroup)).FaReal + uintptr(iChunk)*16)).Fp
	if pSubOpen != 0 {
		(*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods + 8 /* &.xClose */))))(tls, pSubOpen)
		if (pOrigVfs != 0) && ((*multiplexReal)(unsafe.Pointer((*multiplexGroup)(unsafe.Pointer(pGroup)).FaReal+uintptr(iChunk)*16)).Fz != 0) {
			(*(*func(*crt.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer((pOrigVfs + 48 /* &.xDelete */))))(tls, pOrigVfs, (*multiplexReal)(unsafe.Pointer((*multiplexGroup)(unsafe.Pointer(pGroup)).FaReal+uintptr(iChunk)*16)).Fz, 0)
		}
		sqlite3.Xsqlite3_free(tls, (*multiplexReal)(unsafe.Pointer((*multiplexGroup)(unsafe.Pointer(pGroup)).FaReal+uintptr(iChunk)*16)).Fp)
	}
	sqlite3.Xsqlite3_free_filename(tls, (*multiplexReal)(unsafe.Pointer((*multiplexGroup)(unsafe.Pointer(pGroup)).FaReal+uintptr(iChunk)*16)).Fz)
	crt.Xmemset(tls, ((*multiplexGroup)(unsafe.Pointer(pGroup)).FaReal + uintptr(iChunk)*16), 0, uint64(unsafe.Sizeof(multiplexReal{})))
}

// Deallocate memory held by a multiplexGroup
func multiplexFreeComponents(tls *crt.TLS, pGroup uintptr) { /* test_multiplex.c:451:13: */
	var i int32
	for i = 0; i < (*multiplexGroup)(unsafe.Pointer(pGroup)).FnReal; i++ {
		multiplexSubClose(tls, pGroup, i, uintptr(0))
	}
	sqlite3.Xsqlite3_free(tls, (*multiplexGroup)(unsafe.Pointer(pGroup)).FaReal)
	(*multiplexGroup)(unsafe.Pointer(pGroup)).FaReal = uintptr(0)
	(*multiplexGroup)(unsafe.Pointer(pGroup)).FnReal = 0
}

//************************ VFS Method Wrappers ****************************

// This is the xOpen method used for the "multiplex" VFS.
//
// Most of the work is done by the underlying original VFS.  This method
// simply links the new file into the appropriate multiplex group if it is a
// file that needs to be tracked.
func multiplexOpen(tls *crt.TLS, pVfs uintptr, zName uintptr, pConn uintptr, flags int32, pOutFlags uintptr) int32 { /* test_multiplex.c:469:12: */
	bp := tls.Alloc(20)
	defer tls.Free(20)

	*(*int32)(unsafe.Pointer(bp /* rc */)) = 0  // Result code
	var pMultiplexOpen uintptr                  // The new multiplex file descriptor
	var pGroup uintptr = uintptr(0)             // Corresponding multiplexGroup object
	var pSubOpen uintptr = uintptr(0)           // Real file descriptor
	var pOrigVfs uintptr = gMultiplex.FpOrigVfs // Real VFS
	var nName int32 = 0
	var sz int32 = 0
	var zToFree uintptr = uintptr(0)

	_ = pVfs
	crt.Xmemset(tls, pConn, 0, uint64((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FszOsFile))
	if !((zName != 0) || ((flags & 0x00000008) != 0)) {
		crt.X__assert_fail(tls, ts+39698 /* "zName || (flags ..." */, ts+39547 /* "testdata/sqlite-..." */, uint32(487), uintptr(unsafe.Pointer(&__func__103)))
	}

	// We need to create a group structure and manage
	// access to this group of files.
	pMultiplexOpen = pConn

	if *(*int32)(unsafe.Pointer(bp /* rc */)) == 0 {
		// allocate space for group
		if zName != 0 {
			nName = multiplexStrlen30(tls, zName)
		} else {
			nName = 0
		}
		sz = (int32((uint64(unsafe.Sizeof(multiplexGroup{})) + // multiplexGroup
			uint64(nName)) + uint64(1))) // zName
		pGroup = sqlite3.Xsqlite3_malloc64(tls, uint64(sz))
		if pGroup == uintptr(0) {
			*(*int32)(unsafe.Pointer(bp /* rc */)) = 7
		}
	}

	if *(*int32)(unsafe.Pointer(bp /* rc */)) == 0 {
		var zUri uintptr
		if (flags & 0x00000040) != 0 {
			zUri = zName
		} else {
			zUri = uintptr(0)
		}
		// assign pointers to extra space allocated
		crt.Xmemset(tls, pGroup, 0, uint64(sz))
		(*multiplexConn)(unsafe.Pointer(pMultiplexOpen)).FpGroup = pGroup
		(*multiplexGroup)(unsafe.Pointer(pGroup)).FbEnabled = crt.Uint8(crt.Uint8FromInt32(-1))
		(*multiplexGroup)(unsafe.Pointer(pGroup)).FbTruncate = uint8(sqlite3.Xsqlite3_uri_boolean(tls, zUri, ts+24528, /* "truncate" */
			(crt.Bool32((flags & 0x00000100) == 0))))
		(*multiplexGroup)(unsafe.Pointer(pGroup)).FszChunk = uint32(int32(sqlite3.Xsqlite3_uri_int64(tls, zUri, ts+39728, /* "chunksize" */
			int64(2147418112))))
		(*multiplexGroup)(unsafe.Pointer(pGroup)).FszChunk = (((*multiplexGroup)(unsafe.Pointer(pGroup)).FszChunk + uint32(0xffff)) & ^uint32(crt.Int32FromInt32(0xffff)))
		if zName != 0 {
			var p uintptr = (pGroup + uintptr(1)*40)
			(*multiplexGroup)(unsafe.Pointer(pGroup)).FzName = p
			crt.Xmemcpy(tls, (*multiplexGroup)(unsafe.Pointer(pGroup)).FzName, zName, (uint64(nName + 1)))
			(*multiplexGroup)(unsafe.Pointer(pGroup)).FnName = nName
		}
		if (*multiplexGroup)(unsafe.Pointer(pGroup)).FbEnabled != 0 {
			for (uint32(sqlite3.Xsqlite3PendingByte) % (*multiplexGroup)(unsafe.Pointer(pGroup)).FszChunk) >= ((*multiplexGroup)(unsafe.Pointer(pGroup)).FszChunk - uint32(65536)) {
				*(*uint32)(unsafe.Pointer(pGroup + 32 /* &.szChunk */)) += (uint32(65536))
			}
		}
		(*multiplexGroup)(unsafe.Pointer(pGroup)).Fflags = (flags & ^int32(crt.Int32FromInt32(0x00000040)))
		*(*int32)(unsafe.Pointer(bp /* rc */)) = multiplexSubFilename(tls, pGroup, 1)
		if *(*int32)(unsafe.Pointer(bp /* rc */)) == 0 {
			pSubOpen = multiplexSubOpen(tls, pGroup, 0, bp /* &rc */, pOutFlags, 0)
			if (pSubOpen == uintptr(0)) && (*(*int32)(unsafe.Pointer(bp /* rc */)) == 0) {
				*(*int32)(unsafe.Pointer(bp /* rc */)) = 14
			}
		}
		if *(*int32)(unsafe.Pointer(bp /* rc */)) == 0 {
			// var sz64 sqlite3_int64 at bp+8, 8

			*(*int32)(unsafe.Pointer(bp /* rc */)) = (*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods + 48 /* &.xFileSize */))))(tls, pSubOpen, bp+8 /* &sz64 */)
			if (*(*int32)(unsafe.Pointer(bp /* rc */)) == 0) && (zName != 0) {
				// var bExists int32 at bp+16, 4

				if (flags & 0x00004000) != 0 {
					(*multiplexGroup)(unsafe.Pointer(pGroup)).FbEnabled = uint8(0)
				} else if *(*sqlite3_int64)(unsafe.Pointer(bp + 8 /* sz64 */)) == int64(0) {
					if (flags & 0x00000800) != 0 {
						// If opening a main journal file and the first chunk is zero
						// bytes in size, delete any subsequent chunks from the
						// file-system.
						var iChunk int32 = 1
						for ok := true; ok; ok = ((*(*int32)(unsafe.Pointer(bp /* rc */)) == 0) && (*(*int32)(unsafe.Pointer(bp + 16 /* bExists */)) != 0)) {
							*(*int32)(unsafe.Pointer(bp /* rc */)) = (*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer((pOrigVfs + 56 /* &.xAccess */))))(tls, pOrigVfs,
								(*multiplexReal)(unsafe.Pointer((*multiplexGroup)(unsafe.Pointer(pGroup)).FaReal+uintptr(iChunk)*16)).Fz, 0, bp+16 /* &bExists */)
							if (*(*int32)(unsafe.Pointer(bp /* rc */)) == 0) && (*(*int32)(unsafe.Pointer(bp + 16 /* bExists */)) != 0) {
								*(*int32)(unsafe.Pointer(bp /* rc */)) = (*(*func(*crt.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer((pOrigVfs + 48 /* &.xDelete */))))(tls, pOrigVfs, (*multiplexReal)(unsafe.Pointer((*multiplexGroup)(unsafe.Pointer(pGroup)).FaReal+uintptr(iChunk)*16)).Fz, 0)
								if *(*int32)(unsafe.Pointer(bp /* rc */)) == 0 {
									*(*int32)(unsafe.Pointer(bp /* rc */)) = multiplexSubFilename(tls, pGroup, crt.PreIncInt32(&iChunk, 1))
								}
							}
						}
					}
				} else {
					// If the first overflow file exists and if the size of the main file
					// is different from the chunk size, that means the chunk size is set
					// set incorrectly.  So fix it.
					//
					// Or, if the first overflow file does not exist and the main file is
					// larger than the chunk size, that means the chunk size is too small.
					// But we have no way of determining the intended chunk size, so
					// just disable the multiplexor all togethre.
					*(*int32)(unsafe.Pointer(bp /* rc */)) = (*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer((pOrigVfs + 56 /* &.xAccess */))))(tls, pOrigVfs, (*multiplexReal)(unsafe.Pointer((*multiplexGroup)(unsafe.Pointer(pGroup)).FaReal+uintptr(1)*16)).Fz,
						0, bp+16 /* &bExists */)
					*(*int32)(unsafe.Pointer(bp + 16 /* bExists */)) = (crt.Bool32(multiplexSubSize(tls, pGroup, 1, bp /* &rc */) > int64(0)))
					if ((((*(*int32)(unsafe.Pointer(bp /* rc */)) == 0) && (*(*int32)(unsafe.Pointer(bp + 16 /* bExists */)) != 0)) && (*(*sqlite3_int64)(unsafe.Pointer(bp + 8 /* sz64 */)) == (*(*sqlite3_int64)(unsafe.Pointer(bp + 8 /* sz64 */)) & int64(0xffff0000)))) && (*(*sqlite3_int64)(unsafe.Pointer(bp + 8 /* sz64 */)) > int64(0))) &&
						(*(*sqlite3_int64)(unsafe.Pointer(bp + 8 /* sz64 */)) != sqlite3_int64((*multiplexGroup)(unsafe.Pointer(pGroup)).FszChunk)) {
						(*multiplexGroup)(unsafe.Pointer(pGroup)).FszChunk = uint32(int32(*(*sqlite3_int64)(unsafe.Pointer(bp + 8 /* sz64 */))))
					} else if ((*(*int32)(unsafe.Pointer(bp /* rc */)) == 0) && !(*(*int32)(unsafe.Pointer(bp + 16 /* bExists */)) != 0)) && (*(*sqlite3_int64)(unsafe.Pointer(bp + 8 /* sz64 */)) > sqlite3_int64((*multiplexGroup)(unsafe.Pointer(pGroup)).FszChunk)) {
						(*multiplexGroup)(unsafe.Pointer(pGroup)).FbEnabled = uint8(0)
					}
				}
			}
		}

		if *(*int32)(unsafe.Pointer(bp /* rc */)) == 0 {
			if (*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods)).FiVersion == 1 {
				(*multiplexConn)(unsafe.Pointer(pMultiplexOpen)).Fbase.FpMethods = (uintptr(unsafe.Pointer(&gMultiplex)) + 176 /* &.sIoMethodsV1 */)
			} else {
				(*multiplexConn)(unsafe.Pointer(pMultiplexOpen)).Fbase.FpMethods = (uintptr(unsafe.Pointer(&gMultiplex)) + 328 /* &.sIoMethodsV2 */)
			}
		} else {
			multiplexFreeComponents(tls, pGroup)
			sqlite3.Xsqlite3_free(tls, pGroup)
		}
	}
	sqlite3.Xsqlite3_free(tls, zToFree)
	return *(*int32)(unsafe.Pointer(bp /* rc */))
}

var __func__103 = *(*[14]int8)(unsafe.Pointer(ts + 39738 /* "multiplexOpen" */)) /* test_multiplex.c:475:2 */

// This is the xDelete method used for the "multiplex" VFS.
// It attempts to delete the filename specified.
func multiplexDelete(tls *crt.TLS, pVfs uintptr, zName uintptr, syncDir int32) int32 { /* test_multiplex.c:611:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var rc int32
	var pOrigVfs uintptr = gMultiplex.FpOrigVfs // Real VFS
	rc = (*(*func(*crt.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer((pOrigVfs + 48 /* &.xDelete */))))(tls, pOrigVfs, zName, syncDir)
	if rc == 0 {
		// If the main chunk was deleted successfully, also delete any subsequent
		// chunks - starting with the last (highest numbered).
		var nName int32 = int32(crt.Xstrlen(tls, zName))
		var z uintptr
		z = sqlite3.Xsqlite3_malloc64(tls, (uint64(nName + 5)))
		if z == uintptr(0) {
			rc = (10 | (int32(12) << 8))
		} else {
			var iChunk int32 = 0
			// var bExists int32 at bp, 4

			for ok := true; ok; ok = ((rc == 0) && (*(*int32)(unsafe.Pointer(bp /* bExists */)) != 0)) {
				multiplexFilename(tls, zName, nName, 0x00000800, crt.PreIncInt32(&iChunk, 1), z)
				rc = (*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer((pOrigVfs + 56 /* &.xAccess */))))(tls, pOrigVfs, z, 0, bp /* &bExists */)
			}
			for (rc == 0) && (iChunk > 1) {
				multiplexFilename(tls, zName, nName, 0x00000800, crt.PreDecInt32(&iChunk, 1), z)
				rc = (*(*func(*crt.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer((pOrigVfs + 48 /* &.xDelete */))))(tls, pOrigVfs, z, syncDir)
			}
			if rc == 0 {
				iChunk = 0
				for ok1 := true; ok1; ok1 = ((rc == 0) && (*(*int32)(unsafe.Pointer(bp /* bExists */)) != 0)) {
					multiplexFilename(tls, zName, nName, 0x00080000, crt.PreIncInt32(&iChunk, 1), z)
					rc = (*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer((pOrigVfs + 56 /* &.xAccess */))))(tls, pOrigVfs, z, 0, bp /* &bExists */)
				}
				for (rc == 0) && (iChunk > 1) {
					multiplexFilename(tls, zName, nName, 0x00080000, crt.PreDecInt32(&iChunk, 1), z)
					rc = (*(*func(*crt.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer((pOrigVfs + 48 /* &.xDelete */))))(tls, pOrigVfs, z, syncDir)
				}
			}
		}
		sqlite3.Xsqlite3_free(tls, z)
	}
	return rc
}

func multiplexAccess(tls *crt.TLS, a uintptr, b uintptr, c int32, d uintptr) int32 { /* test_multiplex.c:656:12: */
	return (*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer((gMultiplex.FpOrigVfs + 56 /* &.xAccess */))))(tls, gMultiplex.FpOrigVfs, b, c, d)
}
func multiplexFullPathname(tls *crt.TLS, a uintptr, b uintptr, c int32, d uintptr) int32 { /* test_multiplex.c:659:12: */
	return (*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer((gMultiplex.FpOrigVfs + 64 /* &.xFullPathname */))))(tls, gMultiplex.FpOrigVfs, b, c, d)
}
func multiplexDlOpen(tls *crt.TLS, a uintptr, b uintptr) uintptr { /* test_multiplex.c:662:13: */
	return (*(*func(*crt.TLS, uintptr, uintptr) uintptr)(unsafe.Pointer((gMultiplex.FpOrigVfs + 72 /* &.xDlOpen */))))(tls, gMultiplex.FpOrigVfs, b)
}
func multiplexDlError(tls *crt.TLS, a uintptr, b int32, c uintptr) { /* test_multiplex.c:665:13: */
	(*(*func(*crt.TLS, uintptr, int32, uintptr))(unsafe.Pointer((gMultiplex.FpOrigVfs + 80 /* &.xDlError */))))(tls, gMultiplex.FpOrigVfs, b, c)
}
func multiplexDlSym(tls *crt.TLS, a uintptr, b uintptr, c uintptr) uintptr { /* test_multiplex.c:668:13: */
	return (*(*func(*crt.TLS, uintptr, uintptr, uintptr) uintptr)(unsafe.Pointer((gMultiplex.FpOrigVfs + 88 /* &.xDlSym */))))(tls, gMultiplex.FpOrigVfs, b, c)
}
func multiplexDlClose(tls *crt.TLS, a uintptr, b uintptr) { /* test_multiplex.c:671:13: */
	(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((gMultiplex.FpOrigVfs + 96 /* &.xDlClose */))))(tls, gMultiplex.FpOrigVfs, b)
}
func multiplexRandomness(tls *crt.TLS, a uintptr, b int32, c uintptr) int32 { /* test_multiplex.c:674:12: */
	return (*(*func(*crt.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer((gMultiplex.FpOrigVfs + 104 /* &.xRandomness */))))(tls, gMultiplex.FpOrigVfs, b, c)
}
func multiplexSleep(tls *crt.TLS, a uintptr, b int32) int32 { /* test_multiplex.c:677:12: */
	return (*(*func(*crt.TLS, uintptr, int32) int32)(unsafe.Pointer((gMultiplex.FpOrigVfs + 112 /* &.xSleep */))))(tls, gMultiplex.FpOrigVfs, b)
}
func multiplexCurrentTime(tls *crt.TLS, a uintptr, b uintptr) int32 { /* test_multiplex.c:680:12: */
	return (*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer((gMultiplex.FpOrigVfs + 120 /* &.xCurrentTime */))))(tls, gMultiplex.FpOrigVfs, b)
}
func multiplexGetLastError(tls *crt.TLS, a uintptr, b int32, c uintptr) int32 { /* test_multiplex.c:683:12: */
	if (*sqlite3_vfs)(unsafe.Pointer(gMultiplex.FpOrigVfs)).FxGetLastError != 0 {
		return (*(*func(*crt.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer((gMultiplex.FpOrigVfs + 128 /* &.xGetLastError */))))(tls, gMultiplex.FpOrigVfs, b, c)
	} else {
		return 0
	}
	return int32(0)
}
func multiplexCurrentTimeInt64(tls *crt.TLS, a uintptr, b uintptr) int32 { /* test_multiplex.c:690:12: */
	return (*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer((gMultiplex.FpOrigVfs + 136 /* &.xCurrentTimeInt64 */))))(tls, gMultiplex.FpOrigVfs, b)
}

//*********************** I/O Method Wrappers ******************************

// xClose requests get passed through to the original VFS.
// We loop over all open chunk handles and close them.
// The group structure for this file is unlinked from
// our list of groups and freed.
func multiplexClose(tls *crt.TLS, pConn uintptr) int32 { /* test_multiplex.c:701:12: */
	var p uintptr = pConn
	var pGroup uintptr = (*multiplexConn)(unsafe.Pointer(p)).FpGroup
	var rc int32 = 0
	multiplexFreeComponents(tls, pGroup)
	sqlite3.Xsqlite3_free(tls, pGroup)
	return rc
}

// Pass xRead requests thru to the original VFS after
// determining the correct chunk to operate on.
// Break up reads across chunk boundaries.
func multiplexRead(tls *crt.TLS, pConn uintptr, pBuf uintptr, iAmt int32, iOfst sqlite3_int64) int32 { /* test_multiplex.c:714:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var p uintptr = pConn
	var pGroup uintptr = (*multiplexConn)(unsafe.Pointer(p)).FpGroup
	*(*int32)(unsafe.Pointer(bp /* rc */)) = 0
	if !(int32((*multiplexGroup)(unsafe.Pointer(pGroup)).FbEnabled) != 0) {
		var pSubOpen uintptr = multiplexSubOpen(tls, pGroup, 0, bp /* &rc */, uintptr(0), 0)
		if pSubOpen == uintptr(0) {
			*(*int32)(unsafe.Pointer(bp /* rc */)) = (10 | (int32(1) << 8))
		} else {
			*(*int32)(unsafe.Pointer(bp /* rc */)) = (*(*func(*crt.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods + 16 /* &.xRead */))))(tls, pSubOpen, pBuf, iAmt, iOfst)
		}
	} else {
		for iAmt > 0 {
			var i int32 = (int32(iOfst / sqlite3_int64((*multiplexGroup)(unsafe.Pointer(pGroup)).FszChunk)))
			var pSubOpen uintptr
			pSubOpen = multiplexSubOpen(tls, pGroup, i, bp /* &rc */, uintptr(0), 1)
			if pSubOpen != 0 {
				var extra int32 = (int32((uint32((int32(iOfst % sqlite3_int64((*multiplexGroup)(unsafe.Pointer(pGroup)).FszChunk))) + iAmt)) - (*multiplexGroup)(unsafe.Pointer(pGroup)).FszChunk))
				if extra < 0 {
					extra = 0
				}
				iAmt = iAmt - (extra)
				*(*int32)(unsafe.Pointer(bp /* rc */)) = (*(*func(*crt.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods + 16 /* &.xRead */))))(tls, pSubOpen, pBuf, iAmt,
					(iOfst % sqlite3_int64((*multiplexGroup)(unsafe.Pointer(pGroup)).FszChunk)))
				if *(*int32)(unsafe.Pointer(bp /* rc */)) != 0 {
					break
				}
				pBuf = (pBuf + uintptr(iAmt))
				iOfst = iOfst + (sqlite3_int64(iAmt))
				iAmt = extra
			} else {
				*(*int32)(unsafe.Pointer(bp /* rc */)) = (10 | (int32(1) << 8))
				break
			}
		}
	}

	return *(*int32)(unsafe.Pointer(bp /* rc */))
}

// Pass xWrite requests thru to the original VFS after
// determining the correct chunk to operate on.
// Break up writes across chunk boundaries.
func multiplexWrite(tls *crt.TLS, pConn uintptr, pBuf uintptr, iAmt int32, iOfst sqlite3_int64) int32 { /* test_multiplex.c:759:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var p uintptr = pConn
	var pGroup uintptr = (*multiplexConn)(unsafe.Pointer(p)).FpGroup
	*(*int32)(unsafe.Pointer(bp /* rc */)) = 0
	if !(int32((*multiplexGroup)(unsafe.Pointer(pGroup)).FbEnabled) != 0) {
		var pSubOpen uintptr = multiplexSubOpen(tls, pGroup, 0, bp /* &rc */, uintptr(0), 0)
		if pSubOpen == uintptr(0) {
			*(*int32)(unsafe.Pointer(bp /* rc */)) = (10 | (int32(3) << 8))
		} else {
			*(*int32)(unsafe.Pointer(bp /* rc */)) = (*(*func(*crt.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods + 24 /* &.xWrite */))))(tls, pSubOpen, pBuf, iAmt, iOfst)
		}
	} else {
		for (*(*int32)(unsafe.Pointer(bp /* rc */)) == 0) && (iAmt > 0) {
			var i int32 = (int32(iOfst / sqlite3_int64((*multiplexGroup)(unsafe.Pointer(pGroup)).FszChunk)))
			var pSubOpen uintptr = multiplexSubOpen(tls, pGroup, i, bp /* &rc */, uintptr(0), 1)
			if pSubOpen != 0 {
				var extra int32 = (int32((uint32((int32(iOfst % sqlite3_int64((*multiplexGroup)(unsafe.Pointer(pGroup)).FszChunk))) + iAmt)) - (*multiplexGroup)(unsafe.Pointer(pGroup)).FszChunk))
				if extra < 0 {
					extra = 0
				}
				iAmt = iAmt - (extra)
				*(*int32)(unsafe.Pointer(bp /* rc */)) = (*(*func(*crt.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods + 24 /* &.xWrite */))))(tls, pSubOpen, pBuf, iAmt,
					(iOfst % sqlite3_int64((*multiplexGroup)(unsafe.Pointer(pGroup)).FszChunk)))
				pBuf = (pBuf + uintptr(iAmt))
				iOfst = iOfst + (sqlite3_int64(iAmt))
				iAmt = extra
			}
		}
	}
	return *(*int32)(unsafe.Pointer(bp /* rc */))
}

// Pass xTruncate requests thru to the original VFS after
// determining the correct chunk to operate on.  Delete any
// chunks above the truncate mark.
func multiplexTruncate(tls *crt.TLS, pConn uintptr, size sqlite3_int64) int32 { /* test_multiplex.c:799:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var p uintptr = pConn
	var pGroup uintptr = (*multiplexConn)(unsafe.Pointer(p)).FpGroup
	*(*int32)(unsafe.Pointer(bp /* rc */)) = 0
	if !(int32((*multiplexGroup)(unsafe.Pointer(pGroup)).FbEnabled) != 0) {
		var pSubOpen uintptr = multiplexSubOpen(tls, pGroup, 0, bp /* &rc */, uintptr(0), 0)
		if pSubOpen == uintptr(0) {
			*(*int32)(unsafe.Pointer(bp /* rc */)) = (10 | (int32(6) << 8))
		} else {
			*(*int32)(unsafe.Pointer(bp /* rc */)) = (*(*func(*crt.TLS, uintptr, sqlite3_int64) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods + 32 /* &.xTruncate */))))(tls, pSubOpen, size)
		}
	} else {
		var i int32
		var iBaseGroup int32 = (int32(size / sqlite3_int64((*multiplexGroup)(unsafe.Pointer(pGroup)).FszChunk)))
		var pSubOpen uintptr
		var pOrigVfs uintptr = gMultiplex.FpOrigVfs // Real VFS
		// delete the chunks above the truncate limit
		for i = ((*multiplexGroup)(unsafe.Pointer(pGroup)).FnReal - 1); (i > iBaseGroup) && (*(*int32)(unsafe.Pointer(bp /* rc */)) == 0); i-- {
			if (*multiplexGroup)(unsafe.Pointer(pGroup)).FbTruncate != 0 {
				multiplexSubClose(tls, pGroup, i, pOrigVfs)
			} else {
				pSubOpen = multiplexSubOpen(tls, pGroup, i, bp /* &rc */, uintptr(0), 0)
				if pSubOpen != 0 {
					*(*int32)(unsafe.Pointer(bp /* rc */)) = (*(*func(*crt.TLS, uintptr, sqlite3_int64) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods + 32 /* &.xTruncate */))))(tls, pSubOpen, int64(0))
				}
			}
		}
		if *(*int32)(unsafe.Pointer(bp /* rc */)) == 0 {
			pSubOpen = multiplexSubOpen(tls, pGroup, iBaseGroup, bp /* &rc */, uintptr(0), 0)
			if pSubOpen != 0 {
				*(*int32)(unsafe.Pointer(bp /* rc */)) = (*(*func(*crt.TLS, uintptr, sqlite3_int64) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods + 32 /* &.xTruncate */))))(tls, pSubOpen, (size % sqlite3_int64((*multiplexGroup)(unsafe.Pointer(pGroup)).FszChunk)))
			}
		}
		if *(*int32)(unsafe.Pointer(bp /* rc */)) != 0 {
			*(*int32)(unsafe.Pointer(bp /* rc */)) = (10 | (int32(6) << 8))
		}
	}
	return *(*int32)(unsafe.Pointer(bp /* rc */))
}

// Pass xSync requests through to the original VFS without change
func multiplexSync(tls *crt.TLS, pConn uintptr, flags int32) int32 { /* test_multiplex.c:839:12: */
	var p uintptr = pConn
	var pGroup uintptr = (*multiplexConn)(unsafe.Pointer(p)).FpGroup
	var rc int32 = 0
	var i int32
	for i = 0; i < (*multiplexGroup)(unsafe.Pointer(pGroup)).FnReal; i++ {
		var pSubOpen uintptr = (*multiplexReal)(unsafe.Pointer((*multiplexGroup)(unsafe.Pointer(pGroup)).FaReal + uintptr(i)*16)).Fp
		if pSubOpen != 0 {
			var rc2 int32 = (*(*func(*crt.TLS, uintptr, int32) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods + 40 /* &.xSync */))))(tls, pSubOpen, flags)
			if rc2 != 0 {
				rc = rc2
			}
		}
	}
	return rc
}

// Pass xFileSize requests through to the original VFS.
// Aggregate the size of all the chunks before returning.
func multiplexFileSize(tls *crt.TLS, pConn uintptr, pSize uintptr) int32 { /* test_multiplex.c:857:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var p uintptr = pConn
	var pGroup uintptr = (*multiplexConn)(unsafe.Pointer(p)).FpGroup
	*(*int32)(unsafe.Pointer(bp /* rc */)) = 0
	var i int32
	if !(int32((*multiplexGroup)(unsafe.Pointer(pGroup)).FbEnabled) != 0) {
		var pSubOpen uintptr = multiplexSubOpen(tls, pGroup, 0, bp /* &rc */, uintptr(0), 0)
		if pSubOpen == uintptr(0) {
			*(*int32)(unsafe.Pointer(bp /* rc */)) = (10 | (int32(7) << 8))
		} else {
			*(*int32)(unsafe.Pointer(bp /* rc */)) = (*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods + 48 /* &.xFileSize */))))(tls, pSubOpen, pSize)
		}
	} else {
		*(*sqlite3_int64)(unsafe.Pointer(pSize)) = int64(0)
		for i = 0; *(*int32)(unsafe.Pointer(bp /* rc */)) == 0; i++ {
			var sz sqlite3_int64 = multiplexSubSize(tls, pGroup, i, bp /* &rc */)
			if sz == int64(0) {
				break
			}
			*(*sqlite3_int64)(unsafe.Pointer(pSize)) = ((sqlite3_int64(i) * sqlite3_int64((*multiplexGroup)(unsafe.Pointer(pGroup)).FszChunk)) + sz)
		}
	}
	return *(*int32)(unsafe.Pointer(bp /* rc */))
}

// Pass xLock requests through to the original VFS unchanged.
func multiplexLock(tls *crt.TLS, pConn uintptr, lock int32) int32 { /* test_multiplex.c:882:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var p uintptr = pConn
	// var rc int32 at bp, 4

	var pSubOpen uintptr = multiplexSubOpen(tls, (*multiplexConn)(unsafe.Pointer(p)).FpGroup, 0, bp /* &rc */, uintptr(0), 0)
	if pSubOpen != 0 {
		return (*(*func(*crt.TLS, uintptr, int32) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods + 56 /* &.xLock */))))(tls, pSubOpen, lock)
	}
	return 5
}

// Pass xUnlock requests through to the original VFS unchanged.
func multiplexUnlock(tls *crt.TLS, pConn uintptr, lock int32) int32 { /* test_multiplex.c:894:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var p uintptr = pConn
	// var rc int32 at bp, 4

	var pSubOpen uintptr = multiplexSubOpen(tls, (*multiplexConn)(unsafe.Pointer(p)).FpGroup, 0, bp /* &rc */, uintptr(0), 0)
	if pSubOpen != 0 {
		return (*(*func(*crt.TLS, uintptr, int32) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods + 64 /* &.xUnlock */))))(tls, pSubOpen, lock)
	}
	return (10 | (int32(8) << 8))
}

// Pass xCheckReservedLock requests through to the original VFS unchanged.
func multiplexCheckReservedLock(tls *crt.TLS, pConn uintptr, pResOut uintptr) int32 { /* test_multiplex.c:906:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var p uintptr = pConn
	// var rc int32 at bp, 4

	var pSubOpen uintptr = multiplexSubOpen(tls, (*multiplexConn)(unsafe.Pointer(p)).FpGroup, 0, bp /* &rc */, uintptr(0), 0)
	if pSubOpen != 0 {
		return (*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods + 72 /* &.xCheckReservedLock */))))(tls, pSubOpen, pResOut)
	}
	return (10 | (int32(14) << 8))
}

// Pass xFileControl requests through to the original VFS unchanged,
// except for any MULTIPLEX_CTRL_* requests here.
func multiplexFileControl(tls *crt.TLS, pConn uintptr, op int32, pArg uintptr) int32 { /* test_multiplex.c:919:12: */
	bp := tls.Alloc(12)
	defer tls.Free(12)

	var p uintptr = pConn
	var pGroup uintptr = (*multiplexConn)(unsafe.Pointer(p)).FpGroup
	*(*int32)(unsafe.Pointer(bp + 8 /* rc */)) = 1
	var pSubOpen uintptr

	if !(gMultiplex.FisInitialized != 0) {
		return 21
	}
	switch op {
	case 214014:
		if pArg != 0 {
			var bEnabled int32 = *(*int32)(unsafe.Pointer(pArg))
			(*multiplexGroup)(unsafe.Pointer(pGroup)).FbEnabled = uint8(bEnabled)
			*(*int32)(unsafe.Pointer(bp + 8 /* rc */)) = 0
		}
		break
	case 214015:
		if pArg != 0 {
			var szChunk uint32 = *(*uint32)(unsafe.Pointer(pArg))
			if szChunk < uint32(1) {
				*(*int32)(unsafe.Pointer(bp + 8 /* rc */)) = 21
			} else {
				// Round up to nearest multiple of MAX_PAGE_SIZE.
				szChunk = (szChunk + (uint32(0x10000 - 1)))
				szChunk = szChunk & (^uint32(crt.Int32FromInt32((0x10000 - 1))))
				(*multiplexGroup)(unsafe.Pointer(pGroup)).FszChunk = szChunk
				*(*int32)(unsafe.Pointer(bp + 8 /* rc */)) = 0
			}
		}
		break
	case 214016:
		*(*int32)(unsafe.Pointer(bp + 8 /* rc */)) = 0
		break
	case 5:
		fallthrough
	case 6:
		// no-op these
		*(*int32)(unsafe.Pointer(bp + 8 /* rc */)) = 0
		break
	case 14:
		{
			var aFcntl uintptr = pArg
			// EVIDENCE-OF: R-29875-31678 The argument to the SQLITE_FCNTL_PRAGMA
			// file control is an array of pointers to strings (char**) in which the
			// second element of the array is the name of the pragma and the third
			// element is the argument to the pragma or NULL if the pragma has no
			// argument.
			if (*(*uintptr)(unsafe.Pointer(aFcntl + uintptr(1)*8)) != 0) && (sqlite3.Xsqlite3_stricmp(tls, *(*uintptr)(unsafe.Pointer(aFcntl + uintptr(1)*8)), ts+39752 /* "multiplex_trunca..." */) == 0) {
				if (*(*uintptr)(unsafe.Pointer(aFcntl + uintptr(2)*8)) != 0) && (*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(aFcntl + uintptr(2)*8)) + uintptr(0))) != 0) {
					if (sqlite3.Xsqlite3_stricmp(tls, *(*uintptr)(unsafe.Pointer(aFcntl + uintptr(2)*8)), ts+4000 /* "on" */) == 0) ||
						(sqlite3.Xsqlite3_stricmp(tls, *(*uintptr)(unsafe.Pointer(aFcntl + uintptr(2)*8)), ts+33857 /* "1" */) == 0) {
						(*multiplexGroup)(unsafe.Pointer(pGroup)).FbTruncate = uint8(1)
					} else if (sqlite3.Xsqlite3_stricmp(tls, *(*uintptr)(unsafe.Pointer(aFcntl + uintptr(2)*8)), ts+4011 /* "off" */) == 0) ||
						(sqlite3.Xsqlite3_stricmp(tls, *(*uintptr)(unsafe.Pointer(aFcntl + uintptr(2)*8)), ts+8293 /* "0" */) == 0) {
						(*multiplexGroup)(unsafe.Pointer(pGroup)).FbTruncate = uint8(0)
					}
				}
				// EVIDENCE-OF: R-27806-26076 The handler for an SQLITE_FCNTL_PRAGMA
				// file control can optionally make the first element of the char**
				// argument point to a string obtained from sqlite3_mprintf() or the
				// equivalent and that string will become the result of the pragma
				// or the error message if the pragma fails.
				*(*uintptr)(unsafe.Pointer(aFcntl + uintptr(0)*8)) = sqlite3.Xsqlite3_mprintf(tls, func() uintptr {
					if (*multiplexGroup)(unsafe.Pointer(pGroup)).FbTruncate != 0 {
						return ts + 4000 /* "on" */
					}
					return ts + 4011 /* "off" */
				}(), 0)
				*(*int32)(unsafe.Pointer(bp + 8 /* rc */)) = 0
				break
			}
			// If the multiplexor does not handle the pragma, pass it through
			// into the default case.
		}
		fallthrough
	default:
		pSubOpen = multiplexSubOpen(tls, pGroup, 0, bp+8 /* &rc */, uintptr(0), 0)
		if pSubOpen != 0 {
			*(*int32)(unsafe.Pointer(bp + 8 /* rc */)) = (*(*func(*crt.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods + 80 /* &.xFileControl */))))(tls, pSubOpen, op, pArg)
			if (op == 12) && (*(*int32)(unsafe.Pointer(bp + 8 /* rc */)) == 0) {
				*(*uintptr)(unsafe.Pointer(pArg)) = sqlite3.Xsqlite3_mprintf(tls, ts+39771 /* "multiplex/%z" */, crt.VaList(bp, *(*uintptr)(unsafe.Pointer(pArg))))
			}
		}
		break
	}
	return *(*int32)(unsafe.Pointer(bp + 8 /* rc */))
}

// Pass xSectorSize requests through to the original VFS unchanged.
func multiplexSectorSize(tls *crt.TLS, pConn uintptr) int32 { /* test_multiplex.c:1004:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var p uintptr = pConn
	// var rc int32 at bp, 4

	var pSubOpen uintptr = multiplexSubOpen(tls, (*multiplexConn)(unsafe.Pointer(p)).FpGroup, 0, bp /* &rc */, uintptr(0), 0)
	if (pSubOpen != 0) && ((*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods)).FxSectorSize != 0) {
		return (*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods + 88 /* &.xSectorSize */))))(tls, pSubOpen)
	}
	return 0x1000
}

// Pass xDeviceCharacteristics requests through to the original VFS unchanged.
func multiplexDeviceCharacteristics(tls *crt.TLS, pConn uintptr) int32 { /* test_multiplex.c:1016:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var p uintptr = pConn
	// var rc int32 at bp, 4

	var pSubOpen uintptr = multiplexSubOpen(tls, (*multiplexConn)(unsafe.Pointer(p)).FpGroup, 0, bp /* &rc */, uintptr(0), 0)
	if pSubOpen != 0 {
		return (*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods + 96 /* &.xDeviceCharacteristics */))))(tls, pSubOpen)
	}
	return 0
}

// Pass xShmMap requests through to the original VFS unchanged.
func multiplexShmMap(tls *crt.TLS, pConn uintptr, iRegion int32, szRegion int32, bExtend int32, pp uintptr) int32 { /* test_multiplex.c:1028:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var p uintptr = pConn
	// var rc int32 at bp, 4

	var pSubOpen uintptr = multiplexSubOpen(tls, (*multiplexConn)(unsafe.Pointer(p)).FpGroup, 0, bp /* &rc */, uintptr(0), 0)
	if pSubOpen != 0 {
		return (*(*func(*crt.TLS, uintptr, int32, int32, int32, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods + 104 /* &.xShmMap */))))(tls, pSubOpen, iRegion, szRegion, bExtend, pp)
	}
	return 10
}

// Pass xShmLock requests through to the original VFS unchanged.
func multiplexShmLock(tls *crt.TLS, pConn uintptr, ofst int32, n int32, flags int32) int32 { /* test_multiplex.c:1046:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var p uintptr = pConn
	// var rc int32 at bp, 4

	var pSubOpen uintptr = multiplexSubOpen(tls, (*multiplexConn)(unsafe.Pointer(p)).FpGroup, 0, bp /* &rc */, uintptr(0), 0)
	if pSubOpen != 0 {
		return (*(*func(*crt.TLS, uintptr, int32, int32, int32) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods + 112 /* &.xShmLock */))))(tls, pSubOpen, ofst, n, flags)
	}
	return 5
}

// Pass xShmBarrier requests through to the original VFS unchanged.
func multiplexShmBarrier(tls *crt.TLS, pConn uintptr) { /* test_multiplex.c:1063:13: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var p uintptr = pConn
	// var rc int32 at bp, 4

	var pSubOpen uintptr = multiplexSubOpen(tls, (*multiplexConn)(unsafe.Pointer(p)).FpGroup, 0, bp /* &rc */, uintptr(0), 0)
	if pSubOpen != 0 {
		(*(*func(*crt.TLS, uintptr))(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods + 120 /* &.xShmBarrier */))))(tls, pSubOpen)
	}
}

// Pass xShmUnmap requests through to the original VFS unchanged.
func multiplexShmUnmap(tls *crt.TLS, pConn uintptr, deleteFlag int32) int32 { /* test_multiplex.c:1074:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var p uintptr = pConn
	// var rc int32 at bp, 4

	var pSubOpen uintptr = multiplexSubOpen(tls, (*multiplexConn)(unsafe.Pointer(p)).FpGroup, 0, bp /* &rc */, uintptr(0), 0)
	if pSubOpen != 0 {
		return (*(*func(*crt.TLS, uintptr, int32) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods + 128 /* &.xShmUnmap */))))(tls, pSubOpen, deleteFlag)
	}
	return 0
}

//************************* Public Interfaces ****************************
// CAPI: Initialize the multiplex VFS shim - sqlite3_multiplex_initialize()
//
// Use the VFS named zOrigVfsName as the VFS that does the actual work.
// Use the default if zOrigVfsName==NULL.
//
// The multiplex VFS shim is named "multiplex".  It will become the default
// VFS if makeDefault is non-zero.
//
// THIS ROUTINE IS NOT THREADSAFE.  Call this routine exactly once
// during start-up.
func sqlite3_multiplex_initialize(tls *crt.TLS, zOrigVfsName uintptr, makeDefault int32) int32 { /* test_multiplex.c:1097:5: */
	var pOrigVfs uintptr
	if gMultiplex.FisInitialized != 0 {
		return 21
	}
	pOrigVfs = sqlite3.Xsqlite3_vfs_find(tls, zOrigVfsName)
	if pOrigVfs == uintptr(0) {
		return 1
	}
	if !(pOrigVfs != (uintptr(unsafe.Pointer(&gMultiplex)) + 8 /* &.sThisVfs */)) {
		crt.X__assert_fail(tls, ts+39784 /* "pOrigVfs!=&gMult..." */, ts+39547 /* "testdata/sqlite-..." */, uint32(1102), uintptr(unsafe.Pointer(&__func__104)))
	}
	gMultiplex.FisInitialized = 1
	gMultiplex.FpOrigVfs = pOrigVfs
	gMultiplex.FsThisVfs = *(*sqlite3_vfs)(unsafe.Pointer(pOrigVfs))
	*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&gMultiplex)) + 8 /* &.sThisVfs */ + 4 /* &.szOsFile */)) += int32((uint64(unsafe.Sizeof(multiplexConn{}))))
	gMultiplex.FsThisVfs.FzName = ts + 39815 /* "multiplex" */
	gMultiplex.FsThisVfs.FxOpen = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, uintptr, int32, uintptr) int32
	}{multiplexOpen}))
	gMultiplex.FsThisVfs.FxDelete = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32) int32
	}{multiplexDelete}))
	gMultiplex.FsThisVfs.FxAccess = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{multiplexAccess}))
	gMultiplex.FsThisVfs.FxFullPathname = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{multiplexFullPathname}))
	gMultiplex.FsThisVfs.FxDlOpen = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr) uintptr
	}{multiplexDlOpen}))
	gMultiplex.FsThisVfs.FxDlError = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, int32, uintptr)
	}{multiplexDlError}))
	gMultiplex.FsThisVfs.FxDlSym = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, uintptr) uintptr
	}{multiplexDlSym}))
	gMultiplex.FsThisVfs.FxDlClose = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr)
	}{multiplexDlClose}))
	gMultiplex.FsThisVfs.FxRandomness = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, int32, uintptr) int32
	}{multiplexRandomness}))
	gMultiplex.FsThisVfs.FxSleep = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, int32) int32
	}{multiplexSleep}))
	gMultiplex.FsThisVfs.FxCurrentTime = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr) int32
	}{multiplexCurrentTime}))
	gMultiplex.FsThisVfs.FxGetLastError = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, int32, uintptr) int32
	}{multiplexGetLastError}))
	gMultiplex.FsThisVfs.FxCurrentTimeInt64 = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr) int32
	}{multiplexCurrentTimeInt64}))

	gMultiplex.FsIoMethodsV1.FiVersion = 1
	gMultiplex.FsIoMethodsV1.FxClose = *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, uintptr) int32 }{multiplexClose}))
	gMultiplex.FsIoMethodsV1.FxRead = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, sqlite3_int64) int32
	}{multiplexRead}))
	gMultiplex.FsIoMethodsV1.FxWrite = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, sqlite3_int64) int32
	}{multiplexWrite}))
	gMultiplex.FsIoMethodsV1.FxTruncate = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, sqlite3_int64) int32
	}{multiplexTruncate}))
	gMultiplex.FsIoMethodsV1.FxSync = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, int32) int32
	}{multiplexSync}))
	gMultiplex.FsIoMethodsV1.FxFileSize = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr) int32
	}{multiplexFileSize}))
	gMultiplex.FsIoMethodsV1.FxLock = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, int32) int32
	}{multiplexLock}))
	gMultiplex.FsIoMethodsV1.FxUnlock = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, int32) int32
	}{multiplexUnlock}))
	gMultiplex.FsIoMethodsV1.FxCheckReservedLock = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr) int32
	}{multiplexCheckReservedLock}))
	gMultiplex.FsIoMethodsV1.FxFileControl = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, int32, uintptr) int32
	}{multiplexFileControl}))
	gMultiplex.FsIoMethodsV1.FxSectorSize = *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, uintptr) int32 }{multiplexSectorSize}))
	gMultiplex.FsIoMethodsV1.FxDeviceCharacteristics = *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, uintptr) int32 }{multiplexDeviceCharacteristics}))
	gMultiplex.FsIoMethodsV2 = gMultiplex.FsIoMethodsV1
	gMultiplex.FsIoMethodsV2.FiVersion = 2
	gMultiplex.FsIoMethodsV2.FxShmMap = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, int32, int32, int32, uintptr) int32
	}{multiplexShmMap}))
	gMultiplex.FsIoMethodsV2.FxShmLock = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, int32, int32, int32) int32
	}{multiplexShmLock}))
	gMultiplex.FsIoMethodsV2.FxShmBarrier = *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, uintptr) }{multiplexShmBarrier}))
	gMultiplex.FsIoMethodsV2.FxShmUnmap = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, int32) int32
	}{multiplexShmUnmap}))
	sqlite3.Xsqlite3_vfs_register(tls, (uintptr(unsafe.Pointer(&gMultiplex)) + 8 /* &.sThisVfs */), makeDefault)

	sqlite3.Xsqlite3_auto_extension(tls, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, uintptr) int32
	}{multiplexFuncInit})))

	return 0
}

var __func__104 = *(*[29]int8)(unsafe.Pointer(ts + 39825 /* "sqlite3_multiple..." */)) /* test_multiplex.c:1097:76 */

// CAPI: Shutdown the multiplex system - sqlite3_multiplex_shutdown()
//
// All SQLite database connections must be closed before calling this
// routine.
//
// THIS ROUTINE IS NOT THREADSAFE.  Call this routine exactly once while
// shutting down in order to free all remaining multiplex groups.
func sqlite3_multiplex_shutdown(tls *crt.TLS, eForce int32) int32 { /* test_multiplex.c:1158:5: */
	var rc int32 = 0
	if gMultiplex.FisInitialized == 0 {
		return 21
	}
	gMultiplex.FisInitialized = 0
	sqlite3.Xsqlite3_vfs_unregister(tls, (uintptr(unsafe.Pointer(&gMultiplex)) + 8 /* &.sThisVfs */))
	crt.Xmemset(tls, uintptr(unsafe.Pointer(&gMultiplex)), 0, uint64(unsafe.Sizeof(gMultiplex)))
	return rc
}

// tclcmd: sqlite3_multiplex_initialize NAME MAKEDEFAULT
func test_multiplex_initialize(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_multiplex.c:1183:26: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var zName uintptr // Name of new multiplex VFS
	// var makeDefault int32 at bp, 4
	// True to make the new VFS the default
	var rc int32 // Value returned by multiplex_initialize()

	_ = clientData

	// Process arguments
	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+39854 /* "NAME MAKEDEFAULT" */)
		return 1
	}
	zName = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)))
	if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)), bp /* &makeDefault */) != 0 {
		return 1
	}
	if int32(*(*int8)(unsafe.Pointer(zName + uintptr(0)))) == 0 {
		zName = uintptr(0)
	}

	// Call sqlite3_multiplex_initialize()
	rc = sqlite3_multiplex_initialize(tls, zName, *(*int32)(unsafe.Pointer(bp /* makeDefault */)))
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))

	return 0
}

// tclcmd: sqlite3_multiplex_shutdown
func test_multiplex_shutdown(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_multiplex.c:1214:26: */
	var rc int32 // Value returned by multiplex_shutdown()

	_ = clientData

	if (objc == 2) && (crt.Xstrcmp(tls, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), ts+39871 /* "-force" */) != 0) {
		objc = 3
	}
	if (objc != 1) && (objc != 2) {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+39878 /* "?-force?" */)
		return 1
	}

	// Call sqlite3_multiplex_shutdown()
	rc = sqlite3_multiplex_shutdown(tls, (crt.Bool32(objc == 2)))
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))

	return 0
}

// Tclcmd: test_multiplex_control HANDLE DBNAME SUB-COMMAND ?INT-VALUE?
func test_multiplex_control(tls *crt.TLS, cd ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_multiplex.c:1242:26: */
	bp := tls.Alloc(176)
	defer tls.Free(176)

	var rc int32 // Return code from file_control()
	// var idx int32 at bp+168, 4
	// Index in aSub[]
	// var cmdInfo Tcl_CmdInfo at bp+40, 64
	// Command info structure for HANDLE
	var db uintptr // Underlying db handle for HANDLE
	*(*int32)(unsafe.Pointer(bp + 172 /* iValue */)) = 0
	var pArg uintptr = uintptr(0)

	*(*[4]struct {
		FzName   uintptr
		Fop      int32
		Fargtype int32
	})(unsafe.Pointer(bp + 104 /* aSub */)) = [4]struct {
		FzName   uintptr
		Fop      int32
		Fargtype int32
	}{
		{FzName: ts + 39887 /* "enable" */, Fop: 214014, Fargtype: 1},
		{FzName: ts + 39894 /* "chunk_size" */, Fop: 214015, Fargtype: 1},
		{FzName: ts + 39905 /* "max_chunks" */, Fop: 214016, Fargtype: 1},
		{FzName: uintptr(0), Fop: 0, Fargtype: 0},
	}

	if objc != 5 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+39916 /* "HANDLE DBNAME SU..." */)
		return 1
	}

	if 0 == tcl.XTcl_GetCommandInfo(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), bp+40 /* &cmdInfo */) {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+39952 /* "expected databas..." */, 0))
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+16, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), ts+18666 /* "\"" */, 0))
		return 1
	} else {
		db = *(*uintptr)(unsafe.Pointer((*Tcl_CmdInfo)(unsafe.Pointer(bp + 40 /* &cmdInfo */)).FobjClientData))
	}

	rc = tcl.XTcl_GetIndexFromObjStruct(tls,
		interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(3)*8)), bp+104 /* &aSub[0] */, int32(unsafe.Sizeof(struct {
			FzName   uintptr
			Fop      int32
			Fargtype int32
		}{})), ts+2321 /* "sub-command" */, 0, bp+168 /* &idx */)
	if rc != 0 {
		return rc
	}

	switch (*struct {
		FzName   uintptr
		Fop      int32
		Fargtype int32
	})(unsafe.Pointer(bp + 104 /* &aSub */ + uintptr(*(*int32)(unsafe.Pointer(bp + 168 /* idx */)))*16)).Fargtype {
	case 1:
		if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(4)*8)), bp+172 /* &iValue */) != 0 {
			return 1
		}
		pArg = bp + 172 /* &iValue */
		break
	default:
		tcl.XTcl_WrongNumArgs(tls, interp, 4, objv, ts+39984 /* "SUB-COMMAND" */)
		return 1
	}

	rc = sqlite3.Xsqlite3_file_control(tls, db, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8))), (*struct {
		FzName   uintptr
		Fop      int32
		Fargtype int32
	})(unsafe.Pointer(bp+104 /* &aSub */ +uintptr(*(*int32)(unsafe.Pointer(bp + 168 /* idx */)))*16)).Fop, pArg)
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))
	if rc == 0 {
		return 0
	}
	return 1
}

// This routine registers the custom TCL commands defined in this
// module.  This should be the only procedure visible from outside
// of this module.
func Sqlitemultiplex_Init(tls *crt.TLS, interp uintptr) int32 { /* test_multiplex.c:1306:5: */
	var i int32

	for i = 0; uint64(i) < (uint64(unsafe.Sizeof(aCmd5)) / uint64(unsafe.Sizeof(struct {
		FzName uintptr
		FxProc uintptr
	}{}))); i++ {
		tcl.XTcl_CreateObjCommand(tls, interp, aCmd5[i].FzName, aCmd5[i].FxProc, uintptr(0), uintptr(0))
	}

	return 0
}

var aCmd5 = [3]struct {
	FzName uintptr
	FxProc uintptr
}{
	{FzName: ts + 39825 /* "sqlite3_multiple..." */, FxProc: 0},
	{FzName: ts + 39996 /* "sqlite3_multiple..." */, FxProc: 0},
	{FzName: ts + 40023 /* "sqlite3_multiple..." */, FxProc: 0},
} /* test_multiplex.c:1310:5 */

// CAPI3REF: Standard File Control Opcodes
// KEYWORDS: {file control opcodes} {file control opcode}
//
// These integer constants are opcodes for the xFileControl method
// of the [sqlite3_io_methods] object and for the [sqlite3_file_control()]
// interface.
//
// <ul>
// <li>[[SQLITE_FCNTL_LOCKSTATE]]
// The [SQLITE_FCNTL_LOCKSTATE] opcode is used for debugging.  This
// opcode causes the xFileControl method to write the current state of
// the lock (one of [SQLITE_LOCK_NONE], [SQLITE_LOCK_SHARED],
// [SQLITE_LOCK_RESERVED], [SQLITE_LOCK_PENDING], or [SQLITE_LOCK_EXCLUSIVE])
// into an integer that the pArg argument points to. This capability
// is used during testing and is only available when the SQLITE_TEST
// compile-time option is used.
//
// <li>[[SQLITE_FCNTL_SIZE_HINT]]
// The [SQLITE_FCNTL_SIZE_HINT] opcode is used by SQLite to give the VFS
// layer a hint of how large the database file will grow to be during the
// current transaction.  This hint is not guaranteed to be accurate but it
// is often close.  The underlying VFS might choose to preallocate database
// file space based on this hint in order to help writes to the database
// file run faster.
//
// <li>[[SQLITE_FCNTL_SIZE_LIMIT]]
// The [SQLITE_FCNTL_SIZE_LIMIT] opcode is used by in-memory VFS that
// implements [sqlite3_deserialize()] to set an upper bound on the size
// of the in-memory database.  The argument is a pointer to a [sqlite3_int64].
// If the integer pointed to is negative, then it is filled in with the
// current limit.  Otherwise the limit is set to the larger of the value
// of the integer pointed to and the current database size.  The integer
// pointed to is set to the new limit.
//
// <li>[[SQLITE_FCNTL_CHUNK_SIZE]]
// The [SQLITE_FCNTL_CHUNK_SIZE] opcode is used to request that the VFS
// extends and truncates the database file in chunks of a size specified
// by the user. The fourth argument to [sqlite3_file_control()] should
// point to an integer (type int) containing the new chunk-size to use
// for the nominated database. Allocating database file space in large
// chunks (say 1MB at a time), may reduce file-system fragmentation and
// improve performance on some systems.
//
// <li>[[SQLITE_FCNTL_FILE_POINTER]]
// The [SQLITE_FCNTL_FILE_POINTER] opcode is used to obtain a pointer
// to the [sqlite3_file] object associated with a particular database
// connection.  See also [SQLITE_FCNTL_JOURNAL_POINTER].
//
// <li>[[SQLITE_FCNTL_JOURNAL_POINTER]]
// The [SQLITE_FCNTL_JOURNAL_POINTER] opcode is used to obtain a pointer
// to the [sqlite3_file] object associated with the journal file (either
// the [rollback journal] or the [write-ahead log]) for a particular database
// connection.  See also [SQLITE_FCNTL_FILE_POINTER].
//
// <li>[[SQLITE_FCNTL_SYNC_OMITTED]]
// No longer in use.
//
// <li>[[SQLITE_FCNTL_SYNC]]
// The [SQLITE_FCNTL_SYNC] opcode is generated internally by SQLite and
// sent to the VFS immediately before the xSync method is invoked on a
// database file descriptor. Or, if the xSync method is not invoked
// because the user has configured SQLite with
// [PRAGMA synchronous | PRAGMA synchronous=OFF] it is invoked in place
// of the xSync method. In most cases, the pointer argument passed with
// this file-control is NULL. However, if the database file is being synced
// as part of a multi-database commit, the argument points to a nul-terminated
// string containing the transactions master-journal file name. VFSes that
// do not need this signal should silently ignore this opcode. Applications
// should not call [sqlite3_file_control()] with this opcode as doing so may
// disrupt the operation of the specialized VFSes that do require it.
//
// <li>[[SQLITE_FCNTL_COMMIT_PHASETWO]]
// The [SQLITE_FCNTL_COMMIT_PHASETWO] opcode is generated internally by SQLite
// and sent to the VFS after a transaction has been committed immediately
// but before the database is unlocked. VFSes that do not need this signal
// should silently ignore this opcode. Applications should not call
// [sqlite3_file_control()] with this opcode as doing so may disrupt the
// operation of the specialized VFSes that do require it.
//
// <li>[[SQLITE_FCNTL_WIN32_AV_RETRY]]
// ^The [SQLITE_FCNTL_WIN32_AV_RETRY] opcode is used to configure automatic
// retry counts and intervals for certain disk I/O operations for the
// windows [VFS] in order to provide robustness in the presence of
// anti-virus programs.  By default, the windows VFS will retry file read,
// file write, and file delete operations up to 10 times, with a delay
// of 25 milliseconds before the first retry and with the delay increasing
// by an additional 25 milliseconds with each subsequent retry.  This
// opcode allows these two values (10 retries and 25 milliseconds of delay)
// to be adjusted.  The values are changed for all database connections
// within the same process.  The argument is a pointer to an array of two
// integers where the first integer is the new retry count and the second
// integer is the delay.  If either integer is negative, then the setting
// is not changed but instead the prior value of that setting is written
// into the array entry, allowing the current retry settings to be
// interrogated.  The zDbName parameter is ignored.
//
// <li>[[SQLITE_FCNTL_PERSIST_WAL]]
// ^The [SQLITE_FCNTL_PERSIST_WAL] opcode is used to set or query the
// persistent [WAL | Write Ahead Log] setting.  By default, the auxiliary
// write ahead log ([WAL file]) and shared memory
// files used for transaction control
// are automatically deleted when the latest connection to the database
// closes.  Setting persistent WAL mode causes those files to persist after
// close.  Persisting the files is useful when other processes that do not
// have write permission on the directory containing the database file want
// to read the database file, as the WAL and shared memory files must exist
// in order for the database to be readable.  The fourth parameter to
// [sqlite3_file_control()] for this opcode should be a pointer to an integer.
// That integer is 0 to disable persistent WAL mode or 1 to enable persistent
// WAL mode.  If the integer is -1, then it is overwritten with the current
// WAL persistence setting.
//
// <li>[[SQLITE_FCNTL_POWERSAFE_OVERWRITE]]
// ^The [SQLITE_FCNTL_POWERSAFE_OVERWRITE] opcode is used to set or query the
// persistent "powersafe-overwrite" or "PSOW" setting.  The PSOW setting
// determines the [SQLITE_IOCAP_POWERSAFE_OVERWRITE] bit of the
// xDeviceCharacteristics methods. The fourth parameter to
// [sqlite3_file_control()] for this opcode should be a pointer to an integer.
// That integer is 0 to disable zero-damage mode or 1 to enable zero-damage
// mode.  If the integer is -1, then it is overwritten with the current
// zero-damage mode setting.
//
// <li>[[SQLITE_FCNTL_OVERWRITE]]
// ^The [SQLITE_FCNTL_OVERWRITE] opcode is invoked by SQLite after opening
// a write transaction to indicate that, unless it is rolled back for some
// reason, the entire database file will be overwritten by the current
// transaction. This is used by VACUUM operations.
//
// <li>[[SQLITE_FCNTL_VFSNAME]]
// ^The [SQLITE_FCNTL_VFSNAME] opcode can be used to obtain the names of
// all [VFSes] in the VFS stack.  The names are of all VFS shims and the
// final bottom-level VFS are written into memory obtained from
// [sqlite3_malloc()] and the result is stored in the char* variable
// that the fourth parameter of [sqlite3_file_control()] points to.
// The caller is responsible for freeing the memory when done.  As with
// all file-control actions, there is no guarantee that this will actually
// do anything.  Callers should initialize the char* variable to a NULL
// pointer in case this file-control is not implemented.  This file-control
// is intended for diagnostic use only.
//
// <li>[[SQLITE_FCNTL_VFS_POINTER]]
// ^The [SQLITE_FCNTL_VFS_POINTER] opcode finds a pointer to the top-level
// [VFSes] currently in use.  ^(The argument X in
// sqlite3_file_control(db,SQLITE_FCNTL_VFS_POINTER,X) must be
// of type "[sqlite3_vfs] **".  This opcodes will set *X
// to a pointer to the top-level VFS.)^
// ^When there are multiple VFS shims in the stack, this opcode finds the
// upper-most shim only.
//
// <li>[[SQLITE_FCNTL_PRAGMA]]
// ^Whenever a [PRAGMA] statement is parsed, an [SQLITE_FCNTL_PRAGMA]
// file control is sent to the open [sqlite3_file] object corresponding
// to the database file to which the pragma statement refers. ^The argument
// to the [SQLITE_FCNTL_PRAGMA] file control is an array of
// pointers to strings (char**) in which the second element of the array
// is the name of the pragma and the third element is the argument to the
// pragma or NULL if the pragma has no argument.  ^The handler for an
// [SQLITE_FCNTL_PRAGMA] file control can optionally make the first element
// of the char** argument point to a string obtained from [sqlite3_mprintf()]
// or the equivalent and that string will become the result of the pragma or
// the error message if the pragma fails. ^If the
// [SQLITE_FCNTL_PRAGMA] file control returns [SQLITE_NOTFOUND], then normal
// [PRAGMA] processing continues.  ^If the [SQLITE_FCNTL_PRAGMA]
// file control returns [SQLITE_OK], then the parser assumes that the
// VFS has handled the PRAGMA itself and the parser generates a no-op
// prepared statement if result string is NULL, or that returns a copy
// of the result string if the string is non-NULL.
// ^If the [SQLITE_FCNTL_PRAGMA] file control returns
// any result code other than [SQLITE_OK] or [SQLITE_NOTFOUND], that means
// that the VFS encountered an error while handling the [PRAGMA] and the
// compilation of the PRAGMA fails with an error.  ^The [SQLITE_FCNTL_PRAGMA]
// file control occurs at the beginning of pragma statement analysis and so
// it is able to override built-in [PRAGMA] statements.
//
// <li>[[SQLITE_FCNTL_BUSYHANDLER]]
// ^The [SQLITE_FCNTL_BUSYHANDLER]
// file-control may be invoked by SQLite on the database file handle
// shortly after it is opened in order to provide a custom VFS with access
// to the connection's busy-handler callback. The argument is of type (void**)
// - an array of two (void *) values. The first (void *) actually points
// to a function of type (int (*)(void *)). In order to invoke the connection's
// busy-handler, this function should be invoked with the second (void *) in
// the array as the only argument. If it returns non-zero, then the operation
// should be retried. If it returns zero, the custom VFS should abandon the
// current operation.
//
// <li>[[SQLITE_FCNTL_TEMPFILENAME]]
// ^Applications can invoke the [SQLITE_FCNTL_TEMPFILENAME] file-control
// to have SQLite generate a
// temporary filename using the same algorithm that is followed to generate
// temporary filenames for TEMP tables and other internal uses.  The
// argument should be a char** which will be filled with the filename
// written into memory obtained from [sqlite3_malloc()].  The caller should
// invoke [sqlite3_free()] on the result to avoid a memory leak.
//
// <li>[[SQLITE_FCNTL_MMAP_SIZE]]
// The [SQLITE_FCNTL_MMAP_SIZE] file control is used to query or set the
// maximum number of bytes that will be used for memory-mapped I/O.
// The argument is a pointer to a value of type sqlite3_int64 that
// is an advisory maximum number of bytes in the file to memory map.  The
// pointer is overwritten with the old value.  The limit is not changed if
// the value originally pointed to is negative, and so the current limit
// can be queried by passing in a pointer to a negative number.  This
// file-control is used internally to implement [PRAGMA mmap_size].
//
// <li>[[SQLITE_FCNTL_TRACE]]
// The [SQLITE_FCNTL_TRACE] file control provides advisory information
// to the VFS about what the higher layers of the SQLite stack are doing.
// This file control is used by some VFS activity tracing [shims].
// The argument is a zero-terminated string.  Higher layers in the
// SQLite stack may generate instances of this file control if
// the [SQLITE_USE_FCNTL_TRACE] compile-time option is enabled.
//
// <li>[[SQLITE_FCNTL_HAS_MOVED]]
// The [SQLITE_FCNTL_HAS_MOVED] file control interprets its argument as a
// pointer to an integer and it writes a boolean into that integer depending
// on whether or not the file has been renamed, moved, or deleted since it
// was first opened.
//
// <li>[[SQLITE_FCNTL_WIN32_GET_HANDLE]]
// The [SQLITE_FCNTL_WIN32_GET_HANDLE] opcode can be used to obtain the
// underlying native file handle associated with a file handle.  This file
// control interprets its argument as a pointer to a native file handle and
// writes the resulting value there.
//
// <li>[[SQLITE_FCNTL_WIN32_SET_HANDLE]]
// The [SQLITE_FCNTL_WIN32_SET_HANDLE] opcode is used for debugging.  This
// opcode causes the xFileControl method to swap the file handle with the one
// pointed to by the pArg argument.  This capability is used during testing
// and only needs to be supported when SQLITE_TEST is defined.
//
// <li>[[SQLITE_FCNTL_WAL_BLOCK]]
// The [SQLITE_FCNTL_WAL_BLOCK] is a signal to the VFS layer that it might
// be advantageous to block on the next WAL lock if the lock is not immediately
// available.  The WAL subsystem issues this signal during rare
// circumstances in order to fix a problem with priority inversion.
// Applications should <em>not</em> use this file-control.
//
// <li>[[SQLITE_FCNTL_ZIPVFS]]
// The [SQLITE_FCNTL_ZIPVFS] opcode is implemented by zipvfs only. All other
// VFS should return SQLITE_NOTFOUND for this opcode.
//
// <li>[[SQLITE_FCNTL_RBU]]
// The [SQLITE_FCNTL_RBU] opcode is implemented by the special VFS used by
// the RBU extension only.  All other VFS should return SQLITE_NOTFOUND for
// this opcode.
//
// <li>[[SQLITE_FCNTL_BEGIN_ATOMIC_WRITE]]
// If the [SQLITE_FCNTL_BEGIN_ATOMIC_WRITE] opcode returns SQLITE_OK, then
// the file descriptor is placed in "batch write mode", which
// means all subsequent write operations will be deferred and done
// atomically at the next [SQLITE_FCNTL_COMMIT_ATOMIC_WRITE].  Systems
// that do not support batch atomic writes will return SQLITE_NOTFOUND.
// ^Following a successful SQLITE_FCNTL_BEGIN_ATOMIC_WRITE and prior to
// the closing [SQLITE_FCNTL_COMMIT_ATOMIC_WRITE] or
// [SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE], SQLite will make
// no VFS interface calls on the same [sqlite3_file] file descriptor
// except for calls to the xWrite method and the xFileControl method
// with [SQLITE_FCNTL_SIZE_HINT].
//
// <li>[[SQLITE_FCNTL_COMMIT_ATOMIC_WRITE]]
// The [SQLITE_FCNTL_COMMIT_ATOMIC_WRITE] opcode causes all write
// operations since the previous successful call to
// [SQLITE_FCNTL_BEGIN_ATOMIC_WRITE] to be performed atomically.
// This file control returns [SQLITE_OK] if and only if the writes were
// all performed successfully and have been committed to persistent storage.
// ^Regardless of whether or not it is successful, this file control takes
// the file descriptor out of batch write mode so that all subsequent
// write operations are independent.
// ^SQLite will never invoke SQLITE_FCNTL_COMMIT_ATOMIC_WRITE without
// a prior successful call to [SQLITE_FCNTL_BEGIN_ATOMIC_WRITE].
//
// <li>[[SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE]]
// The [SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE] opcode causes all write
// operations since the previous successful call to
// [SQLITE_FCNTL_BEGIN_ATOMIC_WRITE] to be rolled back.
// ^This file control takes the file descriptor out of batch write mode
// so that all subsequent write operations are independent.
// ^SQLite will never invoke SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE without
// a prior successful call to [SQLITE_FCNTL_BEGIN_ATOMIC_WRITE].
//
// <li>[[SQLITE_FCNTL_LOCK_TIMEOUT]]
// The [SQLITE_FCNTL_LOCK_TIMEOUT] opcode is used to configure a VFS
// to block for up to M milliseconds before failing when attempting to
// obtain a file lock using the xLock or xShmLock methods of the VFS.
// The parameter is a pointer to a 32-bit signed integer that contains
// the value that M is to be set to. Before returning, the 32-bit signed
// integer is overwritten with the previous value of M.
//
// <li>[[SQLITE_FCNTL_DATA_VERSION]]
// The [SQLITE_FCNTL_DATA_VERSION] opcode is used to detect changes to
// a database file.  The argument is a pointer to a 32-bit unsigned integer.
// The "data version" for the pager is written into the pointer.  The
// "data version" changes whenever any change occurs to the corresponding
// database file, either through SQL statements on the same database
// connection or through transactions committed by separate database
// connections possibly in other processes. The [sqlite3_total_changes()]
// interface can be used to find if any database on the connection has changed,
// but that interface responds to changes on TEMP as well as MAIN and does
// not provide a mechanism to detect changes to MAIN only.  Also, the
// [sqlite3_total_changes()] interface responds to internal changes only and
// omits changes made by other database connections.  The
// [PRAGMA data_version] command provides a mechanism to detect changes to
// a single attached database that occur due to other database connections,
// but omits changes implemented by the database connection on which it is
// called.  This file control is the only mechanism to detect changes that
// happen either internally or externally and that are associated with
// a particular attached database.
//
// <li>[[SQLITE_FCNTL_CKPT_START]]
// The [SQLITE_FCNTL_CKPT_START] opcode is invoked from within a checkpoint
// in wal mode before the client starts to copy pages from the wal
// file to the database file.
//
// <li>[[SQLITE_FCNTL_CKPT_DONE]]
// The [SQLITE_FCNTL_CKPT_DONE] opcode is invoked from within a checkpoint
// in wal mode after the client has finished copying pages from the wal
// file to the database file, but before the *-shm file is updated to
// record the fact that the pages have been checkpointed.
// </ul>

// deprecated names

// CAPI3REF: Mutex Handle
//
// The mutex module within SQLite defines [sqlite3_mutex] to be an
// abstract type for a mutex object.  The SQLite core never looks
// at the internal representation of an [sqlite3_mutex].  It only
// deals with pointers to the [sqlite3_mutex] object.
//
// Mutexes are created using [sqlite3_mutex_alloc()].
type sqlite3_mutex = sqlite3_mutex1 /* sqlite3.h:1183:30 */

var aName = [15]uintptr{
	ts + 40049 /* "fast" */, ts + 40054 /* "recursive" */, ts + 40064 /* "static_master" */, ts + 40078, /* "static_mem" */
	ts + 40089 /* "static_open" */, ts + 40101 /* "static_prng" */, ts + 40113 /* "static_lru" */, ts + 40124, /* "static_pmem" */
	ts + 40136 /* "static_app1" */, ts + 40148 /* "static_app2" */, ts + 40160 /* "static_app3" */, ts + 40172, /* "static_vfs1" */
	ts + 40184 /* "static_vfs2" */, ts + 40196 /* "static_vfs3" */, uintptr(0),
} /* test_mutex.c:32:19 */

// State variables
type test_mutex_globals = struct {
	FisInstalled int32
	FdisableInit int32
	FdisableTry  int32
	FisInit      int32
	Fm           sqlite3_mutex_methods
	FaCounter    [14]int32
	FaStatic     [12]sqlite3_mutex
}

// State variables
var g3 = test_mutex_globals{FisInstalled: 0} /* test_mutex.c:54:3 */

// Return true if the countable mutex is currently held
func counterMutexHeld(tls *crt.TLS, p uintptr) int32 { /* test_mutex.c:57:12: */
	return (*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer((uintptr(unsafe.Pointer(&g3)) + 16 /* &.m */ + 56 /* &.xMutexHeld */))))(tls, (*sqlite3_mutex)(unsafe.Pointer(p)).FpReal)
}

// Return true if the countable mutex is not currently held
func counterMutexNotheld(tls *crt.TLS, p uintptr) int32 { /* test_mutex.c:62:12: */
	return (*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer((uintptr(unsafe.Pointer(&g3)) + 16 /* &.m */ + 64 /* &.xMutexNotheld */))))(tls, (*sqlite3_mutex)(unsafe.Pointer(p)).FpReal)
}

// Initialize the countable mutex interface
// Or, if g.disableInit is non-zero, then do not initialize but instead
// return the value of g.disableInit as the result code.  This can be used
// to simulate an initialization failure.
func counterMutexInit(tls *crt.TLS) int32 { /* test_mutex.c:71:12: */
	var rc int32
	if g3.FdisableInit != 0 {
		return g3.FdisableInit
	}
	rc = (*(*func(*crt.TLS) int32)(unsafe.Pointer((uintptr(unsafe.Pointer(&g3)) + 16 /* &.m */ /* &.xMutexInit */))))(tls)
	g3.FisInit = 1
	return rc
}

// Uninitialize the mutex subsystem
func counterMutexEnd(tls *crt.TLS) int32 { /* test_mutex.c:82:12: */
	g3.FisInit = 0
	return (*(*func(*crt.TLS) int32)(unsafe.Pointer((uintptr(unsafe.Pointer(&g3)) + 16 /* &.m */ + 8 /* &.xMutexEnd */))))(tls)
}

// Allocate a countable mutex
func counterMutexAlloc(tls *crt.TLS, eType int32) uintptr { /* test_mutex.c:90:22: */
	var pReal uintptr
	var pRet uintptr = uintptr(0)

	pReal = (*(*func(*crt.TLS, int32) uintptr)(unsafe.Pointer((uintptr(unsafe.Pointer(&g3)) + 16 /* &.m */ + 16 /* &.xMutexAlloc */))))(tls, eType)
	if !(pReal != 0) {
		return uintptr(0)
	}

	if (eType == 0) || (eType == 1) {
		pRet = crt.Xmalloc(tls, uint64(unsafe.Sizeof(sqlite3_mutex{})))
	} else {
		var eStaticType int32 = (eType - ((13 + 1) - ((13 + 1) - (1 + 1))))

		pRet = ((uintptr(unsafe.Pointer(&g3)) + 144 /* &.aStatic */) + uintptr(eStaticType)*16)
	}

	(*sqlite3_mutex)(unsafe.Pointer(pRet)).FeType = eType
	(*sqlite3_mutex)(unsafe.Pointer(pRet)).FpReal = pReal
	return pRet
}

// Free a countable mutex
func counterMutexFree(tls *crt.TLS, p uintptr) { /* test_mutex.c:118:13: */

	(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((uintptr(unsafe.Pointer(&g3)) + 16 /* &.m */ + 24 /* &.xMutexFree */))))(tls, (*sqlite3_mutex)(unsafe.Pointer(p)).FpReal)
	if ((*sqlite3_mutex)(unsafe.Pointer(p)).FeType == 0) || ((*sqlite3_mutex)(unsafe.Pointer(p)).FeType == 1) {
		crt.Xfree(tls, p)
	}
}

// Enter a countable mutex.  Block until entry is safe.
func counterMutexEnter(tls *crt.TLS, p uintptr) { /* test_mutex.c:129:13: */

	*(*int32)(unsafe.Pointer((uintptr(unsafe.Pointer(&g3)) + 88 /* &.aCounter */) + uintptr((*sqlite3_mutex)(unsafe.Pointer(p)).FeType)*4))++
	(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((uintptr(unsafe.Pointer(&g3)) + 16 /* &.m */ + 32 /* &.xMutexEnter */))))(tls, (*sqlite3_mutex)(unsafe.Pointer(p)).FpReal)
}

// Try to enter a mutex.  Return true on success.
func counterMutexTry(tls *crt.TLS, p uintptr) int32 { /* test_mutex.c:140:12: */

	*(*int32)(unsafe.Pointer((uintptr(unsafe.Pointer(&g3)) + 88 /* &.aCounter */) + uintptr((*sqlite3_mutex)(unsafe.Pointer(p)).FeType)*4))++
	if g3.FdisableTry != 0 {
		return 5
	}
	return (*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer((uintptr(unsafe.Pointer(&g3)) + 16 /* &.m */ + 40 /* &.xMutexTry */))))(tls, (*sqlite3_mutex)(unsafe.Pointer(p)).FpReal)
}

// Leave a mutex
func counterMutexLeave(tls *crt.TLS, p uintptr) { /* test_mutex.c:151:13: */

	(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((uintptr(unsafe.Pointer(&g3)) + 16 /* &.m */ + 48 /* &.xMutexLeave */))))(tls, (*sqlite3_mutex)(unsafe.Pointer(p)).FpReal)
}

// sqlite3_shutdown
func test_shutdown(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_mutex.c:159:26: */
	var rc int32

	if objc != 1 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+792 /* "" */)
		return 1
	}

	rc = sqlite3.Xsqlite3_shutdown(tls)
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(1))
	return 0
}

// sqlite3_initialize
func test_initialize(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_mutex.c:180:26: */
	var rc int32

	if objc != 1 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+792 /* "" */)
		return 1
	}

	rc = sqlite3.Xsqlite3_initialize(tls)
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(1))
	return 0
}

// install_mutex_counters BOOLEAN
func test_install_mutex_counters(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_mutex.c:201:26: */
	bp := tls.Alloc(136)
	defer tls.Free(136)

	var rc int32 = 0
	// var isInstall int32 at bp+56, 4

	*(*sqlite3_mutex_methods)(unsafe.Pointer(bp + 64 /* counter_methods */)) = sqlite3_mutex_methods{FxMutexInit: *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS) int32 }{counterMutexInit})), FxMutexEnd: *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS) int32 }{counterMutexEnd})), FxMutexAlloc: *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, int32) uintptr }{counterMutexAlloc})), FxMutexFree: *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, uintptr) }{counterMutexFree})), FxMutexEnter: *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, uintptr) }{counterMutexEnter})), FxMutexTry: *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, uintptr) int32 }{counterMutexTry})), FxMutexLeave: *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, uintptr) }{counterMutexLeave})), FxMutexHeld: *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, uintptr) int32 }{counterMutexHeld})), FxMutexNotheld: *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, uintptr) int32 }{counterMutexNotheld}))}

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+38035 /* "BOOLEAN" */)
		return 1
	}
	if 0 != tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)), bp+56 /* &isInstall */) {
		return 1
	}

	if *(*int32)(unsafe.Pointer(bp + 56 /* isInstall */)) == g3.FisInstalled {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+40208 /* "mutex counters a..." */, 0))
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+16, func() uintptr {
			if *(*int32)(unsafe.Pointer(bp + 56 /* isInstall */)) != 0 {
				return ts + 40228 /* "already installe..." */
			}
			return ts + 40246 /* "not installed" */
		}(), 0))
		return 1
	}

	if *(*int32)(unsafe.Pointer(bp + 56 /* isInstall */)) != 0 {

		rc = sqlite3.Xsqlite3_config(tls, 11, crt.VaList(bp+32, (uintptr(unsafe.Pointer(&g3))+16 /* &.m */)))
		if rc == 0 {
			sqlite3.Xsqlite3_config(tls, 10, crt.VaList(bp+40, bp+64 /* &counter_methods */))
		}
		g3.FdisableTry = 0
	} else {

		rc = sqlite3.Xsqlite3_config(tls, 10, crt.VaList(bp+48, (uintptr(unsafe.Pointer(&g3))+16 /* &.m */)))
		crt.Xmemset(tls, (uintptr(unsafe.Pointer(&g3)) + 16 /* &.m */), 0, uint64(unsafe.Sizeof(sqlite3_mutex_methods{})))
	}

	if rc == 0 {
		g3.FisInstalled = *(*int32)(unsafe.Pointer(bp + 56 /* isInstall */))
	}

	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(1))
	return 0
}

// read_mutex_counters
func test_read_mutex_counters(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_mutex.c:262:26: */
	var pRet uintptr
	var ii int32

	if objc != 1 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+792 /* "" */)
		return 1
	}

	pRet = tcl.XTcl_NewObj(tls)
	(*Tcl_Obj)(unsafe.Pointer(pRet)).FrefCount++
	for ii = 0; ii < (13 + 1); ii++ {
		tcl.XTcl_ListObjAppendElement(tls, interp, pRet, tcl.XTcl_NewStringObj(tls, aName[ii], -1))
		tcl.XTcl_ListObjAppendElement(tls, interp, pRet, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer((uintptr(unsafe.Pointer(&g3)) + 88 /* &.aCounter */) + uintptr(ii)*4))))
	}
	tcl.XTcl_SetObjResult(tls, interp, pRet)
	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = pRet
		if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}

	return 0
}

// clear_mutex_counters
func test_clear_mutex_counters(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_mutex.c:291:26: */
	var ii int32

	if objc != 1 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+792 /* "" */)
		return 1
	}

	for ii = 0; ii < (13 + 1); ii++ {
		*(*int32)(unsafe.Pointer((uintptr(unsafe.Pointer(&g3)) + 88 /* &.aCounter */) + uintptr(ii)*4)) = 0
	}
	return 0
}

// Create and free a mutex.  Return the mutex pointer.  The pointer
// will be invalid since the mutex has already been freed.  The
// return pointer just checks to see if the mutex really was allocated.
func test_alloc_mutex(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_mutex.c:315:26: */
	bp := tls.Alloc(124)
	defer tls.Free(124)

	var p uintptr = sqlite3.Xsqlite3_mutex_alloc(tls, 0)
	// var zBuf [100]int8 at bp+24, 100

	sqlite3.Xsqlite3_mutex_free(tls, p)
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([100]int8{})), bp+24 /* &zBuf[0] */, ts+20002 /* "%p" */, crt.VaList(bp, p))
	tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+8, bp+24 /* &zBuf[0] */, uintptr(0)))
	return 0
}

// sqlite3_config OPTION
//
// OPTION can be either one of the keywords:
//
//            SQLITE_CONFIG_SINGLETHREAD
//            SQLITE_CONFIG_MULTITHREAD
//            SQLITE_CONFIG_SERIALIZED
//
// Or OPTION can be an raw integer.
func test_config(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_mutex.c:342:26: */
	bp := tls.Alloc(68)
	defer tls.Free(68)

	*(*[4]ConfigOption)(unsafe.Pointer(bp /* aOpt */)) = [4]ConfigOption{
		{FzName: ts + 40260 /* "singlethread" */, FiValue: 1},
		{FzName: ts + 40273 /* "multithread" */, FiValue: 2},
		{FzName: ts + 40285 /* "serialized" */, FiValue: 3},
		{FzName: uintptr(0), FiValue: 0},
	}
	var s int32 = int32(unsafe.Sizeof(ConfigOption{}))
	// var i int32 at bp+64, 4

	var rc int32

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+792 /* "" */)
		return 1
	}

	if tcl.XTcl_GetIndexFromObjStruct(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)), bp /* &aOpt[0] */, s, ts+23786 /* "flag" */, 0, bp+64 /* &i */) != 0 {
		if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)), bp+64 /* &i */) != 0 {
			return 1
		}
	} else {
		*(*int32)(unsafe.Pointer(bp + 64 /* i */)) = (*ConfigOption)(unsafe.Pointer(bp /* &aOpt */ + uintptr(*(*int32)(unsafe.Pointer(bp + 64 /* i */)))*16)).FiValue
	}

	rc = sqlite3.Xsqlite3_config(tls, *(*int32)(unsafe.Pointer(bp + 64 /* i */)), 0)
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(1))
	return 0
}

type ConfigOption = struct {
	FzName  uintptr
	FiValue int32
	_       [4]byte
}

func getDbPointer1(tls *crt.TLS, pInterp uintptr, pObj uintptr) uintptr { /* test_mutex.c:379:16: */
	bp := tls.Alloc(64)
	defer tls.Free(64)

	var db uintptr
	// var info Tcl_CmdInfo at bp, 64

	var zCmd uintptr = tcl.XTcl_GetString(tls, pObj)
	if tcl.XTcl_GetCommandInfo(tls, pInterp, zCmd, bp /* &info */) != 0 {
		db = *(*uintptr)(unsafe.Pointer((*Tcl_CmdInfo)(unsafe.Pointer(bp /* &info */)).FobjClientData))
	} else {
		db = sqlite3TestTextToPtr(tls, zCmd)
	}

	return db
}

func getStaticMutexPointer(tls *crt.TLS, pInterp uintptr, pObj uintptr) uintptr { /* test_mutex.c:392:22: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	// var iMutex int32 at bp, 4

	if tcl.XTcl_GetIndexFromObjStruct(tls, pInterp, pObj, uintptr(unsafe.Pointer(&aName)), int32(unsafe.Sizeof(uintptr(0))), ts+40296 /* "mutex name" */, 0, bp /* &iMutex */) != 0 {
		return uintptr(0)
	}

	return counterMutexAlloc(tls, *(*int32)(unsafe.Pointer(bp /* iMutex */)))
}

func test_enter_static_mutex(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_mutex.c:404:26: */
	var pMutex uintptr
	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+16896 /* "NAME" */)
		return 1
	}
	pMutex = getStaticMutexPointer(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)))
	if !(pMutex != 0) {
		return 1
	}
	sqlite3.Xsqlite3_mutex_enter(tls, pMutex)
	return 0
}

func test_leave_static_mutex(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_mutex.c:423:26: */
	var pMutex uintptr
	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+16896 /* "NAME" */)
		return 1
	}
	pMutex = getStaticMutexPointer(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)))
	if !(pMutex != 0) {
		return 1
	}
	sqlite3.Xsqlite3_mutex_leave(tls, pMutex)
	return 0
}

func test_enter_db_mutex(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_mutex.c:442:26: */
	var db uintptr
	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+2452 /* "DB" */)
		return 1
	}
	db = getDbPointer1(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)))
	if !(db != 0) {
		return 1
	}
	sqlite3.Xsqlite3_mutex_enter(tls, sqlite3.Xsqlite3_db_mutex(tls, db))
	return 0
}

func test_leave_db_mutex(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_mutex.c:461:26: */
	var db uintptr
	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+2452 /* "DB" */)
		return 1
	}
	db = getDbPointer1(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)))
	if !(db != 0) {
		return 1
	}
	sqlite3.Xsqlite3_mutex_leave(tls, sqlite3.Xsqlite3_db_mutex(tls, db))
	return 0
}

func Sqlitetest_mutex_Init(tls *crt.TLS, interp uintptr) int32 { /* test_mutex.c:480:5: */
	var i int32
	for i = 0; uint64(i) < (uint64(unsafe.Sizeof(aCmd6)) / uint64(unsafe.Sizeof(struct {
		FzName uintptr
		FxProc uintptr
	}{}))); i++ {
		tcl.XTcl_CreateObjCommand(tls, interp, aCmd6[i].FzName, aCmd6[i].FxProc, uintptr(0), uintptr(0))
	}

	tcl.XTcl_LinkVar(tls, interp, ts+40307, /* "disable_mutex_in..." */
		(uintptr(unsafe.Pointer(&g3)) + 4 /* &.disableInit */), 1)
	tcl.XTcl_LinkVar(tls, interp, ts+40326, /* "disable_mutex_tr..." */
		(uintptr(unsafe.Pointer(&g3)) + 8 /* &.disableTry */), 1)
	return 0
}

var aCmd6 = [11]struct {
	FzName uintptr
	FxProc uintptr
}{
	{FzName: ts + 40344 /* "sqlite3_shutdown" */, FxProc: 0},
	{FzName: ts + 40361 /* "sqlite3_initiali..." */, FxProc: 0},
	{FzName: ts + 40380 /* "sqlite3_config" */, FxProc: 0},

	{FzName: ts + 40395 /* "enter_static_mut..." */, FxProc: 0},
	{FzName: ts + 40414 /* "leave_static_mut..." */, FxProc: 0},

	{FzName: ts + 40433 /* "enter_db_mutex" */, FxProc: 0},
	{FzName: ts + 40448 /* "leave_db_mutex" */, FxProc: 0},

	{FzName: ts + 40463 /* "alloc_dealloc_mu..." */, FxProc: 0},
	{FzName: ts + 40483 /* "install_mutex_co..." */, FxProc: 0},
	{FzName: ts + 40506 /* "read_mutex_count..." */, FxProc: 0},
	{FzName: ts + 40526 /* "clear_mutex_coun..." */, FxProc: 0},
} /* test_mutex.c:484:5 */

// Maximum pathname length supported by the fs backend.

// Name used to identify this VFS.

type fs_real_file1 = struct {
	FpFile     uintptr
	FzName     uintptr
	FnDatabase int32
	FnJournal  int32
	FnBlob     int32
	FnRef      int32
	FpNext     uintptr
	FppThis    uintptr
}

// Maximum pathname length supported by the fs backend.

// Name used to identify this VFS.

type fs_real_file = fs_real_file1 /* test_onefile.c:97:29 */

type fs_file1 = struct {
	Fbase  sqlite3_file
	FeType int32
	FpReal uintptr
}

type fs_file = fs_file1 /* test_onefile.c:109:24 */

type tmp_file1 = struct {
	Fbase   sqlite3_file
	FnSize  int32
	FnAlloc int32
	FzAlloc uintptr
}

type tmp_file = tmp_file1 /* test_onefile.c:116:25 */

type fs_vfs_t1 = struct {
	Fbase      sqlite3_vfs
	FpFileList uintptr
	FpParent   uintptr
}

type fs_vfs_t = fs_vfs_t1 /* test_onefile.c:176:25 */

var fs_vfs = fs_vfs_t{Fbase: sqlite3_vfs{FiVersion: 1, FszOsFile: // iVersion
0, FmxPathname:// szOsFile
0, FpNext:// mxPathname
uintptr(0), FzName:// pNext
ts + 36013, /* "fs" */ FpAppData:// zName
uintptr(0), FxOpen:// pAppData
0, FxDelete:// xOpen
0, FxAccess:// xDelete
0, FxFullPathname:// xAccess
0, FxDlOpen:// xFullPathname
0, FxDlError:// xDlOpen
0, FxDlSym:// xDlError
0, FxDlClose:// xDlSym
0, FxRandomness:// xDlClose
0, FxSleep:// xRandomness
0, FxCurrentTime:// xSleep
0, FxGetLastError:// xCurrentTime
uintptr(0), // xCurrentTimeInt64
}, FpFileList: uintptr(0), FpParent: // pFileList
uintptr(0),    // pParent
} /* test_onefile.c:183:17 */

var fs_io_methods = sqlite3_io_methods{FiVersion: 1, FxClose: // iVersion
0, FxRead:// xClose
0, FxWrite:// xRead
0, FxTruncate:// xWrite
0, FxSync:// xTruncate
0, FxFileSize:// xSync
0, FxLock:// xFileSize
0, FxUnlock:// xLock
0, FxCheckReservedLock:// xUnlock
0, FxFileControl:// xCheckReservedLock
0, FxSectorSize:// xFileControl
0, FxDeviceCharacteristics:// xSectorSize
0, FxShmMap:// xDeviceCharacteristics
uintptr(0), FxShmLock:// xShmMap
uintptr(0), FxShmBarrier:// xShmLock
uintptr(0), FxShmUnmap:// xShmBarrier
uintptr(0), // xShmUnmap
} /* test_onefile.c:208:27 */

var tmp_io_methods = sqlite3_io_methods{FiVersion: 1, FxClose: // iVersion
0, FxRead:// xClose
0, FxWrite:// xRead
0, FxTruncate:// xWrite
0, FxSync:// xTruncate
0, FxFileSize:// xSync
0, FxLock:// xFileSize
0, FxUnlock:// xLock
0, FxCheckReservedLock:// xUnlock
0, FxFileControl:// xCheckReservedLock
0, FxSectorSize:// xFileControl
0, FxDeviceCharacteristics:// xSectorSize
0, FxShmMap:// xDeviceCharacteristics
uintptr(0), FxShmLock:// xShmMap
uintptr(0), FxShmBarrier:// xShmLock
uintptr(0), FxShmUnmap:// xShmBarrier
uintptr(0), // xShmUnmap
} /* test_onefile.c:229:27 */

// Useful macros used in several places

// Close a tmp-file.
func tmpClose(tls *crt.TLS, pFile uintptr) int32 { /* test_onefile.c:257:12: */
	var pTmp uintptr = pFile
	sqlite3.Xsqlite3_free(tls, (*tmp_file)(unsafe.Pointer(pTmp)).FzAlloc)
	return 0
}

// Read data from a tmp-file.
func tmpRead(tls *crt.TLS, pFile uintptr, zBuf uintptr, iAmt int32, iOfst sqlite_int64) int32 { /* test_onefile.c:266:12: */
	var pTmp uintptr = pFile
	if (sqlite_int64(iAmt) + iOfst) > sqlite_int64((*tmp_file)(unsafe.Pointer(pTmp)).FnSize) {
		return (10 | (int32(2) << 8))
	}
	crt.Xmemcpy(tls, zBuf, ((*tmp_file)(unsafe.Pointer(pTmp)).FzAlloc + uintptr(iOfst)), uint64(iAmt))
	return 0
}

// Write data to a tmp-file.
func tmpWrite(tls *crt.TLS, pFile uintptr, zBuf uintptr, iAmt int32, iOfst sqlite_int64) int32 { /* test_onefile.c:283:12: */
	var pTmp uintptr = pFile
	if (sqlite_int64(iAmt) + iOfst) > sqlite_int64((*tmp_file)(unsafe.Pointer(pTmp)).FnAlloc) {
		var nNew int32 = (int32(int64(2) * ((sqlite_int64(iAmt) + iOfst) + sqlite_int64((*tmp_file)(unsafe.Pointer(pTmp)).FnAlloc))))
		var zNew uintptr = sqlite3.Xsqlite3_realloc(tls, (*tmp_file)(unsafe.Pointer(pTmp)).FzAlloc, nNew)
		if !(zNew != 0) {
			return 7
		}
		(*tmp_file)(unsafe.Pointer(pTmp)).FzAlloc = zNew
		(*tmp_file)(unsafe.Pointer(pTmp)).FnAlloc = nNew
	}
	crt.Xmemcpy(tls, ((*tmp_file)(unsafe.Pointer(pTmp)).FzAlloc + uintptr(iOfst)), zBuf, uint64(iAmt))
	(*tmp_file)(unsafe.Pointer(pTmp)).FnSize = func() int32 {
		if (sqlite_int64((*tmp_file)(unsafe.Pointer(pTmp)).FnSize)) > (iOfst + sqlite_int64(iAmt)) {
			return (*tmp_file)(unsafe.Pointer(pTmp)).FnSize
		}
		return (int32(iOfst + sqlite_int64(iAmt)))
	}()
	return 0
}

// Truncate a tmp-file.
func tmpTruncate(tls *crt.TLS, pFile uintptr, size sqlite_int64) int32 { /* test_onefile.c:307:12: */
	var pTmp uintptr = pFile
	(*tmp_file)(unsafe.Pointer(pTmp)).FnSize = func() int32 {
		if (sqlite_int64((*tmp_file)(unsafe.Pointer(pTmp)).FnSize)) < (size) {
			return (*tmp_file)(unsafe.Pointer(pTmp)).FnSize
		}
		return int32(size)
	}()
	return 0
}

// Sync a tmp-file.
func tmpSync(tls *crt.TLS, pFile uintptr, flags int32) int32 { /* test_onefile.c:316:12: */
	return 0
}

// Return the current file-size of a tmp-file.
func tmpFileSize(tls *crt.TLS, pFile uintptr, pSize uintptr) int32 { /* test_onefile.c:323:12: */
	var pTmp uintptr = pFile
	*(*sqlite_int64)(unsafe.Pointer(pSize)) = sqlite_int64((*tmp_file)(unsafe.Pointer(pTmp)).FnSize)
	return 0
}

// Lock a tmp-file.
func tmpLock(tls *crt.TLS, pFile uintptr, eLock int32) int32 { /* test_onefile.c:332:12: */
	return 0
}

// Unlock a tmp-file.
func tmpUnlock(tls *crt.TLS, pFile uintptr, eLock int32) int32 { /* test_onefile.c:339:12: */
	return 0
}

// Check if another file-handle holds a RESERVED lock on a tmp-file.
func tmpCheckReservedLock(tls *crt.TLS, pFile uintptr, pResOut uintptr) int32 { /* test_onefile.c:346:12: */
	*(*int32)(unsafe.Pointer(pResOut)) = 0
	return 0
}

// File control method. For custom operations on a tmp-file.
func tmpFileControl(tls *crt.TLS, pFile uintptr, op int32, pArg uintptr) int32 { /* test_onefile.c:354:12: */
	return 0
}

// Return the sector-size in bytes for a tmp-file.
func tmpSectorSize(tls *crt.TLS, pFile uintptr) int32 { /* test_onefile.c:361:12: */
	return 0
}

// Return the device characteristic flags supported by a tmp-file.
func tmpDeviceCharacteristics(tls *crt.TLS, pFile uintptr) int32 { /* test_onefile.c:368:12: */
	return 0
}

// Close an fs-file.
func fsClose1(tls *crt.TLS, pFile uintptr) int32 { /* test_onefile.c:375:12: */
	var rc int32 = 0
	var p uintptr = pFile
	var pReal uintptr = (*fs_file)(unsafe.Pointer(p)).FpReal

	// Decrement the real_file ref-count.
	(*fs_real_file)(unsafe.Pointer(pReal)).FnRef--
	if !((*fs_real_file)(unsafe.Pointer(pReal)).FnRef >= 0) {
		crt.X__assert_fail(tls, ts+40547 /* "pReal->nRef>=0" */, ts+40562 /* "testdata/sqlite-..." */, uint32(382), uintptr(unsafe.Pointer(&__func__105)))
	}

	// When the ref-count reaches 0, destroy the structure
	if (*fs_real_file)(unsafe.Pointer(pReal)).FnRef == 0 {
		*(*uintptr)(unsafe.Pointer((*fs_real_file)(unsafe.Pointer(pReal)).FppThis)) = (*fs_real_file)(unsafe.Pointer(pReal)).FpNext
		if (*fs_real_file)(unsafe.Pointer(pReal)).FpNext != 0 {
			(*fs_real_file)(unsafe.Pointer((*fs_real_file)(unsafe.Pointer(pReal)).FpNext)).FppThis = (*fs_real_file)(unsafe.Pointer(pReal)).FppThis
		}
		rc = (*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer((*fs_real_file)(unsafe.Pointer(pReal)).FpFile)).FpMethods + 8 /* &.xClose */))))(tls, (*fs_real_file)(unsafe.Pointer(pReal)).FpFile)
		sqlite3.Xsqlite3_free(tls, pReal)
	}

	return rc
}

var __func__105 = *(*[8]int8)(unsafe.Pointer(ts + 40609 /* "fsClose" */)) /* test_onefile.c:375:40 */

// Read data from an fs-file.
func fsRead(tls *crt.TLS, pFile uintptr, zBuf uintptr, iAmt int32, iOfst sqlite_int64) int32 { /* test_onefile.c:400:12: */
	var rc int32 = 0
	var p uintptr = pFile
	var pReal uintptr = (*fs_file)(unsafe.Pointer(p)).FpReal
	var pF uintptr = (*fs_real_file)(unsafe.Pointer(pReal)).FpFile

	if (((*fs_file)(unsafe.Pointer(p)).FeType == 1) && ((sqlite_int64(iAmt) + iOfst) > sqlite_int64((*fs_real_file)(unsafe.Pointer(pReal)).FnDatabase))) ||
		(((*fs_file)(unsafe.Pointer(p)).FeType == 2) && ((sqlite_int64(iAmt) + iOfst) > sqlite_int64((*fs_real_file)(unsafe.Pointer(pReal)).FnJournal))) {
		rc = (10 | (int32(2) << 8))
	} else if (*fs_file)(unsafe.Pointer(p)).FeType == 1 {
		rc = (*(*func(*crt.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pF)).FpMethods + 16 /* &.xRead */))))(tls, pF, zBuf, iAmt, (iOfst + int64(512)))
	} else {
		// Journal file.
		var iRem int32 = iAmt
		var iBuf int32 = 0
		var ii int32 = int32(iOfst)
		for (iRem > 0) && (rc == 0) {
			var iRealOff int32 = (((*fs_real_file)(unsafe.Pointer(pReal)).FnBlob - (512 * ((ii / 512) + 1))) + (ii % 512))
			var iRealAmt int32 = func() int32 {
				if (iRem) < (512 - (iRealOff % 512)) {
					return iRem
				}
				return (512 - (iRealOff % 512))
			}()

			rc = (*(*func(*crt.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pF)).FpMethods + 16 /* &.xRead */))))(tls, pF, ((zBuf) + uintptr(iBuf)), iRealAmt, int64(iRealOff))
			ii = ii + (iRealAmt)
			iBuf = iBuf + (iRealAmt)
			iRem = iRem - (iRealAmt)
		}
	}

	return rc
}

// Write data to an fs-file.
func fsWrite(tls *crt.TLS, pFile uintptr, zBuf uintptr, iAmt int32, iOfst sqlite_int64) int32 { /* test_onefile.c:439:12: */
	var rc int32 = 0
	var p uintptr = pFile
	var pReal uintptr = (*fs_file)(unsafe.Pointer(p)).FpReal
	var pF uintptr = (*fs_real_file)(unsafe.Pointer(pReal)).FpFile

	if (*fs_file)(unsafe.Pointer(p)).FeType == 1 {
		if ((sqlite_int64(iAmt) + iOfst) + int64(512)) > (sqlite_int64((*fs_real_file)(unsafe.Pointer(pReal)).FnBlob - (*fs_real_file)(unsafe.Pointer(pReal)).FnJournal)) {
			rc = 13
		} else {
			rc = (*(*func(*crt.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pF)).FpMethods + 24 /* &.xWrite */))))(tls, pF, zBuf, iAmt, (iOfst + int64(512)))
			if rc == 0 {
				(*fs_real_file)(unsafe.Pointer(pReal)).FnDatabase = func() int32 {
					if (sqlite_int64((*fs_real_file)(unsafe.Pointer(pReal)).FnDatabase)) > (sqlite_int64(iAmt) + iOfst) {
						return (*fs_real_file)(unsafe.Pointer(pReal)).FnDatabase
					}
					return (int32(sqlite_int64(iAmt) + iOfst))
				}()
			}
		}
	} else {
		// Journal file.
		var iRem int32 = iAmt
		var iBuf int32 = 0
		var ii int32 = int32(iOfst)
		for (iRem > 0) && (rc == 0) {
			var iRealOff int32 = (((*fs_real_file)(unsafe.Pointer(pReal)).FnBlob - (512 * ((ii / 512) + 1))) + (ii % 512))
			var iRealAmt int32 = func() int32 {
				if (iRem) < (512 - (iRealOff % 512)) {
					return iRem
				}
				return (512 - (iRealOff % 512))
			}()

			if iRealOff < ((*fs_real_file)(unsafe.Pointer(pReal)).FnDatabase + 512) {
				rc = 13
			} else {
				rc = (*(*func(*crt.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pF)).FpMethods + 24 /* &.xWrite */))))(tls, pF, ((zBuf) + uintptr(iBuf)), iRealAmt, int64(iRealOff))
				ii = ii + (iRealAmt)
				iBuf = iBuf + (iRealAmt)
				iRem = iRem - (iRealAmt)
			}
		}
		if rc == 0 {
			(*fs_real_file)(unsafe.Pointer(pReal)).FnJournal = func() int32 {
				if (sqlite_int64((*fs_real_file)(unsafe.Pointer(pReal)).FnJournal)) > (sqlite_int64(iAmt) + iOfst) {
					return (*fs_real_file)(unsafe.Pointer(pReal)).FnJournal
				}
				return (int32(sqlite_int64(iAmt) + iOfst))
			}()
		}
	}

	return rc
}

// Truncate an fs-file.
func fsTruncate(tls *crt.TLS, pFile uintptr, size sqlite_int64) int32 { /* test_onefile.c:488:12: */
	var p uintptr = pFile
	var pReal uintptr = (*fs_file)(unsafe.Pointer(p)).FpReal
	if (*fs_file)(unsafe.Pointer(p)).FeType == 1 {
		(*fs_real_file)(unsafe.Pointer(pReal)).FnDatabase = func() int32 {
			if (sqlite_int64((*fs_real_file)(unsafe.Pointer(pReal)).FnDatabase)) < (size) {
				return (*fs_real_file)(unsafe.Pointer(pReal)).FnDatabase
			}
			return int32(size)
		}()
	} else {
		(*fs_real_file)(unsafe.Pointer(pReal)).FnJournal = func() int32 {
			if (sqlite_int64((*fs_real_file)(unsafe.Pointer(pReal)).FnJournal)) < (size) {
				return (*fs_real_file)(unsafe.Pointer(pReal)).FnJournal
			}
			return int32(size)
		}()
	}
	return 0
}

// Sync an fs-file.
func fsSync(tls *crt.TLS, pFile uintptr, flags int32) int32 { /* test_onefile.c:502:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var p uintptr = pFile
	var pReal uintptr = (*fs_file)(unsafe.Pointer(p)).FpReal
	var pRealFile uintptr = (*fs_real_file)(unsafe.Pointer(pReal)).FpFile
	var rc int32 = 0

	if (*fs_file)(unsafe.Pointer(p)).FeType == 1 {
		// var zSize [4]uint8 at bp, 4

		*(*uint8)(unsafe.Pointer(bp /* &zSize[0] */ + uintptr(0))) = (uint8((uint32((*fs_real_file)(unsafe.Pointer(pReal)).FnDatabase) & 0xFF000000) >> 24))
		*(*uint8)(unsafe.Pointer(bp /* &zSize[0] */ + uintptr(1))) = (uint8(((*fs_real_file)(unsafe.Pointer(pReal)).FnDatabase & 0x00FF0000) >> 16))
		*(*uint8)(unsafe.Pointer(bp /* &zSize[0] */ + uintptr(2))) = (uint8(((*fs_real_file)(unsafe.Pointer(pReal)).FnDatabase & 0x0000FF00) >> 8))
		*(*uint8)(unsafe.Pointer(bp /* &zSize[0] */ + uintptr(3))) = (uint8((*fs_real_file)(unsafe.Pointer(pReal)).FnDatabase & 0x000000FF))
		rc = (*(*func(*crt.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pRealFile)).FpMethods + 24 /* &.xWrite */))))(tls, pRealFile, bp /* &zSize[0] */, 4, int64(0))
	}
	if rc == 0 {
		rc = (*(*func(*crt.TLS, uintptr, int32) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pRealFile)).FpMethods + 40 /* &.xSync */))))(tls, pRealFile, (flags & (^int32(crt.Int32FromInt32(0x00010)))))
	}

	return rc
}

// Return the current file-size of an fs-file.
func fsFileSize(tls *crt.TLS, pFile uintptr, pSize uintptr) int32 { /* test_onefile.c:526:12: */
	var p uintptr = pFile
	var pReal uintptr = (*fs_file)(unsafe.Pointer(p)).FpReal
	if (*fs_file)(unsafe.Pointer(p)).FeType == 1 {
		*(*sqlite_int64)(unsafe.Pointer(pSize)) = sqlite_int64((*fs_real_file)(unsafe.Pointer(pReal)).FnDatabase)
	} else {
		*(*sqlite_int64)(unsafe.Pointer(pSize)) = sqlite_int64((*fs_real_file)(unsafe.Pointer(pReal)).FnJournal)
	}
	return 0
}

// Lock an fs-file.
func fsLock(tls *crt.TLS, pFile uintptr, eLock int32) int32 { /* test_onefile.c:540:12: */
	return 0
}

// Unlock an fs-file.
func fsUnlock(tls *crt.TLS, pFile uintptr, eLock int32) int32 { /* test_onefile.c:547:12: */
	return 0
}

// Check if another file-handle holds a RESERVED lock on an fs-file.
func fsCheckReservedLock(tls *crt.TLS, pFile uintptr, pResOut uintptr) int32 { /* test_onefile.c:554:12: */
	*(*int32)(unsafe.Pointer(pResOut)) = 0
	return 0
}

// File control method. For custom operations on an fs-file.
func fsFileControl(tls *crt.TLS, pFile uintptr, op int32, pArg uintptr) int32 { /* test_onefile.c:562:12: */
	if op == 14 {
		return 12
	}
	return 0
}

// Return the sector-size in bytes for an fs-file.
func fsSectorSize(tls *crt.TLS, pFile uintptr) int32 { /* test_onefile.c:570:12: */
	return 512
}

// Return the device characteristic flags supported by an fs-file.
func fsDeviceCharacteristics(tls *crt.TLS, pFile uintptr) int32 { /* test_onefile.c:577:12: */
	return 0
}

// Open an fs file handle.
func fsOpen1(tls *crt.TLS, pVfs uintptr, zName uintptr, pFile uintptr, flags int32, pOutFlags uintptr) int32 { /* test_onefile.c:584:12: */
	bp := tls.Alloc(12)
	defer tls.Free(12)

	var pFsVfs uintptr
	var p uintptr
	var pReal uintptr
	var eType int32
	var nName int32
	var rc int32
	var p2 uintptr
	// var zS [4]uint8 at bp+8, 4

	var real_flags int32
	// var size sqlite3_int64 at bp, 8

	var pRealFile uintptr
	var pParent uintptr
	pFsVfs = pVfs
	p = pFile
	pReal = uintptr(0)
	rc = 0

	if !(0 == (flags & (0x00000100 | 0x00000800))) {
		goto __1
	}
	p2 = pFile
	crt.Xmemset(tls, p2, 0, uint64(unsafe.Sizeof(tmp_file{})))
	(*tmp_file)(unsafe.Pointer(p2)).Fbase.FpMethods = uintptr(unsafe.Pointer(&tmp_io_methods))
	return 0
__1:
	;

	eType = func() int32 {
		if (flags & (0x00000100)) != 0 {
			return 1
		}
		return 2
	}()
	(*fs_file)(unsafe.Pointer(p)).Fbase.FpMethods = uintptr(unsafe.Pointer(&fs_io_methods))
	(*fs_file)(unsafe.Pointer(p)).FeType = eType

	if !(crt.Xstrlen(tls, ts+37721 /* "-journal" */) == uint64(8)) {
		crt.X__assert_fail(tls, ts+40617 /* "strlen(\"-journal..." */, ts+40562 /* "testdata/sqlite-..." */, uint32(609), uintptr(unsafe.Pointer(&__func__106)))
	}
	nName = (int32(crt.Xstrlen(tls, zName)) - (func() int32 {
		if eType == 2 {
			return 8
		}
		return 0
	}()))
	pReal = (*fs_vfs_t)(unsafe.Pointer(pFsVfs)).FpFileList
__2:
	if !((pReal != 0) && (crt.Xstrncmp(tls, (*fs_real_file)(unsafe.Pointer(pReal)).FzName, zName, uint64(nName)) != 0)) {
		goto __4
	}
	goto __3
__3:
	pReal = (*fs_real_file)(unsafe.Pointer(pReal)).FpNext
	goto __2
	goto __4
__4:
	;

	if !(!(pReal != 0)) {
		goto __5
	}
	real_flags = ((flags & ^int32(crt.Int32FromInt32(0x00000100))) | 0x00000200)
	pParent = (*fs_vfs_t)(unsafe.Pointer(pFsVfs)).FpParent
	if !(eType == 1) {
		crt.X__assert_fail(tls, ts+40639 /* "eType==1" */, ts+40562 /* "testdata/sqlite-..." */, uint32(619), uintptr(unsafe.Pointer(&__func__106)))
	}

	pReal = sqlite3.Xsqlite3_malloc(tls, (int32(uint64(unsafe.Sizeof(fs_real_file{})) + uint64((*sqlite3_vfs)(unsafe.Pointer(pParent)).FszOsFile))))
	if !(!(pReal != 0)) {
		goto __6
	}
	rc = 7
	goto open_out
__6:
	;
	crt.Xmemset(tls, pReal, 0, (uint64(unsafe.Sizeof(fs_real_file{})) + uint64((*sqlite3_vfs)(unsafe.Pointer(pParent)).FszOsFile)))
	(*fs_real_file)(unsafe.Pointer(pReal)).FzName = zName
	(*fs_real_file)(unsafe.Pointer(pReal)).FpFile = (pReal + uintptr(1)*48)

	rc = (*(*func(*crt.TLS, uintptr, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer((pParent + 40 /* &.xOpen */))))(tls, pParent, zName, (*fs_real_file)(unsafe.Pointer(pReal)).FpFile, real_flags, pOutFlags)
	if !(rc != 0) {
		goto __7
	}
	goto open_out
__7:
	;
	pRealFile = (*fs_real_file)(unsafe.Pointer(pReal)).FpFile

	rc = (*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pRealFile)).FpMethods + 48 /* &.xFileSize */))))(tls, pRealFile, bp /* &size */)
	if !(rc != 0) {
		goto __8
	}
	goto open_out
__8:
	;
	if !(*(*sqlite3_int64)(unsafe.Pointer(bp /* size */)) == int64(0)) {
		goto __9
	}
	rc = (*(*func(*crt.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pRealFile)).FpMethods + 24 /* &.xWrite */))))(tls, pRealFile, ts+40648 /* "\x00" */, 1, (int64(10485760 - 1)))
	(*fs_real_file)(unsafe.Pointer(pReal)).FnBlob = 10485760
	goto __10
__9:
	(*fs_real_file)(unsafe.Pointer(pReal)).FnBlob = int32(*(*sqlite3_int64)(unsafe.Pointer(bp /* size */)))
	rc = (*(*func(*crt.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pRealFile)).FpMethods + 16 /* &.xRead */))))(tls, pRealFile, bp+8 /* &zS[0] */, 4, int64(0))
	(*fs_real_file)(unsafe.Pointer(pReal)).FnDatabase = ((((int32(*(*uint8)(unsafe.Pointer(bp + 8 /* &zS[0] */ + uintptr(0)))) << 24) + (int32(*(*uint8)(unsafe.Pointer(bp + 8 /* &zS[0] */ + uintptr(1)))) << 16)) + (int32(*(*uint8)(unsafe.Pointer(bp + 8 /* &zS[0] */ + uintptr(2)))) << 8)) + int32(*(*uint8)(unsafe.Pointer(bp + 8 /* &zS[0] */ + uintptr(3)))))
	if !(rc == 0) {
		goto __11
	}
	rc = (*(*func(*crt.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pRealFile)).FpMethods + 16 /* &.xRead */))))(tls, pRealFile, bp+8 /* &zS[0] */, 4, (int64((*fs_real_file)(unsafe.Pointer(pReal)).FnBlob - 4)))
	if !((((*(*uint8)(unsafe.Pointer(bp + 8 /* &zS[0] */ + uintptr(0))) != 0) || (*(*uint8)(unsafe.Pointer(bp + 8 /* &zS[0] */ + uintptr(1))) != 0)) || (*(*uint8)(unsafe.Pointer(bp + 8 /* &zS[0] */ + uintptr(2))) != 0)) || (*(*uint8)(unsafe.Pointer(bp + 8 /* &zS[0] */ + uintptr(3))) != 0)) {
		goto __12
	}
	(*fs_real_file)(unsafe.Pointer(pReal)).FnJournal = (*fs_real_file)(unsafe.Pointer(pReal)).FnBlob
__12:
	;
__11:
	;
__10:
	;

	if !(rc == 0) {
		goto __13
	}
	(*fs_real_file)(unsafe.Pointer(pReal)).FpNext = (*fs_vfs_t)(unsafe.Pointer(pFsVfs)).FpFileList
	if !((*fs_real_file)(unsafe.Pointer(pReal)).FpNext != 0) {
		goto __14
	}
	(*fs_real_file)(unsafe.Pointer((*fs_real_file)(unsafe.Pointer(pReal)).FpNext)).FppThis = (pReal + 32 /* &.pNext */)
__14:
	;
	(*fs_real_file)(unsafe.Pointer(pReal)).FppThis = (pFsVfs + 168 /* &.pFileList */)
	(*fs_vfs_t)(unsafe.Pointer(pFsVfs)).FpFileList = pReal
__13:
	;
__5:
	;

open_out:
	if !(pReal != 0) {
		goto __15
	}
	if !(rc == 0) {
		goto __16
	}
	(*fs_file)(unsafe.Pointer(p)).FpReal = pReal
	(*fs_real_file)(unsafe.Pointer(pReal)).FnRef++
	goto __17
__16:
	if !((*sqlite3_file)(unsafe.Pointer((*fs_real_file)(unsafe.Pointer(pReal)).FpFile)).FpMethods != 0) {
		goto __18
	}
	(*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer((*fs_real_file)(unsafe.Pointer(pReal)).FpFile)).FpMethods + 8 /* &.xClose */))))(tls, (*fs_real_file)(unsafe.Pointer(pReal)).FpFile)
__18:
	;
	sqlite3.Xsqlite3_free(tls, pReal)
__17:
	;
__15:
	;
	return rc
}

var __func__106 = *(*[7]int8)(unsafe.Pointer(ts + 40650 /* "fsOpen" */)) /* test_onefile.c:590:2 */

// Delete the file located at zPath. If the dirSync argument is true,
// ensure the file-system modifications are synced to disk before
// returning.
func fsDelete(tls *crt.TLS, pVfs uintptr, zPath uintptr, dirSync int32) int32 { /* test_onefile.c:686:12: */
	var rc int32 = 0
	var pFsVfs uintptr = pVfs
	var pReal uintptr
	var pF uintptr
	var nName int32 = (int32(crt.Xstrlen(tls, zPath)) - 8)

	if !(crt.Xstrlen(tls, ts+37721 /* "-journal" */) == uint64(8)) {
		crt.X__assert_fail(tls, ts+40617 /* "strlen(\"-journal..." */, ts+40562 /* "testdata/sqlite-..." */, uint32(693), uintptr(unsafe.Pointer(&__func__107)))
	}
	if !(crt.Xstrcmp(tls, ts+37721 /* "-journal" */, (zPath+uintptr(nName))) == 0) {
		crt.X__assert_fail(tls, ts+40657 /* "strcmp(\"-journal..." */, ts+40562 /* "testdata/sqlite-..." */, uint32(694), uintptr(unsafe.Pointer(&__func__107)))
	}

	pReal = (*fs_vfs_t)(unsafe.Pointer(pFsVfs)).FpFileList
	for ; (pReal != 0) && (crt.Xstrncmp(tls, (*fs_real_file)(unsafe.Pointer(pReal)).FzName, zPath, uint64(nName)) != 0); pReal = (*fs_real_file)(unsafe.Pointer(pReal)).FpNext {
	}
	if pReal != 0 {
		pF = (*fs_real_file)(unsafe.Pointer(pReal)).FpFile
		rc = (*(*func(*crt.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pF)).FpMethods + 24 /* &.xWrite */))))(tls, pF, ts+40694 /* "\x00\x00\x00\x00" */, 4, (int64((*fs_real_file)(unsafe.Pointer(pReal)).FnBlob - 512)))
		if rc == 0 {
			(*fs_real_file)(unsafe.Pointer(pReal)).FnJournal = 0
		}
	}
	return rc
}

var __func__107 = *(*[9]int8)(unsafe.Pointer(ts + 40699 /* "fsDelete" */)) /* test_onefile.c:686:71 */

// Test for access permissions. Return true if the requested permission
// is available, or false otherwise.
func fsAccess(tls *crt.TLS, pVfs uintptr, zPath uintptr, flags int32, pResOut uintptr) int32 { /* test_onefile.c:712:12: */
	var pFsVfs uintptr = pVfs
	var pReal uintptr
	var isJournal int32 = 0
	var nName int32 = int32(crt.Xstrlen(tls, zPath))

	if flags != 0 {
		var pParent uintptr = (*fs_vfs_t)(unsafe.Pointer(pVfs)).FpParent
		return (*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer((pParent + 56 /* &.xAccess */))))(tls, pParent, zPath, flags, pResOut)
	}

	if !(crt.Xstrlen(tls, ts+37721 /* "-journal" */) == uint64(8)) {
		crt.X__assert_fail(tls, ts+40617 /* "strlen(\"-journal..." */, ts+40562 /* "testdata/sqlite-..." */, uint32(728), uintptr(unsafe.Pointer(&__func__108)))
	}
	if (nName > 8) && (crt.Xstrcmp(tls, ts+37721 /* "-journal" */, (zPath+uintptr((nName-8)))) == 0) {
		nName = nName - (8)
		isJournal = 1
	}

	pReal = (*fs_vfs_t)(unsafe.Pointer(pFsVfs)).FpFileList
	for ; (pReal != 0) && (crt.Xstrncmp(tls, (*fs_real_file)(unsafe.Pointer(pReal)).FzName, zPath, uint64(nName)) != 0); pReal = (*fs_real_file)(unsafe.Pointer(pReal)).FpNext {
	}

	*(*int32)(unsafe.Pointer(pResOut)) = (crt.Bool32((pReal != 0) && (!(isJournal != 0) || ((*fs_real_file)(unsafe.Pointer(pReal)).FnJournal > 0))))
	return 0
}

var __func__108 = *(*[9]int8)(unsafe.Pointer(ts + 40708 /* "fsAccess" */)) /* test_onefile.c:717:2 */

// Populate buffer zOut with the full canonical pathname corresponding
// to the pathname in zPath. zOut is guaranteed to point to a buffer
// of at least (FS_MAX_PATHNAME+1) bytes.
func fsFullPathname(tls *crt.TLS, pVfs uintptr, zPath uintptr, nOut int32, zOut uintptr) int32 { /* test_onefile.c:746:12: */
	var pParent uintptr = (*fs_vfs_t)(unsafe.Pointer(pVfs)).FpParent
	return (*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer((pParent + 64 /* &.xFullPathname */))))(tls, pParent, zPath, nOut, zOut)
}

// Open the dynamic library located at zPath and return a handle.
func fsDlOpen(tls *crt.TLS, pVfs uintptr, zPath uintptr) uintptr { /* test_onefile.c:759:13: */
	var pParent uintptr = (*fs_vfs_t)(unsafe.Pointer(pVfs)).FpParent
	return (*(*func(*crt.TLS, uintptr, uintptr) uintptr)(unsafe.Pointer((pParent + 72 /* &.xDlOpen */))))(tls, pParent, zPath)
}

// Populate the buffer zErrMsg (size nByte bytes) with a human readable
// utf-8 string describing the most recent error encountered associated
// with dynamic libraries.
func fsDlError(tls *crt.TLS, pVfs uintptr, nByte int32, zErrMsg uintptr) { /* test_onefile.c:769:13: */
	var pParent uintptr = (*fs_vfs_t)(unsafe.Pointer(pVfs)).FpParent
	(*(*func(*crt.TLS, uintptr, int32, uintptr))(unsafe.Pointer((pParent + 80 /* &.xDlError */))))(tls, pParent, nByte, zErrMsg)
}

// Return a pointer to the symbol zSymbol in the dynamic library pHandle.
func fsDlSym(tls *crt.TLS, pVfs uintptr, pH uintptr, zSym uintptr) uintptr { /* test_onefile.c:777:13: */
	var pParent uintptr = (*fs_vfs_t)(unsafe.Pointer(pVfs)).FpParent
	return (*(*func(*crt.TLS, uintptr, uintptr, uintptr) uintptr)(unsafe.Pointer((pParent + 88 /* &.xDlSym */))))(tls, pParent, pH, zSym)
}

// Close the dynamic library handle pHandle.
func fsDlClose(tls *crt.TLS, pVfs uintptr, pHandle uintptr) { /* test_onefile.c:785:13: */
	var pParent uintptr = (*fs_vfs_t)(unsafe.Pointer(pVfs)).FpParent
	(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((pParent + 96 /* &.xDlClose */))))(tls, pParent, pHandle)
}

// Populate the buffer pointed to by zBufOut with nByte bytes of
// random data.
func fsRandomness(tls *crt.TLS, pVfs uintptr, nByte int32, zBufOut uintptr) int32 { /* test_onefile.c:794:12: */
	var pParent uintptr = (*fs_vfs_t)(unsafe.Pointer(pVfs)).FpParent
	return (*(*func(*crt.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer((pParent + 104 /* &.xRandomness */))))(tls, pParent, nByte, zBufOut)
}

// Sleep for nMicro microseconds. Return the number of microseconds
// actually slept.
func fsSleep(tls *crt.TLS, pVfs uintptr, nMicro int32) int32 { /* test_onefile.c:803:12: */
	var pParent uintptr = (*fs_vfs_t)(unsafe.Pointer(pVfs)).FpParent
	return (*(*func(*crt.TLS, uintptr, int32) int32)(unsafe.Pointer((pParent + 112 /* &.xSleep */))))(tls, pParent, nMicro)
}

// Return the current time as a Julian Day number in *pTimeOut.
func fsCurrentTime(tls *crt.TLS, pVfs uintptr, pTimeOut uintptr) int32 { /* test_onefile.c:811:12: */
	var pParent uintptr = (*fs_vfs_t)(unsafe.Pointer(pVfs)).FpParent
	return (*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer((pParent + 120 /* &.xCurrentTime */))))(tls, pParent, pTimeOut)
}

// This procedure registers the fs vfs with SQLite. If the argument is
// true, the fs vfs becomes the new default vfs. It is the only publicly
// available function in this file.
func fs_register(tls *crt.TLS) int32 { /* test_onefile.c:821:5: */
	if fs_vfs.FpParent != 0 {
		return 0
	}
	fs_vfs.FpParent = sqlite3.Xsqlite3_vfs_find(tls, uintptr(0))
	fs_vfs.Fbase.FmxPathname = (*sqlite3_vfs)(unsafe.Pointer(fs_vfs.FpParent)).FmxPathname
	fs_vfs.Fbase.FszOsFile = func() int32 {
		if (uint64(unsafe.Sizeof(tmp_file{}))) > (uint64(unsafe.Sizeof(fs_file{}))) {
			return int32(unsafe.Sizeof(tmp_file{}))
		}
		return int32(unsafe.Sizeof(fs_file{}))
	}()
	return sqlite3.Xsqlite3_vfs_register(tls, (uintptr(unsafe.Pointer(&fs_vfs)) /* &.base */), 0)
}

func SqlitetestOnefile_Init(tls *crt.TLS) int32 { /* test_onefile.c:830:7: */
	return fs_register(tls)
}

// When possible, define assert so that it does not add extra
//   parentheses around EXPR.  Otherwise, those added parentheses would
//   suppress warnings we'd expect to be detected by gcc's -Wparentheses.

// Version 2.4 and later of GCC define a magical variable `__PRETTY_FUNCTION__'
//   which contains the name of the function currently being defined.
//   This is broken in G++ before version 2.6.
//   C9x has a similar variable called __func__, but prefer the GCC one since
//   it demangles C++ function names.

// Maximum pathname length supported by the vfslog backend.

type VfslogVfs1 = struct {
	Fbase        sqlite3_vfs
	FpVfs        uintptr
	FiNextFileId int32
	FpLog        uintptr
	FiOffset     sqlite3_int64
	FnBuf        int32
	FaBuf        [8192]int8
	_            [4]byte
}

// When possible, define assert so that it does not add extra
//   parentheses around EXPR.  Otherwise, those added parentheses would
//   suppress warnings we'd expect to be detected by gcc's -Wparentheses.

// Version 2.4 and later of GCC define a magical variable `__PRETTY_FUNCTION__'
//   which contains the name of the function currently being defined.
//   This is broken in G++ before version 2.6.
//   C9x has a similar variable called __func__, but prefer the GCC one since
//   it demangles C++ function names.

// Maximum pathname length supported by the vfslog backend.

type VfslogVfs = VfslogVfs1 /* test_osinst.c:117:26 */
type VfslogFile1 = struct {
	Fbase    sqlite3_file
	FpReal   uintptr
	FpVfslog uintptr
	FiFileId int32
	_        [4]byte
}

type VfslogFile = VfslogFile1 /* test_osinst.c:118:27 */

var vfslog_vfs = sqlite3_vfs{FiVersion: 1, FszOsFile: // iVersion
int32(unsafe.Sizeof(VfslogFile{})), FmxPathname:// szOsFile
512, FpNext:// mxPathname
uintptr(0), FzName:// pNext
uintptr(0), FpAppData:// zName
uintptr(0), FxOpen:// pAppData
0, FxDelete:// xOpen
0, FxAccess:// xDelete
0, FxFullPathname:// xAccess
0, FxDlOpen:// xFullPathname
0, FxDlError:// xDlOpen
0, FxDlSym:// xDlError
0, FxDlClose:// xDlSym
0, FxRandomness:// xDlClose
0, FxSleep:// xRandomness
0, FxCurrentTime:// xSleep
0, FxGetLastError:// xCurrentTime
0, FxCurrentTimeInt64:// xGetLastError
0, // xCurrentTime
} /* test_osinst.c:180:20 */

var vfslog_io_methods = sqlite3_io_methods{FiVersion: 2, FxClose: // iVersion
0, FxRead:// xClose
0, FxWrite:// xRead
0, FxTruncate:// xWrite
0, FxSync:// xTruncate
0, FxFileSize:// xSync
0, FxLock:// xFileSize
0, FxUnlock:// xLock
0, FxCheckReservedLock:// xUnlock
0, FxFileControl:// xCheckReservedLock
0, FxSectorSize:// xFileControl
0, FxDeviceCharacteristics:// xSectorSize
0, FxShmMap:// xDeviceCharacteristics
0, FxShmLock:// xShmMap
0, FxShmBarrier:// xShmLock
0, FxShmUnmap:// xShmBarrier
0, // xShmUnmap
} /* test_osinst.c:202:27 */

// Convenience macros for operations on timevals.
//   NOTE: `timercmp' does not work for >= or <=.

func vfslog_time(tls *crt.TLS) sqlite3_uint64 { /* test_osinst.c:224:23: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	// var sTime timeval at bp, 16

	crt.Xgettimeofday(tls, bp /* &sTime */, uintptr(0))
	return (sqlite3_uint64((*timeval)(unsafe.Pointer(bp /* &sTime */)).Ftv_usec) + (sqlite3_uint64((*timeval)(unsafe.Pointer(bp /* &sTime */)).Ftv_sec) * uint64(1000000)))
}

// Close an vfslog-file.
func vfslogClose(tls *crt.TLS, pFile uintptr) int32 { /* test_osinst.c:256:12: */
	var t sqlite3_uint64
	var rc int32 = 0
	var p uintptr = pFile

	t = vfslog_time(tls)
	if (*sqlite3_file)(unsafe.Pointer((*VfslogFile)(unsafe.Pointer(p)).FpReal)).FpMethods != 0 {
		rc = (*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer((*VfslogFile)(unsafe.Pointer(p)).FpReal)).FpMethods + 8 /* &.xClose */))))(tls, (*VfslogFile)(unsafe.Pointer(p)).FpReal)
	}
	t = (vfslog_time(tls) - t)
	vfslog_call(tls, (*VfslogFile)(unsafe.Pointer(p)).FpVfslog, 3, (*VfslogFile)(unsafe.Pointer(p)).FiFileId, int64(t), rc, 0, 0)
	return rc
}

// Read data from an vfslog-file.
func vfslogRead(tls *crt.TLS, pFile uintptr, zBuf uintptr, iAmt int32, iOfst sqlite_int64) int32 { /* test_osinst.c:273:12: */
	var rc int32
	var t sqlite3_uint64
	var p uintptr = pFile
	t = vfslog_time(tls)
	rc = (*(*func(*crt.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer((*VfslogFile)(unsafe.Pointer(p)).FpReal)).FpMethods + 16 /* &.xRead */))))(tls, (*VfslogFile)(unsafe.Pointer(p)).FpReal, zBuf, iAmt, iOfst)
	t = (vfslog_time(tls) - t)
	vfslog_call(tls, (*VfslogFile)(unsafe.Pointer(p)).FpVfslog, 14, (*VfslogFile)(unsafe.Pointer(p)).FiFileId, int64(t), rc, iAmt, int32(iOfst))
	return rc
}

// Write data to an vfslog-file.
func vfslogWrite(tls *crt.TLS, pFile uintptr, z uintptr, iAmt int32, iOfst sqlite_int64) int32 { /* test_osinst.c:292:12: */
	var rc int32
	var t sqlite3_uint64
	var p uintptr = pFile
	t = vfslog_time(tls)
	rc = (*(*func(*crt.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer((*VfslogFile)(unsafe.Pointer(p)).FpReal)).FpMethods + 24 /* &.xWrite */))))(tls, (*VfslogFile)(unsafe.Pointer(p)).FpReal, z, iAmt, iOfst)
	t = (vfslog_time(tls) - t)
	vfslog_call(tls, (*VfslogFile)(unsafe.Pointer(p)).FpVfslog, 20, (*VfslogFile)(unsafe.Pointer(p)).FiFileId, int64(t), rc, iAmt, int32(iOfst))
	return rc
}

// Truncate an vfslog-file.
func vfslogTruncate(tls *crt.TLS, pFile uintptr, size sqlite_int64) int32 { /* test_osinst.c:311:12: */
	var rc int32
	var t sqlite3_uint64
	var p uintptr = pFile
	t = vfslog_time(tls)
	rc = (*(*func(*crt.TLS, uintptr, sqlite3_int64) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer((*VfslogFile)(unsafe.Pointer(p)).FpReal)).FpMethods + 32 /* &.xTruncate */))))(tls, (*VfslogFile)(unsafe.Pointer(p)).FpReal, size)
	t = (vfslog_time(tls) - t)
	vfslog_call(tls, (*VfslogFile)(unsafe.Pointer(p)).FpVfslog, 18, (*VfslogFile)(unsafe.Pointer(p)).FiFileId, int64(t), rc, 0, int32(size))
	return rc
}

// Sync an vfslog-file.
func vfslogSync(tls *crt.TLS, pFile uintptr, flags int32) int32 { /* test_osinst.c:325:12: */
	var rc int32
	var t sqlite3_uint64
	var p uintptr = pFile
	t = vfslog_time(tls)
	rc = (*(*func(*crt.TLS, uintptr, int32) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer((*VfslogFile)(unsafe.Pointer(p)).FpReal)).FpMethods + 40 /* &.xSync */))))(tls, (*VfslogFile)(unsafe.Pointer(p)).FpReal, flags)
	t = (vfslog_time(tls) - t)
	vfslog_call(tls, (*VfslogFile)(unsafe.Pointer(p)).FpVfslog, 17, (*VfslogFile)(unsafe.Pointer(p)).FiFileId, int64(t), rc, flags, 0)
	return rc
}

// Return the current file-size of an vfslog-file.
func vfslogFileSize(tls *crt.TLS, pFile uintptr, pSize uintptr) int32 { /* test_osinst.c:339:12: */
	var rc int32
	var t sqlite3_uint64
	var p uintptr = pFile
	t = vfslog_time(tls)
	rc = (*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer((*VfslogFile)(unsafe.Pointer(p)).FpReal)).FpMethods + 48 /* &.xFileSize */))))(tls, (*VfslogFile)(unsafe.Pointer(p)).FpReal, pSize)
	t = (vfslog_time(tls) - t)
	vfslog_call(tls, (*VfslogFile)(unsafe.Pointer(p)).FpVfslog, 8, (*VfslogFile)(unsafe.Pointer(p)).FiFileId, int64(t), rc, 0, int32(*(*sqlite_int64)(unsafe.Pointer(pSize))))
	return rc
}

// Lock an vfslog-file.
func vfslogLock(tls *crt.TLS, pFile uintptr, eLock int32) int32 { /* test_osinst.c:353:12: */
	var rc int32
	var t sqlite3_uint64
	var p uintptr = pFile
	t = vfslog_time(tls)
	rc = (*(*func(*crt.TLS, uintptr, int32) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer((*VfslogFile)(unsafe.Pointer(p)).FpReal)).FpMethods + 56 /* &.xLock */))))(tls, (*VfslogFile)(unsafe.Pointer(p)).FpReal, eLock)
	t = (vfslog_time(tls) - t)
	vfslog_call(tls, (*VfslogFile)(unsafe.Pointer(p)).FpVfslog, 11, (*VfslogFile)(unsafe.Pointer(p)).FiFileId, int64(t), rc, eLock, 0)
	return rc
}

// Unlock an vfslog-file.
func vfslogUnlock(tls *crt.TLS, pFile uintptr, eLock int32) int32 { /* test_osinst.c:367:12: */
	var rc int32
	var t sqlite3_uint64
	var p uintptr = pFile
	t = vfslog_time(tls)
	rc = (*(*func(*crt.TLS, uintptr, int32) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer((*VfslogFile)(unsafe.Pointer(p)).FpReal)).FpMethods + 64 /* &.xUnlock */))))(tls, (*VfslogFile)(unsafe.Pointer(p)).FpReal, eLock)
	t = (vfslog_time(tls) - t)
	vfslog_call(tls, (*VfslogFile)(unsafe.Pointer(p)).FpVfslog, 19, (*VfslogFile)(unsafe.Pointer(p)).FiFileId, int64(t), rc, eLock, 0)
	return rc
}

// Check if another file-handle holds a RESERVED lock on an vfslog-file.
func vfslogCheckReservedLock(tls *crt.TLS, pFile uintptr, pResOut uintptr) int32 { /* test_osinst.c:381:12: */
	var rc int32
	var t sqlite3_uint64
	var p uintptr = pFile
	t = vfslog_time(tls)
	rc = (*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer((*VfslogFile)(unsafe.Pointer(p)).FpReal)).FpMethods + 72 /* &.xCheckReservedLock */))))(tls, (*VfslogFile)(unsafe.Pointer(p)).FpReal, pResOut)
	t = (vfslog_time(tls) - t)
	vfslog_call(tls, (*VfslogFile)(unsafe.Pointer(p)).FpVfslog, 2, (*VfslogFile)(unsafe.Pointer(p)).FiFileId, int64(t), rc, *(*int32)(unsafe.Pointer(pResOut)), 0)
	return rc
}

// File control method. For custom operations on an vfslog-file.
func vfslogFileControl(tls *crt.TLS, pFile uintptr, op int32, pArg uintptr) int32 { /* test_osinst.c:395:12: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var p uintptr = pFile
	var rc int32 = (*(*func(*crt.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer((*VfslogFile)(unsafe.Pointer(p)).FpReal)).FpMethods + 80 /* &.xFileControl */))))(tls, (*VfslogFile)(unsafe.Pointer(p)).FpReal, op, pArg)
	if (op == 12) && (rc == 0) {
		*(*uintptr)(unsafe.Pointer(pArg)) = sqlite3.Xsqlite3_mprintf(tls, ts+40717 /* "vfslog/%z" */, crt.VaList(bp, *(*uintptr)(unsafe.Pointer(pArg))))
	}
	return rc
}

// Return the sector-size in bytes for an vfslog-file.
func vfslogSectorSize(tls *crt.TLS, pFile uintptr) int32 { /* test_osinst.c:407:12: */
	var rc int32
	var t sqlite3_uint64
	var p uintptr = pFile
	t = vfslog_time(tls)
	rc = (*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer((*VfslogFile)(unsafe.Pointer(p)).FpReal)).FpMethods + 88 /* &.xSectorSize */))))(tls, (*VfslogFile)(unsafe.Pointer(p)).FpReal)
	t = (vfslog_time(tls) - t)
	vfslog_call(tls, (*VfslogFile)(unsafe.Pointer(p)).FpVfslog, 15, (*VfslogFile)(unsafe.Pointer(p)).FiFileId, int64(t), rc, 0, 0)
	return rc
}

// Return the device characteristic flags supported by an vfslog-file.
func vfslogDeviceCharacteristics(tls *crt.TLS, pFile uintptr) int32 { /* test_osinst.c:421:12: */
	var rc int32
	var t sqlite3_uint64
	var p uintptr = pFile
	t = vfslog_time(tls)
	rc = (*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer((*VfslogFile)(unsafe.Pointer(p)).FpReal)).FpMethods + 96 /* &.xDeviceCharacteristics */))))(tls, (*VfslogFile)(unsafe.Pointer(p)).FpReal)
	t = (vfslog_time(tls) - t)
	vfslog_call(tls, (*VfslogFile)(unsafe.Pointer(p)).FpVfslog, 6, (*VfslogFile)(unsafe.Pointer(p)).FiFileId, int64(t), rc, 0, 0)
	return rc
}

func vfslogShmLock(tls *crt.TLS, pFile uintptr, ofst int32, n int32, flags int32) int32 { /* test_osinst.c:432:12: */
	var rc int32
	var t sqlite3_uint64
	var p uintptr = pFile
	t = vfslog_time(tls)
	rc = (*(*func(*crt.TLS, uintptr, int32, int32, int32) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer((*VfslogFile)(unsafe.Pointer(p)).FpReal)).FpMethods + 112 /* &.xShmLock */))))(tls, (*VfslogFile)(unsafe.Pointer(p)).FpReal, ofst, n, flags)
	t = (vfslog_time(tls) - t)
	vfslog_call(tls, (*VfslogFile)(unsafe.Pointer(p)).FpVfslog, 25, (*VfslogFile)(unsafe.Pointer(p)).FiFileId, int64(t), rc, 0, 0)
	return rc
}
func vfslogShmMap(tls *crt.TLS, pFile uintptr, iRegion int32, szRegion int32, isWrite int32, pp uintptr) int32 { /* test_osinst.c:442:12: */
	var rc int32
	var t sqlite3_uint64
	var p uintptr = pFile
	t = vfslog_time(tls)
	rc = (*(*func(*crt.TLS, uintptr, int32, int32, int32, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer((*VfslogFile)(unsafe.Pointer(p)).FpReal)).FpMethods + 104 /* &.xShmMap */))))(tls, (*VfslogFile)(unsafe.Pointer(p)).FpReal, iRegion, szRegion, isWrite, pp)
	t = (vfslog_time(tls) - t)
	vfslog_call(tls, (*VfslogFile)(unsafe.Pointer(p)).FpVfslog, 23, (*VfslogFile)(unsafe.Pointer(p)).FiFileId, int64(t), rc, 0, 0)
	return rc
}
func vfslogShmBarrier(tls *crt.TLS, pFile uintptr) { /* test_osinst.c:458:13: */
	var t sqlite3_uint64
	var p uintptr = pFile
	t = vfslog_time(tls)
	(*(*func(*crt.TLS, uintptr))(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer((*VfslogFile)(unsafe.Pointer(p)).FpReal)).FpMethods + 120 /* &.xShmBarrier */))))(tls, (*VfslogFile)(unsafe.Pointer(p)).FpReal)
	t = (vfslog_time(tls) - t)
	vfslog_call(tls, (*VfslogFile)(unsafe.Pointer(p)).FpVfslog, 26, (*VfslogFile)(unsafe.Pointer(p)).FiFileId, int64(t), 0, 0, 0)
}
func vfslogShmUnmap(tls *crt.TLS, pFile uintptr, deleteFlag int32) int32 { /* test_osinst.c:466:12: */
	var rc int32
	var t sqlite3_uint64
	var p uintptr = pFile
	t = vfslog_time(tls)
	rc = (*(*func(*crt.TLS, uintptr, int32) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer((*VfslogFile)(unsafe.Pointer(p)).FpReal)).FpMethods + 128 /* &.xShmUnmap */))))(tls, (*VfslogFile)(unsafe.Pointer(p)).FpReal, deleteFlag)
	t = (vfslog_time(tls) - t)
	vfslog_call(tls, (*VfslogFile)(unsafe.Pointer(p)).FpVfslog, 22, (*VfslogFile)(unsafe.Pointer(p)).FiFileId, int64(t), rc, 0, 0)
	return rc
}

// Open an vfslog file handle.
func vfslogOpen(tls *crt.TLS, pVfs uintptr, zName uintptr, pFile uintptr, flags int32, pOutFlags uintptr) int32 { /* test_osinst.c:481:12: */
	var rc int32
	var t sqlite3_uint64
	var p uintptr = pFile
	var pLog uintptr = pVfs

	(*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods = uintptr(unsafe.Pointer(&vfslog_io_methods))
	(*VfslogFile)(unsafe.Pointer(p)).FpReal = (p + uintptr(1)*32)
	(*VfslogFile)(unsafe.Pointer(p)).FpVfslog = pVfs
	(*VfslogFile)(unsafe.Pointer(p)).FiFileId = crt.PreIncInt32(&(*VfslogVfs)(unsafe.Pointer(pLog)).FiNextFileId, 1)

	t = vfslog_time(tls)
	rc = (*(*func(*crt.TLS, uintptr, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(((*VfslogVfs)(unsafe.Pointer(pVfs)).FpVfs + 40 /* &.xOpen */))))(tls, (*VfslogVfs)(unsafe.Pointer(pVfs)).FpVfs, zName, (*VfslogFile)(unsafe.Pointer(p)).FpReal, flags, pOutFlags)
	t = (vfslog_time(tls) - t)

	vfslog_call(tls, pVfs, 12, (*VfslogFile)(unsafe.Pointer(p)).FiFileId, int64(t), rc, 0, 0)
	vfslog_string(tls, pVfs, zName)
	return rc
}

// Delete the file located at zPath. If the dirSync argument is true,
// ensure the file-system modifications are synced to disk before
// returning.
func vfslogDelete(tls *crt.TLS, pVfs uintptr, zPath uintptr, dirSync int32) int32 { /* test_osinst.c:512:12: */
	var rc int32
	var t sqlite3_uint64
	t = vfslog_time(tls)
	rc = (*(*func(*crt.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(((*VfslogVfs)(unsafe.Pointer(pVfs)).FpVfs + 48 /* &.xDelete */))))(tls, (*VfslogVfs)(unsafe.Pointer(pVfs)).FpVfs, zPath, dirSync)
	t = (vfslog_time(tls) - t)
	vfslog_call(tls, pVfs, 5, 0, int64(t), rc, dirSync, 0)
	vfslog_string(tls, pVfs, zPath)
	return rc
}

// Test for access permissions. Return true if the requested permission
// is available, or false otherwise.
func vfslogAccess(tls *crt.TLS, pVfs uintptr, zPath uintptr, flags int32, pResOut uintptr) int32 { /* test_osinst.c:527:12: */
	var rc int32
	var t sqlite3_uint64
	t = vfslog_time(tls)
	rc = (*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(((*VfslogVfs)(unsafe.Pointer(pVfs)).FpVfs + 56 /* &.xAccess */))))(tls, (*VfslogVfs)(unsafe.Pointer(pVfs)).FpVfs, zPath, flags, pResOut)
	t = (vfslog_time(tls) - t)
	vfslog_call(tls, pVfs, 1, 0, int64(t), rc, flags, *(*int32)(unsafe.Pointer(pResOut)))
	vfslog_string(tls, pVfs, zPath)
	return rc
}

// Populate buffer zOut with the full canonical pathname corresponding
// to the pathname in zPath. zOut is guaranteed to point to a buffer
// of at least (INST_MAX_PATHNAME+1) bytes.
func vfslogFullPathname(tls *crt.TLS, pVfs uintptr, zPath uintptr, nOut int32, zOut uintptr) int32 { /* test_osinst.c:548:12: */
	return (*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(((*VfslogVfs)(unsafe.Pointer(pVfs)).FpVfs + 64 /* &.xFullPathname */))))(tls, (*VfslogVfs)(unsafe.Pointer(pVfs)).FpVfs, zPath, nOut, zOut)
}

// Open the dynamic library located at zPath and return a handle.
func vfslogDlOpen(tls *crt.TLS, pVfs uintptr, zPath uintptr) uintptr { /* test_osinst.c:560:13: */
	return (*(*func(*crt.TLS, uintptr, uintptr) uintptr)(unsafe.Pointer(((*VfslogVfs)(unsafe.Pointer(pVfs)).FpVfs + 72 /* &.xDlOpen */))))(tls, (*VfslogVfs)(unsafe.Pointer(pVfs)).FpVfs, zPath)
}

// Populate the buffer zErrMsg (size nByte bytes) with a human readable
// utf-8 string describing the most recent error encountered associated
// with dynamic libraries.
func vfslogDlError(tls *crt.TLS, pVfs uintptr, nByte int32, zErrMsg uintptr) { /* test_osinst.c:569:13: */
	(*(*func(*crt.TLS, uintptr, int32, uintptr))(unsafe.Pointer(((*VfslogVfs)(unsafe.Pointer(pVfs)).FpVfs + 80 /* &.xDlError */))))(tls, (*VfslogVfs)(unsafe.Pointer(pVfs)).FpVfs, nByte, zErrMsg)
}

// Return a pointer to the symbol zSymbol in the dynamic library pHandle.
func vfslogDlSym(tls *crt.TLS, pVfs uintptr, p uintptr, zSym uintptr) uintptr { /* test_osinst.c:576:13: */
	return (*(*func(*crt.TLS, uintptr, uintptr, uintptr) uintptr)(unsafe.Pointer(((*VfslogVfs)(unsafe.Pointer(pVfs)).FpVfs + 88 /* &.xDlSym */))))(tls, (*VfslogVfs)(unsafe.Pointer(pVfs)).FpVfs, p, zSym)
}

// Close the dynamic library handle pHandle.
func vfslogDlClose(tls *crt.TLS, pVfs uintptr, pHandle uintptr) { /* test_osinst.c:583:13: */
	(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer(((*VfslogVfs)(unsafe.Pointer(pVfs)).FpVfs + 96 /* &.xDlClose */))))(tls, (*VfslogVfs)(unsafe.Pointer(pVfs)).FpVfs, pHandle)
}

// Populate the buffer pointed to by zBufOut with nByte bytes of
// random data.
func vfslogRandomness(tls *crt.TLS, pVfs uintptr, nByte int32, zBufOut uintptr) int32 { /* test_osinst.c:591:12: */
	return (*(*func(*crt.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(((*VfslogVfs)(unsafe.Pointer(pVfs)).FpVfs + 104 /* &.xRandomness */))))(tls, (*VfslogVfs)(unsafe.Pointer(pVfs)).FpVfs, nByte, zBufOut)
}

// Sleep for nMicro microseconds. Return the number of microseconds
// actually slept.
func vfslogSleep(tls *crt.TLS, pVfs uintptr, nMicro int32) int32 { /* test_osinst.c:599:12: */
	return (*(*func(*crt.TLS, uintptr, int32) int32)(unsafe.Pointer(((*VfslogVfs)(unsafe.Pointer(pVfs)).FpVfs + 112 /* &.xSleep */))))(tls, (*VfslogVfs)(unsafe.Pointer(pVfs)).FpVfs, nMicro)
}

// Return the current time as a Julian Day number in *pTimeOut.
func vfslogCurrentTime(tls *crt.TLS, pVfs uintptr, pTimeOut uintptr) int32 { /* test_osinst.c:606:12: */
	return (*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(((*VfslogVfs)(unsafe.Pointer(pVfs)).FpVfs + 120 /* &.xCurrentTime */))))(tls, (*VfslogVfs)(unsafe.Pointer(pVfs)).FpVfs, pTimeOut)
}

func vfslogGetLastError(tls *crt.TLS, pVfs uintptr, a int32, b uintptr) int32 { /* test_osinst.c:610:12: */
	return (*(*func(*crt.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(((*VfslogVfs)(unsafe.Pointer(pVfs)).FpVfs + 128 /* &.xGetLastError */))))(tls, (*VfslogVfs)(unsafe.Pointer(pVfs)).FpVfs, a, b)
}
func vfslogCurrentTimeInt64(tls *crt.TLS, pVfs uintptr, p uintptr) int32 { /* test_osinst.c:613:12: */
	return (*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(((*VfslogVfs)(unsafe.Pointer(pVfs)).FpVfs + 136 /* &.xCurrentTimeInt64 */))))(tls, (*VfslogVfs)(unsafe.Pointer(pVfs)).FpVfs, p)
}

func vfslog_flush(tls *crt.TLS, p uintptr) { /* test_osinst.c:617:13: */

	var pending int32 = sqlite3.Xsqlite3_io_error_pending
	var persist int32 = sqlite3.Xsqlite3_io_error_persist
	var diskfull int32 = sqlite3.Xsqlite3_diskfull_pending

	sqlite3.Xsqlite3_io_error_pending = 0
	sqlite3.Xsqlite3_io_error_persist = 0
	sqlite3.Xsqlite3_diskfull_pending = 0

	if (*VfslogVfs)(unsafe.Pointer(p)).FnBuf != 0 {
		(*(*func(*crt.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer((*VfslogVfs)(unsafe.Pointer(p)).FpLog)).FpMethods + 24 /* &.xWrite */))))(tls, (*VfslogVfs)(unsafe.Pointer(p)).FpLog, p+204 /* &.aBuf */, (*VfslogVfs)(unsafe.Pointer(p)).FnBuf, (*VfslogVfs)(unsafe.Pointer(p)).FiOffset)
		*(*sqlite3_int64)(unsafe.Pointer(p + 192 /* &.iOffset */)) += (sqlite3_int64((*VfslogVfs)(unsafe.Pointer(p)).FnBuf))
		(*VfslogVfs)(unsafe.Pointer(p)).FnBuf = 0
	}

	sqlite3.Xsqlite3_io_error_pending = pending
	sqlite3.Xsqlite3_io_error_persist = persist
	sqlite3.Xsqlite3_diskfull_pending = diskfull
}

func put32bits(tls *crt.TLS, p uintptr, v uint32) { /* test_osinst.c:645:13: */
	*(*uint8)(unsafe.Pointer(p + uintptr(0))) = (uint8(v >> 24))
	*(*uint8)(unsafe.Pointer(p + uintptr(1))) = (uint8(v >> 16))
	*(*uint8)(unsafe.Pointer(p + uintptr(2))) = (uint8(v >> 8))
	*(*uint8)(unsafe.Pointer(p + uintptr(3))) = uint8(v)
}

func vfslog_call(tls *crt.TLS, pVfs uintptr, eEvent int32, iFileid int32, nClick sqlite3_int64, return_code int32, size int32, offset int32) { /* test_osinst.c:652:13: */
	var p uintptr = pVfs
	var zRec uintptr
	if (uint64(24 + (*VfslogVfs)(unsafe.Pointer(p)).FnBuf)) > uint64(unsafe.Sizeof([8192]int8{})) {
		vfslog_flush(tls, p)
	}
	zRec = ((p + 204 /* &.aBuf */) + uintptr((*VfslogVfs)(unsafe.Pointer(p)).FnBuf))
	put32bits(tls, (zRec + uintptr(0)), uint32(eEvent))
	put32bits(tls, (zRec + uintptr(4)), uint32(iFileid))
	put32bits(tls, (zRec + uintptr(8)), (uint32(nClick & int64(0xffff))))
	put32bits(tls, (zRec + uintptr(12)), uint32(return_code))
	put32bits(tls, (zRec + uintptr(16)), uint32(size))
	put32bits(tls, (zRec + uintptr(20)), uint32(offset))
	*(*int32)(unsafe.Pointer(p + 200 /* &.nBuf */)) += (24)
}

func vfslog_string(tls *crt.TLS, pVfs uintptr, zStr uintptr) { /* test_osinst.c:676:13: */
	var p uintptr = pVfs
	var zRec uintptr
	var nStr int32
	if zStr != 0 {
		nStr = int32(crt.Xstrlen(tls, zStr))
	} else {
		nStr = 0
	}
	if (uint64((4 + nStr) + (*VfslogVfs)(unsafe.Pointer(p)).FnBuf)) > uint64(unsafe.Sizeof([8192]int8{})) {
		vfslog_flush(tls, p)
	}
	zRec = ((p + 204 /* &.aBuf */) + uintptr((*VfslogVfs)(unsafe.Pointer(p)).FnBuf))
	put32bits(tls, (zRec + uintptr(0)), uint32(nStr))
	if zStr != 0 {
		crt.Xmemcpy(tls, (zRec + uintptr(4)), zStr, uint64(nStr))
	}
	*(*int32)(unsafe.Pointer(p + 200 /* &.nBuf */)) += (4 + nStr)
}

func vfslog_finalize(tls *crt.TLS, p uintptr) { /* test_osinst.c:691:13: */
	if (*sqlite3_file)(unsafe.Pointer((*VfslogVfs)(unsafe.Pointer(p)).FpLog)).FpMethods != 0 {
		vfslog_flush(tls, p)
		(*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer((*VfslogVfs)(unsafe.Pointer(p)).FpLog)).FpMethods + 8 /* &.xClose */))))(tls, (*VfslogVfs)(unsafe.Pointer(p)).FpLog)
	}
	sqlite3.Xsqlite3_free(tls, p)
}

func sqlite3_vfslog_finalize(tls *crt.TLS, zVfs uintptr) int32 { /* test_osinst.c:699:5: */
	var pVfs uintptr
	pVfs = sqlite3.Xsqlite3_vfs_find(tls, zVfs)
	if !(pVfs != 0) || ((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FxOpen != *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, uintptr, int32, uintptr) int32
	}{vfslogOpen}))) {
		return 1
	}
	sqlite3.Xsqlite3_vfs_unregister(tls, pVfs)
	vfslog_finalize(tls, pVfs)
	return 0
}

func sqlite3_vfslog_new(tls *crt.TLS, zVfs uintptr, zParentVfs uintptr, zLog uintptr) int32 { /* test_osinst.c:710:5: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var p uintptr
	var pParent uintptr
	var nByte int32
	// var flags int32 at bp, 4

	var rc int32
	var zFile uintptr
	var nVfs int32

	pParent = sqlite3.Xsqlite3_vfs_find(tls, zParentVfs)
	if !(pParent != 0) {
		return 1
	}

	nVfs = int32(crt.Xstrlen(tls, zVfs))
	nByte = (int32(((((uint64(unsafe.Sizeof(VfslogVfs{})) + uint64((*sqlite3_vfs)(unsafe.Pointer(pParent)).FszOsFile)) + uint64(nVfs)) + uint64(1)) + uint64((*sqlite3_vfs)(unsafe.Pointer(pParent)).FmxPathname)) + uint64(1)))
	p = sqlite3.Xsqlite3_malloc(tls, nByte)
	crt.Xmemset(tls, p, 0, uint64(nByte))

	(*VfslogVfs)(unsafe.Pointer(p)).FpVfs = pParent
	(*VfslogVfs)(unsafe.Pointer(p)).FpLog = (p + uintptr(1)*8400)
	crt.Xmemcpy(tls, (p /* &.base */), uintptr(unsafe.Pointer(&vfslog_vfs)), uint64(unsafe.Sizeof(sqlite3_vfs{})))
	(*VfslogVfs)(unsafe.Pointer(p)).Fbase.FzName = (((*VfslogVfs)(unsafe.Pointer(p)).FpLog) + uintptr((*sqlite3_vfs)(unsafe.Pointer(pParent)).FszOsFile))
	*(*int32)(unsafe.Pointer(p /* &.base */ + 4 /* &.szOsFile */)) += ((*sqlite3_vfs)(unsafe.Pointer(pParent)).FszOsFile)
	crt.Xmemcpy(tls, (*VfslogVfs)(unsafe.Pointer(p)).Fbase.FzName, zVfs, uint64(nVfs))

	zFile = ((*VfslogVfs)(unsafe.Pointer(p)).Fbase.FzName + uintptr((nVfs + 1)))
	(*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer((pParent + 64 /* &.xFullPathname */))))(tls, pParent, zLog, (*sqlite3_vfs)(unsafe.Pointer(pParent)).FmxPathname, zFile)

	*(*int32)(unsafe.Pointer(bp /* flags */)) = ((0x00000002 | 0x00000004) | 0x00004000)
	(*(*func(*crt.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer((pParent + 48 /* &.xDelete */))))(tls, pParent, zFile, 0)
	rc = (*(*func(*crt.TLS, uintptr, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer((pParent + 40 /* &.xOpen */))))(tls, pParent, zFile, (*VfslogVfs)(unsafe.Pointer(p)).FpLog, *(*int32)(unsafe.Pointer(bp /* flags */)), bp /* &flags */)
	if rc == 0 {
		crt.Xmemcpy(tls, p+204 /* &.aBuf */, ts+40727 /* "sqlite_ostrace1...." */, uint64(20))
		(*VfslogVfs)(unsafe.Pointer(p)).FiOffset = int64(0)
		(*VfslogVfs)(unsafe.Pointer(p)).FnBuf = 20
		rc = sqlite3.Xsqlite3_vfs_register(tls, p, 1)
	}
	if rc != 0 {
		vfslog_finalize(tls, p)
	}
	return rc
}

func sqlite3_vfslog_annotate(tls *crt.TLS, zVfs uintptr, zMsg uintptr) int32 { /* test_osinst.c:758:5: */
	var pVfs uintptr
	pVfs = sqlite3.Xsqlite3_vfs_find(tls, zVfs)
	if !(pVfs != 0) || ((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FxOpen != *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, uintptr, int32, uintptr) int32
	}{vfslogOpen}))) {
		return 1
	}
	vfslog_call(tls, pVfs, 28, 0, int64(0), 0, 0, 0)
	vfslog_string(tls, pVfs, zMsg)
	return 0
}

func vfslog_eventname(tls *crt.TLS, eEvent int32) uintptr { /* test_osinst.c:769:19: */
	var zEvent uintptr = uintptr(0)

	switch eEvent {
	case 3:
		zEvent = ts + 40748 /* "xClose" */
		break
	case 14:
		zEvent = ts + 40755 /* "xRead" */
		break
	case 20:
		zEvent = ts + 40761 /* "xWrite" */
		break
	case 18:
		zEvent = ts + 40768 /* "xTruncate" */
		break
	case 17:
		zEvent = ts + 32890 /* "xSync" */
		break
	case 8:
		zEvent = ts + 40778 /* "xFilesize" */
		break
	case 11:
		zEvent = ts + 40788 /* "xLock" */
		break
	case 19:
		zEvent = ts + 40794 /* "xUnlock" */
		break
	case 2:
		zEvent = ts + 40802 /* "xCheckResLock" */
		break
	case 7:
		zEvent = ts + 40816 /* "xFileControl" */
		break
	case 15:
		zEvent = ts + 40829 /* "xSectorSize" */
		break
	case 6:
		zEvent = ts + 40841 /* "xDeviceChar" */
		break
	case 12:
		zEvent = ts + 32455 /* "xOpen" */
		break
	case 5:
		zEvent = ts + 40853 /* "xDelete" */
		break
	case 1:
		zEvent = ts + 40861 /* "xAccess" */
		break
	case 9:
		zEvent = ts + 40869 /* "xFullPathname" */
		break
	case 13:
		zEvent = ts + 40883 /* "xRandomness" */
		break
	case 16:
		zEvent = ts + 40895 /* "xSleep" */
		break
	case 4:
		zEvent = ts + 40902 /* "xCurrentTime" */
		break

	case 22:
		zEvent = ts + 40915 /* "xShmUnmap" */
		break
	case 25:
		zEvent = ts + 40925 /* "xShmLock" */
		break
	case 26:
		zEvent = ts + 40934 /* "xShmBarrier" */
		break
	case 23:
		zEvent = ts + 40946 /* "xShmMap" */
		break

	case 28:
		zEvent = ts + 40954 /* "annotation" */
		break
	}

	return zEvent
}

type VfslogVtab1 = struct {
	Fbase  sqlite3_vtab
	FpFd   uintptr
	FnByte sqlite3_int64
	FzFile uintptr
}

type VfslogVtab = VfslogVtab1 /* test_osinst.c:804:27 */
type VfslogCsr1 = struct {
	Fbase       sqlite3_vtab_cursor
	FiRowid     sqlite3_int64
	FiOffset    sqlite3_int64
	FzTransient uintptr
	FnFile      int32
	FazFile     uintptr
	FaBuf       [1024]uint8
}

type VfslogCsr = VfslogCsr1 /* test_osinst.c:805:26 */

func get32bits(tls *crt.TLS, p uintptr) uint32 { /* test_osinst.c:830:21: */
	return (uint32((((int32(*(*uint8)(unsafe.Pointer(p + uintptr(0)))) << 24) + (int32(*(*uint8)(unsafe.Pointer(p + uintptr(1)))) << 16)) + (int32(*(*uint8)(unsafe.Pointer(p + uintptr(2)))) << 8)) + int32(*(*uint8)(unsafe.Pointer(p + uintptr(3))))))
}

// The argument must point to a buffer containing a nul-terminated string.
// If the string begins with an SQL quote character it is overwritten by
// the dequoted version. Otherwise the buffer is left unmodified.
func dequote(tls *crt.TLS, z uintptr) { /* test_osinst.c:839:13: */
	var quote int8 // Quote character (if any )
	quote = *(*int8)(unsafe.Pointer(z + uintptr(0)))
	if (((int32(quote) == '[') || (int32(quote) == '\'')) || (int32(quote) == '"')) || (int32(quote) == '`') {
		var iIn int32 = 1  // Index of next byte to read from input
		var iOut int32 = 0 // Index of next byte to write to output
		if int32(quote) == '[' {
			quote = int8(']')
		}
		for *(*int8)(unsafe.Pointer(z + uintptr(iIn))) != 0 {
			if int32(*(*int8)(unsafe.Pointer(z + uintptr(iIn)))) == int32(quote) {
				if int32(*(*int8)(unsafe.Pointer(z + uintptr((iIn + 1))))) != int32(quote) {
					break
				}
				*(*int8)(unsafe.Pointer(z + uintptr(crt.PostIncInt32(&iOut, 1)))) = quote
				iIn = iIn + (2)
			} else {
				*(*int8)(unsafe.Pointer(z + uintptr(crt.PostIncInt32(&iOut, 1)))) = *(*int8)(unsafe.Pointer(z + uintptr(crt.PostIncInt32(&iIn, 1))))
			}
		}
		*(*int8)(unsafe.Pointer(z + uintptr(iOut))) = int8(0)
	}
}

// Connect to or create a vfslog virtual table.
func vlogConnect(tls *crt.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVtab uintptr, pzErr uintptr) int32 { /* test_osinst.c:863:12: */
	bp := tls.Alloc(12)
	defer tls.Free(12)

	var pVfs uintptr // VFS used to read log file
	// var flags int32 at bp+8, 4
	// flags passed to pVfs->xOpen()
	var p uintptr
	var rc int32
	var nByte int32
	var zFile uintptr

	*(*uintptr)(unsafe.Pointer(ppVtab)) = uintptr(0)
	pVfs = sqlite3.Xsqlite3_vfs_find(tls, uintptr(0))
	nByte = (int32((uint64(unsafe.Sizeof(VfslogVtab{})) + uint64((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FszOsFile)) + uint64((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FmxPathname)))
	p = sqlite3.Xsqlite3_malloc(tls, nByte)
	if p == uintptr(0) {
		return 7
	}
	crt.Xmemset(tls, p, 0, uint64(nByte))

	(*VfslogVtab)(unsafe.Pointer(p)).FpFd = (p + uintptr(1)*48)
	(*VfslogVtab)(unsafe.Pointer(p)).FzFile = (((*VfslogVtab)(unsafe.Pointer(p)).FpFd) + uintptr((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FszOsFile))

	zFile = sqlite3.Xsqlite3_mprintf(tls, ts+130 /* "%s" */, crt.VaList(bp, *(*uintptr)(unsafe.Pointer(argv + uintptr(3)*8))))
	if !(zFile != 0) {
		sqlite3.Xsqlite3_free(tls, p)
		return 7
	}
	dequote(tls, zFile)
	(*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer((pVfs + 64 /* &.xFullPathname */))))(tls, pVfs, zFile, (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FmxPathname, (*VfslogVtab)(unsafe.Pointer(p)).FzFile)
	sqlite3.Xsqlite3_free(tls, zFile)

	*(*int32)(unsafe.Pointer(bp + 8 /* flags */)) = (0x00000002 | 0x00004000)
	rc = (*(*func(*crt.TLS, uintptr, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer((pVfs + 40 /* &.xOpen */))))(tls, pVfs, (*VfslogVtab)(unsafe.Pointer(p)).FzFile, (*VfslogVtab)(unsafe.Pointer(p)).FpFd, *(*int32)(unsafe.Pointer(bp + 8 /* flags */)), bp+8 /* &flags */)

	if rc == 0 {
		(*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer((*VfslogVtab)(unsafe.Pointer(p)).FpFd)).FpMethods + 48 /* &.xFileSize */))))(tls, (*VfslogVtab)(unsafe.Pointer(p)).FpFd, (p + 32 /* &.nByte */))
		sqlite3.Xsqlite3_declare_vtab(tls, db,
			ts+40965 /* "CREATE TABLE xxx..." */)
		*(*uintptr)(unsafe.Pointer(ppVtab)) = (p /* &.base */)
	} else {
		sqlite3.Xsqlite3_free(tls, p)
	}

	return rc
}

// There is no "best-index". This virtual table always does a linear
// scan of the binary VFS log file.
func vlogBestIndex(tls *crt.TLS, tab uintptr, pIdxInfo uintptr) int32 { /* test_osinst.c:916:12: */
	(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = 10.0
	return 0
}

// Disconnect from or destroy a vfslog virtual table.
func vlogDisconnect(tls *crt.TLS, pVtab uintptr) int32 { /* test_osinst.c:924:12: */
	var p uintptr = pVtab
	if (*sqlite3_file)(unsafe.Pointer((*VfslogVtab)(unsafe.Pointer(p)).FpFd)).FpMethods != 0 {
		(*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer((*VfslogVtab)(unsafe.Pointer(p)).FpFd)).FpMethods + 8 /* &.xClose */))))(tls, (*VfslogVtab)(unsafe.Pointer(p)).FpFd)
		(*sqlite3_file)(unsafe.Pointer((*VfslogVtab)(unsafe.Pointer(p)).FpFd)).FpMethods = uintptr(0)
	}
	sqlite3.Xsqlite3_free(tls, p)
	return 0
}

// Open a new vfslog cursor.
func vlogOpen(tls *crt.TLS, pVTab uintptr, ppCursor uintptr) int32 { /* test_osinst.c:937:12: */
	var pCsr uintptr // Newly allocated cursor object

	pCsr = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(VfslogCsr{})))
	if !(pCsr != 0) {
		return 7
	}
	crt.Xmemset(tls, pCsr, 0, uint64(unsafe.Sizeof(VfslogCsr{})))
	*(*uintptr)(unsafe.Pointer(ppCursor)) = (pCsr /* &.base */)
	return 0
}

// Close a vfslog cursor.
func vlogClose(tls *crt.TLS, pCursor uintptr) int32 { /* test_osinst.c:950:12: */
	var p uintptr = pCursor
	var i int32
	for i = 0; i < (*VfslogCsr)(unsafe.Pointer(p)).FnFile; i++ {
		sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer((*VfslogCsr)(unsafe.Pointer(p)).FazFile + uintptr(i)*8)))
	}
	sqlite3.Xsqlite3_free(tls, (*VfslogCsr)(unsafe.Pointer(p)).FazFile)
	sqlite3.Xsqlite3_free(tls, (*VfslogCsr)(unsafe.Pointer(p)).FzTransient)
	sqlite3.Xsqlite3_free(tls, p)
	return 0
}

// Move a vfslog cursor to the next entry in the file.
func vlogNext(tls *crt.TLS, pCursor uintptr) int32 { /* test_osinst.c:965:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var pCsr uintptr = pCursor
	var p uintptr = (*sqlite3_vtab_cursor)(unsafe.Pointer(pCursor)).FpVtab
	var rc int32 = 0
	var nRead int32

	sqlite3.Xsqlite3_free(tls, (*VfslogCsr)(unsafe.Pointer(pCsr)).FzTransient)
	(*VfslogCsr)(unsafe.Pointer(pCsr)).FzTransient = uintptr(0)

	nRead = 24
	if ((*VfslogCsr)(unsafe.Pointer(pCsr)).FiOffset + sqlite3_int64(nRead)) <= (*VfslogVtab)(unsafe.Pointer(p)).FnByte {
		var eEvent int32
		rc = (*(*func(*crt.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer((*VfslogVtab)(unsafe.Pointer(p)).FpFd)).FpMethods + 16 /* &.xRead */))))(tls, (*VfslogVtab)(unsafe.Pointer(p)).FpFd, pCsr+48 /* &.aBuf */, nRead, (*VfslogCsr)(unsafe.Pointer(pCsr)).FiOffset)

		eEvent = int32(get32bits(tls, pCsr+48 /* &.aBuf */))
		if (rc == 0) &&
			(((eEvent == 12) || (eEvent == 5)) || (eEvent == 1)) {
			// var buf [4]int8 at bp, 4

			rc = (*(*func(*crt.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer((*VfslogVtab)(unsafe.Pointer(p)).FpFd)).FpMethods + 16 /* &.xRead */))))(tls, (*VfslogVtab)(unsafe.Pointer(p)).FpFd, bp /* &buf[0] */, 4, ((*VfslogCsr)(unsafe.Pointer(pCsr)).FiOffset + sqlite3_int64(nRead)))
			nRead = nRead + (4)
			if rc == 0 {
				var nStr int32 = int32(get32bits(tls, bp /* buf */))
				var zStr uintptr = sqlite3.Xsqlite3_malloc(tls, (nStr + 1))
				rc = (*(*func(*crt.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer((*VfslogVtab)(unsafe.Pointer(p)).FpFd)).FpMethods + 16 /* &.xRead */))))(tls, (*VfslogVtab)(unsafe.Pointer(p)).FpFd, zStr, nStr, ((*VfslogCsr)(unsafe.Pointer(pCsr)).FiOffset + sqlite3_int64(nRead)))
				*(*int8)(unsafe.Pointer(zStr + uintptr(nStr))) = int8(0)
				nRead = nRead + (nStr)

				if eEvent == 12 {
					var iFileid int32 = int32(get32bits(tls, ((pCsr + 48 /* &.aBuf */) + uintptr(4))))
					if iFileid >= (*VfslogCsr)(unsafe.Pointer(pCsr)).FnFile {
						var nNew int32 = (int32(uint64(unsafe.Sizeof(uintptr(0))) * (uint64(iFileid + 1))))
						(*VfslogCsr)(unsafe.Pointer(pCsr)).FazFile = sqlite3.Xsqlite3_realloc(tls, (*VfslogCsr)(unsafe.Pointer(pCsr)).FazFile, nNew)
						nNew = int32(uint64(nNew) - (uint64(unsafe.Sizeof(uintptr(0))) * uint64((*VfslogCsr)(unsafe.Pointer(pCsr)).FnFile)))
						crt.Xmemset(tls, ((*VfslogCsr)(unsafe.Pointer(pCsr)).FazFile + uintptr((*VfslogCsr)(unsafe.Pointer(pCsr)).FnFile)*8), 0, uint64(nNew))
						(*VfslogCsr)(unsafe.Pointer(pCsr)).FnFile = (iFileid + 1)
					}
					sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer((*VfslogCsr)(unsafe.Pointer(pCsr)).FazFile + uintptr(iFileid)*8)))
					*(*uintptr)(unsafe.Pointer((*VfslogCsr)(unsafe.Pointer(pCsr)).FazFile + uintptr(iFileid)*8)) = zStr
				} else {
					(*VfslogCsr)(unsafe.Pointer(pCsr)).FzTransient = zStr
				}
			}
		}
	}

	*(*sqlite3_int64)(unsafe.Pointer(pCsr + 8 /* &.iRowid */)) += (int64(1))
	*(*sqlite3_int64)(unsafe.Pointer(pCsr + 16 /* &.iOffset */)) += (sqlite3_int64(nRead))
	return rc
}

func vlogEof(tls *crt.TLS, pCursor uintptr) int32 { /* test_osinst.c:1016:12: */
	var pCsr uintptr = pCursor
	var p uintptr = (*sqlite3_vtab_cursor)(unsafe.Pointer(pCursor)).FpVtab
	return (crt.Bool32((*VfslogCsr)(unsafe.Pointer(pCsr)).FiOffset >= (*VfslogVtab)(unsafe.Pointer(p)).FnByte))
}

func vlogFilter(tls *crt.TLS, pCursor uintptr, idxNum int32, idxStr uintptr, argc int32, argv uintptr) int32 { /* test_osinst.c:1022:12: */
	var pCsr uintptr = pCursor
	(*VfslogCsr)(unsafe.Pointer(pCsr)).FiRowid = int64(0)
	(*VfslogCsr)(unsafe.Pointer(pCsr)).FiOffset = int64(20)
	return vlogNext(tls, pCursor)
}

func vlogColumn(tls *crt.TLS, pCursor uintptr, ctx uintptr, i int32) int32 { /* test_osinst.c:1033:12: */
	var val uint32
	var pCsr uintptr = pCursor

	if !(i < 7) {
		crt.X__assert_fail(tls, ts+41020 /* "i<7" */, ts+41024 /* "testdata/sqlite-..." */, uint32(1041), uintptr(unsafe.Pointer(&__func__109)))
	}
	val = get32bits(tls, ((pCsr + 48 /* &.aBuf */) + uintptr((4 * i))))

	switch i {
	case 0:
		{
			sqlite3.Xsqlite3_result_text(tls, ctx, vfslog_eventname(tls, int32(val)), -1, uintptr(0))
			break
		}
	case 1:
		{
			var zStr uintptr = (*VfslogCsr)(unsafe.Pointer(pCsr)).FzTransient
			if (val != uint32(0)) && (val < uint32((*VfslogCsr)(unsafe.Pointer(pCsr)).FnFile)) {
				zStr = *(*uintptr)(unsafe.Pointer((*VfslogCsr)(unsafe.Pointer(pCsr)).FazFile + uintptr(val)*8))
			}
			sqlite3.Xsqlite3_result_text(tls, ctx, zStr, -1, crt.UintptrFromInt32(-1))
			break
		}
	default:
		sqlite3.Xsqlite3_result_int(tls, ctx, int32(val))
		break
	}

	return 0
}

var __func__109 = *(*[11]int8)(unsafe.Pointer(ts + 41070 /* "vlogColumn" */)) /* test_osinst.c:1037:2 */

func vlogRowid(tls *crt.TLS, pCursor uintptr, pRowid uintptr) int32 { /* test_osinst.c:1065:12: */
	var pCsr uintptr = pCursor
	*(*sqlite_int64)(unsafe.Pointer(pRowid)) = (*VfslogCsr)(unsafe.Pointer(pCsr)).FiRowid
	return 0
}

func sqlite3_vfslog_register(tls *crt.TLS, db uintptr) int32 { /* test_osinst.c:1071:5: */

	sqlite3.Xsqlite3_create_module(tls, db, ts+41081 /* "vfslog" */, uintptr(unsafe.Pointer(&vfslog_module)), uintptr(0))
	return 0
}

var vfslog_module = sqlite3_module{FiVersion: 0, FxCreate: // iVersion
0, FxConnect:// xCreate
0, FxBestIndex:// xConnect
0, FxDisconnect:// xBestIndex
0, FxDestroy:// xDisconnect
0, FxOpen:// xDestroy
0, FxClose:// xOpen - open a cursor
0, FxFilter:// xClose - close a cursor
0, FxNext:// xFilter - configure scan constraints
0, FxEof:// xNext - advance a cursor
0, FxColumn:// xEof - check for end of scan
0, FxRowid:// xColumn - read data
0, FxUpdate:// xRowid - read data
uintptr(0), FxBegin:// xUpdate
uintptr(0), FxSync:// xBegin
uintptr(0), FxCommit:// xSync
uintptr(0), FxRollback:// xCommit
uintptr(0), FxFindFunction:// xRollback
uintptr(0), FxRename:// xFindMethod
uintptr(0), // xRename
} /* test_osinst.c:1072:25 */

// end block for C++

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:

func test_vfslog(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_osinst.c:1116:26: */
	bp := tls.Alloc(144)
	defer tls.Free(144)

	var db uintptr
	// var cmdInfo Tcl_CmdInfo at bp+80, 64

	var rc int32 = 1
	const ( /* test_osinst.c:1128:3: */
		VL_ANNOTATE = 0
		VL_FINALIZE = 1
		VL_NEW      = 2
		VL_REGISTER = 3
	)
	// var iSub int32 at bp+72, 4

	if objc < 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+37895 /* "SUB-COMMAND ..." */)
		return 1
	}
	if tcl.XTcl_GetIndexFromObjStruct(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)), uintptr(unsafe.Pointer(&strs)), int32(unsafe.Sizeof(uintptr(0))), ts+2321 /* "sub-command" */, 0, bp+72 /* &iSub */) != 0 {
		return 1
	}

	switch uint32(*(*int32)(unsafe.Pointer(bp + 72 /* iSub */))) {
	case VL_ANNOTATE:
		{
			var zVfs uintptr
			var zMsg uintptr
			if objc != 4 {
				tcl.XTcl_WrongNumArgs(tls, interp, 3, objv, ts+41088 /* "VFS" */)
				return 1
			}
			zVfs = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)))
			zMsg = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(3)*8)))
			rc = sqlite3_vfslog_annotate(tls, zVfs, zMsg)
			if rc != 0 {
				tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+41092 /* "failed" */, 0))
				return 1
			}
			break
		}
	case VL_FINALIZE:
		{
			var zVfs uintptr
			if objc != 3 {
				tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+41088 /* "VFS" */)
				return 1
			}
			zVfs = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)))
			rc = sqlite3_vfslog_finalize(tls, zVfs)
			if rc != 0 {
				tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+16, ts+41092 /* "failed" */, 0))
				return 1
			}
			break
		}

	case VL_NEW:
		{
			var zVfs uintptr
			var zParent uintptr
			var zLog uintptr
			if objc != 5 {
				tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+41099 /* "VFS PARENT LOGFI..." */)
				return 1
			}
			zVfs = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)))
			zParent = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(3)*8)))
			zLog = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(4)*8)))
			if int32(*(*int8)(unsafe.Pointer(zParent))) == 0 {
				zParent = uintptr(0)
			}
			rc = sqlite3_vfslog_new(tls, zVfs, zParent, zLog)
			if rc != 0 {
				tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+32, ts+41092 /* "failed" */, 0))
				return 1
			}
			break
		}

	case VL_REGISTER:
		{
			var zDb uintptr
			if objc != 3 {
				tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+2452 /* "DB" */)
				return 1
			}
			zDb = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)))
			if tcl.XTcl_GetCommandInfo(tls, interp, zDb, bp+80 /* &cmdInfo */) != 0 {
				db = (*struct{ Fdb uintptr })(unsafe.Pointer((*Tcl_CmdInfo)(unsafe.Pointer(bp + 80 /* &cmdInfo */)).FobjClientData)).Fdb
				rc = sqlite3_vfslog_register(tls, db)
			}
			if rc != 0 {
				tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+48, ts+41118 /* "bad sqlite3 hand..." */, zDb, uintptr(0)))
				return 1
			}
			break
		}
	}

	return 0
}

var strs = [5]uintptr{ts + 41139 /* "annotate" */, ts + 41148 /* "finalize" */, ts + 12847 /* "new" */, ts + 41157 /* "register" */, uintptr(0)} /* test_osinst.c:1127:21 */

func SqlitetestOsinst_Init(tls *crt.TLS, interp uintptr) int32 { /* test_osinst.c:1219:5: */
	tcl.XTcl_CreateObjCommand(tls, interp, ts+41081 /* "vfslog" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_vfslog})), uintptr(0), uintptr(0))
	return 0
}

// When possible, define assert so that it does not add extra
//   parentheses around EXPR.  Otherwise, those added parentheses would
//   suppress warnings we'd expect to be detected by gcc's -Wparentheses.

// Version 2.4 and later of GCC define a magical variable `__PRETTY_FUNCTION__'
//   which contains the name of the function currently being defined.
//   This is broken in G++ before version 2.6.
//   C9x has a similar variable called __func__, but prefer the GCC one since
//   it demangles C++ function names.

// Global data used by this test implementation.  There is no
// mutexing, which means this page cache will not work in a
// multi-threaded test.
type testpcacheGlobalType1 = struct {
	FpDummy        uintptr
	FnInstance     int32
	FdiscardChance uint32
	FprngSeed      uint32
	FhighStress    uint32
}

// When possible, define assert so that it does not add extra
//   parentheses around EXPR.  Otherwise, those added parentheses would
//   suppress warnings we'd expect to be detected by gcc's -Wparentheses.

// Version 2.4 and later of GCC define a magical variable `__PRETTY_FUNCTION__'
//   which contains the name of the function currently being defined.
//   This is broken in G++ before version 2.6.
//   C9x has a similar variable called __func__, but prefer the GCC one since
//   it demangles C++ function names.

// Global data used by this test implementation.  There is no
// mutexing, which means this page cache will not work in a
// multi-threaded test.
type testpcacheGlobalType = testpcacheGlobalType1 /* test_pcache.c:33:37 */
var testpcacheGlobal testpcacheGlobalType         /* test_pcache.c:41:29: */

// Initializer.
//
// Verify that the initializer is only called when the system is
// uninitialized.  Allocate some memory and report SQLITE_NOMEM if
// the allocation fails.  This provides a means to test the recovery
// from a failed initialization attempt.  It also verifies that the
// the destructor always gets call - otherwise there would be a
// memory leak.
func testpcacheInit(tls *crt.TLS, pArg uintptr) int32 { /* test_pcache.c:53:12: */
	if !(pArg == uintptr(unsafe.Pointer(&testpcacheGlobal))) {
		crt.X__assert_fail(tls, ts+41166 /* "pArg==(void*)&te..." */, ts+41197 /* "testdata/sqlite-..." */, uint32(54), uintptr(unsafe.Pointer(&__func__110)))
	}
	if !(testpcacheGlobal.FpDummy == uintptr(0)) {
		crt.X__assert_fail(tls, ts+41243 /* "testpcacheGlobal..." */, ts+41197 /* "testdata/sqlite-..." */, uint32(55), uintptr(unsafe.Pointer(&__func__110)))
	}
	if !(testpcacheGlobal.FnInstance == 0) {
		crt.X__assert_fail(tls, ts+41270 /* "testpcacheGlobal..." */, ts+41197 /* "testdata/sqlite-..." */, uint32(56), uintptr(unsafe.Pointer(&__func__110)))
	}
	testpcacheGlobal.FpDummy = sqlite3.Xsqlite3_malloc(tls, 10)
	if testpcacheGlobal.FpDummy == uintptr(0) {
		return 7
	}
	return 0
}

var __func__110 = *(*[15]int8)(unsafe.Pointer(ts + 41300 /* "testpcacheInit" */)) /* test_pcache.c:53:38 */

// Destructor
//
// Verify that this is only called after initialization.
// Free the memory allocated by the initializer.
func testpcacheShutdown(tls *crt.TLS, pArg uintptr) { /* test_pcache.c:67:13: */
	if !(pArg == uintptr(unsafe.Pointer(&testpcacheGlobal))) {
		crt.X__assert_fail(tls, ts+41166 /* "pArg==(void*)&te..." */, ts+41197 /* "testdata/sqlite-..." */, uint32(68), uintptr(unsafe.Pointer(&__func__111)))
	}
	if !(testpcacheGlobal.FpDummy != uintptr(0)) {
		crt.X__assert_fail(tls, ts+41315 /* "testpcacheGlobal..." */, ts+41197 /* "testdata/sqlite-..." */, uint32(69), uintptr(unsafe.Pointer(&__func__111)))
	}
	if !(testpcacheGlobal.FnInstance == 0) {
		crt.X__assert_fail(tls, ts+41270 /* "testpcacheGlobal..." */, ts+41197 /* "testdata/sqlite-..." */, uint32(70), uintptr(unsafe.Pointer(&__func__111)))
	}
	sqlite3.Xsqlite3_free(tls, testpcacheGlobal.FpDummy)
	testpcacheGlobal.FpDummy = uintptr(0)
}

var __func__111 = *(*[19]int8)(unsafe.Pointer(ts + 41342 /* "testpcacheShutdo..." */)) /* test_pcache.c:67:43 */

// Number of pages in a cache.
//
// The number of pages is a hard upper bound in this test module.
// If more pages are requested, sqlite3PcacheFetch() returns NULL.
//
// If testing with in-memory temp tables, provide a larger pcache.
// Some of the test cases need this.

// Magic numbers used to determine validity of the page cache.

// Private implementation of a page cache.
type testpcache1 = struct {
	FszPage     int32
	FszExtra    int32
	FbPurgeable int32
	FnFree      int32
	FnPinned    int32
	FiRand      uint32
	FiMagic     uint32
	Fa          [217]struct {
		Fpage     sqlite3_pcache_page
		Fkey      uint32
		FisPinned int32
	}
}

// Number of pages in a cache.
//
// The number of pages is a hard upper bound in this test module.
// If more pages are requested, sqlite3PcacheFetch() returns NULL.
//
// If testing with in-memory temp tables, provide a larger pcache.
// Some of the test cases need this.

// Magic numbers used to determine validity of the page cache.

// Private implementation of a page cache.
type testpcache = testpcache1 /* test_pcache.c:100:27 */
type testpcachePage = struct {
	Fpage     sqlite3_pcache_page
	Fkey      uint32
	FisPinned int32
}

// Get a random number using the PRNG in the given page cache.
func testpcacheRandom(tls *crt.TLS, p uintptr) uint32 { /* test_pcache.c:119:17: */
	var x uint32 = uint32(0)
	var i int32
	for i = 0; i < 4; i++ {
		(*testpcache)(unsafe.Pointer(p)).FiRand = (((*testpcache)(unsafe.Pointer(p)).FiRand * uint32(69069)) + uint32(5))
		x = ((x << 8) | (((*testpcache)(unsafe.Pointer(p)).FiRand >> 16) & uint32(0xff)))
	}
	return x
}

// Allocate a new page cache instance.
func testpcacheCreate(tls *crt.TLS, szPage int32, szExtra int32, bPurgeable int32) uintptr { /* test_pcache.c:133:23: */
	var nMem int32
	var x uintptr
	var p uintptr
	var i int32
	if !(testpcacheGlobal.FpDummy != uintptr(0)) {
		crt.X__assert_fail(tls, ts+41315 /* "testpcacheGlobal..." */, ts+41197 /* "testdata/sqlite-..." */, uint32(142), uintptr(unsafe.Pointer(&__func__112)))
	}
	szPage = ((szPage + 7) & ^int32(crt.Int32FromInt32(7)))
	nMem = (int32(uint64(unsafe.Sizeof(testpcache{})) + (uint64(217 * (szPage + szExtra)))))
	p = sqlite3.Xsqlite3_malloc(tls, nMem)
	if p == uintptr(0) {
		return uintptr(0)
	}
	x = (p + uintptr(1)*5240)
	(*testpcache)(unsafe.Pointer(p)).FszPage = szPage
	(*testpcache)(unsafe.Pointer(p)).FszExtra = szExtra
	(*testpcache)(unsafe.Pointer(p)).FnFree = 217
	(*testpcache)(unsafe.Pointer(p)).FnPinned = 0
	(*testpcache)(unsafe.Pointer(p)).FiRand = testpcacheGlobal.FprngSeed
	(*testpcache)(unsafe.Pointer(p)).FbPurgeable = bPurgeable
	(*testpcache)(unsafe.Pointer(p)).FiMagic = uint32(0x364585fd)
	i = 0
__1:
	if !(i < 217) {
		goto __3
	}
	{
		(*testpcachePage)(unsafe.Pointer((p + 32 /* &.a */) + uintptr(i)*24)).Fkey = uint32(0)
		(*testpcachePage)(unsafe.Pointer((p + 32 /* &.a */) + uintptr(i)*24)).FisPinned = 0
		(*testpcachePage)(unsafe.Pointer((p + 32 /* &.a */) + uintptr(i)*24)).Fpage.FpBuf = x
		(*testpcachePage)(unsafe.Pointer((p + 32 /* &.a */) + uintptr(i)*24)).Fpage.FpExtra = (x + uintptr(szPage))
	}
	goto __2
__2:
	i++
	x += (uintptr(szPage + szExtra))
	goto __1
	goto __3
__3:
	;
	testpcacheGlobal.FnInstance++
	return p
}

var __func__112 = *(*[17]int8)(unsafe.Pointer(ts + 41361 /* "testpcacheCreate" */)) /* test_pcache.c:137:2 */

// Set the cache size
func testpcacheCachesize(tls *crt.TLS, pCache uintptr, newSize int32) { /* test_pcache.c:168:13: */
	var p uintptr = pCache
	if !((*testpcache)(unsafe.Pointer(p)).FiMagic == uint32(0x364585fd)) {
		crt.X__assert_fail(tls, ts+41378 /* "p->iMagic==0x364..." */, ts+41197 /* "testdata/sqlite-..." */, uint32(170), uintptr(unsafe.Pointer(&__func__113)))
	}
	if !(testpcacheGlobal.FpDummy != uintptr(0)) {
		crt.X__assert_fail(tls, ts+41315 /* "testpcacheGlobal..." */, ts+41197 /* "testdata/sqlite-..." */, uint32(171), uintptr(unsafe.Pointer(&__func__113)))
	}
	if !(testpcacheGlobal.FnInstance > 0) {
		crt.X__assert_fail(tls, ts+41400 /* "testpcacheGlobal..." */, ts+41197 /* "testdata/sqlite-..." */, uint32(172), uintptr(unsafe.Pointer(&__func__113)))
	}
}

var __func__113 = *(*[20]int8)(unsafe.Pointer(ts + 41429 /* "testpcacheCaches..." */)) /* test_pcache.c:168:69 */

// Return the number of pages in the cache that are being used.
// This includes both pinned and unpinned pages.
func testpcachePagecount(tls *crt.TLS, pCache uintptr) int32 { /* test_pcache.c:179:12: */
	var p uintptr = pCache
	if !((*testpcache)(unsafe.Pointer(p)).FiMagic == uint32(0x364585fd)) {
		crt.X__assert_fail(tls, ts+41378 /* "p->iMagic==0x364..." */, ts+41197 /* "testdata/sqlite-..." */, uint32(181), uintptr(unsafe.Pointer(&__func__114)))
	}
	if !(testpcacheGlobal.FpDummy != uintptr(0)) {
		crt.X__assert_fail(tls, ts+41315 /* "testpcacheGlobal..." */, ts+41197 /* "testdata/sqlite-..." */, uint32(182), uintptr(unsafe.Pointer(&__func__114)))
	}
	if !(testpcacheGlobal.FnInstance > 0) {
		crt.X__assert_fail(tls, ts+41400 /* "testpcacheGlobal..." */, ts+41197 /* "testdata/sqlite-..." */, uint32(183), uintptr(unsafe.Pointer(&__func__114)))
	}
	return (217 - (*testpcache)(unsafe.Pointer(p)).FnFree)
}

var __func__114 = *(*[20]int8)(unsafe.Pointer(ts + 41449 /* "testpcachePageco..." */)) /* test_pcache.c:179:55 */

// Fetch a page.
func testpcacheFetch(tls *crt.TLS, pCache uintptr, key uint32, createFlag int32) uintptr { /* test_pcache.c:190:28: */
	var p uintptr = pCache
	var i int32
	var j int32
	if !((*testpcache)(unsafe.Pointer(p)).FiMagic == uint32(0x364585fd)) {
		crt.X__assert_fail(tls, ts+41378 /* "p->iMagic==0x364..." */, ts+41197 /* "testdata/sqlite-..." */, uint32(197), uintptr(unsafe.Pointer(&__func__115)))
	}
	if !(testpcacheGlobal.FpDummy != uintptr(0)) {
		crt.X__assert_fail(tls, ts+41315 /* "testpcacheGlobal..." */, ts+41197 /* "testdata/sqlite-..." */, uint32(198), uintptr(unsafe.Pointer(&__func__115)))
	}
	if !(testpcacheGlobal.FnInstance > 0) {
		crt.X__assert_fail(tls, ts+41400 /* "testpcacheGlobal..." */, ts+41197 /* "testdata/sqlite-..." */, uint32(199), uintptr(unsafe.Pointer(&__func__115)))
	}

	// See if the page is already in cache.  Return immediately if it is
	for i = 0; i < 217; i++ {
		if (*testpcachePage)(unsafe.Pointer((p+32 /* &.a */)+uintptr(i)*24)).Fkey == key {
			if !((*testpcachePage)(unsafe.Pointer((p+32 /* &.a */)+uintptr(i)*24)).FisPinned != 0) {
				(*testpcache)(unsafe.Pointer(p)).FnPinned++
				if !((*testpcache)(unsafe.Pointer(p)).FnPinned <= (217 - (*testpcache)(unsafe.Pointer(p)).FnFree)) {
					crt.X__assert_fail(tls, ts+41469 /* "p->nPinned <= 21..." */, ts+41197 /* "testdata/sqlite-..." */, uint32(206), uintptr(unsafe.Pointer(&__func__115)))
				}
				(*testpcachePage)(unsafe.Pointer((p + 32 /* &.a */) + uintptr(i)*24)).FisPinned = 1
			}
			return ((p + 32 /* &.a */) + uintptr(i)*24 /* &.page */)
		}
	}

	// If createFlag is 0, never allocate a new page
	if createFlag == 0 {
		return uintptr(0)
	}

	// If no pages are available, always fail
	if (*testpcache)(unsafe.Pointer(p)).FnPinned == 217 {
		return uintptr(0)
	}

	// Do not allocate the last TESTPCACHE_RESERVE pages unless createFlag is 2
	if ((*testpcache)(unsafe.Pointer(p)).FnPinned >= (217 - 17)) && (createFlag < 2) {
		return uintptr(0)
	}

	// Do not allocate if highStress is enabled and createFlag is not 2.
	//
	// The highStress setting causes pagerStress() to be called much more
	// often, which exercises the pager logic more intensely.
	if (testpcacheGlobal.FhighStress != 0) && (createFlag < 2) {
		return uintptr(0)
	}

	// Find a free page to allocate if there are any free pages.
	// Withhold TESTPCACHE_RESERVE free pages until createFlag is 2.
	if ((*testpcache)(unsafe.Pointer(p)).FnFree > 17) || ((createFlag == 2) && ((*testpcache)(unsafe.Pointer(p)).FnFree > 0)) {
		j = (int32(testpcacheRandom(tls, p) % uint32(217)))
		i = 0
	__1:
		if !(i < 217) {
			goto __3
		}
		{
			if (*testpcachePage)(unsafe.Pointer((p+32 /* &.a */)+uintptr(j)*24)).Fkey == uint32(0) {
				(*testpcachePage)(unsafe.Pointer((p + 32 /* &.a */) + uintptr(j)*24)).Fkey = key
				(*testpcachePage)(unsafe.Pointer((p + 32 /* &.a */) + uintptr(j)*24)).FisPinned = 1
				crt.Xmemset(tls, (*testpcachePage)(unsafe.Pointer((p+32 /* &.a */)+uintptr(j)*24)).Fpage.FpBuf, 0, uint64((*testpcache)(unsafe.Pointer(p)).FszPage))
				crt.Xmemset(tls, (*testpcachePage)(unsafe.Pointer((p+32 /* &.a */)+uintptr(j)*24)).Fpage.FpExtra, 0, uint64((*testpcache)(unsafe.Pointer(p)).FszExtra))
				(*testpcache)(unsafe.Pointer(p)).FnPinned++
				(*testpcache)(unsafe.Pointer(p)).FnFree--
				if !((*testpcache)(unsafe.Pointer(p)).FnPinned <= (217 - (*testpcache)(unsafe.Pointer(p)).FnFree)) {
					crt.X__assert_fail(tls, ts+41469 /* "p->nPinned <= 21..." */, ts+41197 /* "testdata/sqlite-..." */, uint32(250), uintptr(unsafe.Pointer(&__func__115)))
				}
				return ((p + 32 /* &.a */) + uintptr(j)*24 /* &.page */)
			}
		}
		goto __2
	__2:
		i++
		j = ((j + 1) % 217)
		goto __1
		goto __3
	__3:
		;

		// The prior loop always finds a freepage to allocate
		if !(0 != 0) {
			crt.X__assert_fail(tls, ts+8293 /* "0" */, ts+41197 /* "testdata/sqlite-..." */, uint32(256), uintptr(unsafe.Pointer(&__func__115)))
		}
	}

	// If this cache is not purgeable then we have to fail.
	if (*testpcache)(unsafe.Pointer(p)).FbPurgeable == 0 {
		return uintptr(0)
	}

	// If there are no free pages, recycle a page.  The page to
	// recycle is selected at random from all unpinned pages.
	j = (int32(testpcacheRandom(tls, p) % uint32(217)))
	i = 0
__4:
	if !(i < 217) {
		goto __6
	}
	{
		if ((*testpcachePage)(unsafe.Pointer((p+32 /* &.a */)+uintptr(j)*24)).Fkey > uint32(0)) && ((*testpcachePage)(unsafe.Pointer((p+32 /* &.a */)+uintptr(j)*24)).FisPinned == 0) {
			(*testpcachePage)(unsafe.Pointer((p + 32 /* &.a */) + uintptr(j)*24)).Fkey = key
			(*testpcachePage)(unsafe.Pointer((p + 32 /* &.a */) + uintptr(j)*24)).FisPinned = 1
			crt.Xmemset(tls, (*testpcachePage)(unsafe.Pointer((p+32 /* &.a */)+uintptr(j)*24)).Fpage.FpBuf, 0, uint64((*testpcache)(unsafe.Pointer(p)).FszPage))
			crt.Xmemset(tls, (*testpcachePage)(unsafe.Pointer((p+32 /* &.a */)+uintptr(j)*24)).Fpage.FpExtra, 0, uint64((*testpcache)(unsafe.Pointer(p)).FszExtra))
			(*testpcache)(unsafe.Pointer(p)).FnPinned++
			if !((*testpcache)(unsafe.Pointer(p)).FnPinned <= (217 - (*testpcache)(unsafe.Pointer(p)).FnFree)) {
				crt.X__assert_fail(tls, ts+41469 /* "p->nPinned <= 21..." */, ts+41197 /* "testdata/sqlite-..." */, uint32(276), uintptr(unsafe.Pointer(&__func__115)))
			}
			return ((p + 32 /* &.a */) + uintptr(j)*24 /* &.page */)
		}
	}
	goto __5
__5:
	i++
	j = ((j + 1) % 217)
	goto __4
	goto __6
__6:
	;

	// The previous loop always finds a page to recycle.
	if !(0 != 0) {
		crt.X__assert_fail(tls, ts+8293 /* "0" */, ts+41197 /* "testdata/sqlite-..." */, uint32(282), uintptr(unsafe.Pointer(&__func__115)))
	}
	return uintptr(0)
}

var __func__115 = *(*[16]int8)(unsafe.Pointer(ts + 41498 /* "testpcacheFetch" */)) /* test_pcache.c:194:2 */

// Unpin a page.
func testpcacheUnpin(tls *crt.TLS, pCache uintptr, pOldPage uintptr, discard int32) { /* test_pcache.c:289:13: */
	var p uintptr = pCache
	var i int32
	if !((*testpcache)(unsafe.Pointer(p)).FiMagic == uint32(0x364585fd)) {
		crt.X__assert_fail(tls, ts+41378 /* "p->iMagic==0x364..." */, ts+41197 /* "testdata/sqlite-..." */, uint32(296), uintptr(unsafe.Pointer(&__func__116)))
	}
	if !(testpcacheGlobal.FpDummy != uintptr(0)) {
		crt.X__assert_fail(tls, ts+41315 /* "testpcacheGlobal..." */, ts+41197 /* "testdata/sqlite-..." */, uint32(297), uintptr(unsafe.Pointer(&__func__116)))
	}
	if !(testpcacheGlobal.FnInstance > 0) {
		crt.X__assert_fail(tls, ts+41400 /* "testpcacheGlobal..." */, ts+41197 /* "testdata/sqlite-..." */, uint32(298), uintptr(unsafe.Pointer(&__func__116)))
	}

	// Randomly discard pages as they are unpinned according to the
	// discardChance setting.  If discardChance is 0, the random discard
	// never happens.  If discardChance is 100, it always happens.
	if ((*testpcache)(unsafe.Pointer(p)).FbPurgeable != 0) &&
		((uint32(100) - testpcacheGlobal.FdiscardChance) <= (testpcacheRandom(tls, p) % uint32(100))) {
		discard = 1
	}

	for i = 0; i < 217; i++ {
		if ((p + 32 /* &.a */) + uintptr(i)*24 /* &.page */) == pOldPage {
			// The pOldPage pointer always points to a pinned page
			if !((*testpcachePage)(unsafe.Pointer((p+32 /* &.a */)+uintptr(i)*24)).FisPinned != 0) {
				crt.X__assert_fail(tls, ts+41514 /* "p->a[i].isPinned" */, ts+41197 /* "testdata/sqlite-..." */, uint32(313), uintptr(unsafe.Pointer(&__func__116)))
			}
			(*testpcachePage)(unsafe.Pointer((p + 32 /* &.a */) + uintptr(i)*24)).FisPinned = 0
			(*testpcache)(unsafe.Pointer(p)).FnPinned--
			if !((*testpcache)(unsafe.Pointer(p)).FnPinned >= 0) {
				crt.X__assert_fail(tls, ts+41531 /* "p->nPinned>=0" */, ts+41197 /* "testdata/sqlite-..." */, uint32(316), uintptr(unsafe.Pointer(&__func__116)))
			}
			if discard != 0 {
				(*testpcachePage)(unsafe.Pointer((p + 32 /* &.a */) + uintptr(i)*24)).Fkey = uint32(0)
				(*testpcache)(unsafe.Pointer(p)).FnFree++
				if !((*testpcache)(unsafe.Pointer(p)).FnFree <= 217) {
					crt.X__assert_fail(tls, ts+41545 /* "p->nFree<=217" */, ts+41197 /* "testdata/sqlite-..." */, uint32(320), uintptr(unsafe.Pointer(&__func__116)))
				}
			}
			return
		}
	}

	// The pOldPage pointer always points to a valid page
	if !(0 != 0) {
		crt.X__assert_fail(tls, ts+8293 /* "0" */, ts+41197 /* "testdata/sqlite-..." */, uint32(327), uintptr(unsafe.Pointer(&__func__116)))
	}
}

var __func__116 = *(*[16]int8)(unsafe.Pointer(ts + 41559 /* "testpcacheUnpin" */)) /* test_pcache.c:293:2 */

// Rekey a single page.
func testpcacheRekey(tls *crt.TLS, pCache uintptr, pOldPage uintptr, oldKey uint32, newKey uint32) { /* test_pcache.c:334:13: */
	var p uintptr = pCache
	var i int32
	if !((*testpcache)(unsafe.Pointer(p)).FiMagic == uint32(0x364585fd)) {
		crt.X__assert_fail(tls, ts+41378 /* "p->iMagic==0x364..." */, ts+41197 /* "testdata/sqlite-..." */, uint32(342), uintptr(unsafe.Pointer(&__func__117)))
	}
	if !(testpcacheGlobal.FpDummy != uintptr(0)) {
		crt.X__assert_fail(tls, ts+41315 /* "testpcacheGlobal..." */, ts+41197 /* "testdata/sqlite-..." */, uint32(343), uintptr(unsafe.Pointer(&__func__117)))
	}
	if !(testpcacheGlobal.FnInstance > 0) {
		crt.X__assert_fail(tls, ts+41400 /* "testpcacheGlobal..." */, ts+41197 /* "testdata/sqlite-..." */, uint32(344), uintptr(unsafe.Pointer(&__func__117)))
	}

	// If there already exists another page at newKey, verify that
	// the other page is unpinned and discard it.
	for i = 0; i < 217; i++ {
		if (*testpcachePage)(unsafe.Pointer((p+32 /* &.a */)+uintptr(i)*24)).Fkey == newKey {
			// The new key is never a page that is already pinned
			if !((*testpcachePage)(unsafe.Pointer((p+32 /* &.a */)+uintptr(i)*24)).FisPinned == 0) {
				crt.X__assert_fail(tls, ts+41575 /* "p->a[i].isPinned..." */, ts+41197 /* "testdata/sqlite-..." */, uint32(352), uintptr(unsafe.Pointer(&__func__117)))
			}
			(*testpcachePage)(unsafe.Pointer((p + 32 /* &.a */) + uintptr(i)*24)).Fkey = uint32(0)
			(*testpcache)(unsafe.Pointer(p)).FnFree++
			if !((*testpcache)(unsafe.Pointer(p)).FnFree <= 217) {
				crt.X__assert_fail(tls, ts+41545 /* "p->nFree<=217" */, ts+41197 /* "testdata/sqlite-..." */, uint32(355), uintptr(unsafe.Pointer(&__func__117)))
			}
			break
		}
	}

	// Find the page to be rekeyed and rekey it.
	for i = 0; i < 217; i++ {
		if (*testpcachePage)(unsafe.Pointer((p+32 /* &.a */)+uintptr(i)*24)).Fkey == oldKey {
			// The oldKey and pOldPage parameters match
			if !(((p + 32 /* &.a */) + uintptr(i)*24 /* &.page */) == pOldPage) {
				crt.X__assert_fail(tls, ts+41595 /* "&p->a[i].page==p..." */, ts+41197 /* "testdata/sqlite-..." */, uint32(365), uintptr(unsafe.Pointer(&__func__117)))
			}
			// Page to be rekeyed must be pinned
			if !((*testpcachePage)(unsafe.Pointer((p+32 /* &.a */)+uintptr(i)*24)).FisPinned != 0) {
				crt.X__assert_fail(tls, ts+41514 /* "p->a[i].isPinned" */, ts+41197 /* "testdata/sqlite-..." */, uint32(367), uintptr(unsafe.Pointer(&__func__117)))
			}
			(*testpcachePage)(unsafe.Pointer((p + 32 /* &.a */) + uintptr(i)*24)).Fkey = newKey
			return
		}
	}

	// Rekey is always given a valid page to work with
	if !(0 != 0) {
		crt.X__assert_fail(tls, ts+8293 /* "0" */, ts+41197 /* "testdata/sqlite-..." */, uint32(374), uintptr(unsafe.Pointer(&__func__117)))
	}
}

var __func__117 = *(*[16]int8)(unsafe.Pointer(ts + 41619 /* "testpcacheRekey" */)) /* test_pcache.c:339:2 */

// Truncate the page cache.  Every page with a key of iLimit or larger
// is discarded.
func testpcacheTruncate(tls *crt.TLS, pCache uintptr, iLimit uint32) { /* test_pcache.c:382:13: */
	var p uintptr = pCache
	var i uint32
	if !((*testpcache)(unsafe.Pointer(p)).FiMagic == uint32(0x364585fd)) {
		crt.X__assert_fail(tls, ts+41378 /* "p->iMagic==0x364..." */, ts+41197 /* "testdata/sqlite-..." */, uint32(385), uintptr(unsafe.Pointer(&__func__118)))
	}
	if !(testpcacheGlobal.FpDummy != uintptr(0)) {
		crt.X__assert_fail(tls, ts+41315 /* "testpcacheGlobal..." */, ts+41197 /* "testdata/sqlite-..." */, uint32(386), uintptr(unsafe.Pointer(&__func__118)))
	}
	if !(testpcacheGlobal.FnInstance > 0) {
		crt.X__assert_fail(tls, ts+41400 /* "testpcacheGlobal..." */, ts+41197 /* "testdata/sqlite-..." */, uint32(387), uintptr(unsafe.Pointer(&__func__118)))
	}
	for i = uint32(0); i < uint32(217); i++ {
		if (*testpcachePage)(unsafe.Pointer((p+32 /* &.a */)+uintptr(i)*24)).Fkey >= iLimit {
			(*testpcachePage)(unsafe.Pointer((p + 32 /* &.a */) + uintptr(i)*24)).Fkey = uint32(0)
			if (*testpcachePage)(unsafe.Pointer((p+32 /* &.a */)+uintptr(i)*24)).FisPinned != 0 {
				(*testpcache)(unsafe.Pointer(p)).FnPinned--
				if !((*testpcache)(unsafe.Pointer(p)).FnPinned >= 0) {
					crt.X__assert_fail(tls, ts+41531 /* "p->nPinned>=0" */, ts+41197 /* "testdata/sqlite-..." */, uint32(393), uintptr(unsafe.Pointer(&__func__118)))
				}
			}
			(*testpcache)(unsafe.Pointer(p)).FnFree++
			if !((*testpcache)(unsafe.Pointer(p)).FnFree <= 217) {
				crt.X__assert_fail(tls, ts+41545 /* "p->nFree<=217" */, ts+41197 /* "testdata/sqlite-..." */, uint32(396), uintptr(unsafe.Pointer(&__func__118)))
			}
		}
	}
}

var __func__118 = *(*[19]int8)(unsafe.Pointer(ts + 41635 /* "testpcacheTrunca..." */)) /* test_pcache.c:382:72 */

// Destroy a page cache.
func testpcacheDestroy(tls *crt.TLS, pCache uintptr) { /* test_pcache.c:404:13: */
	var p uintptr = pCache
	if !((*testpcache)(unsafe.Pointer(p)).FiMagic == uint32(0x364585fd)) {
		crt.X__assert_fail(tls, ts+41378 /* "p->iMagic==0x364..." */, ts+41197 /* "testdata/sqlite-..." */, uint32(406), uintptr(unsafe.Pointer(&__func__119)))
	}
	if !(testpcacheGlobal.FpDummy != uintptr(0)) {
		crt.X__assert_fail(tls, ts+41315 /* "testpcacheGlobal..." */, ts+41197 /* "testdata/sqlite-..." */, uint32(407), uintptr(unsafe.Pointer(&__func__119)))
	}
	if !(testpcacheGlobal.FnInstance > 0) {
		crt.X__assert_fail(tls, ts+41400 /* "testpcacheGlobal..." */, ts+41197 /* "testdata/sqlite-..." */, uint32(408), uintptr(unsafe.Pointer(&__func__119)))
	}
	(*testpcache)(unsafe.Pointer(p)).FiMagic = 0xd42670d4
	sqlite3.Xsqlite3_free(tls, p)
	testpcacheGlobal.FnInstance--
}

var __func__119 = *(*[18]int8)(unsafe.Pointer(ts + 41654 /* "testpcacheDestro..." */)) /* test_pcache.c:404:54 */

// Invoke this routine to register or unregister the testing pager cache
// implemented by this file.
//
// Install the test pager cache if installFlag is 1 and uninstall it if
// installFlag is 0.
//
// When installing, discardChance is a number between 0 and 100 that
// indicates the probability of discarding a page when unpinning the
// page.  0 means never discard (unless the discard flag is set).
// 100 means always discard.
func installTestPCache(tls *crt.TLS, installFlag int32, discardChance uint32, prngSeed uint32, highStress uint32) { /* test_pcache.c:427:6: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	if !(testpcacheGlobal.FnInstance == 0) {
		crt.X__assert_fail(tls, ts+41270 /* "testpcacheGlobal..." */, ts+41197 /* "testdata/sqlite-..." */, uint32(450), uintptr(unsafe.Pointer(&__func__120)))
	}
	if !(testpcacheGlobal.FpDummy == uintptr(0)) {
		crt.X__assert_fail(tls, ts+41243 /* "testpcacheGlobal..." */, ts+41197 /* "testdata/sqlite-..." */, uint32(451), uintptr(unsafe.Pointer(&__func__120)))
	}
	if !(discardChance <= uint32(100)) {
		crt.X__assert_fail(tls, ts+41672 /* "discardChance<=1..." */, ts+41197 /* "testdata/sqlite-..." */, uint32(452), uintptr(unsafe.Pointer(&__func__120)))
	}
	testpcacheGlobal.FdiscardChance = discardChance
	testpcacheGlobal.FprngSeed = (prngSeed ^ (prngSeed << 16))
	testpcacheGlobal.FhighStress = highStress
	if installFlag != isInstalled {
		if installFlag != 0 {
			sqlite3.Xsqlite3_config(tls, 19, crt.VaList(bp, uintptr(unsafe.Pointer(&defaultPcache))))
			if !(defaultPcache.FxCreate != *(*uintptr)(unsafe.Pointer(&struct {
				f func(*crt.TLS, int32, int32, int32) uintptr
			}{testpcacheCreate}))) {
				crt.X__assert_fail(tls, ts+41691 /* "defaultPcache.xC..." */, ts+41197 /* "testdata/sqlite-..." */, uint32(459), uintptr(unsafe.Pointer(&__func__120)))
			}
			sqlite3.Xsqlite3_config(tls, 18, crt.VaList(bp+8, uintptr(unsafe.Pointer(&testPcache))))
		} else {
			if !(defaultPcache.FxCreate != uintptr(0)) {
				crt.X__assert_fail(tls, ts+41731 /* "defaultPcache.xC..." */, ts+41197 /* "testdata/sqlite-..." */, uint32(462), uintptr(unsafe.Pointer(&__func__120)))
			}
			sqlite3.Xsqlite3_config(tls, 18, crt.VaList(bp+16, uintptr(unsafe.Pointer(&defaultPcache))))
		}
		isInstalled = installFlag
	}
}

var __func__120 = *(*[18]int8)(unsafe.Pointer(ts + 41756 /* "installTestPCach..." */))                                                                                                                   /* test_pcache.c:432:2 */
var testPcache = sqlite3_pcache_methods2{FiVersion: 1, FpArg: 0, FxInit: 0, FxShutdown: 0, FxCreate: 0, FxCachesize: 0, FxPagecount: 0, FxFetch: 0, FxUnpin: 0, FxRekey: 0, FxTruncate: 0, FxDestroy: 0} /* test_pcache.c:433:40 */
var defaultPcache sqlite3_pcache_methods2                                                                                                                                                                /* test_pcache.c:447:34: */
var isInstalled int32 = 0                                                                                                                                                                                /* test_pcache.c:448:14 */

// The following object serves the same role as FILE in the standard C
// library.  It represents an open connection to a file on disk for I/O.
//
// A single quota_FILE should not be used by two or more threads at the
// same time.  Multiple threads can be using different quota_FILE objects
// simultaneously, but not the same quota_FILE object.
type quota_FILE1 = struct {
	Ff     uintptr
	FiOfst sqlite3_int64
	FpFile uintptr
}

// The following object serves the same role as FILE in the standard C
// library.  It represents an open connection to a file on disk for I/O.
//
// A single quota_FILE should not be used by two or more threads at the
// same time.  Multiple threads can be using different quota_FILE objects
// simultaneously, but not the same quota_FILE object.
type quota_FILE = quota_FILE1 /* test_quota.h:145:27 */

// Define some macros helping to catch buffer overflows.

//*********************** Object Definitions *****************************

// Forward declaration of all object types
type quotaGroup1 = struct {
	FzPattern  uintptr
	FiLimit    sqlite3_int64
	FiSize     sqlite3_int64
	FxCallback uintptr
	FpArg      uintptr
	FxDestroy  uintptr
	FpNext     uintptr
	FppPrev    uintptr
	FpFiles    uintptr
}

// Define some macros helping to catch buffer overflows.

//*********************** Object Definitions *****************************

// Forward declaration of all object types
type quotaGroup = quotaGroup1 /* test_quota.c:61:27 */
type quotaConn1 = struct {
	Fbase  sqlite3_file
	FpFile uintptr
}

type quotaConn = quotaConn1 /* test_quota.c:62:26 */
type quotaFile1 = struct {
	FzFilename     uintptr
	FpGroup        uintptr
	FiSize         sqlite3_int64
	FnRef          int32
	FdeleteOnClose int32
	FpNext         uintptr
	FppPrev        uintptr
}

type quotaFile = quotaFile1 /* test_quota.c:63:26 */

//************************ Global Variables *********************************
// All global variables used by this file are containing within the following
// gQuota structure.
var gQuota struct {
	FpOrigVfs      uintptr
	FsThisVfs      sqlite3_vfs
	FsIoMethodsV1  sqlite3_io_methods
	FsIoMethodsV2  sqlite3_io_methods
	FisInitialized int32
	FpMutex        uintptr
	FpGroup        uintptr
} /* test_quota.c:183:3: */

//************************ Utility Routines ********************************
// Acquire and release the mutex used to serialize access to the
// list of quotaGroups.
func quotaEnter(tls *crt.TLS) { /* test_quota.c:190:13: */
	sqlite3.Xsqlite3_mutex_enter(tls, gQuota.FpMutex)
}
func quotaLeave(tls *crt.TLS) { /* test_quota.c:191:13: */
	sqlite3.Xsqlite3_mutex_leave(tls, gQuota.FpMutex)
}

// Count the number of open files in a quotaGroup
func quotaGroupOpenFileCount(tls *crt.TLS, pGroup uintptr) int32 { /* test_quota.c:195:12: */
	var N int32 = 0
	var pFile uintptr = (*quotaGroup)(unsafe.Pointer(pGroup)).FpFiles
	for pFile != 0 {
		if (*quotaFile)(unsafe.Pointer(pFile)).FnRef != 0 {
			N++
		}
		pFile = (*quotaFile)(unsafe.Pointer(pFile)).FpNext
	}
	return N
}

// Remove a file from a quota group.
func quotaRemoveFile(tls *crt.TLS, pFile uintptr) { /* test_quota.c:207:13: */
	var pGroup uintptr = (*quotaFile)(unsafe.Pointer(pFile)).FpGroup
	*(*sqlite3_int64)(unsafe.Pointer(pGroup + 16 /* &.iSize */)) -= ((*quotaFile)(unsafe.Pointer(pFile)).FiSize)
	*(*uintptr)(unsafe.Pointer((*quotaFile)(unsafe.Pointer(pFile)).FppPrev)) = (*quotaFile)(unsafe.Pointer(pFile)).FpNext
	if (*quotaFile)(unsafe.Pointer(pFile)).FpNext != 0 {
		(*quotaFile)(unsafe.Pointer((*quotaFile)(unsafe.Pointer(pFile)).FpNext)).FppPrev = (*quotaFile)(unsafe.Pointer(pFile)).FppPrev
	}
	sqlite3.Xsqlite3_free(tls, pFile)
}

// Remove all files from a quota group.  It is always the case that
// all files will be closed when this routine is called.
func quotaRemoveAllFiles(tls *crt.TLS, pGroup uintptr) { /* test_quota.c:218:13: */
	for (*quotaGroup)(unsafe.Pointer(pGroup)).FpFiles != 0 {
		if !((*quotaFile)(unsafe.Pointer((*quotaGroup)(unsafe.Pointer(pGroup)).FpFiles)).FnRef == 0) {
			crt.X__assert_fail(tls, ts+41774 /* "pGroup->pFiles->..." */, ts+41798 /* "testdata/sqlite-..." */, uint32(220), uintptr(unsafe.Pointer(&__func__121)))
		}
		quotaRemoveFile(tls, (*quotaGroup)(unsafe.Pointer(pGroup)).FpFiles)
	}
}

var __func__121 = *(*[20]int8)(unsafe.Pointer(ts + 41843 /* "quotaRemoveAllFi..." */)) /* test_quota.c:218:52 */

// If the reference count and threshold for a quotaGroup are both
// zero, then destroy the quotaGroup.
func quotaGroupDeref(tls *crt.TLS, pGroup uintptr) { /* test_quota.c:229:13: */
	if ((*quotaGroup)(unsafe.Pointer(pGroup)).FiLimit == int64(0)) && (quotaGroupOpenFileCount(tls, pGroup) == 0) {
		quotaRemoveAllFiles(tls, pGroup)
		*(*uintptr)(unsafe.Pointer((*quotaGroup)(unsafe.Pointer(pGroup)).FppPrev)) = (*quotaGroup)(unsafe.Pointer(pGroup)).FpNext
		if (*quotaGroup)(unsafe.Pointer(pGroup)).FpNext != 0 {
			(*quotaGroup)(unsafe.Pointer((*quotaGroup)(unsafe.Pointer(pGroup)).FpNext)).FppPrev = (*quotaGroup)(unsafe.Pointer(pGroup)).FppPrev
		}
		if (*quotaGroup)(unsafe.Pointer(pGroup)).FxDestroy != 0 {
			(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((pGroup + 40 /* &.xDestroy */))))(tls, (*quotaGroup)(unsafe.Pointer(pGroup)).FpArg)
		}
		sqlite3.Xsqlite3_free(tls, pGroup)
	}
}

// Return TRUE if string z matches glob pattern zGlob.
//
// Globbing rules:
//
//      '*'       Matches any sequence of zero or more characters.
//
//      '?'       Matches exactly one character.
//
//     [...]      Matches one character from the enclosed list of
//                characters.
//
//     [^...]     Matches one character not in the enclosed list.
//
//     /          Matches "/" or "\\"
//
func quotaStrglob(tls *crt.TLS, zGlob uintptr, z uintptr) int32 { /* test_quota.c:256:12: */
	var c int32
	var c2 int32
	var cx int32
	var invert int32
	var seen int32

	for (crt.AssignInt32(&c, int32(*(*int8)(unsafe.Pointer(crt.PostIncUintptr(&zGlob, 1)))))) != 0 {
		if c == '*' {
			for ((crt.AssignInt32(&c, int32(*(*int8)(unsafe.Pointer(crt.PostIncUintptr(&zGlob, 1)))))) == '*') || (c == '?') {
				if (c == '?') && ((int32(*(*int8)(unsafe.Pointer(crt.PostIncUintptr(&z, 1))))) == 0) {
					return 0
				}
			}
			if c == 0 {
				return 1
			} else if c == '[' {
				for (*(*int8)(unsafe.Pointer(z)) != 0) && (quotaStrglob(tls, (zGlob-uintptr(1)), z) == 0) {
					z++
				}
				return (crt.Bool32((int32(*(*int8)(unsafe.Pointer(z)))) != 0))
			}
			if c == '/' {
				cx = '\\'
			} else {
				cx = c
			}
			for (crt.AssignInt32(&c2, int32(*(*int8)(unsafe.Pointer(crt.PostIncUintptr(&z, 1)))))) != 0 {
				for (c2 != c) && (c2 != cx) {
					c2 = int32(*(*int8)(unsafe.Pointer(crt.PostIncUintptr(&z, 1))))
					if c2 == 0 {
						return 0
					}
				}
				if quotaStrglob(tls, zGlob, z) != 0 {
					return 1
				}
			}
			return 0
		} else if c == '?' {
			if (int32(*(*int8)(unsafe.Pointer(crt.PostIncUintptr(&z, 1))))) == 0 {
				return 0
			}
		} else if c == '[' {
			var prior_c int32 = 0
			seen = 0
			invert = 0
			c = int32(*(*int8)(unsafe.Pointer(crt.PostIncUintptr(&z, 1))))
			if c == 0 {
				return 0
			}
			c2 = int32(*(*int8)(unsafe.Pointer(crt.PostIncUintptr(&zGlob, 1))))
			if c2 == '^' {
				invert = 1
				c2 = int32(*(*int8)(unsafe.Pointer(crt.PostIncUintptr(&zGlob, 1))))
			}
			if c2 == ']' {
				if c == ']' {
					seen = 1
				}
				c2 = int32(*(*int8)(unsafe.Pointer(crt.PostIncUintptr(&zGlob, 1))))
			}
			for (c2 != 0) && (c2 != ']') {
				if (((c2 == '-') && (int32(*(*int8)(unsafe.Pointer(zGlob + uintptr(0)))) != ']')) && (int32(*(*int8)(unsafe.Pointer(zGlob + uintptr(0)))) != 0)) && (prior_c > 0) {
					c2 = int32(*(*int8)(unsafe.Pointer(crt.PostIncUintptr(&zGlob, 1))))
					if (c >= prior_c) && (c <= c2) {
						seen = 1
					}
					prior_c = 0
				} else {
					if c == c2 {
						seen = 1
					}
					prior_c = c2
				}
				c2 = int32(*(*int8)(unsafe.Pointer(crt.PostIncUintptr(&zGlob, 1))))
			}
			if (c2 == 0) || ((seen ^ invert) == 0) {
				return 0
			}
		} else if c == '/' {
			if (int32(*(*int8)(unsafe.Pointer(z + uintptr(0)))) != '/') && (int32(*(*int8)(unsafe.Pointer(z + uintptr(0)))) != '\\') {
				return 0
			}
			z++
		} else {
			if c != (int32(*(*int8)(unsafe.Pointer(crt.PostIncUintptr(&z, 1))))) {
				return 0
			}
		}
	}
	return (crt.Bool32(int32(*(*int8)(unsafe.Pointer(z))) == 0))
}

// Find a quotaGroup given the filename.
//
// Return a pointer to the quotaGroup object. Return NULL if not found.
func quotaGroupFind(tls *crt.TLS, zFilename uintptr) uintptr { /* test_quota.c:329:19: */
	var p uintptr
	for p = gQuota.FpGroup; (p != 0) && (quotaStrglob(tls, (*quotaGroup)(unsafe.Pointer(p)).FzPattern, zFilename) == 0); p = (*quotaGroup)(unsafe.Pointer(p)).FpNext {
	}
	return p
}

// Translate an sqlite3_file* that is really a quotaConn* into
// the sqlite3_file* for the underlying original VFS.
func quotaSubOpen(tls *crt.TLS, pConn uintptr) uintptr { /* test_quota.c:339:21: */
	var p uintptr = pConn
	return (p + uintptr(1)*16)
}

// Find a file in a quota group and return a pointer to that file.
// Return NULL if the file is not in the group.
func quotaFindFile(tls *crt.TLS, pGroup uintptr, zName uintptr, createFlag int32) uintptr { /* test_quota.c:347:18: */
	var pFile uintptr = (*quotaGroup)(unsafe.Pointer(pGroup)).FpFiles
	for (pFile != 0) && (crt.Xstrcmp(tls, (*quotaFile)(unsafe.Pointer(pFile)).FzFilename, zName) != 0) {
		pFile = (*quotaFile)(unsafe.Pointer(pFile)).FpNext
	}
	if (pFile == uintptr(0)) && (createFlag != 0) {
		var nName int32 = (int32(crt.Xstrlen(tls, zName) & uint64(0x3fffffff)))
		pFile = sqlite3.Xsqlite3_malloc(tls, (int32((uint64(unsafe.Sizeof(quotaFile{})) + uint64(nName)) + uint64(1))))
		if pFile != 0 {
			crt.Xmemset(tls, pFile, 0, uint64(unsafe.Sizeof(quotaFile{})))
			(*quotaFile)(unsafe.Pointer(pFile)).FzFilename = (pFile + uintptr(1)*48)
			crt.Xmemcpy(tls, (*quotaFile)(unsafe.Pointer(pFile)).FzFilename, zName, (uint64(nName + 1)))
			(*quotaFile)(unsafe.Pointer(pFile)).FpNext = (*quotaGroup)(unsafe.Pointer(pGroup)).FpFiles
			if (*quotaGroup)(unsafe.Pointer(pGroup)).FpFiles != 0 {
				(*quotaFile)(unsafe.Pointer((*quotaGroup)(unsafe.Pointer(pGroup)).FpFiles)).FppPrev = (pFile + 32 /* &.pNext */)
			}
			(*quotaFile)(unsafe.Pointer(pFile)).FppPrev = (pGroup + 64 /* &.pFiles */)
			(*quotaGroup)(unsafe.Pointer(pGroup)).FpFiles = pFile
			(*quotaFile)(unsafe.Pointer(pFile)).FpGroup = pGroup
		}
	}
	return pFile
}

// Translate UTF8 to MBCS for use in fopen() calls.  Return a pointer to the
// translated text..  Call quota_mbcs_free() to deallocate any memory
// used to store the returned pointer when done.
func quota_utf8_to_mbcs(tls *crt.TLS, zUtf8 uintptr) uintptr { /* test_quota.c:377:13: */
	return zUtf8 // No-op on unix
}

// Deallocate any memory allocated by quota_utf8_to_mbcs().
func quota_mbcs_free(tls *crt.TLS, zOld uintptr) { /* test_quota.c:408:13: */
	// No-op on unix
}

//************************ VFS Method Wrappers ****************************
// This is the xOpen method used for the "quota" VFS.
//
// Most of the work is done by the underlying original VFS.  This method
// simply links the new file into the appropriate quota group if it is a
// file that needs to be tracked.
func quotaOpen(tls *crt.TLS, pVfs uintptr, zName uintptr, pConn uintptr, flags int32, pOutFlags uintptr) int32 { /* test_quota.c:424:12: */
	var rc int32                            // Result code
	var pQuotaOpen uintptr                  // The new quota file descriptor
	var pFile uintptr                       // Corresponding quotaFile obj
	var pGroup uintptr                      // The group file belongs to
	var pSubOpen uintptr                    // Real file descriptor
	var pOrigVfs uintptr = gQuota.FpOrigVfs // Real VFS

	// If the file is not a main database file or a WAL, then use the
	// normal xOpen method.
	if (flags & (0x00000100 | 0x00080000)) == 0 {
		return (*(*func(*crt.TLS, uintptr, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer((pOrigVfs + 40 /* &.xOpen */))))(tls, pOrigVfs, zName, pConn, flags, pOutFlags)
	}

	// If the name of the file does not match any quota group, then
	// use the normal xOpen method.
	quotaEnter(tls)
	pGroup = quotaGroupFind(tls, zName)
	if pGroup == uintptr(0) {
		rc = (*(*func(*crt.TLS, uintptr, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer((pOrigVfs + 40 /* &.xOpen */))))(tls, pOrigVfs, zName, pConn, flags, pOutFlags)
	} else {
		// If we get to this point, it means the file needs to be quota tracked.
		pQuotaOpen = pConn
		pSubOpen = quotaSubOpen(tls, pConn)
		rc = (*(*func(*crt.TLS, uintptr, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer((pOrigVfs + 40 /* &.xOpen */))))(tls, pOrigVfs, zName, pSubOpen, flags, pOutFlags)
		if rc == 0 {
			pFile = quotaFindFile(tls, pGroup, zName, 1)
			if pFile == uintptr(0) {
				quotaLeave(tls)
				(*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods + 8 /* &.xClose */))))(tls, pSubOpen)
				return 7
			}
			(*quotaFile)(unsafe.Pointer(pFile)).FdeleteOnClose = (crt.Bool32((flags & 0x00000008) != 0))
			(*quotaFile)(unsafe.Pointer(pFile)).FnRef++
			(*quotaConn)(unsafe.Pointer(pQuotaOpen)).FpFile = pFile
			if (*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods)).FiVersion == 1 {
				(*quotaConn)(unsafe.Pointer(pQuotaOpen)).Fbase.FpMethods = (uintptr(unsafe.Pointer(&gQuota)) + 176 /* &.sIoMethodsV1 */)
			} else {
				(*quotaConn)(unsafe.Pointer(pQuotaOpen)).Fbase.FpMethods = (uintptr(unsafe.Pointer(&gQuota)) + 328 /* &.sIoMethodsV2 */)
			}
		}
	}
	quotaLeave(tls)
	return rc
}

// This is the xDelete method used for the "quota" VFS.
//
// If the file being deleted is part of the quota group, then reduce
// the size of the quota group accordingly.  And remove the file from
// the set of files in the quota group.
func quotaDelete(tls *crt.TLS, pVfs uintptr, zName uintptr, syncDir int32) int32 { /* test_quota.c:486:12: */
	var rc int32                            // Result code
	var pFile uintptr                       // Files in the quota
	var pGroup uintptr                      // The group file belongs to
	var pOrigVfs uintptr = gQuota.FpOrigVfs // Real VFS

	// Do the actual file delete
	rc = (*(*func(*crt.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer((pOrigVfs + 48 /* &.xDelete */))))(tls, pOrigVfs, zName, syncDir)

	// If the file just deleted is a member of a quota group, then remove
	// it from that quota group.
	if rc == 0 {
		quotaEnter(tls)
		pGroup = quotaGroupFind(tls, zName)
		if pGroup != 0 {
			pFile = quotaFindFile(tls, pGroup, zName, 0)
			if pFile != 0 {
				if (*quotaFile)(unsafe.Pointer(pFile)).FnRef != 0 {
					(*quotaFile)(unsafe.Pointer(pFile)).FdeleteOnClose = 1
				} else {
					quotaRemoveFile(tls, pFile)
					quotaGroupDeref(tls, pGroup)
				}
			}
		}
		quotaLeave(tls)
	}
	return rc
}

//*********************** I/O Method Wrappers ******************************

// xClose requests get passed through to the original VFS.  But we
// also have to unlink the quotaConn from the quotaFile and quotaGroup.
// The quotaFile and/or quotaGroup are freed if they are no longer in use.
func quotaClose(tls *crt.TLS, pConn uintptr) int32 { /* test_quota.c:528:12: */
	var p uintptr = pConn
	var pFile uintptr = (*quotaConn)(unsafe.Pointer(p)).FpFile
	var pSubOpen uintptr = quotaSubOpen(tls, pConn)
	var rc int32
	rc = (*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods + 8 /* &.xClose */))))(tls, pSubOpen)
	quotaEnter(tls)
	(*quotaFile)(unsafe.Pointer(pFile)).FnRef--
	if (*quotaFile)(unsafe.Pointer(pFile)).FnRef == 0 {
		var pGroup uintptr = (*quotaFile)(unsafe.Pointer(pFile)).FpGroup
		if (*quotaFile)(unsafe.Pointer(pFile)).FdeleteOnClose != 0 {
			(*(*func(*crt.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer((gQuota.FpOrigVfs + 48 /* &.xDelete */))))(tls, gQuota.FpOrigVfs, (*quotaFile)(unsafe.Pointer(pFile)).FzFilename, 0)
			quotaRemoveFile(tls, pFile)
		}
		quotaGroupDeref(tls, pGroup)
	}
	quotaLeave(tls)
	return rc
}

// Pass xRead requests directory thru to the original VFS without
// further processing.
func quotaRead(tls *crt.TLS, pConn uintptr, pBuf uintptr, iAmt int32, iOfst sqlite3_int64) int32 { /* test_quota.c:551:12: */
	var pSubOpen uintptr = quotaSubOpen(tls, pConn)
	return (*(*func(*crt.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods + 16 /* &.xRead */))))(tls, pSubOpen, pBuf, iAmt, iOfst)
}

// Check xWrite requests to see if they expand the file.  If they do,
// the perform a quota check before passing them through to the
// original VFS.
func quotaWrite(tls *crt.TLS, pConn uintptr, pBuf uintptr, iAmt int32, iOfst sqlite3_int64) int32 { /* test_quota.c:565:12: */
	var p uintptr = pConn
	var pSubOpen uintptr = quotaSubOpen(tls, pConn)
	var iEnd sqlite3_int64 = (iOfst + sqlite3_int64(iAmt))
	var pGroup uintptr
	var pFile uintptr = (*quotaConn)(unsafe.Pointer(p)).FpFile
	var szNew sqlite3_int64

	if (*quotaFile)(unsafe.Pointer(pFile)).FiSize < iEnd {
		pGroup = (*quotaFile)(unsafe.Pointer(pFile)).FpGroup
		quotaEnter(tls)
		szNew = (((*quotaGroup)(unsafe.Pointer(pGroup)).FiSize - (*quotaFile)(unsafe.Pointer(pFile)).FiSize) + iEnd)
		if (szNew > (*quotaGroup)(unsafe.Pointer(pGroup)).FiLimit) && ((*quotaGroup)(unsafe.Pointer(pGroup)).FiLimit > int64(0)) {
			if (*quotaGroup)(unsafe.Pointer(pGroup)).FxCallback != 0 {
				(*(*func(*crt.TLS, uintptr, uintptr, sqlite3_int64, uintptr))(unsafe.Pointer((pGroup + 24 /* &.xCallback */))))(tls, (*quotaFile)(unsafe.Pointer(pFile)).FzFilename, (pGroup + 8 /* &.iLimit */), szNew,
					(*quotaGroup)(unsafe.Pointer(pGroup)).FpArg)
			}
			if (szNew > (*quotaGroup)(unsafe.Pointer(pGroup)).FiLimit) && ((*quotaGroup)(unsafe.Pointer(pGroup)).FiLimit > int64(0)) {
				quotaLeave(tls)
				return 13
			}
		}
		(*quotaGroup)(unsafe.Pointer(pGroup)).FiSize = szNew
		(*quotaFile)(unsafe.Pointer(pFile)).FiSize = iEnd
		quotaLeave(tls)
	}
	return (*(*func(*crt.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods + 24 /* &.xWrite */))))(tls, pSubOpen, pBuf, iAmt, iOfst)
}

// Pass xTruncate requests thru to the original VFS.  If the
// success, update the file size.
func quotaTruncate(tls *crt.TLS, pConn uintptr, size sqlite3_int64) int32 { /* test_quota.c:602:12: */
	var p uintptr = pConn
	var pSubOpen uintptr = quotaSubOpen(tls, pConn)
	var rc int32 = (*(*func(*crt.TLS, uintptr, sqlite3_int64) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods + 32 /* &.xTruncate */))))(tls, pSubOpen, size)
	var pFile uintptr = (*quotaConn)(unsafe.Pointer(p)).FpFile
	var pGroup uintptr
	if rc == 0 {
		quotaEnter(tls)
		pGroup = (*quotaFile)(unsafe.Pointer(pFile)).FpGroup
		*(*sqlite3_int64)(unsafe.Pointer(pGroup + 16 /* &.iSize */)) -= ((*quotaFile)(unsafe.Pointer(pFile)).FiSize)
		(*quotaFile)(unsafe.Pointer(pFile)).FiSize = size
		*(*sqlite3_int64)(unsafe.Pointer(pGroup + 16 /* &.iSize */)) += (size)
		quotaLeave(tls)
	}
	return rc
}

// Pass xSync requests through to the original VFS without change
func quotaSync(tls *crt.TLS, pConn uintptr, flags int32) int32 { /* test_quota.c:621:12: */
	var pSubOpen uintptr = quotaSubOpen(tls, pConn)
	return (*(*func(*crt.TLS, uintptr, int32) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods + 40 /* &.xSync */))))(tls, pSubOpen, flags)
}

// Pass xFileSize requests through to the original VFS but then
// update the quotaGroup with the new size before returning.
func quotaFileSize(tls *crt.TLS, pConn uintptr, pSize uintptr) int32 { /* test_quota.c:629:12: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var p uintptr = pConn
	var pSubOpen uintptr = quotaSubOpen(tls, pConn)
	var pFile uintptr = (*quotaConn)(unsafe.Pointer(p)).FpFile
	var pGroup uintptr
	// var sz sqlite3_int64 at bp, 8

	var rc int32

	rc = (*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods + 48 /* &.xFileSize */))))(tls, pSubOpen, bp /* &sz */)
	if rc == 0 {
		quotaEnter(tls)
		pGroup = (*quotaFile)(unsafe.Pointer(pFile)).FpGroup
		*(*sqlite3_int64)(unsafe.Pointer(pGroup + 16 /* &.iSize */)) -= ((*quotaFile)(unsafe.Pointer(pFile)).FiSize)
		(*quotaFile)(unsafe.Pointer(pFile)).FiSize = *(*sqlite3_int64)(unsafe.Pointer(bp /* sz */))
		*(*sqlite3_int64)(unsafe.Pointer(pGroup + 16 /* &.iSize */)) += (*(*sqlite3_int64)(unsafe.Pointer(bp /* sz */)))
		quotaLeave(tls)
		*(*sqlite3_int64)(unsafe.Pointer(pSize)) = *(*sqlite3_int64)(unsafe.Pointer(bp /* sz */))
	}
	return rc
}

// Pass xLock requests through to the original VFS unchanged.
func quotaLock(tls *crt.TLS, pConn uintptr, lock int32) int32 { /* test_quota.c:652:12: */
	var pSubOpen uintptr = quotaSubOpen(tls, pConn)
	return (*(*func(*crt.TLS, uintptr, int32) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods + 56 /* &.xLock */))))(tls, pSubOpen, lock)
}

// Pass xUnlock requests through to the original VFS unchanged.
func quotaUnlock(tls *crt.TLS, pConn uintptr, lock int32) int32 { /* test_quota.c:659:12: */
	var pSubOpen uintptr = quotaSubOpen(tls, pConn)
	return (*(*func(*crt.TLS, uintptr, int32) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods + 64 /* &.xUnlock */))))(tls, pSubOpen, lock)
}

// Pass xCheckReservedLock requests through to the original VFS unchanged.
func quotaCheckReservedLock(tls *crt.TLS, pConn uintptr, pResOut uintptr) int32 { /* test_quota.c:666:12: */
	var pSubOpen uintptr = quotaSubOpen(tls, pConn)
	return (*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods + 72 /* &.xCheckReservedLock */))))(tls, pSubOpen, pResOut)
}

// Pass xFileControl requests through to the original VFS unchanged.
func quotaFileControl(tls *crt.TLS, pConn uintptr, op int32, pArg uintptr) int32 { /* test_quota.c:673:12: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var pSubOpen uintptr = quotaSubOpen(tls, pConn)
	var rc int32 = (*(*func(*crt.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods + 80 /* &.xFileControl */))))(tls, pSubOpen, op, pArg)
	if (op == 12) && (rc == 0) {
		*(*uintptr)(unsafe.Pointer(pArg)) = sqlite3.Xsqlite3_mprintf(tls, ts+41863 /* "quota/%z" */, crt.VaList(bp, *(*uintptr)(unsafe.Pointer(pArg))))
	}
	return rc
}

// Pass xSectorSize requests through to the original VFS unchanged.
func quotaSectorSize(tls *crt.TLS, pConn uintptr) int32 { /* test_quota.c:686:12: */
	var pSubOpen uintptr = quotaSubOpen(tls, pConn)
	return (*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods + 88 /* &.xSectorSize */))))(tls, pSubOpen)
}

// Pass xDeviceCharacteristics requests through to the original VFS unchanged.
func quotaDeviceCharacteristics(tls *crt.TLS, pConn uintptr) int32 { /* test_quota.c:693:12: */
	var pSubOpen uintptr = quotaSubOpen(tls, pConn)
	return (*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods + 96 /* &.xDeviceCharacteristics */))))(tls, pSubOpen)
}

// Pass xShmMap requests through to the original VFS unchanged.
func quotaShmMap(tls *crt.TLS, pConn uintptr, iRegion int32, szRegion int32, bExtend int32, pp uintptr) int32 { /* test_quota.c:700:12: */
	var pSubOpen uintptr = quotaSubOpen(tls, pConn)
	return (*(*func(*crt.TLS, uintptr, int32, int32, int32, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods + 104 /* &.xShmMap */))))(tls, pSubOpen, iRegion, szRegion, bExtend, pp)
}

// Pass xShmLock requests through to the original VFS unchanged.
func quotaShmLock(tls *crt.TLS, pConn uintptr, ofst int32, n int32, flags int32) int32 { /* test_quota.c:713:12: */
	var pSubOpen uintptr = quotaSubOpen(tls, pConn)
	return (*(*func(*crt.TLS, uintptr, int32, int32, int32) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods + 112 /* &.xShmLock */))))(tls, pSubOpen, ofst, n, flags)
}

// Pass xShmBarrier requests through to the original VFS unchanged.
func quotaShmBarrier(tls *crt.TLS, pConn uintptr) { /* test_quota.c:725:13: */
	var pSubOpen uintptr = quotaSubOpen(tls, pConn)
	(*(*func(*crt.TLS, uintptr))(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods + 120 /* &.xShmBarrier */))))(tls, pSubOpen)
}

// Pass xShmUnmap requests through to the original VFS unchanged.
func quotaShmUnmap(tls *crt.TLS, pConn uintptr, deleteFlag int32) int32 { /* test_quota.c:732:12: */
	var pSubOpen uintptr = quotaSubOpen(tls, pConn)
	return (*(*func(*crt.TLS, uintptr, int32) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods + 128 /* &.xShmUnmap */))))(tls, pSubOpen, deleteFlag)
}

//************************* Public Interfaces ****************************
// Initialize the quota VFS shim.  Use the VFS named zOrigVfsName
// as the VFS that does the actual work.  Use the default if
// zOrigVfsName==NULL.
//
// The quota VFS shim is named "quota".  It will become the default
// VFS if makeDefault is non-zero.
//
// THIS ROUTINE IS NOT THREADSAFE.  Call this routine exactly once
// during start-up.
func sqlite3_quota_initialize(tls *crt.TLS, zOrigVfsName uintptr, makeDefault int32) int32 { /* test_quota.c:749:5: */
	var pOrigVfs uintptr
	if gQuota.FisInitialized != 0 {
		return 21
	}
	pOrigVfs = sqlite3.Xsqlite3_vfs_find(tls, zOrigVfsName)
	if pOrigVfs == uintptr(0) {
		return 1
	}
	if !(pOrigVfs != (uintptr(unsafe.Pointer(&gQuota)) + 8 /* &.sThisVfs */)) {
		crt.X__assert_fail(tls, ts+41872 /* "pOrigVfs!=&gQuot..." */, ts+41798 /* "testdata/sqlite-..." */, uint32(754), uintptr(unsafe.Pointer(&__func__122)))
	}
	gQuota.FpMutex = sqlite3.Xsqlite3_mutex_alloc(tls, 0)
	if !(int32(gQuota.FpMutex) != 0) {
		return 7
	}
	gQuota.FisInitialized = 1
	gQuota.FpOrigVfs = pOrigVfs
	gQuota.FsThisVfs = *(*sqlite3_vfs)(unsafe.Pointer(pOrigVfs))
	gQuota.FsThisVfs.FxOpen = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, uintptr, int32, uintptr) int32
	}{quotaOpen}))
	gQuota.FsThisVfs.FxDelete = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32) int32
	}{quotaDelete}))
	*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&gQuota)) + 8 /* &.sThisVfs */ + 4 /* &.szOsFile */)) += int32((uint64(unsafe.Sizeof(quotaConn{}))))
	gQuota.FsThisVfs.FzName = ts + 41899 /* "quota" */
	gQuota.FsIoMethodsV1.FiVersion = 1
	gQuota.FsIoMethodsV1.FxClose = *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, uintptr) int32 }{quotaClose}))
	gQuota.FsIoMethodsV1.FxRead = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, sqlite3_int64) int32
	}{quotaRead}))
	gQuota.FsIoMethodsV1.FxWrite = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, sqlite3_int64) int32
	}{quotaWrite}))
	gQuota.FsIoMethodsV1.FxTruncate = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, sqlite3_int64) int32
	}{quotaTruncate}))
	gQuota.FsIoMethodsV1.FxSync = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, int32) int32
	}{quotaSync}))
	gQuota.FsIoMethodsV1.FxFileSize = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr) int32
	}{quotaFileSize}))
	gQuota.FsIoMethodsV1.FxLock = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, int32) int32
	}{quotaLock}))
	gQuota.FsIoMethodsV1.FxUnlock = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, int32) int32
	}{quotaUnlock}))
	gQuota.FsIoMethodsV1.FxCheckReservedLock = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr) int32
	}{quotaCheckReservedLock}))
	gQuota.FsIoMethodsV1.FxFileControl = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, int32, uintptr) int32
	}{quotaFileControl}))
	gQuota.FsIoMethodsV1.FxSectorSize = *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, uintptr) int32 }{quotaSectorSize}))
	gQuota.FsIoMethodsV1.FxDeviceCharacteristics = *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, uintptr) int32 }{quotaDeviceCharacteristics}))
	gQuota.FsIoMethodsV2 = gQuota.FsIoMethodsV1
	gQuota.FsIoMethodsV2.FiVersion = 2
	gQuota.FsIoMethodsV2.FxShmMap = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, int32, int32, int32, uintptr) int32
	}{quotaShmMap}))
	gQuota.FsIoMethodsV2.FxShmLock = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, int32, int32, int32) int32
	}{quotaShmLock}))
	gQuota.FsIoMethodsV2.FxShmBarrier = *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, uintptr) }{quotaShmBarrier}))
	gQuota.FsIoMethodsV2.FxShmUnmap = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, int32) int32
	}{quotaShmUnmap}))
	sqlite3.Xsqlite3_vfs_register(tls, (uintptr(unsafe.Pointer(&gQuota)) + 8 /* &.sThisVfs */), makeDefault)
	return 0
}

var __func__122 = *(*[25]int8)(unsafe.Pointer(ts + 41905 /* "sqlite3_quota_in..." */)) /* test_quota.c:749:72 */

// Shutdown the quota system.
//
// All SQLite database connections must be closed before calling this
// routine.
//
// THIS ROUTINE IS NOT THREADSAFE.  Call this routine exactly once while
// shutting down in order to free all remaining quota groups.
func sqlite3_quota_shutdown(tls *crt.TLS) int32 { /* test_quota.c:798:5: */
	var pGroup uintptr
	if gQuota.FisInitialized == 0 {
		return 21
	}
	for pGroup = gQuota.FpGroup; pGroup != 0; pGroup = (*quotaGroup)(unsafe.Pointer(pGroup)).FpNext {
		if quotaGroupOpenFileCount(tls, pGroup) > 0 {
			return 21
		}
	}
	for gQuota.FpGroup != 0 {
		pGroup = gQuota.FpGroup
		gQuota.FpGroup = (*quotaGroup)(unsafe.Pointer(pGroup)).FpNext
		(*quotaGroup)(unsafe.Pointer(pGroup)).FiLimit = int64(0)
		if !(quotaGroupOpenFileCount(tls, pGroup) == 0) {
			crt.X__assert_fail(tls, ts+41930 /* "quotaGroupOpenFi..." */, ts+41798 /* "testdata/sqlite-..." */, uint32(808), uintptr(unsafe.Pointer(&__func__123)))
		}
		quotaGroupDeref(tls, pGroup)
	}
	gQuota.FisInitialized = 0
	sqlite3.Xsqlite3_mutex_free(tls, gQuota.FpMutex)
	sqlite3.Xsqlite3_vfs_unregister(tls, (uintptr(unsafe.Pointer(&gQuota)) + 8 /* &.sThisVfs */))
	crt.Xmemset(tls, uintptr(unsafe.Pointer(&gQuota)), 0, uint64(unsafe.Sizeof(gQuota)))
	return 0
}

var __func__123 = *(*[23]int8)(unsafe.Pointer(ts + 41965 /* "sqlite3_quota_sh..." */)) /* test_quota.c:798:33 */

// Create or destroy a quota group.
//
// The quota group is defined by the zPattern.  When calling this routine
// with a zPattern for a quota group that already exists, this routine
// merely updates the iLimit, xCallback, and pArg values for that quota
// group.  If zPattern is new, then a new quota group is created.
//
// If the iLimit for a quota group is set to zero, then the quota group
// is disabled and will be deleted when the last database connection using
// the quota group is closed.
//
// Calling this routine on a zPattern that does not exist and with a
// zero iLimit is a no-op.
//
// A quota group must exist with a non-zero iLimit prior to opening
// database connections if those connections are to participate in the
// quota group.  Creating a quota group does not affect database connections
// that are already open.
func sqlite3_quota_set(tls *crt.TLS, zPattern uintptr, iLimit sqlite3_int64, xCallback uintptr, pArg uintptr, xDestroy uintptr) int32 { /* test_quota.c:838:5: */
	var pGroup uintptr
	quotaEnter(tls)
	pGroup = gQuota.FpGroup
	for (pGroup != 0) && (crt.Xstrcmp(tls, (*quotaGroup)(unsafe.Pointer(pGroup)).FzPattern, zPattern) != 0) {
		pGroup = (*quotaGroup)(unsafe.Pointer(pGroup)).FpNext
	}
	if pGroup == uintptr(0) {
		var nPattern int32 = (int32(crt.Xstrlen(tls, zPattern) & uint64(0x3fffffff)))
		if iLimit <= int64(0) {
			quotaLeave(tls)
			return 0
		}
		pGroup = sqlite3.Xsqlite3_malloc(tls, (int32((uint64(unsafe.Sizeof(quotaGroup{})) + uint64(nPattern)) + uint64(1))))
		if pGroup == uintptr(0) {
			quotaLeave(tls)
			return 7
		}
		crt.Xmemset(tls, pGroup, 0, uint64(unsafe.Sizeof(quotaGroup{})))
		(*quotaGroup)(unsafe.Pointer(pGroup)).FzPattern = (pGroup + uintptr(1)*72)
		crt.Xmemcpy(tls, (*quotaGroup)(unsafe.Pointer(pGroup)).FzPattern, zPattern, (uint64(nPattern + 1)))
		if gQuota.FpGroup != 0 {
			(*quotaGroup)(unsafe.Pointer(gQuota.FpGroup)).FppPrev = (pGroup + 48 /* &.pNext */)
		}
		(*quotaGroup)(unsafe.Pointer(pGroup)).FpNext = gQuota.FpGroup
		(*quotaGroup)(unsafe.Pointer(pGroup)).FppPrev = (uintptr(unsafe.Pointer(&gQuota)) + 496 /* &.pGroup */)
		gQuota.FpGroup = pGroup
	}
	(*quotaGroup)(unsafe.Pointer(pGroup)).FiLimit = iLimit
	(*quotaGroup)(unsafe.Pointer(pGroup)).FxCallback = xCallback
	if ((*quotaGroup)(unsafe.Pointer(pGroup)).FxDestroy != 0) && ((*quotaGroup)(unsafe.Pointer(pGroup)).FpArg != pArg) {
		(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((pGroup + 40 /* &.xDestroy */))))(tls, (*quotaGroup)(unsafe.Pointer(pGroup)).FpArg)
	}
	(*quotaGroup)(unsafe.Pointer(pGroup)).FpArg = pArg
	(*quotaGroup)(unsafe.Pointer(pGroup)).FxDestroy = xDestroy
	quotaGroupDeref(tls, pGroup)
	quotaLeave(tls)
	return 0
}

// Bring the named file under quota management.  Or if it is already under
// management, update its size.
func sqlite3_quota_file(tls *crt.TLS, zFilename uintptr) int32 { /* test_quota.c:891:5: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var zFull uintptr = uintptr(0)
	var fd uintptr
	var rc int32
	*(*int32)(unsafe.Pointer(bp /* outFlags */)) = 0
	// var iSize sqlite3_int64 at bp+8, 8

	var nAlloc int32 = ((gQuota.FsThisVfs.FszOsFile + gQuota.FsThisVfs.FmxPathname) + 2)

	// Allocate space for a file-handle and the full path for file zFilename
	fd = sqlite3.Xsqlite3_malloc(tls, nAlloc)
	if fd == uintptr(0) {
		rc = 7
	} else {
		zFull = ((fd) + uintptr(gQuota.FsThisVfs.FszOsFile))
		rc = (*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer((gQuota.FpOrigVfs + 64 /* &.xFullPathname */))))(tls, gQuota.FpOrigVfs, zFilename,
			(gQuota.FsThisVfs.FmxPathname + 1), zFull)
	}

	if rc == 0 {
		*(*int8)(unsafe.Pointer(zFull + uintptr((crt.Xstrlen(tls, zFull) + uint64(1))))) = int8(0)
		rc = quotaOpen(tls, (uintptr(unsafe.Pointer(&gQuota)) + 8 /* &.sThisVfs */), zFull, fd,
			(0x00000001 | 0x00000100), bp /* &outFlags */)
		if rc == 0 {
			(*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(fd)).FpMethods + 48 /* &.xFileSize */))))(tls, fd, bp+8 /* &iSize */)
			(*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(fd)).FpMethods + 8 /* &.xClose */))))(tls, fd)
		} else if rc == 14 {
			var pGroup uintptr
			var pFile uintptr
			quotaEnter(tls)
			pGroup = quotaGroupFind(tls, zFull)
			if pGroup != 0 {
				pFile = quotaFindFile(tls, pGroup, zFull, 0)
				if pFile != 0 {
					quotaRemoveFile(tls, pFile)
				}
			}
			quotaLeave(tls)
		}
	}

	sqlite3.Xsqlite3_free(tls, fd)
	return rc
}

// Open a potentially quotaed file for I/O.
func sqlite3_quota_fopen(tls *crt.TLS, zFilename uintptr, zMode uintptr) uintptr { /* test_quota.c:936:12: */
	var p uintptr
	var zFull uintptr
	var zFullTranslated uintptr
	var rc int32
	var pGroup uintptr
	var pFile uintptr
	p = uintptr(0)
	zFull = uintptr(0)
	zFullTranslated = uintptr(0)

	zFull = sqlite3.Xsqlite3_malloc(tls, (gQuota.FsThisVfs.FmxPathname + 1))
	if !(zFull == uintptr(0)) {
		goto __1
	}
	return uintptr(0)
__1:
	;
	rc = (*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer((gQuota.FpOrigVfs + 64 /* &.xFullPathname */))))(tls, gQuota.FpOrigVfs, zFilename,
		(gQuota.FsThisVfs.FmxPathname + 1), zFull)
	if !(rc != 0) {
		goto __2
	}
	goto quota_fopen_error
__2:
	;
	p = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(quota_FILE{})))
	if !(p == uintptr(0)) {
		goto __3
	}
	goto quota_fopen_error
__3:
	;
	crt.Xmemset(tls, p, 0, uint64(unsafe.Sizeof(quota_FILE{})))
	zFullTranslated = quota_utf8_to_mbcs(tls, zFull)
	if !(zFullTranslated == uintptr(0)) {
		goto __4
	}
	goto quota_fopen_error
__4:
	;
	(*quota_FILE)(unsafe.Pointer(p)).Ff = crt.Xfopen(tls, zFullTranslated, zMode)
	if !((*quota_FILE)(unsafe.Pointer(p)).Ff == uintptr(0)) {
		goto __5
	}
	goto quota_fopen_error
__5:
	;
	quotaEnter(tls)
	pGroup = quotaGroupFind(tls, zFull)
	if !(pGroup != 0) {
		goto __6
	}
	pFile = quotaFindFile(tls, pGroup, zFull, 1)
	if !(pFile == uintptr(0)) {
		goto __7
	}
	quotaLeave(tls)
	goto quota_fopen_error
__7:
	;
	(*quotaFile)(unsafe.Pointer(pFile)).FnRef++
	(*quota_FILE)(unsafe.Pointer(p)).FpFile = pFile
__6:
	;
	quotaLeave(tls)
	sqlite3.Xsqlite3_free(tls, zFull)
	return p

quota_fopen_error:
	quota_mbcs_free(tls, zFullTranslated)
	sqlite3.Xsqlite3_free(tls, zFull)
	if !((p != 0) && ((*quota_FILE)(unsafe.Pointer(p)).Ff != 0)) {
		goto __8
	}
	crt.Xfclose(tls, (*quota_FILE)(unsafe.Pointer(p)).Ff)
__8:
	;
	sqlite3.Xsqlite3_free(tls, p)
	return uintptr(0)
}

// Read content from a quota_FILE
func sqlite3_quota_fread(tls *crt.TLS, pBuf uintptr, size size_t, nmemb size_t, p uintptr) size_t { /* test_quota.c:985:8: */
	return crt.Xfread(tls, pBuf, size, nmemb, (*quota_FILE)(unsafe.Pointer(p)).Ff)
}

// Write content into a quota_FILE.  Invoke the quota callback and block
// the write if we exceed quota.
func sqlite3_quota_fwrite(tls *crt.TLS, pBuf uintptr, size size_t, nmemb size_t, p uintptr) size_t { /* test_quota.c:998:8: */
	var iOfst sqlite3_int64
	var iEnd sqlite3_int64
	var szNew sqlite3_int64
	var pFile uintptr
	var rc size_t

	iOfst = sqlite3_int64(crt.Xftell(tls, (*quota_FILE)(unsafe.Pointer(p)).Ff))
	iEnd = (sqlite3_int64(uint64(iOfst) + (uint64(size * nmemb))))
	pFile = (*quota_FILE)(unsafe.Pointer(p)).FpFile
	if (pFile != 0) && ((*quotaFile)(unsafe.Pointer(pFile)).FiSize < iEnd) {
		var pGroup uintptr = (*quotaFile)(unsafe.Pointer(pFile)).FpGroup
		quotaEnter(tls)
		szNew = (((*quotaGroup)(unsafe.Pointer(pGroup)).FiSize - (*quotaFile)(unsafe.Pointer(pFile)).FiSize) + iEnd)
		if (szNew > (*quotaGroup)(unsafe.Pointer(pGroup)).FiLimit) && ((*quotaGroup)(unsafe.Pointer(pGroup)).FiLimit > int64(0)) {
			if (*quotaGroup)(unsafe.Pointer(pGroup)).FxCallback != 0 {
				(*(*func(*crt.TLS, uintptr, uintptr, sqlite3_int64, uintptr))(unsafe.Pointer((pGroup + 24 /* &.xCallback */))))(tls, (*quotaFile)(unsafe.Pointer(pFile)).FzFilename, (pGroup + 8 /* &.iLimit */), szNew,
					(*quotaGroup)(unsafe.Pointer(pGroup)).FpArg)
			}
			if (szNew > (*quotaGroup)(unsafe.Pointer(pGroup)).FiLimit) && ((*quotaGroup)(unsafe.Pointer(pGroup)).FiLimit > int64(0)) {
				iEnd = (((*quotaGroup)(unsafe.Pointer(pGroup)).FiLimit - (*quotaGroup)(unsafe.Pointer(pGroup)).FiSize) + (*quotaFile)(unsafe.Pointer(pFile)).FiSize)
				nmemb = (size_t((uint64(iEnd - iOfst)) / uint64(size)))
				iEnd = (sqlite3_int64(uint64(iOfst) + (uint64(size * nmemb))))
				szNew = (((*quotaGroup)(unsafe.Pointer(pGroup)).FiSize - (*quotaFile)(unsafe.Pointer(pFile)).FiSize) + iEnd)
			}
		}
		(*quotaGroup)(unsafe.Pointer(pGroup)).FiSize = szNew
		(*quotaFile)(unsafe.Pointer(pFile)).FiSize = iEnd
		quotaLeave(tls)
	} else {
		pFile = uintptr(0)
	}
	rc = crt.Xfwrite(tls, pBuf, size, nmemb, (*quota_FILE)(unsafe.Pointer(p)).Ff)

	// If the write was incomplete, adjust the file size and group size
	// downward
	if (rc < nmemb) && (pFile != 0) {
		var nWritten size_t = rc
		var iNewEnd sqlite3_int64 = (sqlite3_int64(uint64(iOfst) + (uint64(size * nWritten))))
		if iNewEnd < iEnd {
			iNewEnd = iEnd
		}
		quotaEnter(tls)
		*(*sqlite3_int64)(unsafe.Pointer((*quotaFile)(unsafe.Pointer(pFile)).FpGroup + 16 /* &.iSize */)) += (iNewEnd - (*quotaFile)(unsafe.Pointer(pFile)).FiSize)
		(*quotaFile)(unsafe.Pointer(pFile)).FiSize = iNewEnd
		quotaLeave(tls)
	}
	return rc
}

// Close an open quota_FILE stream.
func sqlite3_quota_fclose(tls *crt.TLS, p uintptr) int32 { /* test_quota.c:1054:5: */
	var rc int32
	var pFile uintptr
	rc = crt.Xfclose(tls, (*quota_FILE)(unsafe.Pointer(p)).Ff)
	pFile = (*quota_FILE)(unsafe.Pointer(p)).FpFile
	if pFile != 0 {
		quotaEnter(tls)
		(*quotaFile)(unsafe.Pointer(pFile)).FnRef--
		if (*quotaFile)(unsafe.Pointer(pFile)).FnRef == 0 {
			var pGroup uintptr = (*quotaFile)(unsafe.Pointer(pFile)).FpGroup
			if (*quotaFile)(unsafe.Pointer(pFile)).FdeleteOnClose != 0 {
				(*(*func(*crt.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer((gQuota.FpOrigVfs + 48 /* &.xDelete */))))(tls, gQuota.FpOrigVfs, (*quotaFile)(unsafe.Pointer(pFile)).FzFilename, 0)
				quotaRemoveFile(tls, pFile)
			}
			quotaGroupDeref(tls, pGroup)
		}
		quotaLeave(tls)
	}
	sqlite3.Xsqlite3_free(tls, p)
	return rc
}

// Flush memory buffers for a quota_FILE to disk.
func sqlite3_quota_fflush(tls *crt.TLS, p uintptr, doFsync int32) int32 { /* test_quota.c:1082:5: */
	var rc int32
	rc = crt.Xfflush(tls, (*quota_FILE)(unsafe.Pointer(p)).Ff)
	if (rc == 0) && (doFsync != 0) {
		rc = crt.Xfsync(tls, crt.Xfileno(tls, (*quota_FILE)(unsafe.Pointer(p)).Ff))
	}
	return (crt.Bool32(rc != 0))
}

// Seek on a quota_FILE stream.
func sqlite3_quota_fseek(tls *crt.TLS, p uintptr, offset int64, whence int32) int32 { /* test_quota.c:1099:5: */
	return crt.Xfseek(tls, (*quota_FILE)(unsafe.Pointer(p)).Ff, offset, whence)
}

// rewind a quota_FILE stream.
func sqlite3_quota_rewind(tls *crt.TLS, p uintptr) { /* test_quota.c:1106:6: */
	crt.Xrewind(tls, (*quota_FILE)(unsafe.Pointer(p)).Ff)
}

// Tell the current location of a quota_FILE stream.
func sqlite3_quota_ftell(tls *crt.TLS, p uintptr) int64 { /* test_quota.c:1113:6: */
	return crt.Xftell(tls, (*quota_FILE)(unsafe.Pointer(p)).Ff)
}

// Test the error indicator for the given file.
func sqlite3_quota_ferror(tls *crt.TLS, p uintptr) int32 { /* test_quota.c:1120:5: */
	return crt2.Xferror(tls, (*quota_FILE)(unsafe.Pointer(p)).Ff)
}

// Truncate a file to szNew bytes.
func sqlite3_quota_ftruncate(tls *crt.TLS, p uintptr, szNew sqlite3_int64) int32 { /* test_quota.c:1127:5: */
	var pFile uintptr = (*quota_FILE)(unsafe.Pointer(p)).FpFile
	var rc int32
	if ((crt.AssignUintptr(&pFile, (*quota_FILE)(unsafe.Pointer(p)).FpFile)) != uintptr(0)) && ((*quotaFile)(unsafe.Pointer(pFile)).FiSize < szNew) {
		var pGroup uintptr
		if (*quotaFile)(unsafe.Pointer(pFile)).FiSize < szNew {
			// This routine cannot be used to extend a file that is under
			// quota management.  Only true truncation is allowed.
			return -1
		}
		pGroup = (*quotaFile)(unsafe.Pointer(pFile)).FpGroup
		quotaEnter(tls)
		*(*sqlite3_int64)(unsafe.Pointer(pGroup + 16 /* &.iSize */)) += (szNew - (*quotaFile)(unsafe.Pointer(pFile)).FiSize)
		quotaLeave(tls)
	}
	rc = crt.Xftruncate(tls, crt.Xfileno(tls, (*quota_FILE)(unsafe.Pointer(p)).Ff), int64(szNew))
	if (pFile != 0) && (rc == 0) {
		var pGroup uintptr = (*quotaFile)(unsafe.Pointer(pFile)).FpGroup
		quotaEnter(tls)
		*(*sqlite3_int64)(unsafe.Pointer(pGroup + 16 /* &.iSize */)) += (szNew - (*quotaFile)(unsafe.Pointer(pFile)).FiSize)
		(*quotaFile)(unsafe.Pointer(pFile)).FiSize = szNew
		quotaLeave(tls)
	}
	return rc
}

// Determine the time that the given file was last modified, in
// seconds size 1970.  Write the result into *pTime.  Return 0 on
// success and non-zero on any kind of error.
func sqlite3_quota_file_mtime(tls *crt.TLS, p uintptr, pTime uintptr) int32 { /* test_quota.c:1169:5: */
	bp := tls.Alloc(144)
	defer tls.Free(144)

	var rc int32
	// var buf struct {Fst_dev uint64;Fst_ino uint64;Fst_nlink uint64;Fst_mode uint32;Fst_uid uint32;Fst_gid uint32;F__pad0 int32;Fst_rdev uint64;Fst_size int64;Fst_blksize int64;Fst_blocks int64;Fst_atim timespec;Fst_mtim timespec;Fst_ctim timespec;F__glibc_reserved [3]int64;} at bp, 144

	rc = crt2.Xfstat(tls, crt.Xfileno(tls, (*quota_FILE)(unsafe.Pointer(p)).Ff), bp /* &buf */)
	if rc == 0 {
		*(*time_t)(unsafe.Pointer(pTime)) = (*struct {
			Fst_dev           uint64
			Fst_ino           uint64
			Fst_nlink         uint64
			Fst_mode          uint32
			Fst_uid           uint32
			Fst_gid           uint32
			F__pad0           int32
			Fst_rdev          uint64
			Fst_size          int64
			Fst_blksize       int64
			Fst_blocks        int64
			Fst_atim          timespec
			Fst_mtim          timespec
			Fst_ctim          timespec
			F__glibc_reserved [3]int64
		})(unsafe.Pointer(bp /* &buf */)).Fst_mtim.Ftv_sec
	}
	return rc
}

// Return the true size of the file, as reported by the operating
// system.
func sqlite3_quota_file_truesize(tls *crt.TLS, p uintptr) sqlite3_int64 { /* test_quota.c:1187:15: */
	bp := tls.Alloc(144)
	defer tls.Free(144)

	var rc int32
	// var buf struct {Fst_dev uint64;Fst_ino uint64;Fst_nlink uint64;Fst_mode uint32;Fst_uid uint32;Fst_gid uint32;F__pad0 int32;Fst_rdev uint64;Fst_size int64;Fst_blksize int64;Fst_blocks int64;Fst_atim timespec;Fst_mtim timespec;Fst_ctim timespec;F__glibc_reserved [3]int64;} at bp, 144

	rc = crt2.Xfstat(tls, crt.Xfileno(tls, (*quota_FILE)(unsafe.Pointer(p)).Ff), bp /* &buf */)
	if rc == 0 {
		return int64((*struct {
			Fst_dev           uint64
			Fst_ino           uint64
			Fst_nlink         uint64
			Fst_mode          uint32
			Fst_uid           uint32
			Fst_gid           uint32
			F__pad0           int32
			Fst_rdev          uint64
			Fst_size          int64
			Fst_blksize       int64
			Fst_blocks        int64
			Fst_atim          timespec
			Fst_mtim          timespec
			Fst_ctim          timespec
			F__glibc_reserved [3]int64
		})(unsafe.Pointer(bp /* &buf */)).Fst_size)
	}
	return int64(-1)
}

// Return the size of the file, as it is known to the quota subsystem.
func sqlite3_quota_file_size(tls *crt.TLS, p uintptr) sqlite3_int64 { /* test_quota.c:1203:15: */
	if (*quota_FILE)(unsafe.Pointer(p)).FpFile != 0 {
		return (*quotaFile)(unsafe.Pointer((*quota_FILE)(unsafe.Pointer(p)).FpFile)).FiSize
	}
	return int64(-1)
}

// Determine the amount of data in bytes available for reading
// in the given file.
func sqlite3_quota_file_available(tls *crt.TLS, p uintptr) int64 { /* test_quota.c:1211:6: */
	var f uintptr = (*quota_FILE)(unsafe.Pointer(p)).Ff
	var pos1 int64
	var pos2 int64
	var rc int32
	pos1 = crt.Xftell(tls, f)
	if pos1 < int64(0) {
		return int64(-1)
	}
	rc = crt.Xfseek(tls, f, int64(0), 2)
	if rc != 0 {
		return int64(-1)
	}
	pos2 = crt.Xftell(tls, f)
	if pos2 < int64(0) {
		return int64(-1)
	}
	rc = crt.Xfseek(tls, f, pos1, 0)
	if rc != 0 {
		return int64(-1)
	}
	return (pos2 - pos1)
}

// Remove a managed file.  Update quotas accordingly.
func sqlite3_quota_remove(tls *crt.TLS, zFilename uintptr) int32 { /* test_quota.c:1229:5: */
	var zFull uintptr     // Full pathname for zFilename
	var nFull size_t      // Number of bytes in zFilename
	var rc int32          // Result code
	var pGroup uintptr    // Group containing zFilename
	var pFile uintptr     // A file in the group
	var pNextFile uintptr // next file in the group
	var diff int32        // Difference between filenames
	var c int8            // First character past end of pattern

	zFull = sqlite3.Xsqlite3_malloc(tls, (gQuota.FsThisVfs.FmxPathname + 1))
	if zFull == uintptr(0) {
		return 7
	}
	rc = (*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer((gQuota.FpOrigVfs + 64 /* &.xFullPathname */))))(tls, gQuota.FpOrigVfs, zFilename,
		(gQuota.FsThisVfs.FmxPathname + 1), zFull)
	if rc != 0 {
		sqlite3.Xsqlite3_free(tls, zFull)
		return rc
	}

	// Figure out the length of the full pathname.  If the name ends with
	// / (or \ on windows) then remove the trailing /.
	nFull = crt.Xstrlen(tls, zFull)
	if (nFull > uint64(0)) && ((int32(*(*int8)(unsafe.Pointer(zFull + uintptr((nFull - uint64(1)))))) == '/') || (int32(*(*int8)(unsafe.Pointer(zFull + uintptr((nFull - uint64(1)))))) == '\\')) {
		nFull--
		*(*int8)(unsafe.Pointer(zFull + uintptr(nFull))) = int8(0)
	}

	quotaEnter(tls)
	pGroup = quotaGroupFind(tls, zFull)
	if pGroup != 0 {
		for pFile = (*quotaGroup)(unsafe.Pointer(pGroup)).FpFiles; (pFile != 0) && (rc == 0); pFile = pNextFile {
			pNextFile = (*quotaFile)(unsafe.Pointer(pFile)).FpNext
			diff = crt.Xstrncmp(tls, zFull, (*quotaFile)(unsafe.Pointer(pFile)).FzFilename, nFull)
			if (diff == 0) && ((((int32(crt.AssignInt8(&c, *(*int8)(unsafe.Pointer((*quotaFile)(unsafe.Pointer(pFile)).FzFilename + uintptr(nFull)))))) == 0) || (int32(c) == '/')) || (int32(c) == '\\')) {
				if (*quotaFile)(unsafe.Pointer(pFile)).FnRef != 0 {
					(*quotaFile)(unsafe.Pointer(pFile)).FdeleteOnClose = 1
				} else {
					rc = (*(*func(*crt.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer((gQuota.FpOrigVfs + 48 /* &.xDelete */))))(tls, gQuota.FpOrigVfs, (*quotaFile)(unsafe.Pointer(pFile)).FzFilename, 0)
					quotaRemoveFile(tls, pFile)
					quotaGroupDeref(tls, pGroup)
				}
			}
		}
	}
	quotaLeave(tls)
	sqlite3.Xsqlite3_free(tls, zFull)
	return rc
}

type Tcl_StatBuf1 = struct {
	Fst_dev           uint64
	Fst_ino           uint64
	Fst_nlink         uint64
	Fst_mode          uint32
	Fst_uid           uint32
	Fst_gid           uint32
	F__pad0           int32
	Fst_rdev          uint64
	Fst_size          int64
	Fst_blksize       int64
	Fst_blocks        int64
	Fst_atim          timespec
	Fst_mtim          timespec
	Fst_ctim          timespec
	F__glibc_reserved [3]int64
} /* tcl.h:470:25 */

// end block for C++

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:

// Argument passed to a TCL quota-over-limit callback.
type TclQuotaCallback1 = struct {
	Finterp  uintptr
	FpScript uintptr
}

// end block for C++

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:

// Argument passed to a TCL quota-over-limit callback.
type TclQuotaCallback = TclQuotaCallback1 /* test_quota.c:1293:33 */

// This is the callback from a quota-over-limit.
func tclQuotaCallback(tls *crt.TLS, zFilename uintptr, piLimit uintptr, iSize sqlite3_int64, pArg uintptr) { /* test_quota.c:1305:13: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var p uintptr        // Callback script object
	var pEval uintptr    // Script to evaluate
	var pVarname uintptr // Name of variable to pass as 2nd arg
	// var rnd uint32 at bp, 4
	// Random part of pVarname
	var rc int32 // Tcl error code

	p = pArg
	if p == uintptr(0) {
		return
	}

	pVarname = tcl.XTcl_NewStringObj(tls, ts+41988 /* "::piLimit_" */, -1)
	(*Tcl_Obj)(unsafe.Pointer(pVarname)).FrefCount++
	sqlite3.Xsqlite3_randomness(tls, int32(unsafe.Sizeof(uint32(0))), bp /* &rnd */)
	tcl.XTcl_AppendObjToObj(tls, pVarname, tcl.XTcl_NewIntObj(tls, (int32(*(*uint32)(unsafe.Pointer(bp /* rnd */))&uint32(0x7FFFFFFF)))))
	tcl.XTcl_ObjSetVar2(tls, (*TclQuotaCallback)(unsafe.Pointer(p)).Finterp, pVarname, uintptr(0), tcl.XTcl_NewWideIntObj(tls, int64(*(*sqlite3_int64)(unsafe.Pointer(piLimit)))), 0)

	pEval = tcl.XTcl_DuplicateObj(tls, (*TclQuotaCallback)(unsafe.Pointer(p)).FpScript)
	(*Tcl_Obj)(unsafe.Pointer(pEval)).FrefCount++
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pEval, tcl.XTcl_NewStringObj(tls, zFilename, -1))
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pEval, pVarname)
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pEval, tcl.XTcl_NewWideIntObj(tls, int64(iSize)))
	rc = tcl.XTcl_EvalObjEx(tls, (*TclQuotaCallback)(unsafe.Pointer(p)).Finterp, pEval, 0x020000)

	if rc == 0 {
		// var x Tcl_WideInt at bp+8, 8

		var pLimit uintptr = tcl.XTcl_ObjGetVar2(tls, (*TclQuotaCallback)(unsafe.Pointer(p)).Finterp, pVarname, uintptr(0), 0)
		rc = tcl.XTcl_GetWideIntFromObj(tls, (*TclQuotaCallback)(unsafe.Pointer(p)).Finterp, pLimit, bp+8 /* &x */)
		*(*sqlite3_int64)(unsafe.Pointer(piLimit)) = sqlite3_int64(*(*Tcl_WideInt)(unsafe.Pointer(bp + 8 /* x */)))
		tcl.XTcl_UnsetVar2(tls, (*TclQuotaCallback)(unsafe.Pointer(p)).Finterp, tcl.XTcl_GetString(tls, pVarname), uintptr(0), 0)
	}

	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = pEval
		if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	for ok1 := true; ok1; ok1 = 0 != 0 {
		var _objPtr uintptr = pVarname
		if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	if rc != 0 {
		tcl.XTcl_BackgroundError(tls, (*TclQuotaCallback)(unsafe.Pointer(p)).Finterp)
	}
}

// Destructor for a TCL quota-over-limit callback.
func tclCallbackDestructor(tls *crt.TLS, pObj uintptr) { /* test_quota.c:1349:13: */
	var p uintptr = pObj
	if p != 0 {
		for ok := true; ok; ok = 0 != 0 {
			var _objPtr uintptr = (*TclQuotaCallback)(unsafe.Pointer(p)).FpScript
			if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
		sqlite3.Xsqlite3_free(tls, p)
	}
}

// tclcmd: sqlite3_quota_initialize NAME MAKEDEFAULT
func test_quota_initialize(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_quota.c:1360:26: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var zName uintptr // Name of new quota VFS
	// var makeDefault int32 at bp, 4
	// True to make the new VFS the default
	var rc int32 // Value returned by quota_initialize()

	// Process arguments
	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+39854 /* "NAME MAKEDEFAULT" */)
		return 1
	}
	zName = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)))
	if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)), bp /* &makeDefault */) != 0 {
		return 1
	}
	if int32(*(*int8)(unsafe.Pointer(zName + uintptr(0)))) == 0 {
		zName = uintptr(0)
	}

	// Call sqlite3_quota_initialize()
	rc = sqlite3_quota_initialize(tls, zName, *(*int32)(unsafe.Pointer(bp /* makeDefault */)))
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))

	return 0
}

// tclcmd: sqlite3_quota_shutdown
func test_quota_shutdown(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_quota.c:1389:26: */
	var rc int32 // Value returned by quota_shutdown()

	if objc != 1 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+792 /* "" */)
		return 1
	}

	// Call sqlite3_quota_shutdown()
	rc = sqlite3_quota_shutdown(tls)
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))

	return 0
}

// tclcmd: sqlite3_quota_set PATTERN LIMIT SCRIPT
func test_quota_set(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_quota.c:1412:26: */
	bp := tls.Alloc(12)
	defer tls.Free(12)

	var zPattern uintptr // File pattern to configure
	// var iLimit Tcl_WideInt at bp, 8
	// Initial quota in bytes
	var pScript uintptr // Tcl script to invoke to increase quota
	var rc int32        // Value returned by quota_set()
	var p uintptr       // Callback object
	// var nScript int32 at bp+8, 4
	// Length of callback script
	var xDestroy uintptr // Optional destructor for pArg
	var xCallback uintptr

	// Process arguments
	if objc != 4 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+41999 /* "PATTERN LIMIT SC..." */)
		return 1
	}
	zPattern = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)))
	if tcl.XTcl_GetWideIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)), bp /* &iLimit */) != 0 {
		return 1
	}
	pScript = *(*uintptr)(unsafe.Pointer(objv + uintptr(3)*8))
	tcl.XTcl_GetStringFromObj(tls, pScript, bp+8 /* &nScript */)

	if *(*int32)(unsafe.Pointer(bp + 8 /* nScript */)) > 0 {
		// Allocate a TclQuotaCallback object
		p = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(TclQuotaCallback{})))
		if !(p != 0) {
			tcl.XTcl_SetResult(tls, interp, ts+37659 /* "SQLITE_NOMEM" */, uintptr(0))
			return 0
		}
		crt.Xmemset(tls, p, 0, uint64(unsafe.Sizeof(TclQuotaCallback{})))
		(*TclQuotaCallback)(unsafe.Pointer(p)).Finterp = interp
		(*Tcl_Obj)(unsafe.Pointer(pScript)).FrefCount++
		(*TclQuotaCallback)(unsafe.Pointer(p)).FpScript = pScript
		xDestroy = *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, uintptr) }{tclCallbackDestructor}))
		xCallback = *(*uintptr)(unsafe.Pointer(&struct {
			f func(*crt.TLS, uintptr, uintptr, sqlite3_int64, uintptr)
		}{tclQuotaCallback}))
	} else {
		p = uintptr(0)
		xDestroy = uintptr(0)
		xCallback = uintptr(0)
	}

	// Invoke sqlite3_quota_set()
	rc = sqlite3_quota_set(tls, zPattern, int64(*(*Tcl_WideInt)(unsafe.Pointer(bp /* iLimit */))), xCallback, p, xDestroy)

	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))
	return 0
}

// tclcmd: sqlite3_quota_file FILENAME
func test_quota_file(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_quota.c:1466:26: */
	var zFilename uintptr // File pattern to configure
	var rc int32          // Value returned by quota_file()

	// Process arguments
	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+37843 /* "FILENAME" */)
		return 1
	}
	zFilename = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)))

	// Invoke sqlite3_quota_file()
	rc = sqlite3_quota_file(tls, zFilename)

	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))
	return 0
}

// tclcmd:  sqlite3_quota_dump
func test_quota_dump(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_quota.c:1492:26: */
	bp := tls.Alloc(1008)
	defer tls.Free(1008)

	var pResult uintptr
	var pGroupTerm uintptr
	var pFileTerm uintptr
	var pGroup uintptr
	var pFile uintptr

	pResult = tcl.XTcl_NewObj(tls)
	quotaEnter(tls)
	for pGroup = gQuota.FpGroup; pGroup != 0; pGroup = (*quotaGroup)(unsafe.Pointer(pGroup)).FpNext {
		pGroupTerm = tcl.XTcl_NewObj(tls)
		tcl.XTcl_ListObjAppendElement(tls, interp, pGroupTerm,
			tcl.XTcl_NewStringObj(tls, (*quotaGroup)(unsafe.Pointer(pGroup)).FzPattern, -1))
		tcl.XTcl_ListObjAppendElement(tls, interp, pGroupTerm,
			tcl.XTcl_NewWideIntObj(tls, int64((*quotaGroup)(unsafe.Pointer(pGroup)).FiLimit)))
		tcl.XTcl_ListObjAppendElement(tls, interp, pGroupTerm,
			tcl.XTcl_NewWideIntObj(tls, int64((*quotaGroup)(unsafe.Pointer(pGroup)).FiSize)))
		for pFile = (*quotaGroup)(unsafe.Pointer(pGroup)).FpFiles; pFile != 0; pFile = (*quotaFile)(unsafe.Pointer(pFile)).FpNext {
			var i int32
			// var zTemp [1000]int8 at bp+8, 1000

			pFileTerm = tcl.XTcl_NewObj(tls)
			sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([1000]int8{})), bp+8 /* &zTemp[0] */, ts+130 /* "%s" */, crt.VaList(bp, (*quotaFile)(unsafe.Pointer(pFile)).FzFilename))
			for i = 0; *(*int8)(unsafe.Pointer(bp + 8 /* &zTemp[0] */ + uintptr(i))) != 0; i++ {
				if int32(*(*int8)(unsafe.Pointer(bp + 8 /* &zTemp[0] */ + uintptr(i)))) == '\\' {
					*(*int8)(unsafe.Pointer(bp + 8 /* &zTemp[0] */ + uintptr(i))) = int8('/')
				}
			}
			tcl.XTcl_ListObjAppendElement(tls, interp, pFileTerm,
				tcl.XTcl_NewStringObj(tls, bp+8 /* &zTemp[0] */, -1))
			tcl.XTcl_ListObjAppendElement(tls, interp, pFileTerm,
				tcl.XTcl_NewWideIntObj(tls, int64((*quotaFile)(unsafe.Pointer(pFile)).FiSize)))
			tcl.XTcl_ListObjAppendElement(tls, interp, pFileTerm,
				tcl.XTcl_NewWideIntObj(tls, int64((*quotaFile)(unsafe.Pointer(pFile)).FnRef)))
			tcl.XTcl_ListObjAppendElement(tls, interp, pFileTerm,
				tcl.XTcl_NewWideIntObj(tls, int64((*quotaFile)(unsafe.Pointer(pFile)).FdeleteOnClose)))
			tcl.XTcl_ListObjAppendElement(tls, interp, pGroupTerm, pFileTerm)
		}
		tcl.XTcl_ListObjAppendElement(tls, interp, pResult, pGroupTerm)
	}
	quotaLeave(tls)
	tcl.XTcl_SetObjResult(tls, interp, pResult)
	return 0
}

// tclcmd: sqlite3_quota_fopen FILENAME MODE
func test_quota_fopen(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_quota.c:1540:26: */
	bp := tls.Alloc(58)
	defer tls.Free(58)

	var zFilename uintptr // File pattern to configure
	var zMode uintptr     // Mode string
	var p uintptr         // Open string object
	// var zReturn [50]int8 at bp+8, 50
	// Name of pointer to return

	// Process arguments
	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+42020 /* "FILENAME MODE" */)
		return 1
	}
	zFilename = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)))
	zMode = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)))
	p = sqlite3_quota_fopen(tls, zFilename, zMode)
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([50]int8{})), bp+8 /* &zReturn[0] */, ts+20002 /* "%p" */, crt.VaList(bp, p))
	tcl.XTcl_SetResult(tls, interp, bp+8 /* &zReturn[0] */, uintptr(1))
	return 0
}

// tclcmd: sqlite3_quota_fread HANDLE SIZE NELEM
func test_quota_fread(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_quota.c:1570:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var p uintptr
	var zBuf uintptr
	// var sz int32 at bp, 4

	// var nElem int32 at bp+4, 4

	var got size_t

	if objc != 4 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+42034 /* "HANDLE SIZE NELE..." */)
		return 1
	}
	p = sqlite3TestTextToPtr(tls, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))))
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)), bp /* &sz */) != 0 {
		return 1
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(3)*8)), bp+4 /* &nElem */) != 0 {
		return 1
	}
	zBuf = sqlite3.Xsqlite3_malloc(tls, ((*(*int32)(unsafe.Pointer(bp /* sz */)) * *(*int32)(unsafe.Pointer(bp + 4 /* nElem */))) + 1))
	if zBuf == uintptr(0) {
		tcl.XTcl_SetResult(tls, interp, ts+2471 /* "out of memory" */, uintptr(0))
		return 1
	}
	got = sqlite3_quota_fread(tls, zBuf, uint64(*(*int32)(unsafe.Pointer(bp /* sz */))), uint64(*(*int32)(unsafe.Pointer(bp + 4 /* nElem */))), p)
	*(*int8)(unsafe.Pointer(zBuf + uintptr((got * size_t(*(*int32)(unsafe.Pointer(bp /* sz */))))))) = int8(0)
	tcl.XTcl_SetResult(tls, interp, zBuf, uintptr(1))
	sqlite3.Xsqlite3_free(tls, zBuf)
	return 0
}

// tclcmd: sqlite3_quota_fwrite HANDLE SIZE NELEM CONTENT
func test_quota_fwrite(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_quota.c:1604:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var p uintptr
	var zBuf uintptr
	// var sz int32 at bp, 4

	// var nElem int32 at bp+4, 4

	var got size_t

	if objc != 5 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+42052 /* "HANDLE SIZE NELE..." */)
		return 1
	}
	p = sqlite3TestTextToPtr(tls, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))))
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)), bp /* &sz */) != 0 {
		return 1
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(3)*8)), bp+4 /* &nElem */) != 0 {
		return 1
	}
	zBuf = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(4)*8)))
	got = sqlite3_quota_fwrite(tls, zBuf, uint64(*(*int32)(unsafe.Pointer(bp /* sz */))), uint64(*(*int32)(unsafe.Pointer(bp + 4 /* nElem */))), p)
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewWideIntObj(tls, int64(got)))
	return 0
}

// tclcmd: sqlite3_quota_fclose HANDLE
func test_quota_fclose(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_quota.c:1632:26: */
	var p uintptr
	var rc int32

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+33585 /* "HANDLE" */)
		return 1
	}
	p = sqlite3TestTextToPtr(tls, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))))
	rc = sqlite3_quota_fclose(tls, p)
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, rc))
	return 0
}

// tclcmd: sqlite3_quota_fflush HANDLE ?HARDSYNC?
func test_quota_fflush(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_quota.c:1654:26: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var p uintptr
	var rc int32
	*(*int32)(unsafe.Pointer(bp /* doSync */)) = 0

	if (objc != 2) && (objc != 3) {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+42078 /* "HANDLE ?HARDSYNC..." */)
		return 1
	}
	p = sqlite3TestTextToPtr(tls, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))))
	if objc == 3 {
		if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)), bp /* &doSync */) != 0 {
			return 1
		}
	}
	rc = sqlite3_quota_fflush(tls, p, *(*int32)(unsafe.Pointer(bp /* doSync */)))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, rc))
	return 0
}

// tclcmd: sqlite3_quota_fseek HANDLE OFFSET WHENCE
func test_quota_fseek(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_quota.c:1680:26: */
	bp := tls.Alloc(20)
	defer tls.Free(20)

	var p uintptr
	// var ofst int32 at bp+16, 4

	var zWhence uintptr
	var whence int32
	var rc int32

	if objc != 4 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+42096 /* "HANDLE OFFSET WH..." */)
		return 1
	}
	p = sqlite3TestTextToPtr(tls, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))))
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)), bp+16 /* &ofst */) != 0 {
		return 1
	}
	zWhence = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(3)*8)))
	if crt.Xstrcmp(tls, zWhence, ts+42117 /* "SEEK_SET" */) == 0 {
		whence = 0
	} else if crt.Xstrcmp(tls, zWhence, ts+42126 /* "SEEK_CUR" */) == 0 {
		whence = 1
	} else if crt.Xstrcmp(tls, zWhence, ts+42135 /* "SEEK_END" */) == 0 {
		whence = 2
	} else {
		tcl.XTcl_AppendResult(tls, interp,
			crt.VaList(bp, ts+42144 /* "WHENCE should be..." */, uintptr(0)))
		return 1
	}
	rc = sqlite3_quota_fseek(tls, p, int64(*(*int32)(unsafe.Pointer(bp + 16 /* ofst */))), whence)
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, rc))
	return 0
}

// tclcmd: sqlite3_quota_rewind HANDLE
func test_quota_rewind(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_quota.c:1718:26: */
	var p uintptr
	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+33585 /* "HANDLE" */)
		return 1
	}
	p = sqlite3TestTextToPtr(tls, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))))
	sqlite3_quota_rewind(tls, p)
	return 0
}

// tclcmd: sqlite3_quota_ftell HANDLE
func test_quota_ftell(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_quota.c:1737:26: */
	var p uintptr
	var x sqlite3_int64
	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+33585 /* "HANDLE" */)
		return 1
	}
	p = sqlite3TestTextToPtr(tls, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))))
	x = sqlite3_int64(sqlite3_quota_ftell(tls, p))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewWideIntObj(tls, int64(x)))
	return 0
}

// tclcmd: sqlite3_quota_ftruncate HANDLE SIZE
func test_quota_ftruncate(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_quota.c:1758:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var p uintptr
	var x sqlite3_int64
	// var w Tcl_WideInt at bp, 8

	var rc int32
	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+42193 /* "HANDLE SIZE" */)
		return 1
	}
	p = sqlite3TestTextToPtr(tls, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))))
	if tcl.XTcl_GetWideIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)), bp /* &w */) != 0 {
		return 1
	}
	x = sqlite3_int64(*(*Tcl_WideInt)(unsafe.Pointer(bp /* w */)))
	rc = sqlite3_quota_ftruncate(tls, p, x)
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, rc))
	return 0
}

// tclcmd: sqlite3_quota_file_size HANDLE
func test_quota_file_size(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_quota.c:1783:26: */
	var p uintptr
	var x sqlite3_int64
	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+33585 /* "HANDLE" */)
		return 1
	}
	p = sqlite3TestTextToPtr(tls, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))))
	x = sqlite3_quota_file_size(tls, p)
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewWideIntObj(tls, int64(x)))
	return 0
}

// tclcmd: sqlite3_quota_file_truesize HANDLE
func test_quota_file_truesize(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_quota.c:1804:26: */
	var p uintptr
	var x sqlite3_int64
	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+33585 /* "HANDLE" */)
		return 1
	}
	p = sqlite3TestTextToPtr(tls, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))))
	x = sqlite3_quota_file_truesize(tls, p)
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewWideIntObj(tls, int64(x)))
	return 0
}

// tclcmd: sqlite3_quota_file_mtime HANDLE
func test_quota_file_mtime(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_quota.c:1825:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var p uintptr
	// var t time_t at bp, 8

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+33585 /* "HANDLE" */)
		return 1
	}
	p = sqlite3TestTextToPtr(tls, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))))
	*(*time_t)(unsafe.Pointer(bp /* t */)) = int64(0)
	sqlite3_quota_file_mtime(tls, p, bp /* &t */)
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewWideIntObj(tls, *(*time_t)(unsafe.Pointer(bp /* t */))))
	return 0
}

// tclcmd: sqlite3_quota_remove FILENAME
func test_quota_remove(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_quota.c:1848:26: */
	var zFilename uintptr // File pattern to configure
	var rc int32
	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+37843 /* "FILENAME" */)
		return 1
	}
	zFilename = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)))
	rc = sqlite3_quota_remove(tls, zFilename)
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, rc))
	return 0
}

// tclcmd: sqlite3_quota_glob PATTERN TEXT
//
// Test the glob pattern matching.  Return 1 if TEXT matches PATTERN
// and return 0 if it does not.
func test_quota_glob(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_quota.c:1872:26: */
	var zPattern uintptr // The glob pattern
	var zText uintptr    // Text to compare agains the pattern
	var rc int32
	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+42205 /* "PATTERN TEXT" */)
		return 1
	}
	zPattern = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)))
	zText = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)))
	rc = quotaStrglob(tls, zPattern, zText)
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, rc))
	return 0
}

// tclcmd: sqlite3_quota_file_available HANDLE
//
// Return the number of bytes from the current file point to the end of
// the file.
func test_quota_file_available(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_quota.c:1898:26: */
	var p uintptr
	var x sqlite3_int64
	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+33585 /* "HANDLE" */)
		return 1
	}
	p = sqlite3TestTextToPtr(tls, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))))
	x = sqlite3_int64(sqlite3_quota_file_available(tls, p))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewWideIntObj(tls, int64(x)))
	return 0
}

// tclcmd: sqlite3_quota_ferror HANDLE
//
// Return true if the file handle is in the error state.
func test_quota_ferror(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_quota.c:1921:26: */
	var p uintptr
	var x int32
	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+33585 /* "HANDLE" */)
		return 1
	}
	p = sqlite3TestTextToPtr(tls, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))))
	x = sqlite3_quota_ferror(tls, p)
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, x))
	return 0
}

// This routine registers the custom TCL commands defined in this
// module.  This should be the only procedure visible from outside
// of this module.
func Sqlitequota_Init(tls *crt.TLS, interp uintptr) int32 { /* test_quota.c:1944:5: */
	var i int32

	for i = 0; uint64(i) < (uint64(unsafe.Sizeof(aCmd7)) / uint64(unsafe.Sizeof(struct {
		FzName uintptr
		FxProc uintptr
	}{}))); i++ {
		tcl.XTcl_CreateObjCommand(tls, interp, aCmd7[i].FzName, aCmd7[i].FxProc, uintptr(0), uintptr(0))
	}

	return 0
}

var aCmd7 = [21]struct {
	FzName uintptr
	FxProc uintptr
}{
	{FzName: ts + 41905 /* "sqlite3_quota_in..." */, FxProc: 0},
	{FzName: ts + 41965 /* "sqlite3_quota_sh..." */, FxProc: 0},
	{FzName: ts + 42218 /* "sqlite3_quota_se..." */, FxProc: 0},
	{FzName: ts + 42236 /* "sqlite3_quota_fi..." */, FxProc: 0},
	{FzName: ts + 42255 /* "sqlite3_quota_du..." */, FxProc: 0},
	{FzName: ts + 42274 /* "sqlite3_quota_fo..." */, FxProc: 0},
	{FzName: ts + 42294 /* "sqlite3_quota_fr..." */, FxProc: 0},
	{FzName: ts + 42314 /* "sqlite3_quota_fw..." */, FxProc: 0},
	{FzName: ts + 42335 /* "sqlite3_quota_fc..." */, FxProc: 0},
	{FzName: ts + 42356 /* "sqlite3_quota_ff..." */, FxProc: 0},
	{FzName: ts + 42377 /* "sqlite3_quota_fs..." */, FxProc: 0},
	{FzName: ts + 42397 /* "sqlite3_quota_re..." */, FxProc: 0},
	{FzName: ts + 42418 /* "sqlite3_quota_ft..." */, FxProc: 0},
	{FzName: ts + 42438 /* "sqlite3_quota_ft..." */, FxProc: 0},
	{FzName: ts + 42462 /* "sqlite3_quota_fi..." */, FxProc: 0},
	{FzName: ts + 42486 /* "sqlite3_quota_fi..." */, FxProc: 0},
	{FzName: ts + 42514 /* "sqlite3_quota_fi..." */, FxProc: 0},
	{FzName: ts + 42539 /* "sqlite3_quota_re..." */, FxProc: 0},
	{FzName: ts + 42560 /* "sqlite3_quota_gl..." */, FxProc: 0},
	{FzName: ts + 42579 /* "sqlite3_quota_fi..." */, FxProc: 0},
	{FzName: ts + 42608 /* "sqlite3_quota_fe..." */, FxProc: 0},
} /* test_quota.c:1948:5 */

func register_cube_geom(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_rtree.c:443:26: */
	_ = clientData
	_ = interp
	_ = objc
	_ = objv
	return 0
}

func register_circle_geom(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_rtree.c:471:26: */
	_ = clientData
	_ = interp
	_ = objc
	_ = objv
	return 0
}

func Sqlitetestrtree_Init(tls *crt.TLS, interp uintptr) int32 { /* test_rtree.c:507:5: */
	tcl.XTcl_CreateObjCommand(tls, interp, ts+42629 /* "register_cube_ge..." */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{register_cube_geom})), uintptr(0), uintptr(0))
	tcl.XTcl_CreateObjCommand(tls, interp, ts+42648 /* "register_circle_..." */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{register_circle_geom})), uintptr(0), uintptr(0))
	return 0
}

// end block for C++

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.20 General utilities	<stdlib.h>

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.21 String handling	<string.h>

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.2 Diagnostics	<assert.h>

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// void assert (int expression);
//
//   If NDEBUG is defined, do nothing.
//   If not, and EXPRESSION is zero, print an error message and abort.

// void assert_perror (int errnum);
//
//   If NDEBUG is defined, do nothing.  If not, and ERRNUM is not zero, print an
//   error message with the error text for ERRNUM and abort.
//   (This is a GNU extension.)

type schema_vtab1 = struct {
	Fbase sqlite3_vtab
	Fdb   uintptr
}

// end block for C++

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.20 General utilities	<stdlib.h>

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.21 String handling	<string.h>

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.2 Diagnostics	<assert.h>

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// void assert (int expression);
//
//   If NDEBUG is defined, do nothing.
//   If not, and EXPRESSION is zero, print an error message and abort.

// void assert_perror (int errnum);
//
//   If NDEBUG is defined, do nothing.  If not, and ERRNUM is not zero, print an
//   error message with the error text for ERRNUM and abort.
//   (This is a GNU extension.)

type schema_vtab = schema_vtab1 /* test_schema.c:53:28 */
type schema_cursor1 = struct {
	Fbase        sqlite3_vtab_cursor
	FpDbList     uintptr
	FpTableList  uintptr
	FpColumnList uintptr
	Frowid       int32
	_            [4]byte
}

type schema_cursor = schema_cursor1 /* test_schema.c:54:30 */

// None of this works unless we have virtual tables.

// Table destructor for the schema module.
func schemaDestroy(tls *crt.TLS, pVtab uintptr) int32 { /* test_schema.c:79:12: */
	sqlite3.Xsqlite3_free(tls, pVtab)
	return 0
}

// Table constructor for the schema module.
func schemaCreate(tls *crt.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVtab uintptr, pzErr uintptr) int32 { /* test_schema.c:87:12: */
	var rc int32 = 7
	var pVtab uintptr = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(schema_vtab{})))
	if pVtab != 0 {
		crt.Xmemset(tls, pVtab, 0, uint64(unsafe.Sizeof(schema_vtab{})))
		(*schema_vtab)(unsafe.Pointer(pVtab)).Fdb = db
		rc = sqlite3.Xsqlite3_declare_vtab(tls, db /* Name of database (i.e. main, temp etc.) */ /* Name of table */ /* Column number (from left-to-right, 0 upward) */ /* Column name */ /* Specified type (i.e. VARCHAR(32)) */ /* Boolean. True if NOT NULL was specified */ /* Default value for this column */ /* True if this column is part of the primary key */, ts+42669 /* "CREATE TABLE x(d..." */)
	}
	*(*uintptr)(unsafe.Pointer(ppVtab)) = pVtab
	return rc
}

// Open a new cursor on the schema table.
func schemaOpen(tls *crt.TLS, pVTab uintptr, ppCursor uintptr) int32 { /* test_schema.c:110:12: */
	var rc int32 = 7
	var pCur uintptr
	pCur = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(schema_cursor{})))
	if pCur != 0 {
		crt.Xmemset(tls, pCur, 0, uint64(unsafe.Sizeof(schema_cursor{})))
		*(*uintptr)(unsafe.Pointer(ppCursor)) = pCur
		rc = 0
	}
	return rc
}

// Close a schema table cursor.
func schemaClose(tls *crt.TLS, cur uintptr) int32 { /* test_schema.c:125:12: */
	var pCur uintptr = cur
	sqlite3.Xsqlite3_finalize(tls, (*schema_cursor)(unsafe.Pointer(pCur)).FpDbList)
	sqlite3.Xsqlite3_finalize(tls, (*schema_cursor)(unsafe.Pointer(pCur)).FpTableList)
	sqlite3.Xsqlite3_finalize(tls, (*schema_cursor)(unsafe.Pointer(pCur)).FpColumnList)
	sqlite3.Xsqlite3_free(tls, pCur)
	return 0
}

// Retrieve a column of data.
func schemaColumn(tls *crt.TLS, cur uintptr, ctx uintptr, i int32) int32 { /* test_schema.c:137:12: */
	var pCur uintptr = cur
	switch i {
	case 0:
		sqlite3.Xsqlite3_result_value(tls, ctx, sqlite3.Xsqlite3_column_value(tls, (*schema_cursor)(unsafe.Pointer(pCur)).FpDbList, 1))
		break
	case 1:
		sqlite3.Xsqlite3_result_value(tls, ctx, sqlite3.Xsqlite3_column_value(tls, (*schema_cursor)(unsafe.Pointer(pCur)).FpTableList, 0))
		break
	default:
		sqlite3.Xsqlite3_result_value(tls, ctx, sqlite3.Xsqlite3_column_value(tls, (*schema_cursor)(unsafe.Pointer(pCur)).FpColumnList, (i-2)))
		break
	}
	return 0
}

// Retrieve the current rowid.
func schemaRowid(tls *crt.TLS, cur uintptr, pRowid uintptr) int32 { /* test_schema.c:156:12: */
	var pCur uintptr = cur
	*(*sqlite_int64)(unsafe.Pointer(pRowid)) = sqlite_int64((*schema_cursor)(unsafe.Pointer(pCur)).Frowid)
	return 0
}

func finalize(tls *crt.TLS, ppStmt uintptr) int32 { /* test_schema.c:162:12: */
	var rc int32 = sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(ppStmt)))
	*(*uintptr)(unsafe.Pointer(ppStmt)) = uintptr(0)
	return rc
}

func schemaEof(tls *crt.TLS, cur uintptr) int32 { /* test_schema.c:168:12: */
	var pCur uintptr = cur
	return func() int32 {
		if (*schema_cursor)(unsafe.Pointer(pCur)).FpDbList != 0 {
			return 0
		}
		return 1
	}()
}

// Advance the cursor to the next row.
func schemaNext(tls *crt.TLS, cur uintptr) int32 { /* test_schema.c:176:12: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	var rc int32
	var pCur uintptr
	var pVtab uintptr
	var zSql uintptr
	var pDbList uintptr
	rc = 0
	pCur = cur
	pVtab = (*sqlite3_vtab_cursor)(unsafe.Pointer(cur)).FpVtab
	zSql = uintptr(0)

__1:
	if !(!(int32((*schema_cursor)(unsafe.Pointer(pCur)).FpColumnList) != 0) || (100 != sqlite3.Xsqlite3_step(tls, (*schema_cursor)(unsafe.Pointer(pCur)).FpColumnList))) {
		goto __2
	}
	if !(0 != (crt.AssignInt32(&rc, finalize(tls, (pCur+24 /* &.pColumnList */))))) {
		goto __3
	}
	goto next_exit
__3:
	;

__4:
	if !(!(int32((*schema_cursor)(unsafe.Pointer(pCur)).FpTableList) != 0) || (100 != sqlite3.Xsqlite3_step(tls, (*schema_cursor)(unsafe.Pointer(pCur)).FpTableList))) {
		goto __5
	}
	if !(0 != (crt.AssignInt32(&rc, finalize(tls, (pCur+16 /* &.pTableList */))))) {
		goto __6
	}
	goto next_exit
__6:
	;

__7:
	if !(100 != sqlite3.Xsqlite3_step(tls, (*schema_cursor)(unsafe.Pointer(pCur)).FpDbList)) {
		goto __8
	}
	rc = finalize(tls, (pCur + 8 /* &.pDbList */))
	goto next_exit
	goto __7
__8:
	;

	// Set zSql to the SQL to pull the list of tables from the
	// sqlite_master (or sqlite_temp_master) table of the database
	// identified by the row pointed to by the SQL statement pCur->pDbList
	// (iterating through a "PRAGMA database_list;" statement).
	if !(sqlite3.Xsqlite3_column_int(tls, (*schema_cursor)(unsafe.Pointer(pCur)).FpDbList, 0) == 1) {
		goto __9
	}
	zSql = sqlite3.Xsqlite3_mprintf(tls,
		ts+42741 /* "SELECT name FROM..." */, 0)
	goto __10
__9:
	pDbList = (*schema_cursor)(unsafe.Pointer(pCur)).FpDbList
	zSql = sqlite3.Xsqlite3_mprintf(tls,
		ts+42796, /* "SELECT name FROM..." */
		crt.VaList(bp, sqlite3.Xsqlite3_column_text(tls, pDbList, 1)))
__10:
	;
	if !(!(zSql != 0)) {
		goto __11
	}
	rc = 7
	goto next_exit
__11:
	;

	rc = sqlite3.Xsqlite3_prepare(tls, (*schema_vtab)(unsafe.Pointer(pVtab)).Fdb, zSql, -1, (pCur + 16 /* &.pTableList */), uintptr(0))
	sqlite3.Xsqlite3_free(tls, zSql)
	if !(rc != 0) {
		goto __12
	}
	goto next_exit
__12:
	;
	goto __4
__5:
	;

	// Set zSql to the SQL to the table_info pragma for the table currently
	// identified by the rows pointed to by statements pCur->pDbList and
	// pCur->pTableList.
	zSql = sqlite3.Xsqlite3_mprintf(tls, ts+42849, /* "PRAGMA %Q.table_..." */
		crt.VaList(bp+8, sqlite3.Xsqlite3_column_text(tls, (*schema_cursor)(unsafe.Pointer(pCur)).FpDbList, 1),
			sqlite3.Xsqlite3_column_text(tls, (*schema_cursor)(unsafe.Pointer(pCur)).FpTableList, 0)))

	if !(!(zSql != 0)) {
		goto __13
	}
	rc = 7
	goto next_exit
__13:
	;
	rc = sqlite3.Xsqlite3_prepare(tls, (*schema_vtab)(unsafe.Pointer(pVtab)).Fdb, zSql, -1, (pCur + 24 /* &.pColumnList */), uintptr(0))
	sqlite3.Xsqlite3_free(tls, zSql)
	if !(rc != 0) {
		goto __14
	}
	goto next_exit
__14:
	;
	goto __1
__2:
	;
	(*schema_cursor)(unsafe.Pointer(pCur)).Frowid++

next_exit:
	// TODO: Handle rc
	return rc
}

// Reset a schema table cursor.
func schemaFilter(tls *crt.TLS, pVtabCursor uintptr, idxNum int32, idxStr uintptr, argc int32, argv uintptr) int32 { /* test_schema.c:247:12: */
	var rc int32
	var pVtab uintptr = (*sqlite3_vtab_cursor)(unsafe.Pointer(pVtabCursor)).FpVtab
	var pCur uintptr = pVtabCursor
	(*schema_cursor)(unsafe.Pointer(pCur)).Frowid = 0
	finalize(tls, (pCur + 16 /* &.pTableList */))
	finalize(tls, (pCur + 24 /* &.pColumnList */))
	finalize(tls, (pCur + 8 /* &.pDbList */))
	rc = sqlite3.Xsqlite3_prepare(tls, (*schema_vtab)(unsafe.Pointer(pVtab)).Fdb, ts+42874 /* "PRAGMA database_..." */, -1, (pCur + 8 /* &.pDbList */), uintptr(0))
	return func() int32 {
		if rc == 0 {
			return schemaNext(tls, pVtabCursor)
		}
		return rc
	}()
}

// Analyse the WHERE condition.
func schemaBestIndex(tls *crt.TLS, tab uintptr, pIdxInfo uintptr) int32 { /* test_schema.c:266:12: */
	return 0
}

// A virtual table module that merely echos method calls into TCL
// variables.
var schemaModule = sqlite3_module{FiVersion: 0, FxCreate: // iVersion
0, FxConnect:                                             0, FxBestIndex: 0, FxDisconnect: 0, FxDestroy: 0, FxOpen: 0, FxClose: // xOpen - open a cursor
0, FxFilter:// xClose - close a cursor
0, FxNext:// xFilter - configure scan constraints
0, FxEof:// xNext - advance a cursor
0, FxColumn:// xEof
0, FxRowid:// xColumn - read data
0, FxUpdate:// xRowid - read data
uintptr(0), FxBegin:// xUpdate
uintptr(0), FxSync:// xBegin
uintptr(0), FxCommit:// xSync
uintptr(0), FxRollback:// xCommit
uintptr(0), FxFindFunction:// xRollback
uintptr(0), FxRename:// xFindMethod
uintptr(0), // xRename
} /* test_schema.c:274:23 */

// Register the schema virtual table module.
func register_schema_module(tls *crt.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_schema.c:309:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// var db uintptr at bp, 8

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+2452 /* "DB" */)
		return 1
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), bp /* &db */) != 0 {
		return 1
	}
	sqlite3.Xsqlite3_create_module(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), ts+4325 /* "schema" */, uintptr(unsafe.Pointer(&schemaModule)), uintptr(0))
	return 0
}

// Register commands with the TCL interpreter.
func Sqlitetestschema_Init(tls *crt.TLS, interp uintptr) int32 { /* test_schema.c:330:5: */
	var i int32
	for i = 0; uint64(i) < (uint64(unsafe.Sizeof(aObjCmd12)) / uint64(unsafe.Sizeof(struct {
		FzName      uintptr
		FxProc      uintptr
		FclientData uintptr
	}{}))); i++ {
		tcl.XTcl_CreateObjCommand(tls, interp, aObjCmd12[i].FzName,
			aObjCmd12[i].FxProc, aObjCmd12[i].FclientData, uintptr(0))
	}
	return 0
}

var aObjCmd12 = [1]struct {
	FzName      uintptr
	FxProc      uintptr
	FclientData uintptr
}{
	{FzName: ts + 42895 /* "register_schema_..." */, FxProc: 0, FclientData: uintptr(0)},
} /* test_schema.c:335:5 */

// When possible, define assert so that it does not add extra
//   parentheses around EXPR.  Otherwise, those added parentheses would
//   suppress warnings we'd expect to be detected by gcc's -Wparentheses.

// Version 2.4 and later of GCC define a magical variable `__PRETTY_FUNCTION__'
//   which contains the name of the function currently being defined.
//   This is broken in G++ before version 2.6.
//   C9x has a similar variable called __func__, but prefer the GCC one since
//   it demangles C++ function names.

// A structure to collect a busy-handler callback and argument and a count
// of the number of times it has been invoked.
type SuperlockBusy1 = struct {
	FxBusy    uintptr
	FpBusyArg uintptr
	FnBusy    int32
	_         [4]byte
}

type SuperlockBusy = SuperlockBusy1 /* test_superlock.c:34:30 */

// An instance of the following structure is allocated for each active
// superlock. The opaque handle returned by sqlite3demo_superlock() is
// actually a pointer to an instance of this structure.
type Superlock1 = struct {
	Fdb   uintptr
	FbWal int32
	_     [4]byte
}

type Superlock = Superlock1 /* test_superlock.c:45:26 */

// The pCtx pointer passed to this function is actually a pointer to a
// SuperlockBusy structure. Invoke the busy-handler function encapsulated
// by the structure and return the result.
func superlockBusyHandler(tls *crt.TLS, pCtx uintptr, UNUSED int32) int32 { /* test_superlock.c:52:12: */
	var pBusy uintptr = pCtx
	if (*SuperlockBusy)(unsafe.Pointer(pBusy)).FxBusy == uintptr(0) {
		return 0
	}
	return (*(*func(*crt.TLS, uintptr, int32) int32)(unsafe.Pointer((pBusy /* &.xBusy */))))(tls, (*SuperlockBusy)(unsafe.Pointer(pBusy)).FpBusyArg, crt.PostIncInt32(&(*SuperlockBusy)(unsafe.Pointer(pBusy)).FnBusy, 1))
}

// This function is used to determine if the main database file for
// connection db is open in WAL mode or not. If no error occurs and the
// database file is in WAL mode, set *pbWal to true and return SQLITE_OK.
// If it is not in WAL mode, set *pbWal to false.
//
// If an error occurs, return an SQLite error code. The value of *pbWal
// is undefined in this case.
func superlockIsWal(tls *crt.TLS, pLock uintptr) int32 { /* test_superlock.c:67:12: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var rc int32 // Return Code
	// var pStmt uintptr at bp, 8
	// Compiled PRAGMA journal_mode statement

	rc = sqlite3.Xsqlite3_prepare(tls, (*Superlock)(unsafe.Pointer(pLock)).Fdb, ts+42918 /* "PRAGMA main.jour..." */, -1, bp /* &pStmt */, uintptr(0))
	if rc != 0 {
		return rc
	}

	(*Superlock)(unsafe.Pointer(pLock)).FbWal = 0
	if 100 == sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp /* pStmt */))) {
		var zMode uintptr = sqlite3.Xsqlite3_column_text(tls, *(*uintptr)(unsafe.Pointer(bp /* pStmt */)), 0)
		if ((zMode != 0) && (crt.Xstrlen(tls, zMode) == uint64(3))) && (sqlite3.Xsqlite3_strnicmp(tls, ts+34838 /* "wal" */, zMode, 3) == 0) {
			(*Superlock)(unsafe.Pointer(pLock)).FbWal = 1
		}
	}

	return sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp /* pStmt */)))
}

// Obtain an exclusive shm-lock on nByte bytes starting at offset idx
// of the file fd. If the lock cannot be obtained immediately, invoke
// the busy-handler until either it is obtained or the busy-handler
// callback returns 0.
func superlockShmLock(tls *crt.TLS, fd uintptr, idx int32, nByte int32, pBusy uintptr) int32 { /* test_superlock.c:91:12: */
	var rc int32
	var xShmLock uintptr = (*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(fd)).FpMethods)).FxShmLock
	for ok := true; ok; ok = ((rc == 5) && (superlockBusyHandler(tls, pBusy, 0) != 0)) {
		rc = (*(*func(*crt.TLS, uintptr, int32, int32, int32) int32)(unsafe.Pointer(&xShmLock)))(tls, fd, idx, nByte, (2 | 8))
	}
	return rc
}

// Obtain the extra locks on the database file required for WAL databases.
// Invoke the supplied busy-handler as required.
func superlockWalLock(tls *crt.TLS, db uintptr, pBusy uintptr) int32 { /* test_superlock.c:109:12: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var rc int32                                             // Return code
	*(*uintptr)(unsafe.Pointer(bp /* fd */)) = uintptr(0)    // Main database file handle
	*(*uintptr)(unsafe.Pointer(bp + 8 /* p */)) = uintptr(0) // Pointer to first page of shared memory

	// Obtain a pointer to the sqlite3_file object open on the main db file.
	rc = sqlite3.Xsqlite3_file_control(tls, db, ts+354 /* "main" */, 7, bp /* &fd */)
	if rc != 0 {
		return rc
	}

	// Obtain the "recovery" lock. Normally, this lock is only obtained by
	// clients running database recovery.
	rc = superlockShmLock(tls, *(*uintptr)(unsafe.Pointer(bp /* fd */)), 2, 1, pBusy)
	if rc != 0 {
		return rc
	}

	// Zero the start of the first shared-memory page. This means that any
	// clients that open read or write transactions from this point on will
	// have to run recovery before proceeding. Since they need the "recovery"
	// lock that this process is holding to do that, no new read or write
	// transactions may now be opened. Nor can a checkpoint be run, for the
	// same reason.
	rc = (*(*func(*crt.TLS, uintptr, int32, int32, int32, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* fd */)))).FpMethods + 104 /* &.xShmMap */))))(tls, *(*uintptr)(unsafe.Pointer(bp /* fd */)), 0, (32 * 1024), 1, bp+8 /* &p */)
	if rc != 0 {
		return rc
	}
	crt.Xmemset(tls, *(*uintptr)(unsafe.Pointer(bp + 8 /* p */)), 0, uint64(32))

	// Obtain exclusive locks on all the "read-lock" slots. Once these locks
	// are held, it is guaranteed that there are no active reader, writer or
	// checkpointer clients.
	rc = superlockShmLock(tls, *(*uintptr)(unsafe.Pointer(bp /* fd */)), 3, (8 - 3), pBusy)
	return rc
}

// Release a superlock held on a database file. The argument passed to
// this function must have been obtained from a successful call to
// sqlite3demo_superlock().
func sqlite3demo_superunlock(tls *crt.TLS, pLock uintptr) { /* test_superlock.c:151:6: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var p uintptr = pLock
	if (*Superlock)(unsafe.Pointer(p)).FbWal != 0 {
		var rc int32 // Return code
		var flags int32 = (1 | 8)
		*(*uintptr)(unsafe.Pointer(bp /* fd */)) = uintptr(0)
		rc = sqlite3.Xsqlite3_file_control(tls, (*Superlock)(unsafe.Pointer(p)).Fdb, ts+354 /* "main" */, 7, bp /* &fd */)
		if rc == 0 {
			(*(*func(*crt.TLS, uintptr, int32, int32, int32) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* fd */)))).FpMethods + 112 /* &.xShmLock */))))(tls, *(*uintptr)(unsafe.Pointer(bp /* fd */)), 2, 1, flags)
			(*(*func(*crt.TLS, uintptr, int32, int32, int32) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* fd */)))).FpMethods + 112 /* &.xShmLock */))))(tls, *(*uintptr)(unsafe.Pointer(bp /* fd */)), 3, (8 - 3), flags)
		}
	}
	sqlite3.Xsqlite3_close(tls, (*Superlock)(unsafe.Pointer(p)).Fdb)
	sqlite3.Xsqlite3_free(tls, p)
}

// Obtain a superlock on the database file identified by zPath, using the
// locking primitives provided by VFS zVfs. If successful, SQLITE_OK is
// returned and output variable *ppLock is populated with an opaque handle
// that may be used with sqlite3demo_superunlock() to release the lock.
//
// If an error occurs, *ppLock is set to 0 and an SQLite error code
// (e.g. SQLITE_BUSY) is returned.
//
// If a required lock cannot be obtained immediately and the xBusy parameter
// to this function is not NULL, then xBusy is invoked in the same way
// as a busy-handler registered with SQLite (using sqlite3_busy_handler())
// until either the lock can be obtained or the busy-handler function returns
// 0 (indicating "give up").
func sqlite3demo_superlock(tls *crt.TLS, zPath uintptr, zVfs uintptr, xBusy uintptr, pBusyArg uintptr, ppLock uintptr) int32 { /* test_superlock.c:182:5: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	*(*SuperlockBusy)(unsafe.Pointer(bp /* busy */)) = SuperlockBusy{FxBusy: uintptr(0), FpBusyArg: uintptr(0), FnBusy: 0} // Busy handler wrapper object
	var rc int32                                                                                                           // Return code
	var pLock uintptr

	pLock = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(Superlock{})))
	if !(pLock != 0) {
		return 7
	}
	crt.Xmemset(tls, pLock, 0, uint64(unsafe.Sizeof(Superlock{})))

	// Open a database handle on the file to superlock.
	rc = sqlite3.Xsqlite3_open_v2(tls,
		zPath, (pLock /* &.db */), (0x00000002 | 0x00000004), zVfs)

	// Install a busy-handler and execute a BEGIN EXCLUSIVE. If this is not
	// a WAL database, this is all we need to do.
	//
	// A wrapper function is used to invoke the busy-handler instead of
	// registering the busy-handler function supplied by the user directly
	// with SQLite. This is because the same busy-handler function may be
	// invoked directly later on when attempting to obtain the extra locks
	// required in WAL mode. By using the wrapper, we are able to guarantee
	// that the "nBusy" integer parameter passed to the users busy-handler
	// represents the total number of busy-handler invocations made within
	// this call to sqlite3demo_superlock(), including any made during the
	// "BEGIN EXCLUSIVE".
	if rc == 0 {
		(*SuperlockBusy)(unsafe.Pointer(bp /* &busy */)).FxBusy = xBusy
		(*SuperlockBusy)(unsafe.Pointer(bp /* &busy */)).FpBusyArg = pBusyArg
		sqlite3.Xsqlite3_busy_handler(tls, (*Superlock)(unsafe.Pointer(pLock)).Fdb, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*crt.TLS, uintptr, int32) int32
		}{superlockBusyHandler})), bp /* &busy */)
		rc = sqlite3.Xsqlite3_exec(tls, (*Superlock)(unsafe.Pointer(pLock)).Fdb, ts+19899 /* "BEGIN EXCLUSIVE" */, uintptr(0), uintptr(0), uintptr(0))
	}

	// If the BEGIN EXCLUSIVE was executed successfully and this is a WAL
	// database, call superlockWalLock() to obtain the extra locks required
	// to prevent readers, writers and/or checkpointers from accessing the
	// db while this process is holding the superlock.
	//
	// Before attempting any WAL locks, commit the transaction started above
	// to drop the WAL read and write locks currently held. Otherwise, the
	// new WAL locks may conflict with the old.
	if rc == 0 {
		if (0 == (crt.AssignInt32(&rc, superlockIsWal(tls, pLock)))) && ((*Superlock)(unsafe.Pointer(pLock)).FbWal != 0) {
			rc = sqlite3.Xsqlite3_exec(tls, (*Superlock)(unsafe.Pointer(pLock)).Fdb, ts+15071 /* "COMMIT" */, uintptr(0), uintptr(0), uintptr(0))
			if rc == 0 {
				rc = superlockWalLock(tls, (*Superlock)(unsafe.Pointer(pLock)).Fdb, bp /* &busy */)
			}
		}
	}

	if rc != 0 {
		sqlite3demo_superunlock(tls, pLock)
		*(*uintptr)(unsafe.Pointer(ppLock)) = uintptr(0)
	} else {
		*(*uintptr)(unsafe.Pointer(ppLock)) = pLock
	}

	return rc
}

// end block for C++

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:

type InterpAndScript1 = struct {
	Finterp  uintptr
	FpScript uintptr
}

type InterpAndScript = InterpAndScript1 /* test_superlock.c:272:32 */

func superunlock_del(tls *crt.TLS, cd ClientData) { /* test_superlock.c:274:27: */
	sqlite3demo_superunlock(tls, cd)
}

func superunlock_cmd(tls *crt.TLS, cd ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_superlock.c:278:26: */
	if objc != 1 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+792 /* "" */)
		return 1
	}
	tcl.XTcl_DeleteCommand(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(0)*8))))
	return 0
}

func superlock_busy(tls *crt.TLS, pCtx uintptr, nBusy int32) int32 { /* test_superlock.c:292:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var p uintptr = pCtx
	var pEval uintptr                            // Script to evaluate
	*(*int32)(unsafe.Pointer(bp /* iVal */)) = 0 // Value to return

	pEval = tcl.XTcl_DuplicateObj(tls, (*InterpAndScript)(unsafe.Pointer(p)).FpScript)
	(*Tcl_Obj)(unsafe.Pointer(pEval)).FrefCount++
	tcl.XTcl_ListObjAppendElement(tls, (*InterpAndScript)(unsafe.Pointer(p)).Finterp, pEval, tcl.XTcl_NewIntObj(tls, nBusy))
	tcl.XTcl_EvalObjEx(tls, (*InterpAndScript)(unsafe.Pointer(p)).Finterp, pEval, 0x020000)
	tcl.XTcl_GetIntFromObj(tls, (*InterpAndScript)(unsafe.Pointer(p)).Finterp, tcl.XTcl_GetObjResult(tls, (*InterpAndScript)(unsafe.Pointer(p)).Finterp), bp /* &iVal */)
	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = pEval
		if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}

	return *(*int32)(unsafe.Pointer(bp /* iVal */))
}

// Tclcmd: sqlite3demo_superlock CMDNAME PATH VFS BUSY-HANDLER-SCRIPT
func superlock_cmd(tls *crt.TLS, cd ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_superlock.c:310:26: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	// var pLock uintptr at bp+32, 8
	// Lock context
	var zPath uintptr
	var zVfs uintptr = uintptr(0)
	*(*InterpAndScript)(unsafe.Pointer(bp + 16 /* busy */)) = InterpAndScript{Finterp: uintptr(0), FpScript: uintptr(0)}
	var xBusy uintptr = uintptr(0) // Busy handler callback
	var rc int32                   // Return code from sqlite3demo_superlock()

	if (objc < 3) || (objc > 5) {
		tcl.XTcl_WrongNumArgs(tls,
			interp, 1, objv, ts+42943 /* "CMDNAME PATH ?VF..." */)
		return 1
	}

	zPath = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)))

	if objc > 3 {
		zVfs = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(3)*8)))
		if crt.Xstrlen(tls, zVfs) == uint64(0) {
			zVfs = uintptr(0)
		}
	}
	if objc > 4 {
		(*InterpAndScript)(unsafe.Pointer(bp + 16 /* &busy */)).Finterp = interp
		(*InterpAndScript)(unsafe.Pointer(bp + 16 /* &busy */)).FpScript = *(*uintptr)(unsafe.Pointer(objv + uintptr(4)*8))
		xBusy = *(*uintptr)(unsafe.Pointer(&struct {
			f func(*crt.TLS, uintptr, int32) int32
		}{superlock_busy}))
	}

	rc = sqlite3demo_superlock(tls, zPath, zVfs, xBusy, bp+16 /* &busy */, bp+32 /* &pLock */)
	if !((rc == 0) || (*(*uintptr)(unsafe.Pointer(bp + 32 /* pLock */)) == uintptr(0))) {
		crt.X__assert_fail(tls, ts+42984 /* "rc==0 || pLock==..." */, ts+43002 /* "testdata/sqlite-..." */, uint32(342), uintptr(unsafe.Pointer(&__func__124)))
	}
	if !((rc != 0) || (*(*uintptr)(unsafe.Pointer(bp + 32 /* pLock */)) != uintptr(0))) {
		crt.X__assert_fail(tls, ts+43051 /* "rc!=0 || pLock!=..." */, ts+43002 /* "testdata/sqlite-..." */, uint32(343), uintptr(unsafe.Pointer(&__func__124)))
	}

	if rc != 0 {
		tcl.XTcl_ResetResult(tls, interp)
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, sqlite3.Xsqlite3ErrStr(tls, rc), 0))
		return 1
	}

	tcl.XTcl_CreateObjCommand(tls,
		interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), *(*uintptr)(unsafe.Pointer(&struct {
			f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
		}{superunlock_cmd})), *(*uintptr)(unsafe.Pointer(bp + 32 /* pLock */)), *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, ClientData) }{superunlock_del})))
	tcl.XTcl_SetObjResult(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)))
	return 0
}

var __func__124 = *(*[14]int8)(unsafe.Pointer(ts + 43069 /* "superlock_cmd" */)) /* test_superlock.c:315:2 */

func SqliteSuperlock_Init(tls *crt.TLS, interp uintptr) int32 { /* test_superlock.c:359:5: */
	tcl.XTcl_CreateObjCommand(tls, interp, ts+43083 /* "sqlite3demo_supe..." */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
	}{superlock_cmd})), uintptr(0), uintptr(0))
	return 0
}

type TestSyscallGlobal = struct {
	FbPersist         int32
	FnCount           int32
	FnFail            int32
	Fpgsz             int32
	Forig_getpagesize sqlite3_syscall_ptr
}

var gSyscall = TestSyscallGlobal{FbPersist: 0, FnCount: 0, FnFail: 0, Fpgsz: 0, Forig_getpagesize: uintptr(0)} /* test_syscall.c:103:3 */

type TestSyscallArray = struct {
	FzName         uintptr
	FxTest         sqlite3_syscall_ptr
	FxOrig         sqlite3_syscall_ptr
	Fdefault_errno int32
	Fcustom_errno  int32
}

var aSyscall = [19]TestSyscallArray{
	/*  0 */ {FzName: ts + 43105 /* "open" */, FxTest: 0, FxOrig: uintptr(0), Fdefault_errno: 13, Fcustom_errno: 0},
	/*  1 */ {FzName: ts + 16507 /* "close" */, FxTest: 0, FxOrig: uintptr(0), Fdefault_errno: 0, Fcustom_errno: 0},
	/*  2 */ {FzName: ts + 43110 /* "access" */, FxTest: 0, FxOrig: uintptr(0), Fdefault_errno: 0, Fcustom_errno: 0},
	/*  3 */ {FzName: ts + 43117 /* "getcwd" */, FxTest: 0, FxOrig: uintptr(0), Fdefault_errno: 0, Fcustom_errno: 0},
	/*  4 */ {FzName: ts + 13771 /* "stat" */, FxTest: 0, FxOrig: uintptr(0), Fdefault_errno: 0, Fcustom_errno: 0},
	/*  5 */ {FzName: ts + 43124 /* "fstat" */, FxTest: 0, FxOrig: uintptr(0), Fdefault_errno: 0, Fcustom_errno: 0},
	/*  6 */ {FzName: ts + 43130 /* "ftruncate" */, FxTest: 0, FxOrig: uintptr(0), Fdefault_errno: 5, Fcustom_errno: 0},
	/*  7 */ {FzName: ts + 43140 /* "fcntl" */, FxTest: 0, FxOrig: uintptr(0), Fdefault_errno: 13, Fcustom_errno: 0},
	/*  8 */ {FzName: ts + 30332 /* "read" */, FxTest: 0, FxOrig: uintptr(0), Fdefault_errno: 0, Fcustom_errno: 0},
	/*  9 */ {FzName: ts + 43146 /* "pread" */, FxTest: 0, FxOrig: uintptr(0), Fdefault_errno: 0, Fcustom_errno: 0},
	/* 10 */ {FzName: ts + 43152 /* "pread64" */, FxTest: 0, FxOrig: uintptr(0), Fdefault_errno: 0, Fcustom_errno: 0},
	/* 11 */ {FzName: ts + 30337 /* "write" */, FxTest: 0, FxOrig: uintptr(0), Fdefault_errno: 0, Fcustom_errno: 0},
	/* 12 */ {FzName: ts + 43160 /* "pwrite" */, FxTest: 0, FxOrig: uintptr(0), Fdefault_errno: 0, Fcustom_errno: 0},
	/* 13 */ {FzName: ts + 43167 /* "pwrite64" */, FxTest: 0, FxOrig: uintptr(0), Fdefault_errno: 0, Fcustom_errno: 0},
	/* 14 */ {FzName: ts + 43176 /* "fchmod" */, FxTest: 0, FxOrig: uintptr(0), Fdefault_errno: 0, Fcustom_errno: 0},
	/* 15 */ {FzName: ts + 43183 /* "fallocate" */, FxTest: 0, FxOrig: uintptr(0), Fdefault_errno: 0, Fcustom_errno: 0},
	/* 16 */ {FzName: ts + 33948 /* "mmap" */, FxTest: 0, FxOrig: uintptr(0), Fdefault_errno: 0, Fcustom_errno: 0},
	/* 17 */ {FzName: ts + 43193 /* "mremap" */, FxTest: 0, FxOrig: uintptr(0), Fdefault_errno: 0, Fcustom_errno: 0},
	{FzName: uintptr(0), FxTest: uintptr(0), FxOrig: uintptr(0), Fdefault_errno: 0, Fcustom_errno: 0},
} /* test_syscall.c:133:3 */

// This function is called exactly once from within each invocation of a
// system call wrapper in this file. It returns 1 if the function should
// fail, or 0 if it should succeed.
func tsIsFail(tls *crt.TLS) int32 { /* test_syscall.c:181:12: */
	gSyscall.FnCount--
	if (gSyscall.FnCount == 0) || ((gSyscall.FnFail != 0) && (gSyscall.FbPersist != 0)) {
		gSyscall.FnFail++
		return 1
	}
	return 0
}

// Return the current error-number value for function zFunc. zFunc must be
// the name of a system call in the aSyscall[] table.
//
// Usually, the current error-number is the value that errno should be set
// to if the named system call fails. The exception is "fallocate". See
// comments above the implementation of ts_fallocate() for details.
func tsErrno(tls *crt.TLS, zFunc uintptr) int32 { /* test_syscall.c:198:12: */
	var i int32
	var nFunc int32 = int32(crt.Xstrlen(tls, zFunc))
	for i = 0; aSyscall[i].FzName != 0; i++ {
		if crt.Xstrlen(tls, aSyscall[i].FzName) != size_t(nFunc) {
			continue
		}
		if crt.Xmemcmp(tls, aSyscall[i].FzName, zFunc, uint64(nFunc)) != 0 {
			continue
		}
		return aSyscall[i].Fcustom_errno
	}

	return 0
}

/*
** A wrapper around tsIsFail(). If tsIsFail() returns non-zero, set the
** value of errno before returning.
 */
func tsIsFailErrno(tls *crt.TLS, zFunc uintptr) int32 { /* test_syscall.c:215:12: */
	if tsIsFail(tls) != 0 {
		(*(*int32)(unsafe.Pointer(crt.X__errno_location(tls)))) = tsErrno(tls, zFunc)
		return 1
	}
	return 0
}

// A wrapper around open().
func ts_open(tls *crt.TLS, zFile uintptr, flags int32, mode int32) int32 { /* test_syscall.c:226:12: */
	if tsIsFailErrno(tls, ts+43105 /* "open" */) != 0 {
		return -1
	}
	return (*(*func(*crt.TLS, uintptr, int32, int32) int32)(unsafe.Pointer((uintptr(unsafe.Pointer(&aSyscall)) + uintptr(0)*32 + 16 /* &.xOrig */))))(tls, zFile, flags, mode)
}

// A wrapper around close().
func ts_close(tls *crt.TLS, fd int32) int32 { /* test_syscall.c:236:12: */
	if tsIsFail(tls) != 0 {
		// Even if simulating an error, close the original file-descriptor.
		// This is to stop the test process from running out of file-descriptors
		// when running a long test. If a call to close() appears to fail, SQLite
		// never attempts to use the file-descriptor afterwards (or even to close
		// it a second time).
		(*(*func(*crt.TLS, int32) int32)(unsafe.Pointer((uintptr(unsafe.Pointer(&aSyscall)) + uintptr(1)*32 + 16 /* &.xOrig */))))(tls, fd)
		return -1
	}
	return (*(*func(*crt.TLS, int32) int32)(unsafe.Pointer((uintptr(unsafe.Pointer(&aSyscall)) + uintptr(1)*32 + 16 /* &.xOrig */))))(tls, fd)
}

// A wrapper around access().
func ts_access(tls *crt.TLS, zPath uintptr, mode int32) int32 { /* test_syscall.c:252:12: */
	if tsIsFail(tls) != 0 {
		return -1
	}
	return (*(*func(*crt.TLS, uintptr, int32) int32)(unsafe.Pointer((uintptr(unsafe.Pointer(&aSyscall)) + uintptr(2)*32 + 16 /* &.xOrig */))))(tls, zPath, mode)
}

// A wrapper around getcwd().
func ts_getcwd(tls *crt.TLS, zPath uintptr, nPath size_t) uintptr { /* test_syscall.c:262:13: */
	if tsIsFail(tls) != 0 {
		return uintptr(0)
	}
	return (*(*func(*crt.TLS, uintptr, size_t) uintptr)(unsafe.Pointer((uintptr(unsafe.Pointer(&aSyscall)) + uintptr(3)*32 + 16 /* &.xOrig */))))(tls, zPath, nPath)
}

// A wrapper around stat().
func ts_stat(tls *crt.TLS, zPath uintptr, p uintptr) int32 { /* test_syscall.c:272:12: */
	if tsIsFail(tls) != 0 {
		return -1
	}
	return (*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer((uintptr(unsafe.Pointer(&aSyscall)) + uintptr(4)*32 + 16 /* &.xOrig */))))(tls, zPath, p)
}

// A wrapper around fstat().
func ts_fstat(tls *crt.TLS, fd int32, p uintptr) int32 { /* test_syscall.c:282:12: */
	if tsIsFailErrno(tls, ts+43124 /* "fstat" */) != 0 {
		return -1
	}
	return (*(*func(*crt.TLS, int32, uintptr) int32)(unsafe.Pointer((uintptr(unsafe.Pointer(&aSyscall)) + uintptr(5)*32 + 16 /* &.xOrig */))))(tls, fd, p)
}

// A wrapper around ftruncate().
func ts_ftruncate(tls *crt.TLS, fd int32, n off_t) int32 { /* test_syscall.c:292:12: */
	if tsIsFailErrno(tls, ts+43130 /* "ftruncate" */) != 0 {
		return -1
	}
	return (*(*func(*crt.TLS, int32, off_t) int32)(unsafe.Pointer((uintptr(unsafe.Pointer(&aSyscall)) + uintptr(6)*32 + 16 /* &.xOrig */))))(tls, fd, n)
}

// A wrapper around fcntl().
func ts_fcntl(tls *crt.TLS, fd int32, cmd int32, va uintptr) int32 { /* test_syscall.c:302:12: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var ap va_list
	_ = ap
	var pArg uintptr
	if tsIsFailErrno(tls, ts+43140 /* "fcntl" */) != 0 {
		return -1
	}
	ap = va
	pArg = crt.VaUintptr(&ap)
	return (*(*func(*crt.TLS, int32, int32, uintptr) int32)(unsafe.Pointer((uintptr(unsafe.Pointer(&aSyscall)) + uintptr(7)*32 + 16 /* &.xOrig */))))(tls, fd, cmd, crt.VaList(bp, pArg))
}

// A wrapper around read().
func ts_read(tls *crt.TLS, fd int32, aBuf uintptr, nBuf size_t) int32 { /* test_syscall.c:316:12: */
	if tsIsFailErrno(tls, ts+30332 /* "read" */) != 0 {
		return -1
	}
	return int32((*(*func(*crt.TLS, int32, uintptr, size_t) ssize_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&aSyscall)) + uintptr(8)*32 + 16 /* &.xOrig */))))(tls, fd, aBuf, nBuf))
}

// A wrapper around pread().
func ts_pread(tls *crt.TLS, fd int32, aBuf uintptr, nBuf size_t, off off_t) int32 { /* test_syscall.c:326:12: */
	if tsIsFailErrno(tls, ts+43146 /* "pread" */) != 0 {
		return -1
	}
	return int32((*(*func(*crt.TLS, int32, uintptr, size_t, off_t) ssize_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&aSyscall)) + uintptr(9)*32 + 16 /* &.xOrig */))))(tls, fd, aBuf, nBuf, off))
}

// A wrapper around pread64().
func ts_pread64(tls *crt.TLS, fd int32, aBuf uintptr, nBuf size_t, off sqlite3_uint64) int32 { /* test_syscall.c:336:12: */
	if tsIsFailErrno(tls, ts+43152 /* "pread64" */) != 0 {
		return -1
	}
	return int32((*(*func(*crt.TLS, int32, uintptr, size_t, sqlite3_uint64) ssize_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&aSyscall)) + uintptr(10)*32 + 16 /* &.xOrig */))))(tls, fd, aBuf, nBuf, off))
}

// A wrapper around write().
func ts_write(tls *crt.TLS, fd int32, aBuf uintptr, nBuf size_t) int32 { /* test_syscall.c:346:12: */
	if tsIsFailErrno(tls, ts+30337 /* "write" */) != 0 {
		if tsErrno(tls, ts+30337 /* "write" */) == 4 {
			(*(*func(*crt.TLS, int32, uintptr, size_t) ssize_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&aSyscall)) + uintptr(11)*32 + 16 /* &.xOrig */))))(tls, fd, aBuf, (nBuf / uint64(2)))
		}
		return -1
	}
	return int32((*(*func(*crt.TLS, int32, uintptr, size_t) ssize_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&aSyscall)) + uintptr(11)*32 + 16 /* &.xOrig */))))(tls, fd, aBuf, nBuf))
}

// A wrapper around pwrite().
func ts_pwrite(tls *crt.TLS, fd int32, aBuf uintptr, nBuf size_t, off off_t) int32 { /* test_syscall.c:357:12: */
	if tsIsFailErrno(tls, ts+43160 /* "pwrite" */) != 0 {
		return -1
	}
	return int32((*(*func(*crt.TLS, int32, uintptr, size_t, off_t) ssize_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&aSyscall)) + uintptr(12)*32 + 16 /* &.xOrig */))))(tls, fd, aBuf, nBuf, off))
}

// A wrapper around pwrite64().
func ts_pwrite64(tls *crt.TLS, fd int32, aBuf uintptr, nBuf size_t, off sqlite3_uint64) int32 { /* test_syscall.c:367:12: */
	if tsIsFailErrno(tls, ts+43167 /* "pwrite64" */) != 0 {
		return -1
	}
	return int32((*(*func(*crt.TLS, int32, uintptr, size_t, sqlite3_uint64) ssize_t)(unsafe.Pointer((uintptr(unsafe.Pointer(&aSyscall)) + uintptr(13)*32 + 16 /* &.xOrig */))))(tls, fd, aBuf, nBuf, off))
}

// A wrapper around fchmod().
func ts_fchmod(tls *crt.TLS, fd int32, mode mode_t) int32 { /* test_syscall.c:377:12: */
	if tsIsFail(tls) != 0 {
		return -1
	}
	return (*(*func(*crt.TLS, int32, mode_t) int32)(unsafe.Pointer((uintptr(unsafe.Pointer(&aSyscall)) + uintptr(14)*32 + 16 /* &.xOrig */))))(tls, fd, mode)
}

// A wrapper around fallocate().
//
// SQLite assumes that the fallocate() function is compatible with
// posix_fallocate(). According to the Linux man page (2009-09-30):
//
//   posix_fallocate() returns  zero on success, or an error number on
//   failure. Note that errno is not set.
func ts_fallocate(tls *crt.TLS, fd int32, off off_t, len off_t) int32 { /* test_syscall.c:393:12: */
	if tsIsFail(tls) != 0 {
		return tsErrno(tls, ts+43183 /* "fallocate" */)
	}
	return (*(*func(*crt.TLS, int32, off_t, off_t) int32)(unsafe.Pointer((uintptr(unsafe.Pointer(&aSyscall)) + uintptr(15)*32 + 16 /* &.xOrig */))))(tls, fd, off, len)
}

func ts_mmap(tls *crt.TLS, pAddr uintptr, nByte size_t, prot int32, flags int32, fd int32, iOff off_t) uintptr { /* test_syscall.c:400:13: */
	if tsIsFailErrno(tls, ts+33948 /* "mmap" */) != 0 {
		return crt.UintptrFromInt32(-1)
	}
	return (*(*func(*crt.TLS, uintptr, size_t, int32, int32, int32, off_t) uintptr)(unsafe.Pointer((uintptr(unsafe.Pointer(&aSyscall)) + uintptr(16)*32 + 16 /* &.xOrig */))))(tls, pAddr, nByte, prot, flags, fd, iOff)
}

func ts_mremap(tls *crt.TLS, a uintptr, b size_t, c size_t, d int32, va uintptr) uintptr { /* test_syscall.c:414:13: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var ap va_list
	_ = ap
	var pArg uintptr
	if tsIsFailErrno(tls, ts+43193 /* "mremap" */) != 0 {
		return crt.UintptrFromInt32(-1)
	}
	ap = va
	pArg = crt.VaUintptr(&ap)
	return (*(*func(*crt.TLS, uintptr, size_t, size_t, int32, uintptr) uintptr)(unsafe.Pointer((uintptr(unsafe.Pointer(&aSyscall)) + uintptr(17)*32 + 16 /* &.xOrig */))))(tls, a, b, c, d, crt.VaList(bp, pArg))
}

func test_syscall_install(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_syscall.c:425:26: */
	bp := tls.Alloc(20)
	defer tls.Free(20)

	var pVfs uintptr
	// var nElem int32 at bp, 4

	var i int32
	// var apElem uintptr at bp+8, 8

	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+43200 /* "SYSCALL-LIST" */)
		return 1
	}
	if tcl.XTcl_ListObjGetElements(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)), bp /* &nElem */, bp+8 /* &apElem */) != 0 {
		return 1
	}
	pVfs = sqlite3.Xsqlite3_vfs_find(tls, uintptr(0))

	for i = 0; i < *(*int32)(unsafe.Pointer(bp /* nElem */)); i++ {
		// var iCall int32 at bp+16, 4

		var rc int32 = tcl.XTcl_GetIndexFromObjStruct(tls, interp,
			*(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8 /* apElem */)) + uintptr(i)*8)), uintptr(unsafe.Pointer(&aSyscall)), int32(unsafe.Sizeof(TestSyscallArray{})), ts+43213 /* "system-call" */, 0, bp+16 /* &iCall */)
		if rc != 0 {
			return rc
		}
		if aSyscall[*(*int32)(unsafe.Pointer(bp + 16 /* iCall */))].FxOrig == uintptr(0) {
			aSyscall[*(*int32)(unsafe.Pointer(bp + 16 /* iCall */))].FxOrig = (*(*func(*crt.TLS, uintptr, uintptr) sqlite3_syscall_ptr)(unsafe.Pointer((pVfs + 152 /* &.xGetSystemCall */))))(tls, pVfs, aSyscall[*(*int32)(unsafe.Pointer(bp + 16 /* iCall */))].FzName)
			(*(*func(*crt.TLS, uintptr, uintptr, sqlite3_syscall_ptr) int32)(unsafe.Pointer((pVfs + 144 /* &.xSetSystemCall */))))(tls, pVfs, aSyscall[*(*int32)(unsafe.Pointer(bp + 16 /* iCall */))].FzName, aSyscall[*(*int32)(unsafe.Pointer(bp + 16 /* iCall */))].FxTest)
		}
		aSyscall[*(*int32)(unsafe.Pointer(bp + 16 /* iCall */))].Fcustom_errno = aSyscall[*(*int32)(unsafe.Pointer(bp + 16 /* iCall */))].Fdefault_errno
	}

	return 0
}

func test_syscall_uninstall(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_syscall.c:461:26: */
	var pVfs uintptr
	var i int32

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+792 /* "" */)
		return 1
	}

	pVfs = sqlite3.Xsqlite3_vfs_find(tls, uintptr(0))
	for i = 0; aSyscall[i].FzName != 0; i++ {
		if aSyscall[i].FxOrig != 0 {
			(*(*func(*crt.TLS, uintptr, uintptr, sqlite3_syscall_ptr) int32)(unsafe.Pointer((pVfs + 144 /* &.xSetSystemCall */))))(tls, pVfs, aSyscall[i].FzName, uintptr(0))
			aSyscall[i].FxOrig = uintptr(0)
		}
	}
	return 0
}

func test_syscall_reset(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_syscall.c:485:26: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var pVfs uintptr
	var i int32
	var rc int32

	if (objc != 2) && (objc != 3) {
		tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+792 /* "" */)
		return 1
	}

	pVfs = sqlite3.Xsqlite3_vfs_find(tls, uintptr(0))
	if objc == 2 {
		rc = (*(*func(*crt.TLS, uintptr, uintptr, sqlite3_syscall_ptr) int32)(unsafe.Pointer((pVfs + 144 /* &.xSetSystemCall */))))(tls, pVfs, uintptr(0), uintptr(0))
		for i = 0; aSyscall[i].FzName != 0; i++ {
			aSyscall[i].FxOrig = uintptr(0)
		}
	} else {
		// var nFunc int32 at bp, 4

		var zFunc uintptr = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)), bp /* &nFunc */)
		rc = (*(*func(*crt.TLS, uintptr, uintptr, sqlite3_syscall_ptr) int32)(unsafe.Pointer((pVfs + 144 /* &.xSetSystemCall */))))(tls, pVfs, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8))), uintptr(0))
		for i = 0; (rc == 0) && (aSyscall[i].FzName != 0); i++ {
			if crt.Xstrlen(tls, aSyscall[i].FzName) != size_t(*(*int32)(unsafe.Pointer(bp /* nFunc */))) {
				continue
			}
			if crt.Xmemcmp(tls, aSyscall[i].FzName, zFunc, uint64(*(*int32)(unsafe.Pointer(bp /* nFunc */)))) != 0 {
				continue
			}
			aSyscall[i].FxOrig = uintptr(0)
		}
	}
	if rc != 0 {
		tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3ErrName(tls, rc), -1))
		return 1
	}

	tcl.XTcl_ResetResult(tls, interp)
	return 0
}

func test_syscall_exists(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_syscall.c:523:26: */
	var pVfs uintptr
	var x sqlite3_syscall_ptr

	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+792 /* "" */)
		return 1
	}

	pVfs = sqlite3.Xsqlite3_vfs_find(tls, uintptr(0))
	x = (*(*func(*crt.TLS, uintptr, uintptr) sqlite3_syscall_ptr)(unsafe.Pointer((pVfs + 152 /* &.xGetSystemCall */))))(tls, pVfs, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8))))

	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, (crt.Bool32((crt.Bool32(x != uintptr(0))) != 0))))
	return 0
}

func test_syscall_fault(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_syscall.c:544:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	*(*int32)(unsafe.Pointer(bp /* nCount */)) = 0
	*(*int32)(unsafe.Pointer(bp + 4 /* bPersist */)) = 0

	if (objc != 2) && (objc != 4) {
		tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+43225 /* "?COUNT PERSIST?" */)
		return 1
	}

	if objc == 4 {
		if (tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)), bp /* &nCount */) != 0) ||
			(tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(3)*8)), bp+4 /* &bPersist */) != 0) {
			return 1
		}
	}

	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, gSyscall.FnFail))
	gSyscall.FnCount = *(*int32)(unsafe.Pointer(bp /* nCount */))
	gSyscall.FbPersist = *(*int32)(unsafe.Pointer(bp + 4 /* bPersist */))
	gSyscall.FnFail = 0
	return 0
}

func test_syscall_errno(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_syscall.c:573:26: */
	bp := tls.Alloc(204)
	defer tls.Free(204)

	// var iCall int32 at bp, 4

	// var iErrno int32 at bp+200, 4

	var rc int32

	*(*[12]Errno)(unsafe.Pointer(bp + 8 /* aErrno */)) = [12]Errno{
		{Fz: ts + 43241 /* "EACCES" */, Fi: 13},
		{Fz: ts + 43248 /* "EINTR" */, Fi: 4},
		{Fz: ts + 43254 /* "EIO" */, Fi: 5},
		{Fz: ts + 43258 /* "EOVERFLOW" */, Fi: 75},
		{Fz: ts + 43268 /* "ENOMEM" */, Fi: 12},
		{Fz: ts + 43275 /* "EAGAIN" */, Fi: 11},
		{Fz: ts + 43282 /* "ETIMEDOUT" */, Fi: 110},
		{Fz: ts + 43292 /* "EBUSY" */, Fi: 16},
		{Fz: ts + 43298 /* "EPERM" */, Fi: 1},
		{Fz: ts + 43304 /* "EDEADLK" */, Fi: 35},
		{Fz: ts + 43312 /* "ENOLCK" */, Fi: 37},
		{Fz: uintptr(0), Fi: 0},
	}

	if objc != 4 {
		tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+43319 /* "SYSCALL ERRNO" */)
		return 1
	}

	rc = tcl.XTcl_GetIndexFromObjStruct(tls, interp,
		*(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)), uintptr(unsafe.Pointer(&aSyscall)), int32(unsafe.Sizeof(TestSyscallArray{})), ts+43213 /* "system-call" */, 0, bp /* &iCall */)
	if rc != 0 {
		return rc
	}
	rc = tcl.XTcl_GetIndexFromObjStruct(tls, interp,
		*(*uintptr)(unsafe.Pointer(objv + uintptr(3)*8)), bp+8 /* &aErrno[0] */, int32(unsafe.Sizeof(Errno{})), ts+43333 /* "errno" */, 0, bp+200 /* &iErrno */)
	if rc != 0 {
		return rc
	}

	aSyscall[*(*int32)(unsafe.Pointer(bp /* iCall */))].Fcustom_errno = (*Errno)(unsafe.Pointer(bp + 8 /* &aErrno */ + uintptr(*(*int32)(unsafe.Pointer(bp + 200 /* iErrno */)))*16)).Fi
	return 0
}

type Errno = struct {
	Fz uintptr
	Fi int32
	_  [4]byte
}

func test_syscall_list(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_syscall.c:619:26: */
	var zSys uintptr
	var pVfs uintptr
	var pList uintptr

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+792 /* "" */)
		return 1
	}

	pVfs = sqlite3.Xsqlite3_vfs_find(tls, uintptr(0))
	pList = tcl.XTcl_NewObj(tls)
	(*Tcl_Obj)(unsafe.Pointer(pList)).FrefCount++
	for zSys = (*(*func(*crt.TLS, uintptr, uintptr) uintptr)(unsafe.Pointer((pVfs + 160 /* &.xNextSystemCall */))))(tls, pVfs, uintptr(0)); zSys != uintptr(0); zSys = (*(*func(*crt.TLS, uintptr, uintptr) uintptr)(unsafe.Pointer((pVfs + 160 /* &.xNextSystemCall */))))(tls, pVfs, zSys) {
		tcl.XTcl_ListObjAppendElement(tls, interp, pList, tcl.XTcl_NewStringObj(tls, zSys, -1))
	}

	tcl.XTcl_SetObjResult(tls, interp, pList)
	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = pList
		if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	return 0
}

func test_syscall_defaultvfs(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_syscall.c:649:26: */
	var pVfs uintptr

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+792 /* "" */)
		return 1
	}

	pVfs = sqlite3.Xsqlite3_vfs_find(tls, uintptr(0))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FzName, -1))
	return 0
}

func ts_getpagesize(tls *crt.TLS) int32 { /* test_syscall.c:667:12: */
	return gSyscall.Fpgsz
}

func test_syscall_pagesize(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_syscall.c:671:26: */
	bp := tls.Alloc(20)
	defer tls.Free(20)

	var pVfs uintptr = sqlite3.Xsqlite3_vfs_find(tls, uintptr(0))
	// var pgsz int32 at bp+16, 4

	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+43339 /* "PGSZ" */)
		return 1
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)), bp+16 /* &pgsz */) != 0 {
		return 1
	}

	if *(*int32)(unsafe.Pointer(bp + 16 /* pgsz */)) < 0 {
		if gSyscall.Forig_getpagesize != 0 {
			(*(*func(*crt.TLS, uintptr, uintptr, sqlite3_syscall_ptr) int32)(unsafe.Pointer((pVfs + 144 /* &.xSetSystemCall */))))(tls, pVfs, ts+43344 /* "getpagesize" */, gSyscall.Forig_getpagesize)
		}
	} else {
		if (*(*int32)(unsafe.Pointer(bp + 16 /* pgsz */)) < 512) || ((*(*int32)(unsafe.Pointer(bp + 16 /* pgsz */)) & (*(*int32)(unsafe.Pointer(bp + 16 /* pgsz */)) - 1)) != 0) {
			tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+43356 /* "pgsz out of rang..." */, 0))
			return 1
		}
		gSyscall.Forig_getpagesize = (*(*func(*crt.TLS, uintptr, uintptr) sqlite3_syscall_ptr)(unsafe.Pointer((pVfs + 152 /* &.xGetSystemCall */))))(tls, pVfs, ts+43344 /* "getpagesize" */)
		gSyscall.Fpgsz = *(*int32)(unsafe.Pointer(bp + 16 /* pgsz */))
		(*(*func(*crt.TLS, uintptr, uintptr, sqlite3_syscall_ptr) int32)(unsafe.Pointer((pVfs + 144 /* &.xSetSystemCall */))))(tls,
			pVfs, ts+43344 /* "getpagesize" */, *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS) int32 }{ts_getpagesize})))
	}

	return 0
}

func test_syscall(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_syscall.c:706:26: */
	bp := tls.Alloc(180)
	defer tls.Free(180)

	*(*[10]SyscallCmd)(unsafe.Pointer(bp + 16 /* aCmd */)) = [10]SyscallCmd{
		{FzName: ts + 43374 /* "fault" */, FxCmd: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
		}{test_syscall_fault}))},
		{FzName: ts + 43380 /* "install" */, FxCmd: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
		}{test_syscall_install}))},
		{FzName: ts + 43388 /* "uninstall" */, FxCmd: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
		}{test_syscall_uninstall}))},
		{FzName: ts + 7412 /* "reset" */, FxCmd: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
		}{test_syscall_reset}))},
		{FzName: ts + 43333 /* "errno" */, FxCmd: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
		}{test_syscall_errno}))},
		{FzName: ts + 20186 /* "exists" */, FxCmd: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
		}{test_syscall_exists}))},
		{FzName: ts + 43398 /* "list" */, FxCmd: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
		}{test_syscall_list}))},
		{FzName: ts + 43403 /* "defaultvfs" */, FxCmd: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
		}{test_syscall_defaultvfs}))},
		{FzName: ts + 43414 /* "pagesize" */, FxCmd: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
		}{test_syscall_pagesize}))},
		{FzName: uintptr(0), FxCmd: uintptr(0)},
	}
	// var iCmd int32 at bp+176, 4

	var rc int32
	var pVfs uintptr = sqlite3.Xsqlite3_vfs_find(tls, uintptr(0))

	if objc < 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+37895 /* "SUB-COMMAND ..." */)
		return 1
	}
	if ((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FiVersion < 3) || ((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FxSetSystemCall == uintptr(0)) {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+43423 /* "VFS does not sup..." */, 0))
		rc = 1
	} else {
		rc = tcl.XTcl_GetIndexFromObjStruct(tls, interp,
			*(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)), bp+16 /* &aCmd[0] */, int32(unsafe.Sizeof(SyscallCmd{})), ts+2321 /* "sub-command" */, 0, bp+176 /* &iCmd */)
	}
	if rc != 0 {
		return rc
	}
	return (*(*func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer((bp + 16 /* &aCmd */ + uintptr(*(*int32)(unsafe.Pointer(bp + 176 /* iCmd */)))*16 + 8 /* &.xCmd */))))(tls, clientData, interp, objc, objv)
}

type SyscallCmd = struct {
	FzName uintptr
	FxCmd  uintptr
}

func SqlitetestSyscall_Init(tls *crt.TLS, interp uintptr) int32 { /* test_syscall.c:747:5: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	*(*[1]SyscallCmd)(unsafe.Pointer(bp /* aCmd */)) = [1]SyscallCmd{
		{FzName: ts + 43459 /* "test_syscall" */, FxCmd: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
		}{test_syscall}))},
	}
	var i int32

	for i = 0; uint64(i) < (uint64(unsafe.Sizeof([1]SyscallCmd{})) / uint64(unsafe.Sizeof(SyscallCmd{}))); i++ {
		tcl.XTcl_CreateObjCommand(tls, interp, (*SyscallCmd)(unsafe.Pointer(bp /* &aCmd */ +uintptr(i)*16)).FzName, (*SyscallCmd)(unsafe.Pointer(bp /* &aCmd */ +uintptr(i)*16)).FxCmd, uintptr(0), uintptr(0))
	}
	return 0
}

// This routine is the primary export of this file.
//
// Configure the interpreter passed as the first argument to have access
// to the commands and linked variables that make up:
//
//   * the [sqlite3] extension itself,
//
//   * If SQLITE_TCLMD5 or SQLITE_TEST is defined, the Md5 commands, and
//
//   * If SQLITE_TEST is set, the various test interfaces used by the Tcl
//     test suite.
func sqlite3TestInit(tls *crt.TLS, interp uintptr) uintptr { /* test_tclsh.c:58:12: */
	bp := tls.Alloc(80)
	defer tls.Free(80)

	// var cmdInfo Tcl_CmdInfo at bp+16, 64

	/* Since the primary use case for this binary is testing of SQLite,
	 ** be sure to generate core files if we crash */
	{
		// var x rlimit at bp, 16

		crt.Xgetrlimit(tls, 4, bp /* &x */)
		(*rlimit)(unsafe.Pointer(bp /* &x */)).Frlim_cur = (*rlimit)(unsafe.Pointer(bp /* &x */)).Frlim_max
		crt.Xsetrlimit(tls, 4, bp /* &x */)
	}

	if tcl.XTcl_GetCommandInfo(tls, interp, ts+20933 /* "sqlite3" */, bp+16 /* &cmdInfo */) == 0 {
		Sqlite3_Init(tls, interp)
	}
	Md5_Init(tls, interp)
	Sqliteconfig_Init(tls, interp)
	Sqlitetest1_Init(tls, interp)
	Sqlitetest2_Init(tls, interp)
	Sqlitetest3_Init(tls, interp)
	Sqlitetest4_Init(tls, interp)
	Sqlitetest5_Init(tls, interp)
	Sqlitetest6_Init(tls, interp)
	Sqlitetest7_Init(tls, interp)
	Sqlitetest8_Init(tls, interp)
	Sqlitetest9_Init(tls, interp)
	Sqlitetestasync_Init(tls, interp)
	Sqlitetest_autoext_Init(tls, interp)
	Sqlitetest_blob_Init(tls, interp)
	Sqlitetest_demovfs_Init(tls, interp)
	Sqlitetest_func_Init(tls, interp)
	Sqlitetest_hexio_Init(tls, interp)
	Sqlitetest_init_Init(tls, interp)
	Sqlitetest_malloc_Init(tls, interp)
	Sqlitetest_mutex_Init(tls, interp)
	Sqlitetestschema_Init(tls, interp)
	Sqlitetesttclvar_Init(tls, interp)
	Sqlitetestfs_Init(tls, interp)
	SqlitetestThread_Init(tls, interp)
	SqlitetestOnefile_Init(tls)
	SqlitetestOsinst_Init(tls, interp)
	Sqlitetestbackup_Init(tls, interp)
	Sqlitetestintarray_Init(tls, interp)
	Sqlitetestvfs_Init(tls, interp)
	Sqlitetestrtree_Init(tls, interp)
	Sqlitequota_Init(tls, interp)
	Sqlitemultiplex_Init(tls, interp)
	SqliteSuperlock_Init(tls, interp)
	SqlitetestSyscall_Init(tls, interp)
	Fts5tcl_Init(tls, interp)
	SqliteRbu_Init(tls, interp)
	Sqlitetesttcl_Init(tls, interp)

	TestExpert_Init(tls, interp)
	Sqlitetest_window_Init(tls, interp)
	Sqlitetestvdbecov_Init(tls, interp)

	tcl.XTcl_CreateObjCommand(tls,
		interp, ts+43472 /* "load_testfixture..." */, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
		}{load_testfixture_extensions})), uintptr(0), uintptr(0))
	return uintptr(0)
}

// tclcmd:   load_testfixture_extensions
func load_testfixture_extensions(tls *crt.TLS, cd ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_tclsh.c:185:26: */
	var slave uintptr
	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+43500 /* "SLAVE" */)
		return 1
	}

	slave = tcl.XTcl_GetSlave(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))))
	if !(slave != 0) {
		return 1
	}

	sqlite3TestInit(tls, slave)
	return 0
}

// end block for C++

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:
// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.20 General utilities	<stdlib.h>

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.21 String handling	<string.h>

// Characters that make up the idxStr created by xBestIndex for xFilter.

type tclvar_vtab1 = struct {
	Fbase   sqlite3_vtab
	Finterp uintptr
}

// end block for C++

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:
// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.20 General utilities	<stdlib.h>

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.21 String handling	<string.h>

// Characters that make up the idxStr created by xBestIndex for xFilter.

type tclvar_vtab = tclvar_vtab1 /* test_tclvar.c:58:28 */
type tclvar_cursor1 = struct {
	Fbase   sqlite3_vtab_cursor
	FpList1 uintptr
	FpList2 uintptr
	Fi1     int32
	Fi2     int32
}

type tclvar_cursor = tclvar_cursor1 /* test_tclvar.c:59:30 */

// Methods for the tclvar module
func tclvarConnect(tls *crt.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVtab uintptr, pzErr uintptr) int32 { /* test_tclvar.c:80:12: */
	var pVtab uintptr
	pVtab = sqlite3.Xsqlite3MallocZero(tls, uint64(unsafe.Sizeof(tclvar_vtab{})))
	if pVtab == uintptr(0) {
		return 7
	}
	*(*uintptr)(unsafe.Pointer(ppVtab)) = (pVtab /* &.base */)
	(*tclvar_vtab)(unsafe.Pointer(pVtab)).Finterp = pAux
	sqlite3.Xsqlite3_declare_vtab(tls, db, uintptr(unsafe.Pointer(&zSchema)))
	return 0
}

var zSchema = *(*[100]int8)(unsafe.Pointer(ts + 43506 /* "CREATE TABLE x( ..." */)) /* test_tclvar.c:88:21 */
// Note that for this virtual table, the xCreate and xConnect
// methods are identical.

func tclvarDisconnect(tls *crt.TLS, pVtab uintptr) int32 { /* test_tclvar.c:105:12: */
	sqlite3.Xsqlite3_free(tls, pVtab)
	return 0
}

// The xDisconnect and xDestroy methods are also the same

// Open a new tclvar cursor.
func tclvarOpen(tls *crt.TLS, pVTab uintptr, ppCursor uintptr) int32 { /* test_tclvar.c:114:12: */
	var pCur uintptr
	pCur = sqlite3.Xsqlite3MallocZero(tls, uint64(unsafe.Sizeof(tclvar_cursor{})))
	*(*uintptr)(unsafe.Pointer(ppCursor)) = (pCur /* &.base */)
	return 0
}

// Close a tclvar cursor.
func tclvarClose(tls *crt.TLS, cur uintptr) int32 { /* test_tclvar.c:124:12: */
	var pCur uintptr = cur
	if (*tclvar_cursor)(unsafe.Pointer(pCur)).FpList1 != 0 {
		for ok := true; ok; ok = 0 != 0 {
			var _objPtr uintptr = (*tclvar_cursor)(unsafe.Pointer(pCur)).FpList1
			if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
	}
	if (*tclvar_cursor)(unsafe.Pointer(pCur)).FpList2 != 0 {
		for ok1 := true; ok1; ok1 = 0 != 0 {
			var _objPtr uintptr = (*tclvar_cursor)(unsafe.Pointer(pCur)).FpList2
			if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
	}
	sqlite3.Xsqlite3_free(tls, pCur)
	return 0
}

// Returns 1 if data is ready, or 0 if not.
func next2(tls *crt.TLS, interp uintptr, pCur uintptr, pObj uintptr) int32 { /* test_tclvar.c:139:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var p uintptr

	if pObj != 0 {
		if !(int32((*tclvar_cursor)(unsafe.Pointer(pCur)).FpList2) != 0) {
			p = tcl.XTcl_NewStringObj(tls, ts+43606 /* "array names" */, -1)
			(*Tcl_Obj)(unsafe.Pointer(p)).FrefCount++
			tcl.XTcl_ListObjAppendElement(tls, uintptr(0), p, pObj)
			tcl.XTcl_EvalObjEx(tls, interp, p, 0x020000)
			for ok := true; ok; ok = 0 != 0 {
				var _objPtr uintptr = p
				if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
					tcl.XTclFreeObj(tls, _objPtr)
				}
			}
			(*tclvar_cursor)(unsafe.Pointer(pCur)).FpList2 = tcl.XTcl_GetObjResult(tls, interp)
			(*Tcl_Obj)(unsafe.Pointer((*tclvar_cursor)(unsafe.Pointer(pCur)).FpList2)).FrefCount++
		} else {
			*(*int32)(unsafe.Pointer(bp /* n */)) = 0
			(*tclvar_cursor)(unsafe.Pointer(pCur)).Fi2++
			tcl.XTcl_ListObjLength(tls, uintptr(0), (*tclvar_cursor)(unsafe.Pointer(pCur)).FpList2, bp /* &n */)
			if (*tclvar_cursor)(unsafe.Pointer(pCur)).Fi2 >= *(*int32)(unsafe.Pointer(bp /* n */)) {
				for ok1 := true; ok1; ok1 = 0 != 0 {
					var _objPtr uintptr = (*tclvar_cursor)(unsafe.Pointer(pCur)).FpList2
					if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
						tcl.XTclFreeObj(tls, _objPtr)
					}
				}
				(*tclvar_cursor)(unsafe.Pointer(pCur)).FpList2 = uintptr(0)
				(*tclvar_cursor)(unsafe.Pointer(pCur)).Fi2 = 0
				return 0
			}
		}
	}

	return 1
}

func tclvarNext(tls *crt.TLS, cur uintptr) int32 { /* test_tclvar.c:168:12: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	// var pObj uintptr at bp+8, 8

	*(*int32)(unsafe.Pointer(bp /* n */)) = 0
	var ok int32 = 0

	var pCur uintptr = cur
	var interp uintptr = (*tclvar_vtab)(unsafe.Pointer((*sqlite3_vtab_cursor)(unsafe.Pointer(cur)).FpVtab)).Finterp

	tcl.XTcl_ListObjLength(tls, uintptr(0), (*tclvar_cursor)(unsafe.Pointer(pCur)).FpList1, bp /* &n */)
	for !(ok != 0) && ((*tclvar_cursor)(unsafe.Pointer(pCur)).Fi1 < *(*int32)(unsafe.Pointer(bp /* n */))) {
		tcl.XTcl_ListObjIndex(tls, uintptr(0), (*tclvar_cursor)(unsafe.Pointer(pCur)).FpList1, (*tclvar_cursor)(unsafe.Pointer(pCur)).Fi1, bp+8 /* &pObj */)
		ok = next2(tls, interp, pCur, *(*uintptr)(unsafe.Pointer(bp + 8 /* pObj */)))
		if !(ok != 0) {
			(*tclvar_cursor)(unsafe.Pointer(pCur)).Fi1++
		}
	}

	return 0
}

func tclvarFilter(tls *crt.TLS, pVtabCursor uintptr, idxNum int32, idxStr uintptr, argc int32, argv uintptr) int32 { /* test_tclvar.c:188:12: */
	var pCur uintptr = pVtabCursor
	var interp uintptr = (*tclvar_vtab)(unsafe.Pointer((*sqlite3_vtab_cursor)(unsafe.Pointer(pVtabCursor)).FpVtab)).Finterp
	var p uintptr = tcl.XTcl_NewStringObj(tls, ts+43618 /* "tclvar_filter_cm..." */, -1)

	var zEq uintptr = ts + 792     /* "" */
	var zMatch uintptr = ts + 792  /* "" */
	var zGlob uintptr = ts + 792   /* "" */
	var zRegexp uintptr = ts + 792 /* "" */
	var zLike uintptr = ts + 792   /* "" */
	var i int32

	for i = 0; *(*int8)(unsafe.Pointer(idxStr + uintptr(i))) != 0; i++ {
		switch int32(*(*int8)(unsafe.Pointer(idxStr + uintptr(i)))) {
		case 'e':
			zEq = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8)))
			break
		case 'm':
			zMatch = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8)))
			break
		case 'g':
			zGlob = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8)))
			break
		case 'r':
			zRegexp = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8)))
			break
		case 'l':
			zLike = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8)))
			break
		default:
		}
	}

	(*Tcl_Obj)(unsafe.Pointer(p)).FrefCount++
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), p, tcl.XTcl_NewStringObj(tls, zEq, -1))
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), p, tcl.XTcl_NewStringObj(tls, zMatch, -1))
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), p, tcl.XTcl_NewStringObj(tls, zGlob, -1))
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), p, tcl.XTcl_NewStringObj(tls, zRegexp, -1))
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), p, tcl.XTcl_NewStringObj(tls, zLike, -1))

	tcl.XTcl_EvalObjEx(tls, interp, p, 0x020000)
	if (*tclvar_cursor)(unsafe.Pointer(pCur)).FpList1 != 0 {
		for ok := true; ok; ok = 0 != 0 {
			var _objPtr uintptr = (*tclvar_cursor)(unsafe.Pointer(pCur)).FpList1
			if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
	}
	if (*tclvar_cursor)(unsafe.Pointer(pCur)).FpList2 != 0 {
		for ok1 := true; ok1; ok1 = 0 != 0 {
			var _objPtr uintptr = (*tclvar_cursor)(unsafe.Pointer(pCur)).FpList2
			if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
		(*tclvar_cursor)(unsafe.Pointer(pCur)).FpList2 = uintptr(0)
	}
	(*tclvar_cursor)(unsafe.Pointer(pCur)).Fi1 = 0
	(*tclvar_cursor)(unsafe.Pointer(pCur)).Fi2 = 0
	(*tclvar_cursor)(unsafe.Pointer(pCur)).FpList1 = tcl.XTcl_GetObjResult(tls, interp)
	(*Tcl_Obj)(unsafe.Pointer((*tclvar_cursor)(unsafe.Pointer(pCur)).FpList1)).FrefCount++

	for ok2 := true; ok2; ok2 = 0 != 0 {
		var _objPtr uintptr = p
		if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	return tclvarNext(tls, pVtabCursor)
}

func tclvarColumn(tls *crt.TLS, cur uintptr, ctx uintptr, i int32) int32 { /* test_tclvar.c:250:12: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	// var p1 uintptr at bp+16, 8

	// var p2 uintptr at bp+24, 8

	var z1 uintptr
	var z2 uintptr = ts + 792 /* "" */
	var pCur uintptr = cur
	var interp uintptr = (*tclvar_vtab)(unsafe.Pointer((*sqlite3_vtab_cursor)(unsafe.Pointer(cur)).FpVtab)).Finterp

	tcl.XTcl_ListObjIndex(tls, interp, (*tclvar_cursor)(unsafe.Pointer(pCur)).FpList1, (*tclvar_cursor)(unsafe.Pointer(pCur)).Fi1, bp+16 /* &p1 */)
	tcl.XTcl_ListObjIndex(tls, interp, (*tclvar_cursor)(unsafe.Pointer(pCur)).FpList2, (*tclvar_cursor)(unsafe.Pointer(pCur)).Fi2, bp+24 /* &p2 */)
	z1 = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* p1 */)))
	if *(*uintptr)(unsafe.Pointer(bp + 24 /* p2 */)) != 0 {
		z2 = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(bp + 24 /* p2 */)))
	}
	switch i {
	case 0:
		{
			sqlite3.Xsqlite3_result_text(tls, ctx, z1, -1, crt.UintptrFromInt32(-1))
			break
		}
	case 1:
		{
			sqlite3.Xsqlite3_result_text(tls, ctx, z2, -1, crt.UintptrFromInt32(-1))
			break
		}
	case 2:
		{
			var pVal uintptr = tcl.XTcl_GetVar2Ex(tls, interp, z1, func() uintptr {
				if *(*int8)(unsafe.Pointer(z2)) != 0 {
					return z2
				}
				return uintptr(0)
			}(), 1)
			sqlite3.Xsqlite3_result_text(tls, ctx, tcl.XTcl_GetString(tls, pVal), -1, crt.UintptrFromInt32(-1))
			break
		}
	case 3:
		{
			var z3 uintptr
			if *(*uintptr)(unsafe.Pointer(bp + 24 /* p2 */)) != 0 {
				z3 = sqlite3.Xsqlite3_mprintf(tls, ts+43636 /* "%s(%s)" */, crt.VaList(bp, z1, z2))
				sqlite3.Xsqlite3_result_text(tls, ctx, z3, -1, *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, uintptr) }{sqlite3.Xsqlite3_free})))
			} else {
				sqlite3.Xsqlite3_result_text(tls, ctx, z1, -1, crt.UintptrFromInt32(-1))
			}
			break
		}
	}
	return 0
}

func tclvarRowid(tls *crt.TLS, cur uintptr, pRowid uintptr) int32 { /* test_tclvar.c:292:12: */
	*(*sqlite_int64)(unsafe.Pointer(pRowid)) = int64(0)
	return 0
}

func tclvarEof(tls *crt.TLS, cur uintptr) int32 { /* test_tclvar.c:297:12: */
	var pCur uintptr = cur
	return func() int32 {
		if (*tclvar_cursor)(unsafe.Pointer(pCur)).FpList2 != 0 {
			return 0
		}
		return 1
	}()
}

// If nul-terminated string zStr does not already contain the character
// passed as the second argument, append it and return 0. Or, if there is
// already an instance of x in zStr, do nothing return 1;
//
// There is guaranteed to be enough room in the buffer pointed to by zStr
// for the new character and nul-terminator.
func tclvarAddToIdxstr(tls *crt.TLS, zStr uintptr, x int8) int32 { /* test_tclvar.c:310:12: */
	var i int32
	for i = 0; *(*int8)(unsafe.Pointer(zStr + uintptr(i))) != 0; i++ {
		if int32(*(*int8)(unsafe.Pointer(zStr + uintptr(i)))) == int32(x) {
			return 1
		}
	}
	*(*int8)(unsafe.Pointer(zStr + uintptr(i))) = x
	*(*int8)(unsafe.Pointer(zStr + uintptr((i + 1)))) = int8(0)
	return 0
}

// Return true if variable $::tclvar_set_omit exists and is set to true.
// False otherwise.
func tclvarSetOmit(tls *crt.TLS, interp uintptr) int32 { /* test_tclvar.c:324:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var rc int32
	*(*int32)(unsafe.Pointer(bp /* res */)) = 0
	var pRes uintptr
	rc = tcl.XTcl_Eval(tls, interp,
		ts+43643 /* "expr {[info exis..." */)
	if rc == 0 {
		pRes = tcl.XTcl_GetObjResult(tls, interp)
		rc = tcl.XTcl_GetBooleanFromObj(tls, uintptr(0), pRes, bp /* &res */)
	}
	return (crt.Bool32((rc == 0) && (*(*int32)(unsafe.Pointer(bp /* res */)) != 0)))
}

// The xBestIndex() method. This virtual table supports the following
// operators:
//
//     name = ?                    (omit flag clear)
//     name MATCH ?                (omit flag set)
//     value GLOB ?                (omit flag set iff $::tclvar_set_omit)
//     value REGEXP ?              (omit flag set iff $::tclvar_set_omit)
//     value LIKE ?                (omit flag set iff $::tclvar_set_omit)
//
// For each constraint present, the corresponding TCLVAR_XXX character is
// appended to the idxStr value.
func tclvarBestIndex(tls *crt.TLS, tab uintptr, pIdxInfo uintptr) int32 { /* test_tclvar.c:351:12: */
	var pTab uintptr = tab
	var ii int32
	var zStr uintptr = sqlite3.Xsqlite3_malloc(tls, 32)
	var iStr int32 = 0

	if zStr == uintptr(0) {
		return 7
	}
	*(*int8)(unsafe.Pointer(zStr + uintptr(0))) = int8(0)

	for ii = 0; ii < (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnConstraint; ii++ {
		var pCons uintptr = ((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraint + uintptr(ii)*12)
		var pUsage uintptr

		pUsage = ((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(ii)*8)
		if (*sqlite3_index_constraint)(unsafe.Pointer(pCons)).Fusable != 0 {
			// name = ?
			if (int32((*sqlite3_index_constraint)(unsafe.Pointer(pCons)).Fop) == 2) && ((*sqlite3_index_constraint)(unsafe.Pointer(pCons)).FiColumn == 0) {
				if 0 == tclvarAddToIdxstr(tls, zStr, int8('e')) {
					(*sqlite3_index_constraint_usage)(unsafe.Pointer(pUsage)).FargvIndex = crt.PreIncInt32(&iStr, 1)
					(*sqlite3_index_constraint_usage)(unsafe.Pointer(pUsage)).Fomit = uint8(0)
				}
			}

			// name MATCH ?
			if (int32((*sqlite3_index_constraint)(unsafe.Pointer(pCons)).Fop) == 64) && ((*sqlite3_index_constraint)(unsafe.Pointer(pCons)).FiColumn == 0) {
				if 0 == tclvarAddToIdxstr(tls, zStr, int8('m')) {
					(*sqlite3_index_constraint_usage)(unsafe.Pointer(pUsage)).FargvIndex = crt.PreIncInt32(&iStr, 1)
					(*sqlite3_index_constraint_usage)(unsafe.Pointer(pUsage)).Fomit = uint8(1)
				}
			}

			// value GLOB ?
			if (int32((*sqlite3_index_constraint)(unsafe.Pointer(pCons)).Fop) == 66) && ((*sqlite3_index_constraint)(unsafe.Pointer(pCons)).FiColumn == 2) {
				if 0 == tclvarAddToIdxstr(tls, zStr, int8('g')) {
					(*sqlite3_index_constraint_usage)(unsafe.Pointer(pUsage)).FargvIndex = crt.PreIncInt32(&iStr, 1)
					(*sqlite3_index_constraint_usage)(unsafe.Pointer(pUsage)).Fomit = uint8(tclvarSetOmit(tls, (*tclvar_vtab)(unsafe.Pointer(pTab)).Finterp))
				}
			}

			// value REGEXP ?
			if (int32((*sqlite3_index_constraint)(unsafe.Pointer(pCons)).Fop) == 67) && ((*sqlite3_index_constraint)(unsafe.Pointer(pCons)).FiColumn == 2) {
				if 0 == tclvarAddToIdxstr(tls, zStr, int8('r')) {
					(*sqlite3_index_constraint_usage)(unsafe.Pointer(pUsage)).FargvIndex = crt.PreIncInt32(&iStr, 1)
					(*sqlite3_index_constraint_usage)(unsafe.Pointer(pUsage)).Fomit = uint8(tclvarSetOmit(tls, (*tclvar_vtab)(unsafe.Pointer(pTab)).Finterp))
				}
			}

			// value LIKE ?
			if (int32((*sqlite3_index_constraint)(unsafe.Pointer(pCons)).Fop) == 65) && ((*sqlite3_index_constraint)(unsafe.Pointer(pCons)).FiColumn == 2) {
				if 0 == tclvarAddToIdxstr(tls, zStr, int8('l')) {
					(*sqlite3_index_constraint_usage)(unsafe.Pointer(pUsage)).FargvIndex = crt.PreIncInt32(&iStr, 1)
					(*sqlite3_index_constraint_usage)(unsafe.Pointer(pUsage)).Fomit = uint8(tclvarSetOmit(tls, (*tclvar_vtab)(unsafe.Pointer(pTab)).Finterp))
				}
			}
		}
	}
	(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxStr = zStr
	(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FneedToFreeIdxStr = 1

	return 0
}

// Invoked for any UPDATE, INSERT, or DELETE against a tclvar table
func tclvarUpdate(tls *crt.TLS, tab uintptr, argc int32, argv uintptr, pRowid uintptr) int32 { /* test_tclvar.c:416:12: */
	var pTab uintptr = tab
	if argc == 1 {
		// A DELETE operation.  The variable to be deleted is stored in argv[0]
		var zVar uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)))
		tcl.XTcl_UnsetVar2(tls, (*tclvar_vtab)(unsafe.Pointer(pTab)).Finterp, zVar, uintptr(0), 1)
		return 0
	}
	if sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8))) == 5 {
		// An INSERT operation
		var zValue uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(4)*8)))
		var zName uintptr
		if sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(5)*8))) != 3 {
			(*sqlite3_vtab)(unsafe.Pointer(tab)).FzErrMsg = sqlite3.Xsqlite3_mprintf(tls, ts+43704 /* "the 'fullname' c..." */, 0)
			return 1
		}
		zName = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(5)*8)))
		if zValue != 0 {
			tcl.XTcl_SetVar2(tls, (*tclvar_vtab)(unsafe.Pointer(pTab)).Finterp, zName, uintptr(0), zValue, 1)
		} else {
			tcl.XTcl_UnsetVar2(tls, (*tclvar_vtab)(unsafe.Pointer(pTab)).Finterp, zName, uintptr(0), 1)
		}
		return 0
	}
	if (sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8))) == 3) &&
		(sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8))) == 3) {
		// An UPDATE operation
		var zOldName uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)))
		var zNewName uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)))
		var zValue uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(4)*8)))

		if (crt.Xstrcmp(tls, zOldName, zNewName) != 0) || (zValue == uintptr(0)) {
			tcl.XTcl_UnsetVar2(tls, (*tclvar_vtab)(unsafe.Pointer(pTab)).Finterp, zOldName, uintptr(0), 1)
		}
		if zValue != uintptr(0) {
			tcl.XTcl_SetVar2(tls, (*tclvar_vtab)(unsafe.Pointer(pTab)).Finterp, zNewName, uintptr(0), zValue, 1)
		}
		return 0
	}
	(*sqlite3_vtab)(unsafe.Pointer(tab)).FzErrMsg = sqlite3.Xsqlite3_mprintf(tls, ts+43739 /* "prohibited TCL v..." */, 0)
	return 1
}

// A virtual table module that provides read-only access to a
// Tcl global variable namespace.
var tclvarModule = sqlite3_module{FiVersion: 0, FxCreate: // iVersion
0, FxConnect:                                             0, FxBestIndex: 0, FxDisconnect: 0, FxDestroy: 0, FxOpen: 0, FxClose: // xOpen - open a cursor
0, FxFilter:// xClose - close a cursor
0, FxNext:// xFilter - configure scan constraints
0, FxEof:// xNext - advance a cursor
0, FxColumn:// xEof - check for end of scan
0, FxRowid:// xColumn - read data
0, FxUpdate:// xRowid - read data
0, FxBegin:// xUpdate
uintptr(0), FxSync:// xBegin
uintptr(0), FxCommit:// xSync
uintptr(0), FxRollback:// xCommit
uintptr(0), FxFindFunction:// xRollback
uintptr(0), FxRename:// xFindMethod
uintptr(0), // xRename
} /* test_tclvar.c:469:23 */

// Register the echo virtual table module.
func register_tclvar_module(tls *crt.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_tclvar.c:500:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var rc int32 = 0
	// var db uintptr at bp, 8

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+2452 /* "DB" */)
		return 1
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), bp /* &db */) != 0 {
		return 1
	}
	sqlite3.Xsqlite3_create_module(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), ts+34758 /* "tclvar" */, uintptr(unsafe.Pointer(&tclvarModule)), interp)
	rc = tcl.XTcl_Eval(tls, interp,

		ts+43770 /* "proc like {patte..." */)
	return rc
}

// Register commands with the TCL interpreter.
func Sqlitetesttclvar_Init(tls *crt.TLS, interp uintptr) int32 { /* test_tclvar.c:546:5: */
	var i int32
	for i = 0; uint64(i) < (uint64(unsafe.Sizeof(aObjCmd13)) / uint64(unsafe.Sizeof(struct {
		FzName      uintptr
		FxProc      uintptr
		FclientData uintptr
	}{}))); i++ {
		tcl.XTcl_CreateObjCommand(tls, interp, aObjCmd13[i].FzName,
			aObjCmd13[i].FxProc, aObjCmd13[i].FclientData, uintptr(0))
	}
	return 0
}

var aObjCmd13 = [1]struct {
	FzName      uintptr
	FxProc      uintptr
	FclientData uintptr
}{
	{FzName: ts + 44306 /* "register_tclvar_..." */, FxProc: 0, FclientData: uintptr(0)},
} /* test_tclvar.c:552:5 */

// Prior to Issue 6, the Single Unix Specification required these
//   prototypes to appear in this header.  They are also found in
//   <stdio.h>.

// Unix98 requires this function to be declared here.  In other
//   standards it is in <pthread.h>.

// Define some macros helping to catch buffer overflows.

// One of these is allocated for each thread created by [sqlthread spawn].
type SqlThread1 = struct {
	Fparent   Tcl_ThreadId
	Finterp   uintptr
	FzScript  uintptr
	FzVarname uintptr
}

// Prior to Issue 6, the Single Unix Specification required these
//   prototypes to appear in this header.  They are also found in
//   <stdio.h>.

// Unix98 requires this function to be declared here.  In other
//   standards it is in <pthread.h>.

// Define some macros helping to catch buffer overflows.

// One of these is allocated for each thread created by [sqlthread spawn].
type SqlThread = SqlThread1 /* test_thread.c:36:26 */

// A custom Tcl_Event type used by this module. When the event is
// handled, script zScript is evaluated in interpreter interp. If
// the evaluation throws an exception (returns TCL_ERROR), then the
// error is handled by Tcl_BackgroundError(). If no error occurs,
// the result is simply discarded.
type EvalEvent1 = struct {
	Fbase    Tcl_Event
	FzScript uintptr
	Finterp  uintptr
}

// A custom Tcl_Event type used by this module. When the event is
// handled, script zScript is evaluated in interpreter interp. If
// the evaluation throws an exception (returns TCL_ERROR), then the
// error is handled by Tcl_BackgroundError(). If no error occurs,
// the result is simply discarded.
type EvalEvent = EvalEvent1 /* test_thread.c:51:26 */

// Handler for events of type EvalEvent.
func tclScriptEvent(tls *crt.TLS, evPtr uintptr, flags int32) int32 { /* test_thread.c:79:26: */
	var rc int32
	var p uintptr = evPtr
	rc = tcl.XTcl_Eval(tls, (*EvalEvent)(unsafe.Pointer(p)).Finterp, (*EvalEvent)(unsafe.Pointer(p)).FzScript)
	if rc != 0 {
		tcl.XTcl_BackgroundError(tls, (*EvalEvent)(unsafe.Pointer(p)).Finterp)
	}
	_ = flags
	return 1
}

// Register an EvalEvent to evaluate the script pScript in the
// parent interpreter/thread of SqlThread p.
func postToParent(tls *crt.TLS, p uintptr, pScript uintptr) { /* test_thread.c:94:13: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var pEvent uintptr
	var zMsg uintptr
	// var nMsg int32 at bp, 4

	zMsg = tcl.XTcl_GetStringFromObj(tls, pScript, bp /* &nMsg */)
	pEvent = tcl.XTcl_Alloc(tls, (uint32((uint64(unsafe.Sizeof(EvalEvent{})) + uint64(*(*int32)(unsafe.Pointer(bp /* nMsg */)))) + uint64(1))))
	(*EvalEvent)(unsafe.Pointer(pEvent)).Fbase.FnextPtr = uintptr(0)
	(*EvalEvent)(unsafe.Pointer(pEvent)).Fbase.Fproc = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, int32) int32
	}{tclScriptEvent}))
	(*EvalEvent)(unsafe.Pointer(pEvent)).FzScript = (pEvent + uintptr(1)*32)
	crt.Xmemcpy(tls, (*EvalEvent)(unsafe.Pointer(pEvent)).FzScript, zMsg, (uint64(*(*int32)(unsafe.Pointer(bp /* nMsg */)) + 1)))
	(*EvalEvent)(unsafe.Pointer(pEvent)).Finterp = (*SqlThread)(unsafe.Pointer(p)).Finterp

	tcl.XTcl_ThreadQueueEvent(tls, (*SqlThread)(unsafe.Pointer(p)).Fparent, pEvent, uint32(0))
	tcl.XTcl_ThreadAlert(tls, (*SqlThread)(unsafe.Pointer(p)).Fparent)
}

// The main function for threads created with [sqlthread spawn].
func tclScriptThread(tls *crt.TLS, pSqlThread ClientData) { /* test_thread.c:114:29: */
	var interp uintptr
	var pRes uintptr
	var pList uintptr
	var rc int32
	var p uintptr = pSqlThread

	interp = tcl.XTcl_CreateInterp(tls)
	tcl.XTcl_CreateObjCommand(tls, interp, ts+44329 /* "clock_seconds" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
	}{clock_seconds_proc})), uintptr(0), uintptr(0))
	tcl.XTcl_CreateObjCommand(tls, interp, ts+44343 /* "sqlthread" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
	}{sqlthread_proc})), pSqlThread, uintptr(0))
	tcl.XTcl_CreateObjCommand(tls, interp, ts+44353 /* "sqlite3_blocking..." */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{blocking_step_proc})), uintptr(0), uintptr(0))
	tcl.XTcl_CreateObjCommand(tls, interp,
		ts+44375 /* "sqlite3_blocking..." */, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
		}{blocking_prepare_v2_proc})), uintptr(1), uintptr(0))
	tcl.XTcl_CreateObjCommand(tls, interp,
		ts+44403 /* "sqlite3_nonblock..." */, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
		}{blocking_prepare_v2_proc})), uintptr(0), uintptr(0))
	Sqlitetest1_Init(tls, interp)
	Sqlitetest_mutex_Init(tls, interp)
	Sqlite3_Init(tls, interp)

	rc = tcl.XTcl_Eval(tls, interp, (*SqlThread)(unsafe.Pointer(p)).FzScript)
	pRes = tcl.XTcl_GetObjResult(tls, interp)
	pList = tcl.XTcl_NewObj(tls)
	(*Tcl_Obj)(unsafe.Pointer(pList)).FrefCount++
	(*Tcl_Obj)(unsafe.Pointer(pRes)).FrefCount++

	if rc != 0 {
		tcl.XTcl_ListObjAppendElement(tls, interp, pList, tcl.XTcl_NewStringObj(tls, ts+16749 /* "error" */, -1))
		tcl.XTcl_ListObjAppendElement(tls, interp, pList, pRes)
		postToParent(tls, p, pList)
		for ok := true; ok; ok = 0 != 0 {
			var _objPtr uintptr = pList
			if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
		pList = tcl.XTcl_NewObj(tls)
	}

	tcl.XTcl_ListObjAppendElement(tls, interp, pList, tcl.XTcl_NewStringObj(tls, ts+44434 /* "set" */, -1))
	tcl.XTcl_ListObjAppendElement(tls, interp, pList, tcl.XTcl_NewStringObj(tls, (*SqlThread)(unsafe.Pointer(p)).FzVarname, -1))
	tcl.XTcl_ListObjAppendElement(tls, interp, pList, pRes)
	postToParent(tls, p, pList)

	tcl.XTcl_Free(tls, p)
	for ok1 := true; ok1; ok1 = 0 != 0 {
		var _objPtr uintptr = pList
		if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	for ok2 := true; ok2; ok2 = 0 != 0 {
		var _objPtr uintptr = pRes
		if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	tcl.XTcl_DeleteInterp(tls, interp)
	for tcl.XTcl_DoOneEvent(tls, ((^int32(crt.Int32FromInt32((int32(1) << 1))))|(int32(1)<<1))) != 0 {
	}
	tcl.XTcl_ExitThread(tls, 0)

}

// sqlthread spawn VARNAME SCRIPT
//
//     Spawn a new thread with its own Tcl interpreter and run the
//     specified SCRIPT(s) in it. The thread terminates after running
//     the script. The result of the script is stored in the variable
//     VARNAME.
//
//     The caller can wait for the script to terminate using [vwait VARNAME].
func sqlthread_spawn(tls *crt.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_thread.c:174:26: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	// var x Tcl_ThreadId at bp+24, 8

	var pNew uintptr
	var rc int32
	// var nVarname int32 at bp+16, 4

	var zVarname uintptr
	// var nScript int32 at bp+20, 4

	var zScript uintptr

	// Parameters for thread creation
	var nStack int32 = 0
	var flags int32 = 0000

	_ = clientData
	_ = objc

	zVarname = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)), bp+16 /* &nVarname */)
	zScript = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(3)*8)), bp+20 /* &nScript */)

	pNew = tcl.XTcl_Alloc(tls, (uint32(((uint64(unsafe.Sizeof(SqlThread{})) + uint64(*(*int32)(unsafe.Pointer(bp + 16 /* nVarname */)))) + uint64(*(*int32)(unsafe.Pointer(bp + 20 /* nScript */)))) + uint64(2))))
	(*SqlThread)(unsafe.Pointer(pNew)).FzVarname = (pNew + uintptr(1)*32)
	(*SqlThread)(unsafe.Pointer(pNew)).FzScript = ((*SqlThread)(unsafe.Pointer(pNew)).FzVarname + uintptr((*(*int32)(unsafe.Pointer(bp + 16 /* nVarname */)) + 1)))
	crt.Xmemcpy(tls, (*SqlThread)(unsafe.Pointer(pNew)).FzVarname, zVarname, (uint64(*(*int32)(unsafe.Pointer(bp + 16 /* nVarname */)) + 1)))
	crt.Xmemcpy(tls, (*SqlThread)(unsafe.Pointer(pNew)).FzScript, zScript, (uint64(*(*int32)(unsafe.Pointer(bp + 20 /* nScript */)) + 1)))
	(*SqlThread)(unsafe.Pointer(pNew)).Fparent = tcl.XTcl_GetCurrentThread(tls)
	(*SqlThread)(unsafe.Pointer(pNew)).Finterp = interp

	rc = tcl.XTcl_CreateThread(tls, bp+24 /* &x */, *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, ClientData) }{tclScriptThread})), pNew, nStack, flags)
	if rc != 0 {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+44438 /* "Error in Tcl_Cre..." */, 0))
		tcl.XTcl_Free(tls, pNew)
		return 1
	}

	return 0
}

// sqlthread parent SCRIPT
//
//     This can be called by spawned threads only. It sends the specified
//     script back to the parent thread for execution. The result of
//     evaluating the SCRIPT is returned. The parent thread must enter
//     the event loop for this to work - otherwise the caller will
//     block indefinitely.
//
//     NOTE: At the moment, this doesn't work. FIXME.
func sqlthread_parent(tls *crt.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_thread.c:227:26: */
	bp := tls.Alloc(20)
	defer tls.Free(20)

	var pEvent uintptr
	var zMsg uintptr
	// var nMsg int32 at bp+16, 4

	var p uintptr = clientData

	_ = objc

	if p == uintptr(0) {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+44466 /* "no parent thread" */, 0))
		return 1
	}

	zMsg = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)), bp+16 /* &nMsg */)
	pEvent = tcl.XTcl_Alloc(tls, (uint32((uint64(unsafe.Sizeof(EvalEvent{})) + uint64(*(*int32)(unsafe.Pointer(bp + 16 /* nMsg */)))) + uint64(1))))
	(*EvalEvent)(unsafe.Pointer(pEvent)).Fbase.FnextPtr = uintptr(0)
	(*EvalEvent)(unsafe.Pointer(pEvent)).Fbase.Fproc = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, int32) int32
	}{tclScriptEvent}))
	(*EvalEvent)(unsafe.Pointer(pEvent)).FzScript = (pEvent + uintptr(1)*32)
	crt.Xmemcpy(tls, (*EvalEvent)(unsafe.Pointer(pEvent)).FzScript, zMsg, (uint64(*(*int32)(unsafe.Pointer(bp + 16 /* nMsg */)) + 1)))
	(*EvalEvent)(unsafe.Pointer(pEvent)).Finterp = (*SqlThread)(unsafe.Pointer(p)).Finterp
	tcl.XTcl_ThreadQueueEvent(tls, (*SqlThread)(unsafe.Pointer(p)).Fparent, pEvent, uint32(0))
	tcl.XTcl_ThreadAlert(tls, (*SqlThread)(unsafe.Pointer(p)).Fparent)

	return 0
}

func xBusy(tls *crt.TLS, pArg uintptr, nBusy int32) int32 { /* test_thread.c:259:12: */
	_ = pArg
	_ = nBusy
	sqlite3.Xsqlite3_sleep(tls, 50)
	return 1 // Try again...
}

// sqlthread open
//
//     Open a database handle and return the string representation of
//     the pointer value.
func sqlthread_open(tls *crt.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_thread.c:272:26: */
	bp := tls.Alloc(124)
	defer tls.Free(124)

	var zFilename uintptr
	// var db uintptr at bp+16, 8

	// var zBuf [100]int8 at bp+24, 100

	_ = clientData
	_ = objc

	zFilename = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)))
	sqlite3.Xsqlite3_open(tls, zFilename, bp+16 /* &db */)
	Md5_Register(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* db */)), uintptr(0), uintptr(0))
	sqlite3.Xsqlite3_busy_handler(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* db */)), *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, int32) int32
	}{xBusy})), uintptr(0))

	if sqlite3TestMakePointerStr(tls, interp, bp+24 /* &zBuf[0] */, *(*uintptr)(unsafe.Pointer(bp + 16 /* db */))) != 0 {
		return 1
	}
	tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, bp+24 /* &zBuf[0] */, 0))

	return 0
}

// sqlthread open
//
//     Return the current thread-id (Tcl_GetCurrentThread()) cast to
//     an integer.
func sqlthread_id(tls *crt.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_thread.c:306:26: */
	var id Tcl_ThreadId = tcl.XTcl_GetCurrentThread(tls)
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, int32(id)))
	_ = clientData
	_ = objc
	_ = objv
	return 0
}

// Dispatch routine for the sub-commands of [sqlthread].
func sqlthread_proc(tls *crt.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_thread.c:324:26: */
	bp := tls.Alloc(164)
	defer tls.Free(164)

	*(*[5]struct {
		FzName  uintptr
		FxProc  uintptr
		FnArg   int32
		FzUsage uintptr
	})(unsafe.Pointer(bp /* aSub */)) = [5]struct {
		FzName  uintptr
		FxProc  uintptr
		FnArg   int32
		FzUsage uintptr
	}{
		{FzName: ts + 44483 /* "parent" */, FxProc: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
		}{sqlthread_parent})), FnArg: 1, FzUsage: ts + 18615 /* "SCRIPT" */},
		{FzName: ts + 44490 /* "spawn" */, FxProc: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
		}{sqlthread_spawn})), FnArg: 2, FzUsage: ts + 44496 /* "VARNAME SCRIPT" */},
		{FzName: ts + 43105 /* "open" */, FxProc: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
		}{sqlthread_open})), FnArg: 1, FzUsage: ts + 44511 /* "DBNAME" */},
		{FzName: ts + 44518 /* "id" */, FxProc: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
		}{sqlthread_id})), FnArg: 0, FzUsage: ts + 792 /* "" */},
		{FzName: uintptr(0), FxProc: uintptr(0), FnArg: 0},
	}
	var pSub uintptr
	var rc int32
	// var iIndex int32 at bp+160, 4

	if objc < 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+39984 /* "SUB-COMMAND" */)
		return 1
	}

	rc = tcl.XTcl_GetIndexFromObjStruct(tls,
		interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)), bp /* &aSub[0] */, int32(unsafe.Sizeof(struct {
			FzName  uintptr
			FxProc  uintptr
			FnArg   int32
			FzUsage uintptr
		}{})), ts+2321 /* "sub-command" */, 0, bp+160 /* &iIndex */)
	if rc != 0 {
		return rc
	}
	pSub = (bp /* &aSub */ + uintptr(*(*int32)(unsafe.Pointer(bp + 160 /* iIndex */)))*32)

	if objc < ((*struct {
		FzName  uintptr
		FxProc  uintptr
		FnArg   int32
		FzUsage uintptr
	})(unsafe.Pointer(pSub)).FnArg + 2) {
		tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, (*struct {
			FzName  uintptr
			FxProc  uintptr
			FnArg   int32
			FzUsage uintptr
		})(unsafe.Pointer(pSub)).FzUsage)
		return 1
	}

	return (*(*func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer((pSub + 8 /* &.xProc */))))(tls, clientData, interp, objc, objv)
}

/*
** The [clock_seconds] command. This is more or less the same as the
** regular tcl [clock seconds], except that it is available in testfixture
** when linked against both Tcl 8.4 and 8.5. Because [clock seconds] is
** implemented as a script in Tcl 8.5, it is not usually available to
** testfixture.
 */
func clock_seconds_proc(tls *crt.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_thread.c:372:26: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	// var now Tcl_Time at bp, 16

	tcl.XTcl_GetTime(tls, bp /* &now */)
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, int32((*Tcl_Time)(unsafe.Pointer(bp /* &now */)).Fsec)))
	_ = clientData
	_ = objc
	_ = objv
	return 0
}

// A pointer to an instance of this structure is passed as the user-context
// pointer when registering for an unlock-notify callback.
type UnlockNotification1 = struct {
	Ffired int32
	Fcond  pthread_cond_t
	Fmutex pthread_mutex_t
}

// A pointer to an instance of this structure is passed as the user-context
// pointer when registering for an unlock-notify callback.
type UnlockNotification = UnlockNotification1 /* test_thread.c:410:35 */

// This function is an unlock-notify callback registered with SQLite.
func unlock_notify_cb(tls *crt.TLS, apArg uintptr, nArg int32) { /* test_thread.c:420:13: */
	var i int32
	for i = 0; i < nArg; i++ {
		var p uintptr = *(*uintptr)(unsafe.Pointer(apArg + uintptr(i)*8))
		crt2.Xpthread_mutex_lock(tls, (p + 56 /* &.mutex */))
		(*UnlockNotification)(unsafe.Pointer(p)).Ffired = 1
		crt2.Xpthread_cond_signal(tls, (p + 8 /* &.cond */))
		crt2.Xpthread_mutex_unlock(tls, (p + 56 /* &.mutex */))
	}
}

// This function assumes that an SQLite API call (either sqlite3_prepare_v2()
// or sqlite3_step()) has just returned SQLITE_LOCKED. The argument is the
// associated database connection.
//
// This function calls sqlite3_unlock_notify() to register for an
// unlock-notify callback, then blocks until that callback is delivered
// and returns SQLITE_OK. The caller should then retry the failed operation.
//
// Or, if sqlite3_unlock_notify() indicates that to block would deadlock
// the system, then this function returns SQLITE_LOCKED immediately. In
// this case the caller should not retry the operation and should roll
// back the current transaction (if any).
func wait_for_unlock_notify(tls *crt.TLS, db uintptr) int32 { /* test_thread.c:445:12: */
	bp := tls.Alloc(96)
	defer tls.Free(96)

	var rc int32
	// var un UnlockNotification at bp, 96

	// Initialize the UnlockNotification structure.
	(*UnlockNotification)(unsafe.Pointer(bp /* &un */)).Ffired = 0
	crt2.Xpthread_mutex_init(tls, (bp /* &un */ + 56 /* &.mutex */), uintptr(0))
	crt2.Xpthread_cond_init(tls, (bp /* &un */ + 8 /* &.cond */), uintptr(0))

	// Register for an unlock-notify callback.
	rc = sqlite3.Xsqlite3_unlock_notify(tls, db, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, int32)
	}{unlock_notify_cb})), bp /* &un */)

	// The call to sqlite3_unlock_notify() always returns either SQLITE_LOCKED
	// or SQLITE_OK.
	//
	// If SQLITE_LOCKED was returned, then the system is deadlocked. In this
	// case this function needs to return SQLITE_LOCKED to the caller so
	// that the current transaction can be rolled back. Otherwise, block
	// until the unlock-notify callback is invoked, then return SQLITE_OK.
	if rc == 0 {
		crt2.Xpthread_mutex_lock(tls, (bp /* &un */ + 56 /* &.mutex */))
		if !((*UnlockNotification)(unsafe.Pointer(bp /* &un */)).Ffired != 0) {
			crt2.Xpthread_cond_wait(tls, (bp /* &un */ + 8 /* &.cond */), (bp /* &un */ + 56 /* &.mutex */))
		}
		crt2.Xpthread_mutex_unlock(tls, (bp /* &un */ + 56 /* &.mutex */))
	}

	// Destroy the mutex and condition variables.
	crt2.Xpthread_cond_destroy(tls, (bp /* &un */ + 8 /* &.cond */))
	crt2.Xpthread_mutex_destroy(tls, (bp /* &un */ + 56 /* &.mutex */))

	return rc
}

// This function is a wrapper around the SQLite function sqlite3_step().
// It functions in the same way as step(), except that if a required
// shared-cache lock cannot be obtained, this function may block waiting for
// the lock to become available. In this scenario the normal API step()
// function always returns SQLITE_LOCKED.
//
// If this function returns SQLITE_LOCKED, the caller should rollback
// the current transaction (if any) and try again later. Otherwise, the
// system may become deadlocked.
func sqlite3_blocking_step(tls *crt.TLS, pStmt uintptr) int32 { /* test_thread.c:492:5: */
	var rc int32
	for 6 == (crt.AssignInt32(&rc, sqlite3.Xsqlite3_step(tls, pStmt))) {
		rc = wait_for_unlock_notify(tls, sqlite3.Xsqlite3_db_handle(tls, pStmt))
		if rc != 0 {
			break
		}
		sqlite3.Xsqlite3_reset(tls, pStmt)
	}
	return rc
}

// This function is a wrapper around the SQLite function sqlite3_prepare_v2().
// It functions in the same way as prepare_v2(), except that if a required
// shared-cache lock cannot be obtained, this function may block waiting for
// the lock to become available. In this scenario the normal API prepare_v2()
// function always returns SQLITE_LOCKED.
//
// If this function returns SQLITE_LOCKED, the caller should rollback
// the current transaction (if any) and try again later. Otherwise, the
// system may become deadlocked.
func sqlite3_blocking_prepare_v2(tls *crt.TLS, db uintptr, zSql uintptr, nSql int32, ppStmt uintptr, pz uintptr) int32 { /* test_thread.c:513:5: */
	var rc int32
	for 6 == (crt.AssignInt32(&rc, sqlite3.Xsqlite3_prepare_v2(tls, db, zSql, nSql, ppStmt, pz))) {
		rc = wait_for_unlock_notify(tls, db)
		if rc != 0 {
			break
		}
	}
	return rc
}

// END_SQLITE_BLOCKING_STEP

// Usage: sqlite3_blocking_step STMT
//
// Advance the statement to the next row.
func blocking_step_proc(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_thread.c:534:26: */
	var pStmt uintptr
	var rc int32

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+23218 /* "STMT" */)
		return 1
	}

	pStmt = sqlite3TestTextToPtr(tls, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))))
	rc = sqlite3_blocking_step(tls, pStmt)

	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))
	return 0
}

// Usage: sqlite3_blocking_prepare_v2 DB sql bytes ?tailvar?
// Usage: sqlite3_nonblocking_prepare_v2 DB sql bytes ?tailvar?
func blocking_prepare_v2_proc(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_thread.c:560:26: */
	bp := tls.Alloc(162)
	defer tls.Free(162)

	// var db uintptr at bp+80, 8

	var zSql uintptr
	// var bytes int32 at bp+88, 4

	*(*uintptr)(unsafe.Pointer(bp + 104 /* zTail */)) = uintptr(0)
	*(*uintptr)(unsafe.Pointer(bp + 96 /* pStmt */)) = uintptr(0)
	// var zBuf [50]int8 at bp+112, 50

	var rc int32
	var isBlocking int32 = crt.BoolInt32(!(clientData == uintptr(0)))

	if (objc != 5) && (objc != 4) {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+21615, /* "wrong # args: sh..." */
			tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(0)*8))), ts+23264 /* " DB sql bytes ta..." */, 0))
		return 1
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), bp+80 /* &db */) != 0 {
		return 1
	}
	zSql = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)))
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(3)*8)), bp+88 /* &bytes */) != 0 {
		return 1
	}

	if isBlocking != 0 {
		rc = sqlite3_blocking_prepare_v2(tls, *(*uintptr)(unsafe.Pointer(bp + 80 /* db */)), zSql, *(*int32)(unsafe.Pointer(bp + 88 /* bytes */)), bp+96 /* &pStmt */, bp+104 /* &zTail */)
	} else {
		rc = sqlite3.Xsqlite3_prepare_v2(tls, *(*uintptr)(unsafe.Pointer(bp + 80 /* db */)), zSql, *(*int32)(unsafe.Pointer(bp + 88 /* bytes */)), bp+96 /* &pStmt */, bp+104 /* &zTail */)
	}

	if (*(*uintptr)(unsafe.Pointer(bp + 104 /* zTail */)) != 0) && (objc >= 5) {
		if *(*int32)(unsafe.Pointer(bp + 88 /* bytes */)) >= 0 {
			*(*int32)(unsafe.Pointer(bp + 88 /* bytes */)) = (int32(int64(*(*int32)(unsafe.Pointer(bp + 88 /* bytes */))) - ((int64(*(*uintptr)(unsafe.Pointer(bp + 104 /* zTail */))) - int64(zSql)) / 1)))
		}
		tcl.XTcl_ObjSetVar2(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(4)*8)), uintptr(0), tcl.XTcl_NewStringObj(tls, *(*uintptr)(unsafe.Pointer(bp + 104 /* zTail */)), *(*int32)(unsafe.Pointer(bp + 88 /* bytes */))), 0)
	}
	if rc != 0 {

		sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([50]int8{})), bp+112 /* &zBuf[0] */, ts+44521 /* "%s " */, crt.VaList(bp+32, sqlite3.Xsqlite3ErrName(tls, rc)))
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+40, bp+112 /* &zBuf[0] */, sqlite3.Xsqlite3_errmsg(tls, *(*uintptr)(unsafe.Pointer(bp + 80 /* db */))), 0))
		return 1
	}

	if *(*uintptr)(unsafe.Pointer(bp + 96 /* pStmt */)) != 0 {
		if sqlite3TestMakePointerStr(tls, interp, bp+112 /* &zBuf[0] */, *(*uintptr)(unsafe.Pointer(bp + 96 /* pStmt */))) != 0 {
			return 1
		}
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+64, bp+112 /* &zBuf[0] */, 0))
	}
	return 0
}

//
// End of implementation of [sqlite3_blocking_step].
//

// Register commands with the TCL interpreter.
func SqlitetestThread_Init(tls *crt.TLS, interp uintptr) int32 { /* test_thread.c:619:5: */
	tcl.XTcl_CreateObjCommand(tls, interp, ts+44343 /* "sqlthread" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
	}{sqlthread_proc})), uintptr(0), uintptr(0))
	tcl.XTcl_CreateObjCommand(tls, interp, ts+44329 /* "clock_seconds" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
	}{clock_seconds_proc})), uintptr(0), uintptr(0))
	tcl.XTcl_CreateObjCommand(tls, interp, ts+44353 /* "sqlite3_blocking..." */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{blocking_step_proc})), uintptr(0), uintptr(0))
	tcl.XTcl_CreateObjCommand(tls, interp,
		ts+44375 /* "sqlite3_blocking..." */, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
		}{blocking_prepare_v2_proc})), uintptr(1), uintptr(0))
	tcl.XTcl_CreateObjCommand(tls, interp,
		ts+44403 /* "sqlite3_nonblock..." */, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
		}{blocking_prepare_v2_proc})), uintptr(0), uintptr(0))
	return 0
}

// end block for C++

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:

func Sqlitetestvdbecov_Init(tls *crt.TLS, interp uintptr) int32 { /* test_vdbecov.c:113:5: */
	return 0
}

// end block for C++

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:

type Testvfs1 = struct {
	FzName        uintptr
	FpParent      uintptr
	FpVfs         uintptr
	Finterp       uintptr
	FpScript      uintptr
	FpBuffer      uintptr
	FisNoshm      int32
	FisFullshm    int32
	Fmask         int32
	Fioerr_err    TestFaultInject
	Ffull_err     TestFaultInject
	Fcantopen_err TestFaultInject
	FiDevchar     int32
	FiSectorsize  int32
}

// end block for C++

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:

type Testvfs = Testvfs1 /* test_vfs.c:37:24 */
type TestvfsBuffer1 = struct {
	FzFile uintptr
	Fpgsz  int32
	FaPage [1024]uintptr
	FpFile uintptr
	FpNext uintptr
}

type TestvfsBuffer = TestvfsBuffer1 /* test_vfs.c:39:30 */
type TestvfsFile1 = struct {
	Fbase sqlite3_file
	FpFd  uintptr
}

type TestvfsFile = TestvfsFile1 /* test_vfs.c:40:28 */
type TestvfsFd1 = struct {
	FpVfs       uintptr
	FzFilename  uintptr
	FpReal      uintptr
	FpShmId     uintptr
	FpShm       uintptr
	Fexcllock   u32
	Fsharedlock u32
	FpNext      uintptr
}

type TestvfsFd = TestvfsFd1 /* test_vfs.c:41:26 */

type TestFaultInject1 = struct {
	FiCnt   int32
	FeFault int32
	FnFail  int32
}

type TestFaultInject = TestFaultInject1 /* test_vfs.c:69:32 */

var tvfs_io_methods = sqlite3_io_methods{FiVersion: 3, FxClose: // iVersion
0, FxRead:// xClose
0, FxWrite:// xRead
0, FxTruncate:// xWrite
0, FxSync:// xTruncate
0, FxFileSize:// xSync
0, FxLock:// xFileSize
0, FxUnlock:// xLock
0, FxCheckReservedLock:// xUnlock
0, FxFileControl:// xCheckReservedLock
0, FxSectorSize:// xFileControl
0, FxDeviceCharacteristics:// xSectorSize
0, FxShmMap:// xDeviceCharacteristics
0, FxShmLock:// xShmMap
0, FxShmBarrier:// xShmLock
0, FxShmUnmap:// xShmBarrier
0, FxFetch:// xShmUnmap
0, FxUnfetch: 0,
} /* test_vfs.c:204:27 */

func tvfsResultCode(tls *crt.TLS, p uintptr, pRc uintptr) int32 { /* test_vfs.c:226:12: */
	bp := tls.Alloc(144)
	defer tls.Free(144)

	*(*[9]errcode)(unsafe.Pointer(bp /* aCode */)) = [9]errcode{
		{FeCode: 0, FzCode: ts + 18111 /* "SQLITE_OK" */},
		{FeCode: 1, FzCode: ts + 44525 /* "SQLITE_ERROR" */},
		{FeCode: 10, FzCode: ts + 44538 /* "SQLITE_IOERR" */},
		{FeCode: 6, FzCode: ts + 44551 /* "SQLITE_LOCKED" */},
		{FeCode: 5, FzCode: ts + 44565 /* "SQLITE_BUSY" */},
		{FeCode: 8, FzCode: ts + 44577 /* "SQLITE_READONLY" */},
		{FeCode: (8 | (int32(5) << 8)), FzCode: ts + 44593 /* "SQLITE_READONLY_..." */},
		{FeCode: 12, FzCode: ts + 44618 /* "SQLITE_NOTFOUND" */},
		{FeCode: -1, FzCode: ts + 44634 /* "SQLITE_OMIT" */},
	}
	var z uintptr
	var i int32

	z = tcl.XTcl_GetStringResult(tls, (*Testvfs)(unsafe.Pointer(p)).Finterp)
	for i = 0; i < (int32(uint64(unsafe.Sizeof([9]errcode{})) / uint64(unsafe.Sizeof(errcode{})))); i++ {
		if 0 == crt.Xstrcmp(tls, z, (*errcode)(unsafe.Pointer(bp /* &aCode */ +uintptr(i)*16)).FzCode) {
			*(*int32)(unsafe.Pointer(pRc)) = (*errcode)(unsafe.Pointer(bp /* &aCode */ + uintptr(i)*16)).FeCode
			return 1
		}
	}

	return 0
}

type errcode = struct {
	FeCode int32
	FzCode uintptr
}

func tvfsInjectFault(tls *crt.TLS, p uintptr) int32 { /* test_vfs.c:256:12: */
	var ret int32 = 0
	if (*TestFaultInject)(unsafe.Pointer(p)).FeFault != 0 {
		(*TestFaultInject)(unsafe.Pointer(p)).FiCnt--
		if ((*TestFaultInject)(unsafe.Pointer(p)).FiCnt == 0) || (((*TestFaultInject)(unsafe.Pointer(p)).FiCnt < 0) && ((*TestFaultInject)(unsafe.Pointer(p)).FeFault == 2)) {
			ret = 1
			(*TestFaultInject)(unsafe.Pointer(p)).FnFail++
		}
	}
	return ret
}

func tvfsInjectIoerr(tls *crt.TLS, p uintptr) int32 { /* test_vfs.c:269:12: */
	return tvfsInjectFault(tls, (p + 60 /* &.ioerr_err */))
}

func tvfsInjectFullerr(tls *crt.TLS, p uintptr) int32 { /* test_vfs.c:273:12: */
	return tvfsInjectFault(tls, (p + 72 /* &.full_err */))
}
func tvfsInjectCantopenerr(tls *crt.TLS, p uintptr) int32 { /* test_vfs.c:276:12: */
	return tvfsInjectFault(tls, (p + 84 /* &.cantopen_err */))
}

func tvfsExecTcl(tls *crt.TLS, p uintptr, zMethod uintptr, arg1 uintptr, arg2 uintptr, arg3 uintptr, arg4 uintptr) { /* test_vfs.c:281:13: */
	var rc int32 // Return code from Tcl_EvalObj()
	var pEval uintptr

	pEval = tcl.XTcl_DuplicateObj(tls, (*Testvfs)(unsafe.Pointer(p)).FpScript)
	(*Tcl_Obj)(unsafe.Pointer((*Testvfs)(unsafe.Pointer(p)).FpScript)).FrefCount++
	tcl.XTcl_ListObjAppendElement(tls, (*Testvfs)(unsafe.Pointer(p)).Finterp, pEval, tcl.XTcl_NewStringObj(tls, zMethod, -1))
	if arg1 != 0 {
		tcl.XTcl_ListObjAppendElement(tls, (*Testvfs)(unsafe.Pointer(p)).Finterp, pEval, arg1)
	}
	if arg2 != 0 {
		tcl.XTcl_ListObjAppendElement(tls, (*Testvfs)(unsafe.Pointer(p)).Finterp, pEval, arg2)
	}
	if arg3 != 0 {
		tcl.XTcl_ListObjAppendElement(tls, (*Testvfs)(unsafe.Pointer(p)).Finterp, pEval, arg3)
	}
	if arg4 != 0 {
		tcl.XTcl_ListObjAppendElement(tls, (*Testvfs)(unsafe.Pointer(p)).Finterp, pEval, arg4)
	}

	rc = tcl.XTcl_EvalObjEx(tls, (*Testvfs)(unsafe.Pointer(p)).Finterp, pEval, 0x020000)
	if rc != 0 {
		tcl.XTcl_BackgroundError(tls, (*Testvfs)(unsafe.Pointer(p)).Finterp)
		tcl.XTcl_ResetResult(tls, (*Testvfs)(unsafe.Pointer(p)).Finterp)
	}
}

// Close an tvfs-file.
func tvfsClose(tls *crt.TLS, pFile uintptr) int32 { /* test_vfs.c:317:12: */
	var pTestfile uintptr = pFile
	var pFd uintptr = (*TestvfsFile)(unsafe.Pointer(pTestfile)).FpFd
	var p uintptr = (*sqlite3_vfs)(unsafe.Pointer((*TestvfsFd)(unsafe.Pointer(pFd)).FpVfs)).FpAppData

	if ((*Testvfs)(unsafe.Pointer(p)).FpScript != 0) && (((*Testvfs)(unsafe.Pointer(p)).Fmask & 0x00000800) != 0) {
		tvfsExecTcl(tls, p, ts+40748, /* "xClose" */
			tcl.XTcl_NewStringObj(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FzFilename, -1), (*TestvfsFd)(unsafe.Pointer(pFd)).FpShmId, uintptr(0), uintptr(0))
	}

	if (*TestvfsFd)(unsafe.Pointer(pFd)).FpShmId != 0 {
		for ok := true; ok; ok = 0 != 0 {
			var _objPtr uintptr = (*TestvfsFd)(unsafe.Pointer(pFd)).FpShmId
			if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
		(*TestvfsFd)(unsafe.Pointer(pFd)).FpShmId = uintptr(0)
	}
	if (*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods != 0 {
		tcl.XTcl_Free(tls, (*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods)
	}
	sqlite3.Xsqlite3OsClose(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FpReal)
	tcl.XTcl_Free(tls, pFd)
	(*TestvfsFile)(unsafe.Pointer(pTestfile)).FpFd = uintptr(0)
	return 0
}

// Read data from an tvfs-file.
func tvfsRead(tls *crt.TLS, pFile uintptr, zBuf uintptr, iAmt int32, iOfst sqlite_int64) int32 { /* test_vfs.c:344:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	*(*int32)(unsafe.Pointer(bp /* rc */)) = 0
	var pFd uintptr = (*TestvfsFile)(unsafe.Pointer(pFile)).FpFd
	var p uintptr = (*sqlite3_vfs)(unsafe.Pointer((*TestvfsFd)(unsafe.Pointer(pFd)).FpVfs)).FpAppData
	if ((*Testvfs)(unsafe.Pointer(p)).FpScript != 0) && (((*Testvfs)(unsafe.Pointer(p)).Fmask & 0x00010000) != 0) {
		tvfsExecTcl(tls, p, ts+40755, /* "xRead" */
			tcl.XTcl_NewStringObj(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FzFilename, -1), (*TestvfsFd)(unsafe.Pointer(pFd)).FpShmId, uintptr(0), uintptr(0))
		tvfsResultCode(tls, p, bp /* &rc */)
	}
	if ((*(*int32)(unsafe.Pointer(bp /* rc */)) == 0) && (((*Testvfs)(unsafe.Pointer(p)).Fmask & 0x00010000) != 0)) && (tvfsInjectIoerr(tls, p) != 0) {
		*(*int32)(unsafe.Pointer(bp /* rc */)) = 10
	}
	if *(*int32)(unsafe.Pointer(bp /* rc */)) == 0 {
		*(*int32)(unsafe.Pointer(bp /* rc */)) = sqlite3.Xsqlite3OsRead(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FpReal, zBuf, iAmt, iOfst)
	}
	return *(*int32)(unsafe.Pointer(bp /* rc */))
}

// Write data to an tvfs-file.
func tvfsWrite(tls *crt.TLS, pFile uintptr, zBuf uintptr, iAmt int32, iOfst sqlite_int64) int32 { /* test_vfs.c:371:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	*(*int32)(unsafe.Pointer(bp /* rc */)) = 0
	var pFd uintptr = (*TestvfsFile)(unsafe.Pointer(pFile)).FpFd
	var p uintptr = (*sqlite3_vfs)(unsafe.Pointer((*TestvfsFd)(unsafe.Pointer(pFd)).FpVfs)).FpAppData

	if ((*Testvfs)(unsafe.Pointer(p)).FpScript != 0) && (((*Testvfs)(unsafe.Pointer(p)).Fmask & 0x00001000) != 0) {
		tvfsExecTcl(tls, p, ts+40761, /* "xWrite" */
			tcl.XTcl_NewStringObj(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FzFilename, -1), (*TestvfsFd)(unsafe.Pointer(pFd)).FpShmId,
			tcl.XTcl_NewWideIntObj(tls, int64(iOfst)), tcl.XTcl_NewIntObj(tls, iAmt))
		tvfsResultCode(tls, p, bp /* &rc */)
		if *(*int32)(unsafe.Pointer(bp /* rc */)) < 0 {
			return 0
		}
	}

	if (*(*int32)(unsafe.Pointer(bp /* rc */)) == 0) && (tvfsInjectFullerr(tls, p) != 0) {
		*(*int32)(unsafe.Pointer(bp /* rc */)) = 13
	}
	if ((*(*int32)(unsafe.Pointer(bp /* rc */)) == 0) && (((*Testvfs)(unsafe.Pointer(p)).Fmask & 0x00001000) != 0)) && (tvfsInjectIoerr(tls, p) != 0) {
		*(*int32)(unsafe.Pointer(bp /* rc */)) = 10
	}

	if *(*int32)(unsafe.Pointer(bp /* rc */)) == 0 {
		*(*int32)(unsafe.Pointer(bp /* rc */)) = sqlite3.Xsqlite3OsWrite(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FpReal, zBuf, iAmt, iOfst)
	}
	return *(*int32)(unsafe.Pointer(bp /* rc */))
}

// Truncate an tvfs-file.
func tvfsTruncate(tls *crt.TLS, pFile uintptr, size sqlite_int64) int32 { /* test_vfs.c:406:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	*(*int32)(unsafe.Pointer(bp /* rc */)) = 0
	var pFd uintptr = (*TestvfsFile)(unsafe.Pointer(pFile)).FpFd
	var p uintptr = (*sqlite3_vfs)(unsafe.Pointer((*TestvfsFd)(unsafe.Pointer(pFd)).FpVfs)).FpAppData

	if ((*Testvfs)(unsafe.Pointer(p)).FpScript != 0) && (((*Testvfs)(unsafe.Pointer(p)).Fmask & 0x00002000) != 0) {
		tvfsExecTcl(tls, p, ts+40768, /* "xTruncate" */
			tcl.XTcl_NewStringObj(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FzFilename, -1), (*TestvfsFd)(unsafe.Pointer(pFd)).FpShmId, uintptr(0), uintptr(0))
		tvfsResultCode(tls, p, bp /* &rc */)
	}

	if *(*int32)(unsafe.Pointer(bp /* rc */)) == 0 {
		*(*int32)(unsafe.Pointer(bp /* rc */)) = sqlite3.Xsqlite3OsTruncate(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FpReal, size)
	}
	return *(*int32)(unsafe.Pointer(bp /* rc */))
}

// Sync an tvfs-file.
func tvfsSync(tls *crt.TLS, pFile uintptr, flags int32) int32 { /* test_vfs.c:427:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	*(*int32)(unsafe.Pointer(bp /* rc */)) = 0
	var pFd uintptr = (*TestvfsFile)(unsafe.Pointer(pFile)).FpFd
	var p uintptr = (*sqlite3_vfs)(unsafe.Pointer((*TestvfsFd)(unsafe.Pointer(pFd)).FpVfs)).FpAppData

	if ((*Testvfs)(unsafe.Pointer(p)).FpScript != 0) && (((*Testvfs)(unsafe.Pointer(p)).Fmask & 0x00000200) != 0) {
		var zFlags uintptr = uintptr(0)

		switch flags {
		case 0x00002:
			zFlags = ts + 22956 /* "normal" */
			break
			fallthrough
		case 0x00003:
			zFlags = ts + 24515 /* "full" */
			break
			fallthrough
		case (0x00002 | 0x00010):
			zFlags = ts + 44646 /* "normal|dataonly" */
			break
			fallthrough
		case (0x00003 | 0x00010):
			zFlags = ts + 44662 /* "full|dataonly" */
			break
			fallthrough
		default:
		}

		tvfsExecTcl(tls, p, ts+32890, /* "xSync" */
			tcl.XTcl_NewStringObj(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FzFilename, -1), (*TestvfsFd)(unsafe.Pointer(pFd)).FpShmId,
			tcl.XTcl_NewStringObj(tls, zFlags, -1), uintptr(0))
		tvfsResultCode(tls, p, bp /* &rc */)
	}

	if (*(*int32)(unsafe.Pointer(bp /* rc */)) == 0) && (tvfsInjectFullerr(tls, p) != 0) {
		*(*int32)(unsafe.Pointer(bp /* rc */)) = 13
	}

	if *(*int32)(unsafe.Pointer(bp /* rc */)) == 0 {
		*(*int32)(unsafe.Pointer(bp /* rc */)) = sqlite3.Xsqlite3OsSync(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FpReal, flags)
	}

	return *(*int32)(unsafe.Pointer(bp /* rc */))
}

// Return the current file-size of an tvfs-file.
func tvfsFileSize(tls *crt.TLS, pFile uintptr, pSize uintptr) int32 { /* test_vfs.c:471:12: */
	var p uintptr = (*TestvfsFile)(unsafe.Pointer(pFile)).FpFd
	return sqlite3.Xsqlite3OsFileSize(tls, (*TestvfsFd)(unsafe.Pointer(p)).FpReal, pSize)
}

// Lock an tvfs-file.
func tvfsLock(tls *crt.TLS, pFile uintptr, eLock int32) int32 { /* test_vfs.c:479:12: */
	bp := tls.Alloc(38)
	defer tls.Free(38)

	var pFd uintptr = (*TestvfsFile)(unsafe.Pointer(pFile)).FpFd
	var p uintptr = (*sqlite3_vfs)(unsafe.Pointer((*TestvfsFd)(unsafe.Pointer(pFd)).FpVfs)).FpAppData
	if ((*Testvfs)(unsafe.Pointer(p)).FpScript != 0) && (((*Testvfs)(unsafe.Pointer(p)).Fmask & 0x00040000) != 0) {
		// var zLock [30]int8 at bp+8, 30

		sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([30]int8{})), bp+8 /* &zLock[0] */, ts+1647 /* "%d" */, crt.VaList(bp, eLock))
		tvfsExecTcl(tls, p, ts+40788 /* "xLock" */, tcl.XTcl_NewStringObj(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FzFilename, -1),
			tcl.XTcl_NewStringObj(tls, bp+8 /* &zLock[0] */, -1), uintptr(0), uintptr(0))
	}
	return sqlite3.Xsqlite3OsLock(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FpReal, eLock)
}

// Unlock an tvfs-file.
func tvfsUnlock(tls *crt.TLS, pFile uintptr, eLock int32) int32 { /* test_vfs.c:494:12: */
	bp := tls.Alloc(38)
	defer tls.Free(38)

	var pFd uintptr = (*TestvfsFile)(unsafe.Pointer(pFile)).FpFd
	var p uintptr = (*sqlite3_vfs)(unsafe.Pointer((*TestvfsFd)(unsafe.Pointer(pFd)).FpVfs)).FpAppData
	if ((*Testvfs)(unsafe.Pointer(p)).FpScript != 0) && (((*Testvfs)(unsafe.Pointer(p)).Fmask & 0x00020000) != 0) {
		// var zLock [30]int8 at bp+8, 30

		sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([30]int8{})), bp+8 /* &zLock[0] */, ts+1647 /* "%d" */, crt.VaList(bp, eLock))
		tvfsExecTcl(tls, p, ts+40794 /* "xUnlock" */, tcl.XTcl_NewStringObj(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FzFilename, -1),
			tcl.XTcl_NewStringObj(tls, bp+8 /* &zLock[0] */, -1), uintptr(0), uintptr(0))
	}
	if (((*Testvfs)(unsafe.Pointer(p)).Fmask & 0x00001000) != 0) && (tvfsInjectIoerr(tls, p) != 0) {
		return (10 | (int32(8) << 8))
	}
	return sqlite3.Xsqlite3OsUnlock(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FpReal, eLock)
}

// Check if another file-handle holds a RESERVED lock on an tvfs-file.
func tvfsCheckReservedLock(tls *crt.TLS, pFile uintptr, pResOut uintptr) int32 { /* test_vfs.c:512:12: */
	var pFd uintptr = (*TestvfsFile)(unsafe.Pointer(pFile)).FpFd
	var p uintptr = (*sqlite3_vfs)(unsafe.Pointer((*TestvfsFd)(unsafe.Pointer(pFd)).FpVfs)).FpAppData
	if ((*Testvfs)(unsafe.Pointer(p)).FpScript != 0) && (((*Testvfs)(unsafe.Pointer(p)).Fmask & 0x00080000) != 0) {
		tvfsExecTcl(tls, p, ts+44676 /* "xCheckReservedLo..." */, tcl.XTcl_NewStringObj(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FzFilename, -1),
			uintptr(0), uintptr(0), uintptr(0))
	}
	return sqlite3.Xsqlite3OsCheckReservedLock(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FpReal, pResOut)
}

// File control method. For custom operations on an tvfs-file.
func tvfsFileControl(tls *crt.TLS, pFile uintptr, op int32, pArg uintptr) int32 { /* test_vfs.c:525:12: */
	bp := tls.Alloc(68)
	defer tls.Free(68)

	var pFd uintptr = (*TestvfsFile)(unsafe.Pointer(pFile)).FpFd
	var p uintptr = (*sqlite3_vfs)(unsafe.Pointer((*TestvfsFd)(unsafe.Pointer(pFd)).FpVfs)).FpAppData
	if op == 14 {
		var argv uintptr = pArg
		if sqlite3.Xsqlite3_stricmp(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), ts+16749 /* "error" */) == 0 {
			var rc int32 = 1
			if *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8)) != 0 {
				var z uintptr = *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8))
				var x int32 = crt.Xatoi(tls, z)
				if x != 0 {
					rc = x
					for (int32(sqlite3.Xsqlite3CtypeMap[uint8(*(*int8)(unsafe.Pointer(z + uintptr(0))))]) & 0x04) != 0 {
						z++
					}
					for (int32(sqlite3.Xsqlite3CtypeMap[uint8(*(*int8)(unsafe.Pointer(z + uintptr(0))))]) & 0x01) != 0 {
						z++
					}
				}
				if *(*int8)(unsafe.Pointer(z + uintptr(0))) != 0 {
					*(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)) = sqlite3.Xsqlite3_mprintf(tls, ts+130 /* "%s" */, crt.VaList(bp, z))
				}
			}
			return rc
		}
		if sqlite3.Xsqlite3_stricmp(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), ts+4311 /* "filename" */) == 0 {
			*(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)) = sqlite3.Xsqlite3_mprintf(tls, ts+130 /* "%s" */, crt.VaList(bp+8, (*TestvfsFd)(unsafe.Pointer(pFd)).FzFilename))
			return 0
		}
	}
	if ((*Testvfs)(unsafe.Pointer(p)).FpScript != 0) && (((*Testvfs)(unsafe.Pointer(p)).Fmask & 0x00100000) != 0) {
		*(*[3]Fcntl)(unsafe.Pointer(bp + 16 /* aF */)) = [3]Fcntl{
			{FiFnctl: 31, FzFnctl: ts + 44695 /* "BEGIN_ATOMIC_WRI..." */},
			{FiFnctl: 32, FzFnctl: ts + 44714 /* "COMMIT_ATOMIC_WR..." */},
			{FiFnctl: 25, FzFnctl: ts + 44734 /* "ZIPVFS" */},
		}
		var i int32
		for i = 0; uint64(i) < (uint64(unsafe.Sizeof([3]Fcntl{})) / uint64(unsafe.Sizeof(Fcntl{}))); i++ {
			if op == (*Fcntl)(unsafe.Pointer(bp+16 /* &aF */ +uintptr(i)*16)).FiFnctl {
				break
			}
		}
		if uint64(i) < (uint64(unsafe.Sizeof([3]Fcntl{})) / uint64(unsafe.Sizeof(Fcntl{}))) {
			*(*int32)(unsafe.Pointer(bp + 64 /* rc */)) = 0
			tvfsExecTcl(tls, p, ts+40816, /* "xFileControl" */
				tcl.XTcl_NewStringObj(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FzFilename, -1),
				tcl.XTcl_NewStringObj(tls, (*Fcntl)(unsafe.Pointer(bp+16 /* &aF */ +uintptr(i)*16)).FzFnctl, -1),
				uintptr(0), uintptr(0))
			tvfsResultCode(tls, p, bp+64 /* &rc */)
			if *(*int32)(unsafe.Pointer(bp + 64 /* rc */)) != 0 {
				return func() int32 {
					if *(*int32)(unsafe.Pointer(bp + 64 /* rc */)) < 0 {
						return 0
					}
					return *(*int32)(unsafe.Pointer(bp + 64 /* rc */))
				}()
			}
		}
	}
	return sqlite3.Xsqlite3OsFileControl(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FpReal, op, pArg)
}

type Fcntl = struct {
	FiFnctl int32
	FzFnctl uintptr
}

// Return the sector-size in bytes for an tvfs-file.
func tvfsSectorSize(tls *crt.TLS, pFile uintptr) int32 { /* test_vfs.c:579:12: */
	var pFd uintptr = (*TestvfsFile)(unsafe.Pointer(pFile)).FpFd
	var p uintptr = (*sqlite3_vfs)(unsafe.Pointer((*TestvfsFd)(unsafe.Pointer(pFd)).FpVfs)).FpAppData
	if (*Testvfs)(unsafe.Pointer(p)).FiSectorsize >= 0 {
		return (*Testvfs)(unsafe.Pointer(p)).FiSectorsize
	}
	return sqlite3.Xsqlite3OsSectorSize(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FpReal)
}

// Return the device characteristic flags supported by an tvfs-file.
func tvfsDeviceCharacteristics(tls *crt.TLS, pFile uintptr) int32 { /* test_vfs.c:591:12: */
	var pFd uintptr = (*TestvfsFile)(unsafe.Pointer(pFile)).FpFd
	var p uintptr = (*sqlite3_vfs)(unsafe.Pointer((*TestvfsFd)(unsafe.Pointer(pFd)).FpVfs)).FpAppData
	if (*Testvfs)(unsafe.Pointer(p)).FiDevchar >= 0 {
		return (*Testvfs)(unsafe.Pointer(p)).FiDevchar
	}
	return sqlite3.Xsqlite3OsDeviceCharacteristics(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FpReal)
}

// Open an tvfs file handle.
func tvfsOpen(tls *crt.TLS, pVfs uintptr, zName uintptr, pFile uintptr, flags int32, pOutFlags uintptr) int32 { /* test_vfs.c:603:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	// var rc int32 at bp, 4

	var pTestfile uintptr = pFile
	var pFd uintptr
	var pId uintptr = uintptr(0)
	var p uintptr = (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData

	pFd = tcl.XTcl_Alloc(tls, (uint32(uint64(unsafe.Sizeof(TestvfsFd{})) + uint64((*sqlite3_vfs)(unsafe.Pointer(((*Testvfs)(unsafe.Pointer((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData)).FpParent))).FszOsFile))))
	crt.Xmemset(tls, pFd, 0, (uint64(unsafe.Sizeof(TestvfsFd{})) + uint64((*sqlite3_vfs)(unsafe.Pointer(((*Testvfs)(unsafe.Pointer((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData)).FpParent))).FszOsFile)))
	(*TestvfsFd)(unsafe.Pointer(pFd)).FpShm = uintptr(0)
	(*TestvfsFd)(unsafe.Pointer(pFd)).FpShmId = uintptr(0)
	(*TestvfsFd)(unsafe.Pointer(pFd)).FzFilename = zName
	(*TestvfsFd)(unsafe.Pointer(pFd)).FpVfs = pVfs
	(*TestvfsFd)(unsafe.Pointer(pFd)).FpReal = (pFd + uintptr(1)*56)
	crt.Xmemset(tls, pTestfile, 0, uint64(unsafe.Sizeof(TestvfsFile{})))
	(*TestvfsFile)(unsafe.Pointer(pTestfile)).FpFd = pFd

	// Evaluate the Tcl script:
	//
	//   SCRIPT xOpen FILENAME KEY-VALUE-ARGS
	//
	// If the script returns an SQLite error code other than SQLITE_OK, an
	// error is returned to the caller. If it returns SQLITE_OK, the new
	// connection is named "anon". Otherwise, the value returned by the
	// script is used as the connection name.
	tcl.XTcl_ResetResult(tls, (*Testvfs)(unsafe.Pointer(p)).Finterp)
	if ((*Testvfs)(unsafe.Pointer(p)).FpScript != 0) && (((*Testvfs)(unsafe.Pointer(p)).Fmask & 0x00000100) != 0) {
		var pArg uintptr = tcl.XTcl_NewObj(tls)
		(*Tcl_Obj)(unsafe.Pointer(pArg)).FrefCount++
		if (flags & 0x00000100) != 0 {
			var z uintptr = (zName + uintptr((crt.Xstrlen(tls, zName) + uint64(1))))
			for *(*int8)(unsafe.Pointer(z)) != 0 {
				tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pArg, tcl.XTcl_NewStringObj(tls, z, -1))
				z += (uintptr(crt.Xstrlen(tls, z) + uint64(1)))
				tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pArg, tcl.XTcl_NewStringObj(tls, z, -1))
				z += (uintptr(crt.Xstrlen(tls, z) + uint64(1)))
			}
		}
		tvfsExecTcl(tls, p, ts+32455 /* "xOpen" */, tcl.XTcl_NewStringObj(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FzFilename, -1), pArg, uintptr(0), uintptr(0))
		for ok := true; ok; ok = 0 != 0 {
			var _objPtr uintptr = pArg
			if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
		if tvfsResultCode(tls, p, bp /* &rc */) != 0 {
			if *(*int32)(unsafe.Pointer(bp /* rc */)) != 0 {
				return *(*int32)(unsafe.Pointer(bp /* rc */))
			}
		} else {
			pId = tcl.XTcl_GetObjResult(tls, (*Testvfs)(unsafe.Pointer(p)).Finterp)
		}
	}

	if (((*Testvfs)(unsafe.Pointer(p)).Fmask & 0x00000100) != 0) && (tvfsInjectIoerr(tls, p) != 0) {
		return 10
	}
	if tvfsInjectCantopenerr(tls, p) != 0 {
		return 14
	}
	if tvfsInjectFullerr(tls, p) != 0 {
		return 13
	}

	if !(pId != 0) {
		pId = tcl.XTcl_NewStringObj(tls, ts+44741 /* "anon" */, -1)
	}
	(*Tcl_Obj)(unsafe.Pointer(pId)).FrefCount++
	(*TestvfsFd)(unsafe.Pointer(pFd)).FpShmId = pId
	tcl.XTcl_ResetResult(tls, (*Testvfs)(unsafe.Pointer(p)).Finterp)

	*(*int32)(unsafe.Pointer(bp /* rc */)) = sqlite3.Xsqlite3OsOpen(tls, (*Testvfs)(unsafe.Pointer((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData)).FpParent, zName, (*TestvfsFd)(unsafe.Pointer(pFd)).FpReal, flags, pOutFlags)
	if (*sqlite3_file)(unsafe.Pointer((*TestvfsFd)(unsafe.Pointer(pFd)).FpReal)).FpMethods != 0 {
		var pMethods uintptr
		var nByte int32

		if (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FiVersion > 1 {
			nByte = int32(unsafe.Sizeof(sqlite3_io_methods{}))
		} else {
			nByte = int32((uintptr(0) + 104 /* &.xShmMap */))
		}

		pMethods = tcl.XTcl_Alloc(tls, uint32(nByte))
		crt.Xmemcpy(tls, pMethods, uintptr(unsafe.Pointer(&tvfs_io_methods)), uint64(nByte))
		(*sqlite3_io_methods)(unsafe.Pointer(pMethods)).FiVersion = (*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer((*TestvfsFd)(unsafe.Pointer(pFd)).FpReal)).FpMethods)).FiVersion
		if (*sqlite3_io_methods)(unsafe.Pointer(pMethods)).FiVersion > (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FiVersion {
			(*sqlite3_io_methods)(unsafe.Pointer(pMethods)).FiVersion = (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FiVersion
		}
		if ((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FiVersion > 1) && ((*Testvfs)(unsafe.Pointer(((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData))).FisNoshm != 0) {
			(*sqlite3_io_methods)(unsafe.Pointer(pMethods)).FxShmUnmap = uintptr(0)
			(*sqlite3_io_methods)(unsafe.Pointer(pMethods)).FxShmLock = uintptr(0)
			(*sqlite3_io_methods)(unsafe.Pointer(pMethods)).FxShmBarrier = uintptr(0)
			(*sqlite3_io_methods)(unsafe.Pointer(pMethods)).FxShmMap = uintptr(0)
		}
		(*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods = pMethods
	}

	return *(*int32)(unsafe.Pointer(bp /* rc */))
}

// Delete the file located at zPath. If the dirSync argument is true,
// ensure the file-system modifications are synced to disk before
// returning.
func tvfsDelete(tls *crt.TLS, pVfs uintptr, zPath uintptr, dirSync int32) int32 { /* test_vfs.c:702:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	*(*int32)(unsafe.Pointer(bp /* rc */)) = 0
	var p uintptr = (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData

	if ((*Testvfs)(unsafe.Pointer(p)).FpScript != 0) && (((*Testvfs)(unsafe.Pointer(p)).Fmask & 0x00000400) != 0) {
		tvfsExecTcl(tls, p, ts+40853, /* "xDelete" */
			tcl.XTcl_NewStringObj(tls, zPath, -1), tcl.XTcl_NewIntObj(tls, dirSync), uintptr(0), uintptr(0))
		tvfsResultCode(tls, p, bp /* &rc */)
	}
	if *(*int32)(unsafe.Pointer(bp /* rc */)) == 0 {
		*(*int32)(unsafe.Pointer(bp /* rc */)) = sqlite3.Xsqlite3OsDelete(tls, (*Testvfs)(unsafe.Pointer((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData)).FpParent, zPath, dirSync)
	}
	return *(*int32)(unsafe.Pointer(bp /* rc */))
}

// Test for access permissions. Return true if the requested permission
// is available, or false otherwise.
func tvfsAccess(tls *crt.TLS, pVfs uintptr, zPath uintptr, flags int32, pResOut uintptr) int32 { /* test_vfs.c:722:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var p uintptr = (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData
	if ((*Testvfs)(unsafe.Pointer(p)).FpScript != 0) && (((*Testvfs)(unsafe.Pointer(p)).Fmask & 0x00004000) != 0) {
		// var rc int32 at bp, 4

		var zArg uintptr = uintptr(0)
		if flags == 0 {
			zArg = ts + 44746 /* "SQLITE_ACCESS_EX..." */
		}
		if flags == 1 {
			zArg = ts + 44767 /* "SQLITE_ACCESS_RE..." */
		}
		if flags == 2 {
			zArg = ts + 44791 /* "SQLITE_ACCESS_RE..." */
		}
		tvfsExecTcl(tls, p, ts+40861, /* "xAccess" */
			tcl.XTcl_NewStringObj(tls, zPath, -1), tcl.XTcl_NewStringObj(tls, zArg, -1), uintptr(0), uintptr(0))
		if tvfsResultCode(tls, p, bp /* &rc */) != 0 {
			if *(*int32)(unsafe.Pointer(bp /* rc */)) != 0 {
				return *(*int32)(unsafe.Pointer(bp /* rc */))
			}
		} else {
			var interp uintptr = (*Testvfs)(unsafe.Pointer(p)).Finterp
			if 0 == tcl.XTcl_GetBooleanFromObj(tls, uintptr(0), tcl.XTcl_GetObjResult(tls, interp), pResOut) {
				return 0
			}
		}
	}
	return sqlite3.Xsqlite3OsAccess(tls, (*Testvfs)(unsafe.Pointer((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData)).FpParent, zPath, flags, pResOut)
}

// Populate buffer zOut with the full canonical pathname corresponding
// to the pathname in zPath. zOut is guaranteed to point to a buffer
// of at least (DEVSYM_MAX_PATHNAME+1) bytes.
func tvfsFullPathname(tls *crt.TLS, pVfs uintptr, zPath uintptr, nOut int32, zOut uintptr) int32 { /* test_vfs.c:755:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var p uintptr = (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData
	if ((*Testvfs)(unsafe.Pointer(p)).FpScript != 0) && (((*Testvfs)(unsafe.Pointer(p)).Fmask & 0x00008000) != 0) {
		// var rc int32 at bp, 4

		tvfsExecTcl(tls, p, ts+40869 /* "xFullPathname" */, tcl.XTcl_NewStringObj(tls, zPath, -1), uintptr(0), uintptr(0), uintptr(0))
		if tvfsResultCode(tls, p, bp /* &rc */) != 0 {
			if *(*int32)(unsafe.Pointer(bp /* rc */)) != 0 {
				return *(*int32)(unsafe.Pointer(bp /* rc */))
			}
		}
	}
	return sqlite3.Xsqlite3OsFullPathname(tls, (*Testvfs)(unsafe.Pointer((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData)).FpParent, zPath, nOut, zOut)
}

// Populate the buffer pointed to by zBufOut with nByte bytes of
// random data.
func tvfsRandomness(tls *crt.TLS, pVfs uintptr, nByte int32, zBufOut uintptr) int32 { /* test_vfs.c:808:12: */
	return sqlite3.Xsqlite3OsRandomness(tls, (*Testvfs)(unsafe.Pointer((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData)).FpParent, nByte, zBufOut)
}

// Sleep for nMicro microseconds. Return the number of microseconds
// actually slept.
func tvfsSleep(tls *crt.TLS, pVfs uintptr, nMicro int32) int32 { /* test_vfs.c:816:12: */
	return sqlite3.Xsqlite3OsSleep(tls, (*Testvfs)(unsafe.Pointer((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData)).FpParent, nMicro)
}

// Return the current time as a Julian Day number in *pTimeOut.
func tvfsCurrentTime(tls *crt.TLS, pVfs uintptr, pTimeOut uintptr) int32 { /* test_vfs.c:823:12: */
	return (*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(((*Testvfs)(unsafe.Pointer((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData)).FpParent + 120 /* &.xCurrentTime */))))(tls, (*Testvfs)(unsafe.Pointer((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData)).FpParent, pTimeOut)
}

func tvfsShmOpen(tls *crt.TLS, pFile uintptr) int32 { /* test_vfs.c:827:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var p uintptr
	*(*int32)(unsafe.Pointer(bp /* rc */)) = 0 // Return code
	var pBuffer uintptr                        // Buffer to open connection to
	var pFd uintptr                            // The testvfs file structure

	pFd = (*TestvfsFile)(unsafe.Pointer(pFile)).FpFd
	p = (*sqlite3_vfs)(unsafe.Pointer((*TestvfsFd)(unsafe.Pointer(pFd)).FpVfs)).FpAppData

	// Evaluate the Tcl script:
	//
	//   SCRIPT xShmOpen FILENAME
	tcl.XTcl_ResetResult(tls, (*Testvfs)(unsafe.Pointer(p)).Finterp)
	if ((*Testvfs)(unsafe.Pointer(p)).FpScript != 0) && (((*Testvfs)(unsafe.Pointer(p)).Fmask & 0x00000001) != 0) {
		tvfsExecTcl(tls, p, ts+44810 /* "xShmOpen" */, tcl.XTcl_NewStringObj(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FzFilename, -1), uintptr(0), uintptr(0), uintptr(0))
		if tvfsResultCode(tls, p, bp /* &rc */) != 0 {
			if *(*int32)(unsafe.Pointer(bp /* rc */)) != 0 {
				return *(*int32)(unsafe.Pointer(bp /* rc */))
			}
		}
	}

	if (((*Testvfs)(unsafe.Pointer(p)).Fmask & 0x00000001) != 0) && (tvfsInjectIoerr(tls, p) != 0) {
		return 10
	}

	// Search for a TestvfsBuffer. Create a new one if required.
	for pBuffer = (*Testvfs)(unsafe.Pointer(p)).FpBuffer; pBuffer != 0; pBuffer = (*TestvfsBuffer)(unsafe.Pointer(pBuffer)).FpNext {
		if 0 == crt.Xstrcmp(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FzFilename, (*TestvfsBuffer)(unsafe.Pointer(pBuffer)).FzFile) {
			break
		}
	}
	if !(pBuffer != 0) {
		var szName int32 = int32(crt.Xstrlen(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FzFilename))
		var nByte int32 = (int32((uint64(unsafe.Sizeof(TestvfsBuffer{})) + uint64(szName)) + uint64(1)))
		pBuffer = tcl.XTcl_Alloc(tls, uint32(nByte))
		crt.Xmemset(tls, pBuffer, 0, uint64(nByte))
		(*TestvfsBuffer)(unsafe.Pointer(pBuffer)).FzFile = (pBuffer + uintptr(1)*8224)
		crt.Xmemcpy(tls, (*TestvfsBuffer)(unsafe.Pointer(pBuffer)).FzFile, (*TestvfsFd)(unsafe.Pointer(pFd)).FzFilename, (uint64(szName + 1)))
		(*TestvfsBuffer)(unsafe.Pointer(pBuffer)).FpNext = (*Testvfs)(unsafe.Pointer(p)).FpBuffer
		(*Testvfs)(unsafe.Pointer(p)).FpBuffer = pBuffer
	}

	// Connect the TestvfsBuffer to the new TestvfsShm handle and return.
	(*TestvfsFd)(unsafe.Pointer(pFd)).FpNext = (*TestvfsBuffer)(unsafe.Pointer(pBuffer)).FpFile
	(*TestvfsBuffer)(unsafe.Pointer(pBuffer)).FpFile = pFd
	(*TestvfsFd)(unsafe.Pointer(pFd)).FpShm = pBuffer
	return *(*int32)(unsafe.Pointer(bp /* rc */))
}

func tvfsAllocPage(tls *crt.TLS, p uintptr, iPage int32, pgsz int32) { /* test_vfs.c:877:13: */

	if *(*uintptr)(unsafe.Pointer((p + 16 /* &.aPage */) + uintptr(iPage)*8)) == uintptr(0) {
		*(*uintptr)(unsafe.Pointer((p + 16 /* &.aPage */) + uintptr(iPage)*8)) = tcl.XTcl_Alloc(tls, uint32(pgsz))
		crt.Xmemset(tls, *(*uintptr)(unsafe.Pointer((p + 16 /* &.aPage */) + uintptr(iPage)*8)), 0, uint64(pgsz))
		(*TestvfsBuffer)(unsafe.Pointer(p)).Fpgsz = pgsz
	}
}

func tvfsShmMap(tls *crt.TLS, pFile uintptr, iPage int32, pgsz int32, isWrite int32, pp uintptr) int32 { /* test_vfs.c:886:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	*(*int32)(unsafe.Pointer(bp /* rc */)) = 0
	var pFd uintptr = (*TestvfsFile)(unsafe.Pointer(pFile)).FpFd
	var p uintptr = (*sqlite3_vfs)(unsafe.Pointer((*TestvfsFd)(unsafe.Pointer(pFd)).FpVfs)).FpAppData

	if (*Testvfs)(unsafe.Pointer(p)).FisFullshm != 0 {
		return sqlite3.Xsqlite3OsShmMap(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FpReal, iPage, pgsz, isWrite, pp)
	}

	if uintptr(0) == (*TestvfsFd)(unsafe.Pointer(pFd)).FpShm {
		*(*int32)(unsafe.Pointer(bp /* rc */)) = tvfsShmOpen(tls, pFile)
		if *(*int32)(unsafe.Pointer(bp /* rc */)) != 0 {
			return *(*int32)(unsafe.Pointer(bp /* rc */))
		}
	}

	if ((*Testvfs)(unsafe.Pointer(p)).FpScript != 0) && (((*Testvfs)(unsafe.Pointer(p)).Fmask & 0x00000020) != 0) {
		var pArg uintptr = tcl.XTcl_NewObj(tls)
		(*Tcl_Obj)(unsafe.Pointer(pArg)).FrefCount++
		tcl.XTcl_ListObjAppendElement(tls, (*Testvfs)(unsafe.Pointer(p)).Finterp, pArg, tcl.XTcl_NewIntObj(tls, iPage))
		tcl.XTcl_ListObjAppendElement(tls, (*Testvfs)(unsafe.Pointer(p)).Finterp, pArg, tcl.XTcl_NewIntObj(tls, pgsz))
		tcl.XTcl_ListObjAppendElement(tls, (*Testvfs)(unsafe.Pointer(p)).Finterp, pArg, tcl.XTcl_NewIntObj(tls, isWrite))
		tvfsExecTcl(tls, p, ts+40946, /* "xShmMap" */
			tcl.XTcl_NewStringObj(tls, (*TestvfsBuffer)(unsafe.Pointer((*TestvfsFd)(unsafe.Pointer(pFd)).FpShm)).FzFile, -1), (*TestvfsFd)(unsafe.Pointer(pFd)).FpShmId, pArg, uintptr(0))
		tvfsResultCode(tls, p, bp /* &rc */)
		for ok := true; ok; ok = 0 != 0 {
			var _objPtr uintptr = pArg
			if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
	}
	if ((*(*int32)(unsafe.Pointer(bp /* rc */)) == 0) && (((*Testvfs)(unsafe.Pointer(p)).Fmask & 0x00000020) != 0)) && (tvfsInjectIoerr(tls, p) != 0) {
		*(*int32)(unsafe.Pointer(bp /* rc */)) = 10
	}

	if ((*(*int32)(unsafe.Pointer(bp /* rc */)) == 0) && (isWrite != 0)) && !(int32(*(*uintptr)(unsafe.Pointer(((*TestvfsFd)(unsafe.Pointer(pFd)).FpShm + 16 /* &.aPage */) + uintptr(iPage)*8))) != 0) {
		tvfsAllocPage(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FpShm, iPage, pgsz)
	}
	if (*(*int32)(unsafe.Pointer(bp /* rc */)) == 0) || (*(*int32)(unsafe.Pointer(bp /* rc */)) == 8) {
		*(*uintptr)(unsafe.Pointer(pp)) = *(*uintptr)(unsafe.Pointer(((*TestvfsFd)(unsafe.Pointer(pFd)).FpShm + 16 /* &.aPage */) + uintptr(iPage)*8))
	}

	return *(*int32)(unsafe.Pointer(bp /* rc */))
}

func tvfsShmLock(tls *crt.TLS, pFile uintptr, ofst int32, n int32, flags int32) int32 { /* test_vfs.c:935:12: */
	bp := tls.Alloc(100)
	defer tls.Free(100)

	*(*int32)(unsafe.Pointer(bp + 96 /* rc */)) = 0
	var pFd uintptr = (*TestvfsFile)(unsafe.Pointer(pFile)).FpFd
	var p uintptr = (*sqlite3_vfs)(unsafe.Pointer((*TestvfsFd)(unsafe.Pointer(pFd)).FpVfs)).FpAppData
	var nLock int32
	// var zLock [80]int8 at bp+16, 80

	if (*Testvfs)(unsafe.Pointer(p)).FisFullshm != 0 {
		return sqlite3.Xsqlite3OsShmLock(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FpReal, ofst, n, flags)
	}

	if ((*Testvfs)(unsafe.Pointer(p)).FpScript != 0) && (((*Testvfs)(unsafe.Pointer(p)).Fmask & 0x00000010) != 0) {
		sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([80]int8{})), bp+16 /* &zLock[0] */, ts+24063 /* "%d %d" */, crt.VaList(bp, ofst, n))
		nLock = int32(crt.Xstrlen(tls, bp+16 /* &zLock[0] */))
		if (flags & 2) != 0 {
			crt.Xstrcpy(tls, (bp + 16 /* &zLock */ + uintptr(nLock)), ts+44819 /* " lock" */)
		} else {
			crt.Xstrcpy(tls, (bp + 16 /* &zLock */ + uintptr(nLock)), ts+44825 /* " unlock" */)
		}
		nLock = nLock + (int32(crt.Xstrlen(tls, (bp + 16 /* &zLock */ + uintptr(nLock)))))
		if (flags & 4) != 0 {
			crt.Xstrcpy(tls, (bp + 16 /* &zLock */ + uintptr(nLock)), ts+44833 /* " shared" */)
		} else {
			crt.Xstrcpy(tls, (bp + 16 /* &zLock */ + uintptr(nLock)), ts+44841 /* " exclusive" */)
		}
		tvfsExecTcl(tls, p, ts+40925, /* "xShmLock" */
			tcl.XTcl_NewStringObj(tls, (*TestvfsBuffer)(unsafe.Pointer((*TestvfsFd)(unsafe.Pointer(pFd)).FpShm)).FzFile, -1), (*TestvfsFd)(unsafe.Pointer(pFd)).FpShmId,
			tcl.XTcl_NewStringObj(tls, bp+16 /* &zLock[0] */, -1), uintptr(0))
		tvfsResultCode(tls, p, bp+96 /* &rc */)
	}

	if ((*(*int32)(unsafe.Pointer(bp + 96 /* rc */)) == 0) && (((*Testvfs)(unsafe.Pointer(p)).Fmask & 0x00000010) != 0)) && (tvfsInjectIoerr(tls, p) != 0) {
		*(*int32)(unsafe.Pointer(bp + 96 /* rc */)) = 10
	}

	if *(*int32)(unsafe.Pointer(bp + 96 /* rc */)) == 0 {
		var isLock int32 = (flags & 2)
		var isExcl int32 = (flags & 8)
		var mask u32 = (u32(((int32(1) << n) - 1) << ofst))
		if isLock != 0 {
			var p2 uintptr
			for p2 = (*TestvfsBuffer)(unsafe.Pointer((*TestvfsFd)(unsafe.Pointer(pFd)).FpShm)).FpFile; p2 != 0; p2 = (*TestvfsFd)(unsafe.Pointer(p2)).FpNext {
				if p2 == pFd {
					continue
				}
				if (((*TestvfsFd)(unsafe.Pointer(p2)).Fexcllock & mask) != 0) || ((isExcl != 0) && (((*TestvfsFd)(unsafe.Pointer(p2)).Fsharedlock & mask) != 0)) {
					*(*int32)(unsafe.Pointer(bp + 96 /* rc */)) = 5
					break
				}
			}
			if *(*int32)(unsafe.Pointer(bp + 96 /* rc */)) == 0 {
				if isExcl != 0 {
					*(*u32)(unsafe.Pointer(pFd + 40 /* &.excllock */)) |= (mask)
				}
				if !(isExcl != 0) {
					*(*u32)(unsafe.Pointer(pFd + 44 /* &.sharedlock */)) |= (mask)
				}
			}
		} else {
			if isExcl != 0 {
				*(*u32)(unsafe.Pointer(pFd + 40 /* &.excllock */)) &= (^mask)
			}
			if !(isExcl != 0) {
				*(*u32)(unsafe.Pointer(pFd + 44 /* &.sharedlock */)) &= (^mask)
			}
		}
	}

	return *(*int32)(unsafe.Pointer(bp + 96 /* rc */))
}

func tvfsShmBarrier(tls *crt.TLS, pFile uintptr) { /* test_vfs.c:1002:13: */
	var pFd uintptr = (*TestvfsFile)(unsafe.Pointer(pFile)).FpFd
	var p uintptr = (*sqlite3_vfs)(unsafe.Pointer((*TestvfsFd)(unsafe.Pointer(pFd)).FpVfs)).FpAppData

	if ((*Testvfs)(unsafe.Pointer(p)).FpScript != 0) && (((*Testvfs)(unsafe.Pointer(p)).Fmask & 0x00000040) != 0) {
		var z uintptr
		if (*TestvfsFd)(unsafe.Pointer(pFd)).FpShm != 0 {
			z = (*TestvfsBuffer)(unsafe.Pointer((*TestvfsFd)(unsafe.Pointer(pFd)).FpShm)).FzFile
		} else {
			z = ts + 792 /* "" */
		}
		tvfsExecTcl(tls, p, ts+40934 /* "xShmBarrier" */, tcl.XTcl_NewStringObj(tls, z, -1), (*TestvfsFd)(unsafe.Pointer(pFd)).FpShmId, uintptr(0), uintptr(0))
	}

	if (*Testvfs)(unsafe.Pointer(p)).FisFullshm != 0 {
		sqlite3.Xsqlite3OsShmBarrier(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FpReal)
		return
	}
}

func tvfsShmUnmap(tls *crt.TLS, pFile uintptr, deleteFlag int32) int32 { /* test_vfs.c:1017:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	*(*int32)(unsafe.Pointer(bp /* rc */)) = 0
	var pFd uintptr = (*TestvfsFile)(unsafe.Pointer(pFile)).FpFd
	var p uintptr = (*sqlite3_vfs)(unsafe.Pointer((*TestvfsFd)(unsafe.Pointer(pFd)).FpVfs)).FpAppData
	var pBuffer uintptr = (*TestvfsFd)(unsafe.Pointer(pFd)).FpShm
	var ppFd uintptr

	if (*Testvfs)(unsafe.Pointer(p)).FisFullshm != 0 {
		return sqlite3.Xsqlite3OsShmUnmap(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FpReal, deleteFlag)
	}

	if !(pBuffer != 0) {
		return 0
	}

	if ((*Testvfs)(unsafe.Pointer(p)).FpScript != 0) && (((*Testvfs)(unsafe.Pointer(p)).Fmask & 0x00000080) != 0) {
		tvfsExecTcl(tls, p, ts+40915, /* "xShmUnmap" */
			tcl.XTcl_NewStringObj(tls, (*TestvfsBuffer)(unsafe.Pointer((*TestvfsFd)(unsafe.Pointer(pFd)).FpShm)).FzFile, -1), (*TestvfsFd)(unsafe.Pointer(pFd)).FpShmId, uintptr(0), uintptr(0))
		tvfsResultCode(tls, p, bp /* &rc */)
	}

	for ppFd = (pBuffer + 8208 /* &.pFile */); *(*uintptr)(unsafe.Pointer(ppFd)) != pFd; ppFd = (*(*uintptr)(unsafe.Pointer(ppFd)) + 48 /* &.pNext */) {
	}

	*(*uintptr)(unsafe.Pointer(ppFd)) = (*TestvfsFd)(unsafe.Pointer(pFd)).FpNext
	(*TestvfsFd)(unsafe.Pointer(pFd)).FpNext = uintptr(0)

	if (*TestvfsBuffer)(unsafe.Pointer(pBuffer)).FpFile == uintptr(0) {
		var i int32
		var pp uintptr
		for pp = (p + 40 /* &.pBuffer */); *(*uintptr)(unsafe.Pointer(pp)) != pBuffer; pp = (*(*uintptr)(unsafe.Pointer(pp)) + 8216 /* &.pNext */) {
		}
		*(*uintptr)(unsafe.Pointer(pp)) = (*TestvfsBuffer)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(pp)))).FpNext
		for i = 0; *(*uintptr)(unsafe.Pointer((pBuffer + 16 /* &.aPage */) + uintptr(i)*8)) != 0; i++ {
			tcl.XTcl_Free(tls, *(*uintptr)(unsafe.Pointer((pBuffer + 16 /* &.aPage */) + uintptr(i)*8)))
		}
		tcl.XTcl_Free(tls, pBuffer)
	}
	(*TestvfsFd)(unsafe.Pointer(pFd)).FpShm = uintptr(0)

	return *(*int32)(unsafe.Pointer(bp /* rc */))
}

func tvfsFetch(tls *crt.TLS, pFile uintptr, iOfst sqlite3_int64, iAmt int32, pp uintptr) int32 { /* test_vfs.c:1061:12: */
	var pFd uintptr = (*TestvfsFile)(unsafe.Pointer(pFile)).FpFd
	return sqlite3.Xsqlite3OsFetch(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FpReal, iOfst, iAmt, pp)
}

func tvfsUnfetch(tls *crt.TLS, pFile uintptr, iOfst sqlite3_int64, p uintptr) int32 { /* test_vfs.c:1071:12: */
	var pFd uintptr = (*TestvfsFile)(unsafe.Pointer(pFile)).FpFd
	return sqlite3.Xsqlite3OsUnfetch(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FpReal, iOfst, p)
}

func testvfs_obj_cmd(tls *crt.TLS, cd ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_vfs.c:1076:26: */
	bp := tls.Alloc(568)
	defer tls.Free(568)

	var p uintptr = cd

	const ( /* test_vfs.c:1084:3: */
		CMD_SHM         = 0
		CMD_DELETE      = 1
		CMD_FILTER      = 2
		CMD_IOERR       = 3
		CMD_SCRIPT      = 4
		CMD_DEVCHAR     = 5
		CMD_SECTORSIZE  = 6
		CMD_FULLERR     = 7
		CMD_CANTOPENERR = 8
	)
	*(*[10]TestvfsSubcmd)(unsafe.Pointer(bp + 96 /* aSubcmd */)) = [10]TestvfsSubcmd{
		{FzName: ts + 44852 /* "shm" */, FeCmd: CMD_SHM},
		{FzName: ts + 44856 /* "delete" */, FeCmd: CMD_DELETE},
		{FzName: ts + 44863 /* "filter" */, FeCmd: CMD_FILTER},
		{FzName: ts + 44870 /* "ioerr" */, FeCmd: CMD_IOERR},
		{FzName: ts + 44876 /* "fullerr" */, FeCmd: CMD_FULLERR},
		{FzName: ts + 44884 /* "cantopenerr" */, FeCmd: CMD_CANTOPENERR},
		{FzName: ts + 44896 /* "script" */, FeCmd: CMD_SCRIPT},
		{FzName: ts + 44903 /* "devchar" */, FeCmd: CMD_DEVCHAR},
		{FzName: ts + 44911 /* "sectorsize" */, FeCmd: CMD_SECTORSIZE},
		{FzName: uintptr(0), FeCmd: uint32(0)},
	}
	// var i int32 at bp+256, 4

	if objc < 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+2306 /* "SUBCOMMAND ..." */)
		return 1
	}
	if tcl.XTcl_GetIndexFromObjStruct(tls,
		interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)), bp+96 /* &aSubcmd[0] */, int32(unsafe.Sizeof(TestvfsSubcmd{})), ts+44922 /* "subcommand" */, 0, bp+256 /* &i */) != 0 {
		return 1
	}
	tcl.XTcl_ResetResult(tls, interp)

	switch (*TestvfsSubcmd)(unsafe.Pointer(bp + 96 /* &aSubcmd */ + uintptr(*(*int32)(unsafe.Pointer(bp + 256 /* i */)))*16)).FeCmd {
	case CMD_SHM:
		{
			var pObj uintptr
			var rc int32
			var pBuffer uintptr
			var zName uintptr
			if (objc != 3) && (objc != 4) {
				tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+44933 /* "FILE ?VALUE?" */)
				return 1
			}
			zName = tcl.XTcl_Alloc(tls, uint32((*sqlite3_vfs)(unsafe.Pointer((*Testvfs)(unsafe.Pointer(p)).FpParent)).FmxPathname))
			rc = (*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(((*Testvfs)(unsafe.Pointer(p)).FpParent + 64 /* &.xFullPathname */))))(tls,
				(*Testvfs)(unsafe.Pointer(p)).FpParent, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8))),
				(*sqlite3_vfs)(unsafe.Pointer((*Testvfs)(unsafe.Pointer(p)).FpParent)).FmxPathname, zName)
			if rc != 0 {
				tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+44946, /* "failed to get fu..." */
					tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8))), 0))
				tcl.XTcl_Free(tls, zName)
				return 1
			}
			for pBuffer = (*Testvfs)(unsafe.Pointer(p)).FpBuffer; pBuffer != 0; pBuffer = (*TestvfsBuffer)(unsafe.Pointer(pBuffer)).FpNext {
				if 0 == crt.Xstrcmp(tls, (*TestvfsBuffer)(unsafe.Pointer(pBuffer)).FzFile, zName) {
					break
				}
			}
			tcl.XTcl_Free(tls, zName)
			if !(pBuffer != 0) {
				tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+24, ts+44972 /* "no such file: " */, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8))), 0))
				return 1
			}
			if objc == 4 {
				// var n int32 at bp+260, 4

				var a uintptr = tcl.XTcl_GetByteArrayFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(3)*8)), bp+260 /* &n */)
				var pgsz int32 = (*TestvfsBuffer)(unsafe.Pointer(pBuffer)).Fpgsz
				if pgsz == 0 {
					pgsz = 65536
				}
				for *(*int32)(unsafe.Pointer(bp + 256 /* i */)) = 0; (*(*int32)(unsafe.Pointer(bp + 256 /* i */)) * pgsz) < *(*int32)(unsafe.Pointer(bp + 260 /* n */)); *(*int32)(unsafe.Pointer(bp + 256 /* i */))++ {
					var nByte int32 = pgsz
					tvfsAllocPage(tls, pBuffer, *(*int32)(unsafe.Pointer(bp + 256 /* i */)), pgsz)
					if (*(*int32)(unsafe.Pointer(bp + 260 /* n */)) - (*(*int32)(unsafe.Pointer(bp + 256 /* i */)) * pgsz)) < pgsz {
						nByte = *(*int32)(unsafe.Pointer(bp + 260 /* n */))
					}
					crt.Xmemcpy(tls, *(*uintptr)(unsafe.Pointer((pBuffer + 16 /* &.aPage */) + uintptr(*(*int32)(unsafe.Pointer(bp + 256 /* i */)))*8)), (a + uintptr((*(*int32)(unsafe.Pointer(bp + 256 /* i */)) * pgsz))), uint64(nByte))
				}
			}

			pObj = tcl.XTcl_NewObj(tls)
			for *(*int32)(unsafe.Pointer(bp + 256 /* i */)) = 0; *(*uintptr)(unsafe.Pointer((pBuffer + 16 /* &.aPage */) + uintptr(*(*int32)(unsafe.Pointer(bp + 256 /* i */)))*8)) != 0; *(*int32)(unsafe.Pointer(bp + 256 /* i */))++ {
				var pgsz int32 = (*TestvfsBuffer)(unsafe.Pointer(pBuffer)).Fpgsz
				if pgsz == 0 {
					pgsz = 65536
				}
				tcl.XTcl_AppendObjToObj(tls, pObj, tcl.XTcl_NewByteArrayObj(tls, *(*uintptr)(unsafe.Pointer((pBuffer + 16 /* &.aPage */) + uintptr(*(*int32)(unsafe.Pointer(bp + 256 /* i */)))*8)), pgsz))
			}
			tcl.XTcl_SetObjResult(tls, interp, pObj)
			break
		}

	// TESTVFS filter METHOD-LIST
	//
	//     Activate special processing for those methods contained in the list
	case CMD_FILTER:
		{
			*(*uintptr)(unsafe.Pointer(bp + 272 /* apElem */)) = uintptr(0)
			*(*int32)(unsafe.Pointer(bp + 264 /* nElem */)) = 0
			var mask int32 = 0
			if objc != 3 {
				tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+37332 /* "LIST" */)
				return 1
			}
			if tcl.XTcl_ListObjGetElements(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)), bp+264 /* &nElem */, bp+272 /* &apElem */) != 0 {
				return 1
			}
			tcl.XTcl_ResetResult(tls, interp)
			for *(*int32)(unsafe.Pointer(bp + 256 /* i */)) = 0; *(*int32)(unsafe.Pointer(bp + 256 /* i */)) < *(*int32)(unsafe.Pointer(bp + 264 /* nElem */)); *(*int32)(unsafe.Pointer(bp + 256 /* i */))++ {
				var iMethod int32
				var zElem uintptr = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 272 /* apElem */)) + uintptr(*(*int32)(unsafe.Pointer(bp + 256 /* i */)))*8)))
				for iMethod = 0; iMethod < (int32(uint64(unsafe.Sizeof(vfsmethod)) / uint64(unsafe.Sizeof(VfsMethod{})))); iMethod++ {
					if crt.Xstrcmp(tls, zElem, vfsmethod[iMethod].FzName) == 0 {
						mask = mask | (vfsmethod[iMethod].Fmask)
						break
					}
				}
				if iMethod == (int32(uint64(unsafe.Sizeof(vfsmethod)) / uint64(unsafe.Sizeof(VfsMethod{})))) {
					tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+48, ts+44987 /* "unknown method: " */, zElem, 0))
					return 1
				}
			}
			(*Testvfs)(unsafe.Pointer(p)).Fmask = mask
			break
		}

	//  TESTVFS script ?SCRIPT?
	//
	//  Query or set the script to be run when filtered VFS events
	//  occur.
	case CMD_SCRIPT:
		{
			if objc == 3 {
				// var nByte int32 at bp+280, 4

				if (*Testvfs)(unsafe.Pointer(p)).FpScript != 0 {
					for ok := true; ok; ok = 0 != 0 {
						var _objPtr uintptr = (*Testvfs)(unsafe.Pointer(p)).FpScript
						if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
							tcl.XTclFreeObj(tls, _objPtr)
						}
					}
					(*Testvfs)(unsafe.Pointer(p)).FpScript = uintptr(0)
				}
				tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)), bp+280 /* &nByte */)
				if *(*int32)(unsafe.Pointer(bp + 280 /* nByte */)) > 0 {
					(*Testvfs)(unsafe.Pointer(p)).FpScript = tcl.XTcl_DuplicateObj(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)))
					(*Tcl_Obj)(unsafe.Pointer((*Testvfs)(unsafe.Pointer(p)).FpScript)).FrefCount++
				}
			} else if objc != 2 {
				tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+19915 /* "?SCRIPT?" */)
				return 1
			}

			tcl.XTcl_ResetResult(tls, interp)
			if (*Testvfs)(unsafe.Pointer(p)).FpScript != 0 {
				tcl.XTcl_SetObjResult(tls, interp, (*Testvfs)(unsafe.Pointer(p)).FpScript)
			}

			break
		}

	// TESTVFS ioerr ?IFAIL PERSIST?
	//
	//   Where IFAIL is an integer and PERSIST is boolean.
	case CMD_CANTOPENERR:
		fallthrough
	case CMD_IOERR:
		fallthrough
	case CMD_FULLERR:
		{
			var pTest uintptr = uintptr(0)
			var iRet int32

			switch (*TestvfsSubcmd)(unsafe.Pointer(bp + 96 /* &aSubcmd */ + uintptr(*(*int32)(unsafe.Pointer(bp + 256 /* i */)))*16)).FeCmd {
			case CMD_IOERR:
				pTest = (p + 60 /* &.ioerr_err */)
				break
			case CMD_FULLERR:
				pTest = (p + 72 /* &.full_err */)
				break
			case CMD_CANTOPENERR:
				pTest = (p + 84 /* &.cantopen_err */)
				break
			default:
			}
			iRet = (*TestFaultInject)(unsafe.Pointer(pTest)).FnFail
			(*TestFaultInject)(unsafe.Pointer(pTest)).FnFail = 0
			(*TestFaultInject)(unsafe.Pointer(pTest)).FeFault = 0
			(*TestFaultInject)(unsafe.Pointer(pTest)).FiCnt = 0

			if objc == 4 {
				// var iCnt int32 at bp+284, 4

				// var iPersist int32 at bp+288, 4

				if (0 != tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)), bp+284 /* &iCnt */)) ||
					(0 != tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(3)*8)), bp+288 /* &iPersist */)) {
					return 1
				}
				(*TestFaultInject)(unsafe.Pointer(pTest)).FeFault = func() int32 {
					if *(*int32)(unsafe.Pointer(bp + 288 /* iPersist */)) != 0 {
						return 2
					}
					return 1
				}()
				(*TestFaultInject)(unsafe.Pointer(pTest)).FiCnt = *(*int32)(unsafe.Pointer(bp + 284 /* iCnt */))
			} else if objc != 2 {
				tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+45004 /* "?CNT PERSIST?" */)
				return 1
			}
			tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, iRet))
			break
		}

	case CMD_DELETE:
		{
			tcl.XTcl_DeleteCommand(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(0)*8))))
			break
		}

	case CMD_DEVCHAR:
		{
			*(*[16]DeviceFlag)(unsafe.Pointer(bp + 304 /* aFlag */)) = [16]DeviceFlag{
				{FzName: ts + 45018 /* "default" */, FiValue: -1},
				{FzName: ts + 31609 /* "atomic" */, FiValue: 0x00000001},
				{FzName: ts + 31616 /* "atomic512" */, FiValue: 0x00000002},
				{FzName: ts + 31626 /* "atomic1k" */, FiValue: 0x00000004},
				{FzName: ts + 31635 /* "atomic2k" */, FiValue: 0x00000008},
				{FzName: ts + 31644 /* "atomic4k" */, FiValue: 0x00000010},
				{FzName: ts + 31653 /* "atomic8k" */, FiValue: 0x00000020},
				{FzName: ts + 31662 /* "atomic16k" */, FiValue: 0x00000040},
				{FzName: ts + 31672 /* "atomic32k" */, FiValue: 0x00000080},
				{FzName: ts + 31682 /* "atomic64k" */, FiValue: 0x00000100},
				{FzName: ts + 31692 /* "sequential" */, FiValue: 0x00000400},
				{FzName: ts + 31703 /* "safe_append" */, FiValue: 0x00000200},
				{FzName: ts + 45026 /* "undeletable_when..." */, FiValue: 0x00000800},
				{FzName: ts + 31715 /* "powersafe_overwr..." */, FiValue: 0x00001000},
				{FzName: ts + 45048 /* "immutable" */, FiValue: 0x00002000},
				{FzName: uintptr(0), FiValue: 0},
			}
			var pRet uintptr
			var iFlag int32

			if objc > 3 {
				tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+45058 /* "?ATTR-LIST?" */)
				return 1
			}
			if objc == 3 {
				var j int32
				var iNew int32 = 0
				*(*uintptr)(unsafe.Pointer(bp + 296 /* flags */)) = uintptr(0)
				*(*int32)(unsafe.Pointer(bp + 292 /* nFlags */)) = 0

				if tcl.XTcl_ListObjGetElements(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)), bp+292 /* &nFlags */, bp+296 /* &flags */) != 0 {
					return 1
				}

				for j = 0; j < *(*int32)(unsafe.Pointer(bp + 292 /* nFlags */)); j++ {
					*(*int32)(unsafe.Pointer(bp + 560 /* idx */)) = 0
					if tcl.XTcl_GetIndexFromObjStruct(tls, interp, *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 296 /* flags */)) + uintptr(j)*8)), bp+304, /* &aFlag[0] */
						int32(unsafe.Sizeof(DeviceFlag{})), ts+23786 /* "flag" */, 0, bp+560 /* &idx */) != 0 {
						return 1
					}
					if ((*DeviceFlag)(unsafe.Pointer(bp+304 /* &aFlag */ +uintptr(*(*int32)(unsafe.Pointer(bp + 560 /* idx */)))*16)).FiValue < 0) && (*(*int32)(unsafe.Pointer(bp + 292 /* nFlags */)) > 1) {
						tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp+72, ts+45070 /* "bad flags: " */, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8))), 0))
						return 1
					}
					iNew = iNew | ((*DeviceFlag)(unsafe.Pointer(bp + 304 /* &aFlag */ + uintptr(*(*int32)(unsafe.Pointer(bp + 560 /* idx */)))*16)).FiValue)
				}

				(*Testvfs)(unsafe.Pointer(p)).FiDevchar = (iNew | 0x10000000)
			}

			pRet = tcl.XTcl_NewObj(tls)
			for iFlag = 0; uint64(iFlag) < (uint64(unsafe.Sizeof([16]DeviceFlag{})) / uint64(unsafe.Sizeof(DeviceFlag{}))); iFlag++ {
				if ((*Testvfs)(unsafe.Pointer(p)).FiDevchar & (*DeviceFlag)(unsafe.Pointer(bp+304 /* &aFlag */ +uintptr(iFlag)*16)).FiValue) != 0 {
					tcl.XTcl_ListObjAppendElement(tls,
						interp, pRet, tcl.XTcl_NewStringObj(tls, (*DeviceFlag)(unsafe.Pointer(bp+304 /* &aFlag */ +uintptr(iFlag)*16)).FzName, -1))
				}
			}
			tcl.XTcl_SetObjResult(tls, interp, pRet)

			break
		}

	case CMD_SECTORSIZE:
		{
			if objc > 3 {
				tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+45082 /* "?VALUE?" */)
				return 1
			}
			if objc == 3 {
				*(*int32)(unsafe.Pointer(bp + 564 /* iNew */)) = 0
				if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)), bp+564 /* &iNew */) != 0 {
					return 1
				}
				(*Testvfs)(unsafe.Pointer(p)).FiSectorsize = *(*int32)(unsafe.Pointer(bp + 564 /* iNew */))
			}
			tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, (*Testvfs)(unsafe.Pointer(p)).FiSectorsize))
			break
		}
	}

	return 0
}

type TestvfsSubcmd = struct {
	FzName uintptr
	FeCmd  uint32
	_      [4]byte
}

type VfsMethod = struct {
	FzName uintptr
	Fmask  int32
	_      [4]byte
}

var vfsmethod = [18]VfsMethod{
	{FzName: ts + 44810 /* "xShmOpen" */, Fmask: 0x00000001},
	{FzName: ts + 40925 /* "xShmLock" */, Fmask: 0x00000010},
	{FzName: ts + 40934 /* "xShmBarrier" */, Fmask: 0x00000040},
	{FzName: ts + 40915 /* "xShmUnmap" */, Fmask: 0x00000080},
	{FzName: ts + 40946 /* "xShmMap" */, Fmask: 0x00000020},
	{FzName: ts + 32890 /* "xSync" */, Fmask: 0x00000200},
	{FzName: ts + 40853 /* "xDelete" */, Fmask: 0x00000400},
	{FzName: ts + 40761 /* "xWrite" */, Fmask: 0x00001000},
	{FzName: ts + 40755 /* "xRead" */, Fmask: 0x00010000},
	{FzName: ts + 40768 /* "xTruncate" */, Fmask: 0x00002000},
	{FzName: ts + 32455 /* "xOpen" */, Fmask: 0x00000100},
	{FzName: ts + 40748 /* "xClose" */, Fmask: 0x00000800},
	{FzName: ts + 40861 /* "xAccess" */, Fmask: 0x00004000},
	{FzName: ts + 40869 /* "xFullPathname" */, Fmask: 0x00008000},
	{FzName: ts + 40794 /* "xUnlock" */, Fmask: 0x00020000},
	{FzName: ts + 40788 /* "xLock" */, Fmask: 0x00040000},
	{FzName: ts + 44676 /* "xCheckReservedLo..." */, Fmask: 0x00080000},
	{FzName: ts + 40816 /* "xFileControl" */, Fmask: 0x00100000},
} /* test_vfs.c:1178:9 */

func testvfs_obj_del(tls *crt.TLS, cd ClientData) { /* test_vfs.c:1389:27: */
	var p uintptr = cd
	if (*Testvfs)(unsafe.Pointer(p)).FpScript != 0 {
		for ok := true; ok; ok = 0 != 0 {
			var _objPtr uintptr = (*Testvfs)(unsafe.Pointer(p)).FpScript
			if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
	}
	sqlite3.Xsqlite3_vfs_unregister(tls, (*Testvfs)(unsafe.Pointer(p)).FpVfs)
	crt.Xmemset(tls, (*Testvfs)(unsafe.Pointer(p)).FpVfs, 0, uint64(unsafe.Sizeof(sqlite3_vfs{})))
	tcl.XTcl_Free(tls, (*Testvfs)(unsafe.Pointer(p)).FpVfs)
	crt.Xmemset(tls, p, 0, uint64(unsafe.Sizeof(Testvfs{})))
	tcl.XTcl_Free(tls, p)
}

// Usage:  testvfs VFSNAME ?SWITCHES?
//
// Switches are:
//
//   -noshm   BOOLEAN             (True to omit shm methods. Default false)
//   -default BOOLEAN             (True to make the vfs default. Default false)
//
// This command creates two things when it is invoked: an SQLite VFS, and
// a Tcl command. Both are named VFSNAME. The VFS is installed. It is not
// installed as the default VFS.
//
// The VFS passes all file I/O calls through to the underlying VFS.
//
// Whenever the xShmMap method of the VFS
// is invoked, the SCRIPT is executed as follows:
//
//   SCRIPT xShmMap    FILENAME ID
//
// The value returned by the invocation of SCRIPT above is interpreted as
// an SQLite error code and returned to SQLite. Either a symbolic
// "SQLITE_OK" or numeric "0" value may be returned.
//
// The contents of the shared-memory buffer associated with a given file
// may be read and set using the following command:
//
//   VFSNAME shm FILENAME ?NEWVALUE?
//
// When the xShmLock method is invoked by SQLite, the following script is
// run:
//
//   SCRIPT xShmLock    FILENAME ID LOCK
//
// where LOCK is of the form "OFFSET NBYTE lock/unlock shared/exclusive"
func testvfs_cmd(tls *crt.TLS, cd ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_vfs.c:1434:26: */
	bp := tls.Alloc(28)
	defer tls.Free(28)

	var p uintptr    // New object
	var pVfs uintptr // New VFS
	var zVfs uintptr
	var nByte int32 // Bytes of space to allocate at p

	var i int32
	// var isNoshm int32 at bp+4, 4
	// True if -noshm is passed
	// var isFullshm int32 at bp+24, 4
	// True if -fullshm is passed
	// var isDefault int32 at bp+8, 4
	// True if -default is passed
	// var szOsFile int32 at bp+12, 4
	// Value passed to -szosfile
	// var mxPathname int32 at bp+16, 4
	// Value passed to -mxpathname
	// var iVersion int32 at bp+20, 4

	// var nSwitch int32 at bp, 4

	var zSwitch uintptr
	*(*int32)(unsafe.Pointer(bp + 4 /* isNoshm */)) = 0
	*(*int32)(unsafe.Pointer(bp + 24 /* isFullshm */)) = 0
	*(*int32)(unsafe.Pointer(bp + 8 /* isDefault */)) = 0
	*(*int32)(unsafe.Pointer(bp + 12 /* szOsFile */)) = 0
	*(*int32)(unsafe.Pointer(bp + 16 /* mxPathname */)) = -1
	*(*int32)(unsafe.Pointer(bp + 20 /* iVersion */)) = 3 // Value passed to -iversion

	if !((objc < 2) || (0 != (objc % 2))) {
		goto __1
	}
	goto bad_args
__1:
	;
	i = 2
__2:
	if !(i < objc) {
		goto __4
	}
	zSwitch = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(i)*8)), bp /* &nSwitch */)

	if !((*(*int32)(unsafe.Pointer(bp /* nSwitch */)) > 2) && (0 == crt.Xstrncmp(tls, ts+45090 /* "-noshm" */, zSwitch, uint64(*(*int32)(unsafe.Pointer(bp /* nSwitch */)))))) {
		goto __5
	}
	if !(tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr((i+1))*8)), bp+4 /* &isNoshm */) != 0) {
		goto __7
	}
	return 1
__7:
	;
	if !(*(*int32)(unsafe.Pointer(bp + 4 /* isNoshm */)) != 0) {
		goto __8
	}
	*(*int32)(unsafe.Pointer(bp + 24 /* isFullshm */)) = 0
__8:
	;
	goto __6
__5:
	if !((*(*int32)(unsafe.Pointer(bp /* nSwitch */)) > 2) && (0 == crt.Xstrncmp(tls, ts+31985 /* "-default" */, zSwitch, uint64(*(*int32)(unsafe.Pointer(bp /* nSwitch */)))))) {
		goto __9
	}
	if !(tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr((i+1))*8)), bp+8 /* &isDefault */) != 0) {
		goto __11
	}
	return 1
__11:
	;
	goto __10
__9:
	if !((*(*int32)(unsafe.Pointer(bp /* nSwitch */)) > 2) && (0 == crt.Xstrncmp(tls, ts+45097 /* "-szosfile" */, zSwitch, uint64(*(*int32)(unsafe.Pointer(bp /* nSwitch */)))))) {
		goto __12
	}
	if !(tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr((i+1))*8)), bp+12 /* &szOsFile */) != 0) {
		goto __14
	}
	return 1
__14:
	;
	goto __13
__12:
	if !((*(*int32)(unsafe.Pointer(bp /* nSwitch */)) > 2) && (0 == crt.Xstrncmp(tls, ts+45107 /* "-mxpathname" */, zSwitch, uint64(*(*int32)(unsafe.Pointer(bp /* nSwitch */)))))) {
		goto __15
	}
	if !(tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr((i+1))*8)), bp+16 /* &mxPathname */) != 0) {
		goto __17
	}
	return 1
__17:
	;
	goto __16
__15:
	if !((*(*int32)(unsafe.Pointer(bp /* nSwitch */)) > 2) && (0 == crt.Xstrncmp(tls, ts+45119 /* "-iversion" */, zSwitch, uint64(*(*int32)(unsafe.Pointer(bp /* nSwitch */)))))) {
		goto __18
	}
	if !(tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr((i+1))*8)), bp+20 /* &iVersion */) != 0) {
		goto __20
	}
	return 1
__20:
	;
	goto __19
__18:
	if !((*(*int32)(unsafe.Pointer(bp /* nSwitch */)) > 2) && (0 == crt.Xstrncmp(tls, ts+45129 /* "-fullshm" */, zSwitch, uint64(*(*int32)(unsafe.Pointer(bp /* nSwitch */)))))) {
		goto __21
	}
	if !(tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr((i+1))*8)), bp+24 /* &isFullshm */) != 0) {
		goto __23
	}
	return 1
__23:
	;
	if !(*(*int32)(unsafe.Pointer(bp + 24 /* isFullshm */)) != 0) {
		goto __24
	}
	*(*int32)(unsafe.Pointer(bp + 4 /* isNoshm */)) = 0
__24:
	;
	goto __22
__21:
	goto bad_args
__22:
	;
__19:
	;
__16:
	;
__13:
	;
__10:
	;
__6:
	;
	goto __3
__3:
	i = i + (2)
	goto __2
	goto __4
__4:
	;

	if !(uint64(*(*int32)(unsafe.Pointer(bp + 12 /* szOsFile */))) < uint64(unsafe.Sizeof(TestvfsFile{}))) {
		goto __25
	}
	*(*int32)(unsafe.Pointer(bp + 12 /* szOsFile */)) = int32(unsafe.Sizeof(TestvfsFile{}))
__25:
	;

	zVfs = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)))
	nByte = (int32((uint64(unsafe.Sizeof(Testvfs{})) + uint64(int32(crt.Xstrlen(tls, zVfs)))) + uint64(1)))
	p = tcl.XTcl_Alloc(tls, uint32(nByte))
	crt.Xmemset(tls, p, 0, uint64(nByte))
	(*Testvfs)(unsafe.Pointer(p)).FiDevchar = -1
	(*Testvfs)(unsafe.Pointer(p)).FiSectorsize = -1

	// Create the new object command before querying SQLite for a default VFS
	// to use for 'real' IO operations. This is because creating the new VFS
	// may delete an existing [testvfs] VFS of the same name. If such a VFS
	// is currently the default, the new [testvfs] may end up calling the
	// methods of a deleted object.
	tcl.XTcl_CreateObjCommand(tls, interp, zVfs, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
	}{testvfs_obj_cmd})), p, *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, ClientData) }{testvfs_obj_del})))
	(*Testvfs)(unsafe.Pointer(p)).FpParent = sqlite3.Xsqlite3_vfs_find(tls, uintptr(0))
	(*Testvfs)(unsafe.Pointer(p)).Finterp = interp

	(*Testvfs)(unsafe.Pointer(p)).FzName = (p + uintptr(1)*104)
	crt.Xmemcpy(tls, (*Testvfs)(unsafe.Pointer(p)).FzName, zVfs, (crt.Xstrlen(tls, zVfs) + uint64(1)))

	pVfs = tcl.XTcl_Alloc(tls, uint32(unsafe.Sizeof(sqlite3_vfs{})))
	crt.Xmemcpy(tls, pVfs, uintptr(unsafe.Pointer(&tvfs_vfs)), uint64(unsafe.Sizeof(sqlite3_vfs{})))
	(*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData = p
	(*sqlite3_vfs)(unsafe.Pointer(pVfs)).FiVersion = *(*int32)(unsafe.Pointer(bp + 20 /* iVersion */))
	(*sqlite3_vfs)(unsafe.Pointer(pVfs)).FzName = (*Testvfs)(unsafe.Pointer(p)).FzName
	(*sqlite3_vfs)(unsafe.Pointer(pVfs)).FmxPathname = (*sqlite3_vfs)(unsafe.Pointer((*Testvfs)(unsafe.Pointer(p)).FpParent)).FmxPathname
	if !((*(*int32)(unsafe.Pointer(bp + 16 /* mxPathname */)) >= 0) && (*(*int32)(unsafe.Pointer(bp + 16 /* mxPathname */)) < (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FmxPathname)) {
		goto __26
	}
	(*sqlite3_vfs)(unsafe.Pointer(pVfs)).FmxPathname = *(*int32)(unsafe.Pointer(bp + 16 /* mxPathname */))
__26:
	;
	(*sqlite3_vfs)(unsafe.Pointer(pVfs)).FszOsFile = *(*int32)(unsafe.Pointer(bp + 12 /* szOsFile */))
	(*Testvfs)(unsafe.Pointer(p)).FpVfs = pVfs
	(*Testvfs)(unsafe.Pointer(p)).FisNoshm = *(*int32)(unsafe.Pointer(bp + 4 /* isNoshm */))
	(*Testvfs)(unsafe.Pointer(p)).FisFullshm = *(*int32)(unsafe.Pointer(bp + 24 /* isFullshm */))
	(*Testvfs)(unsafe.Pointer(p)).Fmask = 0x001FFFFF

	sqlite3.Xsqlite3_vfs_register(tls, pVfs, *(*int32)(unsafe.Pointer(bp + 8 /* isDefault */)))

	return 0

bad_args:
	tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+45138 /* "VFSNAME ?-noshm ..." */)
	return 1
}

var tvfs_vfs = sqlite3_vfs{FiVersion: 3, FszOsFile: // iVersion
0, FmxPathname:// szOsFile
0, FpNext:// mxPathname
uintptr(0), FzName:// pNext
uintptr(0), FpAppData:// zName
uintptr(0), FxOpen:// pAppData
0, FxDelete:// xOpen
0, FxAccess:// xDelete
0, FxFullPathname:// xAccess
0, FxDlOpen:// xFullPathname
uintptr(0), FxDlError:// xDlOpen
uintptr(0), FxDlSym:// xDlError
uintptr(0), FxDlClose:// xDlSym
uintptr(0), FxRandomness:// xDlClose
0, FxSleep:// xRandomness
0, FxCurrentTime:// xSleep
0, FxGetLastError:// xCurrentTime
uintptr(0), FxCurrentTimeInt64:// xGetLastError
uintptr(0), FxSetSystemCall:// xCurrentTimeInt64
uintptr(0), FxGetSystemCall:// xSetSystemCall
uintptr(0), FxNextSystemCall:// xGetSystemCall
uintptr(0), // xNextSystemCall
} /* test_vfs.c:1440:22 */

// tclcmd: vfs_shmlock DB DBNAME (shared|exclusive) (lock|unlock) OFFSET N
func test_vfs_shmlock(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_vfs.c:1582:26: */
	bp := tls.Alloc(88)
	defer tls.Free(88)

	*(*[3]uintptr)(unsafe.Pointer(bp + 8 /* azArg1 */)) = [3]uintptr{ts + 45242 /* "shared" */, ts + 20648 /* "exclusive" */, uintptr(0)}
	*(*[3]uintptr)(unsafe.Pointer(bp + 40 /* azArg2 */)) = [3]uintptr{ts + 45249 /* "lock" */, ts + 45254 /* "unlock" */, uintptr(0)}
	*(*uintptr)(unsafe.Pointer(bp /* db */)) = uintptr(0)
	var rc int32 = 0
	var zDbname uintptr = uintptr(0)
	*(*int32)(unsafe.Pointer(bp + 32 /* iArg1 */)) = 0
	*(*int32)(unsafe.Pointer(bp + 64 /* iArg2 */)) = 0
	*(*int32)(unsafe.Pointer(bp + 68 /* iOffset */)) = 0
	*(*int32)(unsafe.Pointer(bp + 72 /* n */)) = 0
	// var pFd uintptr at bp+80, 8

	if objc != 7 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv,
			ts+45261 /* "DB DBNAME (share..." */)
		return 1
	}

	zDbname = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)))
	if ((((getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), bp /* &db */) != 0) ||
		(tcl.XTcl_GetIndexFromObjStruct(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(3)*8)), bp+8 /* &azArg1[0] */, int32(unsafe.Sizeof(uintptr(0))), ts+45313 /* "ARG" */, 0, bp+32 /* &iArg1 */) != 0)) ||
		(tcl.XTcl_GetIndexFromObjStruct(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(4)*8)), bp+40 /* &azArg2[0] */, int32(unsafe.Sizeof(uintptr(0))), ts+45313 /* "ARG" */, 0, bp+64 /* &iArg2 */) != 0)) ||
		(tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(5)*8)), bp+68 /* &iOffset */) != 0)) ||
		(tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(6)*8)), bp+72 /* &n */) != 0) {
		return 1
	}

	sqlite3.Xsqlite3_file_control(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), zDbname, 7, bp+80 /* &pFd */)
	if *(*uintptr)(unsafe.Pointer(bp + 80 /* pFd */)) == uintptr(0) {
		return 1
	}
	rc = (*(*func(*crt.TLS, uintptr, int32, int32, int32) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 80 /* pFd */)))).FpMethods + 112 /* &.xShmLock */))))(tls, *(*uintptr)(unsafe.Pointer(bp + 80 /* pFd */)), *(*int32)(unsafe.Pointer(bp + 68 /* iOffset */)), *(*int32)(unsafe.Pointer(bp + 72 /* n */)),
		((func() int32 {
			if *(*int32)(unsafe.Pointer(bp + 32 /* iArg1 */)) == 0 {
				return 4
			}
			return 8
		}()) |
			(func() int32 {
				if *(*int32)(unsafe.Pointer(bp + 64 /* iArg2 */)) == 0 {
					return 2
				}
				return 1
			}())))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3ErrName(tls, rc), -1))
	return 0
}

func test_vfs_set_readmark(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_vfs.c:1628:26: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	*(*uintptr)(unsafe.Pointer(bp + 16 /* db */)) = uintptr(0)
	var rc int32 = 0
	var zDbname uintptr = uintptr(0)
	*(*int32)(unsafe.Pointer(bp + 24 /* iSlot */)) = 0
	*(*int32)(unsafe.Pointer(bp + 28 /* iVal */)) = -1
	// var pFd uintptr at bp+32, 8

	*(*uintptr)(unsafe.Pointer(bp + 40 /* pShm */)) = uintptr(0)
	var aShm uintptr
	var iOff int32

	if (objc != 4) && (objc != 5) {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+45317 /* "DB DBNAME SLOT ?..." */)
		return 1
	}

	zDbname = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)))
	if ((getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), bp+16 /* &db */) != 0) ||
		(tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(3)*8)), bp+24 /* &iSlot */) != 0)) ||
		((objc == 5) && (tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(4)*8)), bp+28 /* &iVal */) != 0)) {
		return 1
	}

	sqlite3.Xsqlite3_file_control(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* db */)), zDbname, 7, bp+32 /* &pFd */)
	if *(*uintptr)(unsafe.Pointer(bp + 32 /* pFd */)) == uintptr(0) {
		return 1
	}
	rc = (*(*func(*crt.TLS, uintptr, int32, int32, int32, uintptr) int32)(unsafe.Pointer(((*sqlite3_file)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32 /* pFd */)))).FpMethods + 104 /* &.xShmMap */))))(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* pFd */)), 0, (32 * 1024), 0, bp+40 /* &pShm */)
	if rc != 0 {
		tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3ErrName(tls, rc), -1))
		return 1
	}
	if *(*uintptr)(unsafe.Pointer(bp + 40 /* pShm */)) == uintptr(0) {
		tcl.XTcl_AppendResult(tls, interp, crt.VaList(bp, ts+45340 /* "*-shm is not yet..." */, 0))
		return 1
	}
	aShm = *(*uintptr)(unsafe.Pointer(bp + 40 /* pShm */))
	iOff = (((12 * 2) + 1) + *(*int32)(unsafe.Pointer(bp + 24 /* iSlot */)))

	if objc == 5 {
		*(*u32)(unsafe.Pointer(aShm + uintptr(iOff)*4)) = u32(*(*int32)(unsafe.Pointer(bp + 28 /* iVal */)))
	}
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, int32(*(*u32)(unsafe.Pointer(aShm + uintptr(iOff)*4)))))

	return 0
}

func Sqlitetestvfs_Init(tls *crt.TLS, interp uintptr) int32 { /* test_vfs.c:1681:5: */
	tcl.XTcl_CreateObjCommand(tls, interp, ts+45364 /* "testvfs" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
	}{testvfs_cmd})), uintptr(0), uintptr(0))
	tcl.XTcl_CreateObjCommand(tls, interp, ts+45372 /* "vfs_shmlock" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_vfs_shmlock})), uintptr(0), uintptr(0))
	tcl.XTcl_CreateObjCommand(tls, interp, ts+45384 /* "vfs_set_readmark" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_vfs_set_readmark})), uintptr(0), uintptr(0))
	return 0
}

type TestWindow1 = struct {
	FxStep    uintptr
	FxFinal   uintptr
	FxValue   uintptr
	FxInverse uintptr
	Finterp   uintptr
}

type TestWindow = TestWindow1 /* test_window.c:24:27 */

type TestWindowCtx1 = struct{ FpVal uintptr }

type TestWindowCtx = TestWindowCtx1 /* test_window.c:33:30 */

func doTestWindowStep(tls *crt.TLS, bInverse int32, ctx uintptr, nArg int32, apArg uintptr) { /* test_window.c:38:13: */
	var i int32
	var p uintptr = sqlite3.Xsqlite3_user_data(tls, ctx)
	var pEval uintptr = tcl.XTcl_DuplicateObj(tls, func() uintptr {
		if bInverse != 0 {
			return (*TestWindow)(unsafe.Pointer(p)).FxInverse
		}
		return (*TestWindow)(unsafe.Pointer(p)).FxStep
	}())
	var pCtx uintptr = sqlite3.Xsqlite3_aggregate_context(tls, ctx, int32(unsafe.Sizeof(TestWindowCtx{})))

	(*Tcl_Obj)(unsafe.Pointer(pEval)).FrefCount++
	if pCtx != 0 {
		var zResult uintptr
		var rc int32
		if (*TestWindowCtx)(unsafe.Pointer(pCtx)).FpVal != 0 {
			tcl.XTcl_ListObjAppendElement(tls, (*TestWindow)(unsafe.Pointer(p)).Finterp, pEval, tcl.XTcl_DuplicateObj(tls, (*TestWindowCtx)(unsafe.Pointer(pCtx)).FpVal))
		} else {
			tcl.XTcl_ListObjAppendElement(tls, (*TestWindow)(unsafe.Pointer(p)).Finterp, pEval, tcl.XTcl_NewStringObj(tls, ts+792 /* "" */, -1))
		}
		for i = 0; i < nArg; i++ {
			var pArg uintptr
			pArg = tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(apArg + uintptr(i)*8))), -1)
			tcl.XTcl_ListObjAppendElement(tls, (*TestWindow)(unsafe.Pointer(p)).Finterp, pEval, pArg)
		}
		rc = tcl.XTcl_EvalObjEx(tls, (*TestWindow)(unsafe.Pointer(p)).Finterp, pEval, 0x020000)
		if rc != 0 {
			zResult = tcl.XTcl_GetStringResult(tls, (*TestWindow)(unsafe.Pointer(p)).Finterp)
			sqlite3.Xsqlite3_result_error(tls, ctx, zResult, -1)
		} else {
			if (*TestWindowCtx)(unsafe.Pointer(pCtx)).FpVal != 0 {
				for ok := true; ok; ok = 0 != 0 {
					var _objPtr uintptr = (*TestWindowCtx)(unsafe.Pointer(pCtx)).FpVal
					if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
						tcl.XTclFreeObj(tls, _objPtr)
					}
				}
			}
			(*TestWindowCtx)(unsafe.Pointer(pCtx)).FpVal = tcl.XTcl_DuplicateObj(tls, tcl.XTcl_GetObjResult(tls, (*TestWindow)(unsafe.Pointer(p)).Finterp))
			(*Tcl_Obj)(unsafe.Pointer((*TestWindowCtx)(unsafe.Pointer(pCtx)).FpVal)).FrefCount++
		}
	}
	for ok1 := true; ok1; ok1 = 0 != 0 {
		var _objPtr uintptr = pEval
		if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
}

func doTestWindowFinalize(tls *crt.TLS, bValue int32, ctx uintptr) { /* test_window.c:76:13: */
	var p uintptr = sqlite3.Xsqlite3_user_data(tls, ctx)
	var pEval uintptr = tcl.XTcl_DuplicateObj(tls, func() uintptr {
		if bValue != 0 {
			return (*TestWindow)(unsafe.Pointer(p)).FxValue
		}
		return (*TestWindow)(unsafe.Pointer(p)).FxFinal
	}())
	var pCtx uintptr = sqlite3.Xsqlite3_aggregate_context(tls, ctx, int32(unsafe.Sizeof(TestWindowCtx{})))

	(*Tcl_Obj)(unsafe.Pointer(pEval)).FrefCount++
	if pCtx != 0 {
		var zResult uintptr
		var rc int32
		if (*TestWindowCtx)(unsafe.Pointer(pCtx)).FpVal != 0 {
			tcl.XTcl_ListObjAppendElement(tls, (*TestWindow)(unsafe.Pointer(p)).Finterp, pEval, tcl.XTcl_DuplicateObj(tls, (*TestWindowCtx)(unsafe.Pointer(pCtx)).FpVal))
		} else {
			tcl.XTcl_ListObjAppendElement(tls, (*TestWindow)(unsafe.Pointer(p)).Finterp, pEval, tcl.XTcl_NewStringObj(tls, ts+792 /* "" */, -1))
		}

		rc = tcl.XTcl_EvalObjEx(tls, (*TestWindow)(unsafe.Pointer(p)).Finterp, pEval, 0x020000)
		zResult = tcl.XTcl_GetStringResult(tls, (*TestWindow)(unsafe.Pointer(p)).Finterp)
		if rc != 0 {
			sqlite3.Xsqlite3_result_error(tls, ctx, zResult, -1)
		} else {
			sqlite3.Xsqlite3_result_text(tls, ctx, zResult, -1, crt.UintptrFromInt32(-1))
		}

		if bValue == 0 {
			if (*TestWindowCtx)(unsafe.Pointer(pCtx)).FpVal != 0 {
				for ok := true; ok; ok = 0 != 0 {
					var _objPtr uintptr = (*TestWindowCtx)(unsafe.Pointer(pCtx)).FpVal
					if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
						tcl.XTclFreeObj(tls, _objPtr)
					}
				}
			}
			(*TestWindowCtx)(unsafe.Pointer(pCtx)).FpVal = uintptr(0)
		}
	}
	for ok1 := true; ok1; ok1 = 0 != 0 {
		var _objPtr uintptr = pEval
		if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
}

func testWindowStep(tls *crt.TLS, ctx uintptr, nArg int32, apArg uintptr) { /* test_window.c:107:13: */
	doTestWindowStep(tls, 0, ctx, nArg, apArg)
}
func testWindowInverse(tls *crt.TLS, ctx uintptr, nArg int32, apArg uintptr) { /* test_window.c:114:13: */
	doTestWindowStep(tls, 1, ctx, nArg, apArg)
}

func testWindowFinal(tls *crt.TLS, ctx uintptr) { /* test_window.c:122:13: */
	doTestWindowFinalize(tls, 0, ctx)
}
func testWindowValue(tls *crt.TLS, ctx uintptr) { /* test_window.c:125:13: */
	doTestWindowFinalize(tls, 1, ctx)
}

func testWindowDestroy(tls *crt.TLS, pCtx uintptr) { /* test_window.c:129:13: */
	tcl.XTcl_Free(tls, pCtx)
}

// Usage: sqlite3_create_window_function DB NAME XSTEP XFINAL XVALUE XINVERSE
func test_create_window(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_window.c:136:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var pNew uintptr
	// var db uintptr at bp, 8

	var zName uintptr
	var rc int32

	if objc != 7 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+45401 /* "DB NAME XSTEP XF..." */)
		return 1
	}

	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), bp /* &db */) != 0 {
		return 1
	}
	zName = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)))
	pNew = tcl.XTcl_Alloc(tls, uint32(unsafe.Sizeof(TestWindow{})))
	crt.Xmemset(tls, pNew, 0, uint64(unsafe.Sizeof(TestWindow{})))
	(*TestWindow)(unsafe.Pointer(pNew)).FxStep = tcl.XTcl_DuplicateObj(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(3)*8)))
	(*TestWindow)(unsafe.Pointer(pNew)).FxFinal = tcl.XTcl_DuplicateObj(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(4)*8)))
	(*TestWindow)(unsafe.Pointer(pNew)).FxValue = tcl.XTcl_DuplicateObj(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(5)*8)))
	(*TestWindow)(unsafe.Pointer(pNew)).FxInverse = tcl.XTcl_DuplicateObj(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(6)*8)))
	(*TestWindow)(unsafe.Pointer(pNew)).Finterp = interp

	(*Tcl_Obj)(unsafe.Pointer((*TestWindow)(unsafe.Pointer(pNew)).FxStep)).FrefCount++
	(*Tcl_Obj)(unsafe.Pointer((*TestWindow)(unsafe.Pointer(pNew)).FxFinal)).FrefCount++
	(*Tcl_Obj)(unsafe.Pointer((*TestWindow)(unsafe.Pointer(pNew)).FxValue)).FrefCount++
	(*Tcl_Obj)(unsafe.Pointer((*TestWindow)(unsafe.Pointer(pNew)).FxInverse)).FrefCount++

	rc = sqlite3.Xsqlite3_create_window_function(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), zName, -1, 1, pNew,
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*crt.TLS, uintptr, int32, uintptr)
		}{testWindowStep})), *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, uintptr) }{testWindowFinal})), *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, uintptr) }{testWindowValue})), *(*uintptr)(unsafe.Pointer(&struct {
			f func(*crt.TLS, uintptr, int32, uintptr)
		}{testWindowInverse})),
		*(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, uintptr) }{testWindowDestroy})))
	if rc != 0 {
		tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3ErrName(tls, rc), -1))
		return 1
	}

	return 0
}

func test_create_window_misuse(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_window.c:179:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// var db uintptr at bp, 8

	var rc int32

	if !(objc != 2) {
		goto __1
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+2452 /* "DB" */)
	return 1
__1:
	;
	if !(getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), bp /* &db */) != 0) {
		goto __2
	}
	return 1
__2:
	;

	rc = sqlite3.Xsqlite3_create_window_function(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), ts+45438 /* "fff" */, -1, 1, uintptr(0),
		uintptr(0), *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, uintptr) }{testWindowFinal})), *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, uintptr) }{testWindowValue})), *(*uintptr)(unsafe.Pointer(&struct {
			f func(*crt.TLS, uintptr, int32, uintptr)
		}{testWindowInverse})),
		uintptr(0))
	if !(rc != 21) {
		goto __3
	}
	goto error
__3:
	;
	rc = sqlite3.Xsqlite3_create_window_function(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), ts+45438 /* "fff" */, -1, 1, uintptr(0),
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*crt.TLS, uintptr, int32, uintptr)
		}{testWindowStep})), uintptr(0), *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, uintptr) }{testWindowValue})), *(*uintptr)(unsafe.Pointer(&struct {
			f func(*crt.TLS, uintptr, int32, uintptr)
		}{testWindowInverse})),
		uintptr(0))
	if !(rc != 21) {
		goto __4
	}
	goto error
__4:
	;
	rc = sqlite3.Xsqlite3_create_window_function(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), ts+45438 /* "fff" */, -1, 1, uintptr(0),
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*crt.TLS, uintptr, int32, uintptr)
		}{testWindowStep})), *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, uintptr) }{testWindowFinal})), uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
			f func(*crt.TLS, uintptr, int32, uintptr)
		}{testWindowInverse})),
		uintptr(0))
	if !(rc != 21) {
		goto __5
	}
	goto error
__5:
	;
	rc = sqlite3.Xsqlite3_create_window_function(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), ts+45438 /* "fff" */, -1, 1, uintptr(0),
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*crt.TLS, uintptr, int32, uintptr)
		}{testWindowStep})), *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, uintptr) }{testWindowFinal})), *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, uintptr) }{testWindowValue})), uintptr(0),
		uintptr(0))
	if !(rc != 21) {
		goto __6
	}
	goto error
__6:
	;

	return 0

error:
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, ts+45442 /* "misuse test erro..." */, -1))
	return 1
}

// xStep for sumint().
func sumintStep(tls *crt.TLS, ctx uintptr, nArg int32, apArg uintptr) { /* test_window.c:225:13: */
	var pInt uintptr

	if sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(apArg + uintptr(0)*8))) != 1 {
		sqlite3.Xsqlite3_result_error(tls, ctx, ts+45460 /* "invalid argument" */, -1)
		return
	}
	pInt = sqlite3.Xsqlite3_aggregate_context(tls, ctx, int32(unsafe.Sizeof(sqlite3_int64(0))))
	if pInt != 0 {
		*(*sqlite3_int64)(unsafe.Pointer(pInt)) += (sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(apArg + uintptr(0)*8))))
	}
}

// xInverse for sumint().
func sumintInverse(tls *crt.TLS, ctx uintptr, nArg int32, apArg uintptr) { /* test_window.c:246:13: */
	var pInt uintptr
	pInt = sqlite3.Xsqlite3_aggregate_context(tls, ctx, int32(unsafe.Sizeof(sqlite3_int64(0))))
	*(*sqlite3_int64)(unsafe.Pointer(pInt)) -= (sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(apArg + uintptr(0)*8))))
}

// xFinal for sumint().
func sumintFinal(tls *crt.TLS, ctx uintptr) { /* test_window.c:259:13: */
	var res sqlite3_int64 = int64(0)
	var pInt uintptr
	pInt = sqlite3.Xsqlite3_aggregate_context(tls, ctx, 0)
	if pInt != 0 {
		res = *(*sqlite3_int64)(unsafe.Pointer(pInt))
	}
	sqlite3.Xsqlite3_result_int64(tls, ctx, res)
}

// xValue for sumint().
func sumintValue(tls *crt.TLS, ctx uintptr) { /* test_window.c:270:13: */
	var res sqlite3_int64 = int64(0)
	var pInt uintptr
	pInt = sqlite3.Xsqlite3_aggregate_context(tls, ctx, 0)
	if pInt != 0 {
		res = *(*sqlite3_int64)(unsafe.Pointer(pInt))
	}
	sqlite3.Xsqlite3_result_int64(tls, ctx, res)
}

func test_create_sumint(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_window.c:278:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// var db uintptr at bp, 8

	var rc int32

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+2452 /* "DB" */)
		return 1
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), bp /* &db */) != 0 {
		return 1
	}

	rc = sqlite3.Xsqlite3_create_window_function(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), ts+45477 /* "sumint" */, 1, 1, uintptr(0),
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*crt.TLS, uintptr, int32, uintptr)
		}{sumintStep})), *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, uintptr) }{sumintFinal})), *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, uintptr) }{sumintValue})), *(*uintptr)(unsafe.Pointer(&struct {
			f func(*crt.TLS, uintptr, int32, uintptr)
		}{sumintInverse})),
		uintptr(0))

	if rc != 0 {
		tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3ErrName(tls, rc), -1))
		return 1
	}
	return 0
}

func test_override_sum(tls *crt.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_window.c:305:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// var db uintptr at bp, 8

	var rc int32

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+2452 /* "DB" */)
		return 1
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), bp /* &db */) != 0 {
		return 1
	}

	rc = sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), ts+45484 /* "sum" */, -1, 1, uintptr(0),
		uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
			f func(*crt.TLS, uintptr, int32, uintptr)
		}{sumintStep})), *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, uintptr) }{sumintFinal})))

	if rc != 0 {
		tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3ErrName(tls, rc), -1))
		return 1
	}
	return 0
}

func Sqlitetest_window_Init(tls *crt.TLS, interp uintptr) int32 { /* test_window.c:331:5: */
	var i int32
	for i = 0; uint64(i) < (uint64(unsafe.Sizeof(aObjCmd14)) / uint64(unsafe.Sizeof(struct {
		FzName      uintptr
		FxProc      uintptr
		FclientData int32
		_           [4]byte
	}{}))); i++ {
		var c ClientData = uintptr(int64(aObjCmd14[i].FclientData))
		tcl.XTcl_CreateObjCommand(tls, interp, aObjCmd14[i].FzName, aObjCmd14[i].FxProc, c, uintptr(0))
	}
	return 0
}

var aObjCmd14 = [4]struct {
	FzName      uintptr
	FxProc      uintptr
	FclientData int32
	_           [4]byte
}{
	{FzName: ts + 45488 /* "sqlite3_create_w..." */, FxProc: 0, FclientData: 0},
	{FzName: ts + 45519 /* "test_create_wind..." */, FxProc: 0, FclientData: 0},
	{FzName: ts + 45554 /* "test_create_sumi..." */, FxProc: 0, FclientData: 0},
	{FzName: ts + 45573 /* "test_override_su..." */, FxProc: 0, FclientData: 0},
} /* test_window.c:336:5 */

func init() {
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CrashFileVtab)) + 8 /* .xClose */)) = cfClose                                                          // test6.c:573:3:
	*(*func(*crt.TLS, uintptr, uintptr, int32, sqlite_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CrashFileVtab)) + 16 /* .xRead */)) = cfRead                             // test6.c:574:3:
	*(*func(*crt.TLS, uintptr, uintptr, int32, sqlite_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CrashFileVtab)) + 24 /* .xWrite */)) = cfWrite                           // test6.c:575:3:
	*(*func(*crt.TLS, uintptr, sqlite_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CrashFileVtab)) + 32 /* .xTruncate */)) = cfTruncate                                     // test6.c:576:3:
	*(*func(*crt.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CrashFileVtab)) + 40 /* .xSync */)) = cfSync                                                    // test6.c:577:3:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CrashFileVtab)) + 48 /* .xFileSize */)) = cfFileSize                                          // test6.c:578:3:
	*(*func(*crt.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CrashFileVtab)) + 56 /* .xLock */)) = cfLock                                                    // test6.c:579:3:
	*(*func(*crt.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CrashFileVtab)) + 64 /* .xUnlock */)) = cfUnlock                                                // test6.c:580:3:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CrashFileVtab)) + 72 /* .xCheckReservedLock */)) = cfCheckReservedLock                        // test6.c:581:3:
	*(*func(*crt.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CrashFileVtab)) + 80 /* .xFileControl */)) = cfFileControl                             // test6.c:582:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CrashFileVtab)) + 88 /* .xSectorSize */)) = cfSectorSize                                               // test6.c:583:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CrashFileVtab)) + 96 /* .xDeviceCharacteristics */)) = cfDeviceCharacteristics                         // test6.c:584:3:
	*(*func(*crt.TLS, uintptr, int32, int32, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CrashFileVtab)) + 104 /* .xShmMap */)) = cfShmMap                        // test6.c:585:3:
	*(*func(*crt.TLS, uintptr, int32, int32, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CrashFileVtab)) + 112 /* .xShmLock */)) = cfShmLock                               // test6.c:586:3:
	*(*func(*crt.TLS, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&CrashFileVtab)) + 120 /* .xShmBarrier */)) = cfShmBarrier                                                    // test6.c:587:3:
	*(*func(*crt.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CrashFileVtab)) + 128 /* .xShmUnmap */)) = cfShmUnmap                                           // test6.c:588:3:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CsvModule)) + 8 /* .xCreate */)) = csvtabCreate             // csv.c:874:3:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CsvModule)) + 16 /* .xConnect */)) = csvtabConnect          // csv.c:875:3:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CsvModule)) + 24 /* .xBestIndex */)) = csvtabBestIndex                                        // csv.c:876:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CsvModule)) + 32 /* .xDisconnect */)) = csvtabDisconnect                                               // csv.c:877:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CsvModule)) + 40 /* .xDestroy */)) = csvtabDisconnect                                                  // csv.c:878:3:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CsvModule)) + 48 /* .xOpen */)) = csvtabOpen                                                  // csv.c:879:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CsvModule)) + 56 /* .xClose */)) = csvtabClose                                                         // csv.c:880:3:
	*(*func(*crt.TLS, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CsvModule)) + 64 /* .xFilter */)) = csvtabFilter                       // csv.c:881:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CsvModule)) + 72 /* .xNext */)) = csvtabNext                                                           // csv.c:882:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CsvModule)) + 80 /* .xEof */)) = csvtabEof                                                             // csv.c:883:3:
	*(*func(*crt.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CsvModule)) + 88 /* .xColumn */)) = csvtabColumn                                       // csv.c:884:3:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CsvModule)) + 96 /* .xRowid */)) = csvtabRowid                                                // csv.c:885:3:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CsvModuleFauxWrite)) + 8 /* .xCreate */)) = csvtabCreate    // csv.c:906:3:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CsvModuleFauxWrite)) + 16 /* .xConnect */)) = csvtabConnect // csv.c:907:3:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CsvModuleFauxWrite)) + 24 /* .xBestIndex */)) = csvtabBestIndex                               // csv.c:908:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CsvModuleFauxWrite)) + 32 /* .xDisconnect */)) = csvtabDisconnect                                      // csv.c:909:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CsvModuleFauxWrite)) + 40 /* .xDestroy */)) = csvtabDisconnect                                         // csv.c:910:3:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CsvModuleFauxWrite)) + 48 /* .xOpen */)) = csvtabOpen                                         // csv.c:911:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CsvModuleFauxWrite)) + 56 /* .xClose */)) = csvtabClose                                                // csv.c:912:3:
	*(*func(*crt.TLS, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CsvModuleFauxWrite)) + 64 /* .xFilter */)) = csvtabFilter              // csv.c:913:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CsvModuleFauxWrite)) + 72 /* .xNext */)) = csvtabNext                                                  // csv.c:914:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CsvModuleFauxWrite)) + 80 /* .xEof */)) = csvtabEof                                                    // csv.c:915:3:
	*(*func(*crt.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CsvModuleFauxWrite)) + 88 /* .xColumn */)) = csvtabColumn                              // csv.c:916:3:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CsvModuleFauxWrite)) + 96 /* .xRowid */)) = csvtabRowid                                       // csv.c:917:3:
	*(*func(*crt.TLS, uintptr, int32, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CsvModuleFauxWrite)) + 104 /* .xUpdate */)) = csvtabUpdate                    // csv.c:918:3:
	*(*func(*crt.TLS, ClientData, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&IncrblobChannelType)) + 16 /* .closeProc */)) = incrblobClose                              // tclsqlite.c:372:3:
	*(*func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&IncrblobChannelType)) + 24 /* .inputProc */)) = incrblobInput              // tclsqlite.c:373:3:
	*(*func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&IncrblobChannelType)) + 32 /* .outputProc */)) = incrblobOutput            // tclsqlite.c:374:3:
	*(*func(*crt.TLS, ClientData, int64, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&IncrblobChannelType)) + 40 /* .seekProc */)) = incrblobSeek                  // tclsqlite.c:375:3:
	*(*func(*crt.TLS, ClientData, int32))(unsafe.Pointer(uintptr(unsafe.Pointer(&IncrblobChannelType)) + 64 /* .watchProc */)) = incrblobWatch                                      // tclsqlite.c:378:3:
	*(*func(*crt.TLS, ClientData, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&IncrblobChannelType)) + 72 /* .getHandleProc */)) = incrblobHandle                  // tclsqlite.c:379:3:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd)) + 8 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{db_enter})) // test1.c:7878:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd)) + 24 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{db_leave})) // test1.c:7879:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd)) + 40 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{sqlite3_mprintf_int})) // test1.c:7880:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd)) + 56 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{sqlite3_mprintf_int64})) // test1.c:7881:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd)) + 72 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{sqlite3_mprintf_long})) // test1.c:7882:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd)) + 88 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{sqlite3_mprintf_str})) // test1.c:7883:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd)) + 104 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{sqlite3_snprintf_str})) // test1.c:7884:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd)) + 120 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{sqlite3_mprintf_stronly})) // test1.c:7885:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd)) + 136 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{sqlite3_mprintf_double})) // test1.c:7886:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd)) + 152 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{sqlite3_mprintf_scaled})) // test1.c:7887:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd)) + 168 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{sqlite3_mprintf_hexdouble})) // test1.c:7888:39:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd)) + 184 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_mprintf_z})) // test1.c:7889:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd)) + 200 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_mprintf_n})) // test1.c:7890:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd)) + 216 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_snprintf_int})) // test1.c:7891:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd)) + 232 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_last_rowid})) // test1.c:7892:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd)) + 248 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_exec_printf})) // test1.c:7893:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd)) + 264 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_exec_hex})) // test1.c:7894:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd)) + 280 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_exec})) // test1.c:7895:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd)) + 296 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_exec_nr})) // test1.c:7896:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd)) + 312 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_get_table_printf})) // test1.c:7898:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd)) + 328 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{sqlite_test_close})) // test1.c:7900:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd)) + 344 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{sqlite_test_close_v2})) // test1.c:7901:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd)) + 360 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_create_function})) // test1.c:7902:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd)) + 376 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_create_aggregate})) // test1.c:7903:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd)) + 392 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_drop_modules})) // test1.c:7904:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd)) + 408 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_register_func})) // test1.c:7905:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd)) + 424 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{sqlite_abort})) // test1.c:7906:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd)) + 440 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_bind})) // test1.c:7907:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd)) + 456 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_breakpoint})) // test1.c:7908:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd)) + 472 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_key})) // test1.c:7909:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd)) + 488 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_rekey})) // test1.c:7910:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd)) + 504 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{sqlite_set_magic})) // test1.c:7911:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd)) + 520 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_interrupt})) // test1.c:7912:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd)) + 536 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{delete_function})) // test1.c:7913:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd)) + 552 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{delete_collation})) // test1.c:7914:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd)) + 568 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{get_autocommit})) // test1.c:7915:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd)) + 584 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_busy_timeout})) // test1.c:7916:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd)) + 600 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_printf})) // test1.c:7917:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd)) + 616 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_io_trace})) // test1.c:7918:39:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd)) + 632 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{clang_sanitize_address})) // test1.c:7919:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 8 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{pager_open})) // test2.c:708:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 24 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{pager_close})) // test2.c:709:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 40 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{pager_commit})) // test2.c:710:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 56 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{pager_rollback})) // test2.c:711:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 72 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{pager_stmt_begin})) // test2.c:712:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 88 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{pager_stmt_commit})) // test2.c:713:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 104 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{pager_stmt_rollback})) // test2.c:714:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 120 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{pager_stats})) // test2.c:715:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 136 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{pager_pagecount})) // test2.c:716:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 152 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{page_get})) // test2.c:717:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 168 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{page_lookup})) // test2.c:718:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 184 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{page_unref})) // test2.c:719:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 200 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{page_read})) // test2.c:720:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 216 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{page_write})) // test2.c:721:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 232 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{page_number})) // test2.c:722:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 248 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{pager_truncate})) // test2.c:723:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 264 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{fake_big_file})) // test2.c:725:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 280 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{testBitvecBuiltinTest})) // test2.c:727:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 296 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{testPendingByte})) // test2.c:728:45:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 312 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{faultInstallCmd})) // test2.c:729:45:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd2)) + 8 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{btree_open})) // test3.c:666:36:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd2)) + 24 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{btree_close})) // test3.c:667:36:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd2)) + 40 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{btree_begin_transaction})) // test3.c:668:36:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd2)) + 56 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{btree_pager_stats})) // test3.c:669:36:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd2)) + 72 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{btree_cursor})) // test3.c:670:36:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd2)) + 88 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{btree_close_cursor})) // test3.c:671:36:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd2)) + 104 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{btree_next})) // test3.c:672:36:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd2)) + 120 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{btree_eof})) // test3.c:673:36:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd2)) + 136 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{btree_payload_size})) // test3.c:674:36:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd2)) + 152 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{btree_first})) // test3.c:675:36:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd2)) + 168 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{btree_varint_test})) // test3.c:676:36:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd2)) + 184 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{btree_from_db})) // test3.c:677:36:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd2)) + 200 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{btree_ismemdb})) // test3.c:678:36:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd2)) + 216 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{btree_set_cache_size})) // test3.c:679:36:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd3)) + 8 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{tcl_thread_create})) // test4.c:701:29:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd3)) + 24 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{tcl_thread_wait})) // test4.c:702:29:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd3)) + 40 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{tcl_thread_halt})) // test4.c:703:29:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd3)) + 56 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{tcl_thread_argc})) // test4.c:704:29:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd3)) + 72 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{tcl_thread_argv})) // test4.c:705:29:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd3)) + 88 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{tcl_thread_colname})) // test4.c:706:29:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd3)) + 104 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{tcl_thread_result})) // test4.c:707:29:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd3)) + 120 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{tcl_thread_error})) // test4.c:708:29:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd3)) + 136 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{tcl_thread_compile})) // test4.c:709:29:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd3)) + 152 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{tcl_thread_step})) // test4.c:710:29:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd3)) + 168 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{tcl_thread_finalize})) // test4.c:711:29:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd3)) + 184 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{tcl_thread_swap})) // test4.c:712:29:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd3)) + 200 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{tcl_thread_db_get})) // test4.c:713:29:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd3)) + 216 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{tcl_thread_db_put})) // test4.c:714:29:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd3)) + 232 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{tcl_thread_stmt_get})) // test4.c:715:29:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd4)) + 8 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{binarize})) // test5.c:210:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd4)) + 24 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_value_overhead})) // test5.c:211:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd4)) + 40 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_translate})) // test5.c:212:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd4)) + 56 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_translate_selftest})) // test5.c:213:34:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd5)) + 8 /* .xProc */)) = test_multiplex_initialize  // test_multiplex.c:1311:39:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd5)) + 24 /* .xProc */)) = test_multiplex_shutdown   // test_multiplex.c:1312:37:
	*(*func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd5)) + 40 /* .xProc */)) = test_multiplex_control // test_multiplex.c:1313:36:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd6)) + 8 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_shutdown})) // test_mutex.c:485:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd6)) + 24 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_initialize})) // test_mutex.c:486:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd6)) + 40 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_config})) // test_mutex.c:487:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd6)) + 56 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_enter_static_mutex})) // test_mutex.c:489:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd6)) + 72 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_leave_static_mutex})) // test_mutex.c:490:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd6)) + 88 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_enter_db_mutex})) // test_mutex.c:492:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd6)) + 104 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_leave_db_mutex})) // test_mutex.c:493:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd6)) + 120 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_alloc_mutex})) // test_mutex.c:495:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd6)) + 136 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_install_mutex_counters})) // test_mutex.c:496:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd6)) + 152 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_read_mutex_counters})) // test_mutex.c:497:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd6)) + 168 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_clear_mutex_counters})) // test_mutex.c:498:34:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd7)) + 8 /* .xProc */)) = test_quota_initialize                  // test_quota.c:1949:38:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd7)) + 24 /* .xProc */)) = test_quota_shutdown                   // test_quota.c:1950:38:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd7)) + 40 /* .xProc */)) = test_quota_set                        // test_quota.c:1951:38:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd7)) + 56 /* .xProc */)) = test_quota_file                       // test_quota.c:1952:38:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd7)) + 72 /* .xProc */)) = test_quota_dump                       // test_quota.c:1953:38:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd7)) + 88 /* .xProc */)) = test_quota_fopen                      // test_quota.c:1954:38:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd7)) + 104 /* .xProc */)) = test_quota_fread                     // test_quota.c:1955:38:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd7)) + 120 /* .xProc */)) = test_quota_fwrite                    // test_quota.c:1956:38:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd7)) + 136 /* .xProc */)) = test_quota_fclose                    // test_quota.c:1957:38:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd7)) + 152 /* .xProc */)) = test_quota_fflush                    // test_quota.c:1958:38:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd7)) + 168 /* .xProc */)) = test_quota_fseek                     // test_quota.c:1959:38:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd7)) + 184 /* .xProc */)) = test_quota_rewind                    // test_quota.c:1960:38:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd7)) + 200 /* .xProc */)) = test_quota_ftell                     // test_quota.c:1961:38:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd7)) + 216 /* .xProc */)) = test_quota_ftruncate                 // test_quota.c:1962:38:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd7)) + 232 /* .xProc */)) = test_quota_file_size                 // test_quota.c:1963:38:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd7)) + 248 /* .xProc */)) = test_quota_file_truesize             // test_quota.c:1964:38:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd7)) + 264 /* .xProc */)) = test_quota_file_mtime                // test_quota.c:1965:38:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd7)) + 280 /* .xProc */)) = test_quota_remove                    // test_quota.c:1966:38:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd7)) + 296 /* .xProc */)) = test_quota_glob                      // test_quota.c:1967:38:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd7)) + 312 /* .xProc */)) = test_quota_file_available            // test_quota.c:1968:38:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd7)) + 328 /* .xProc */)) = test_quota_ferror                    // test_quota.c:1969:38:
	*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aExtension)) + 8 /* .pInit */)) = sqlite3_amatch_init                      // test1.c:7281:32:
	*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aExtension)) + 24 /* .pInit */)) = sqlite3_carray_init                     // test1.c:7282:32:
	*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aExtension)) + 40 /* .pInit */)) = sqlite3_closure_init                    // test1.c:7283:32:
	*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aExtension)) + 56 /* .pInit */)) = sqlite3_csv_init                        // test1.c:7284:32:
	*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aExtension)) + 72 /* .pInit */)) = sqlite3_eval_init                       // test1.c:7285:32:
	*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aExtension)) + 88 /* .pInit */)) = sqlite3_explain_init                    // test1.c:7286:32:
	*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aExtension)) + 104 /* .pInit */)) = sqlite3_fileio_init                    // test1.c:7287:32:
	*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aExtension)) + 120 /* .pInit */)) = sqlite3_fuzzer_init                    // test1.c:7288:32:
	*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aExtension)) + 136 /* .pInit */)) = sqlite3_ieee_init                      // test1.c:7289:32:
	*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aExtension)) + 152 /* .pInit */)) = sqlite3_nextchar_init                  // test1.c:7290:32:
	*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aExtension)) + 168 /* .pInit */)) = sqlite3_percentile_init                // test1.c:7291:32:
	*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aExtension)) + 184 /* .pInit */)) = sqlite3_prefixes_init                  // test1.c:7293:32:
	*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aExtension)) + 200 /* .pInit */)) = sqlite3_regexp_init                    // test1.c:7295:32:
	*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aExtension)) + 216 /* .pInit */)) = sqlite3_remember_init                  // test1.c:7296:32:
	*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aExtension)) + 232 /* .pInit */)) = sqlite3_series_init                    // test1.c:7297:32:
	*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aExtension)) + 248 /* .pInit */)) = sqlite3_spellfix_init                  // test1.c:7298:32:
	*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aExtension)) + 264 /* .pInit */)) = sqlite3_totype_init                    // test1.c:7299:32:
	*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aExtension)) + 280 /* .pInit */)) = sqlite3_unionvtab_init                 // test1.c:7300:32:
	*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aExtension)) + 296 /* .pInit */)) = sqlite3_wholenumber_init               // test1.c:7301:32:
	*(*func(*crt.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFuncs)) + 16 /* .xFunc */)) = randStr                                             // test_func.c:675:48:
	*(*func(*crt.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFuncs)) + 40 /* .xFunc */)) = test_destructor                                     // test_func.c:676:48:
	*(*func(*crt.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFuncs)) + 64 /* .xFunc */)) = testHexToUtf8                                       // test_func.c:682:48:
	*(*func(*crt.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFuncs)) + 88 /* .xFunc */)) = test_destructor_count                               // test_func.c:683:48:
	*(*func(*crt.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFuncs)) + 112 /* .xFunc */)) = test_auxdata                                       // test_func.c:684:48:
	*(*func(*crt.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFuncs)) + 136 /* .xFunc */)) = test_error                                         // test_func.c:685:48:
	*(*func(*crt.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFuncs)) + 160 /* .xFunc */)) = test_error                                         // test_func.c:686:48:
	*(*func(*crt.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFuncs)) + 184 /* .xFunc */)) = test_eval                                          // test_func.c:687:48:
	*(*func(*crt.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFuncs)) + 208 /* .xFunc */)) = test_isolation                                     // test_func.c:688:48:
	*(*func(*crt.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFuncs)) + 232 /* .xFunc */)) = counterFunc                                        // test_func.c:689:48:
	*(*func(*crt.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFuncs)) + 256 /* .xFunc */)) = real2hex                                           // test_func.c:690:48:
	*(*func(*crt.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFuncs)) + 280 /* .xFunc */)) = test_decode                                        // test_func.c:691:48:
	*(*func(*crt.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFuncs)) + 304 /* .xFunc */)) = test_extract                                       // test_func.c:692:48:
	*(*func(*crt.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFuncs)) + 328 /* .xFunc */)) = test_zeroblob                                      // test_func.c:693:62:
	*(*func(*crt.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFuncs)) + 352 /* .xFunc */)) = test_getsubtype                                    // test_func.c:694:48:
	*(*func(*crt.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFuncs)) + 376 /* .xFunc */)) = test_setsubtype                                    // test_func.c:695:48:
	*(*func(*crt.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFuncs)) + 400 /* .xFunc */)) = test_frombind                                      // test_func.c:696:48:
	*(*func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd)) + 8 /* .xProc */)) = test_sqlite3rbu                   // test_rbu.c:370:21:
	*(*func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd)) + 24 /* .xProc */)) = test_sqlite3rbu_vacuum           // test_rbu.c:371:28:
	*(*func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd)) + 40 /* .xProc */)) = test_sqlite3rbu_create_vfs       // test_rbu.c:372:32:
	*(*func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd)) + 56 /* .xProc */)) = test_sqlite3rbu_destroy_vfs      // test_rbu.c:373:33:
	*(*func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd)) + 72 /* .xProc */)) = test_sqlite3rbu_internal_test    // test_rbu.c:374:35:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 8 /* .xProc */)) = test_sqlite3_db_config              // test1.c:7926:41:
	*(*func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 32 /* .xProc */)) = test_bad_behavior               // test1.c:7927:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 40 /* .clientData */)) = uintptr(unsafe.Pointer(&iZero))                                              // test1.c:7927:61:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 56 /* .xProc */)) = test_register_dbstat_vtab          // test1.c:7928:41:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 80 /* .xProc */)) = get_sqlite_pointer                 // test1.c:7929:41:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 104 /* .xProc */)) = test_intarray_addr                // test1.c:7930:41:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 128 /* .xProc */)) = test_int64array_addr              // test1.c:7931:41:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 152 /* .xProc */)) = test_doublearray_addr             // test1.c:7932:41:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 176 /* .xProc */)) = test_textarray_addr               // test1.c:7933:41:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 200 /* .xProc */)) = test_bind_int                     // test1.c:7934:41:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 224 /* .xProc */)) = test_bind_zeroblob                // test1.c:7935:41:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 248 /* .xProc */)) = test_bind_zeroblob64              // test1.c:7936:41:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 272 /* .xProc */)) = test_bind_int64                   // test1.c:7937:41:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 296 /* .xProc */)) = test_bind_double                  // test1.c:7938:41:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 320 /* .xProc */)) = test_bind_null                    // test1.c:7939:41:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 344 /* .xProc */)) = test_bind_text                    // test1.c:7940:41:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 368 /* .xProc */)) = test_bind_text16                  // test1.c:7941:41:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 392 /* .xProc */)) = test_bind_blob                    // test1.c:7942:41:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 416 /* .xProc */)) = test_bind_parameter_count         // test1.c:7943:41:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 440 /* .xProc */)) = test_bind_parameter_name          // test1.c:7944:41:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 464 /* .xProc */)) = test_bind_parameter_index         // test1.c:7945:41:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 488 /* .xProc */)) = test_clear_bindings               // test1.c:7946:41:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 512 /* .xProc */)) = test_sleep                        // test1.c:7947:41:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 536 /* .xProc */)) = test_errcode                      // test1.c:7948:41:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 560 /* .xProc */)) = test_ex_errcode                   // test1.c:7949:41:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 584 /* .xProc */)) = test_errmsg                       // test1.c:7950:41:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 608 /* .xProc */)) = test_errmsg16                     // test1.c:7951:41:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 632 /* .xProc */)) = test_open                         // test1.c:7952:41:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 656 /* .xProc */)) = test_open16                       // test1.c:7953:41:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 680 /* .xProc */)) = test_open_v2                      // test1.c:7954:41:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 704 /* .xProc */)) = test_complete16                   // test1.c:7955:41:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 728 /* .xProc */)) = test_normalize                    // test1.c:7956:41:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 752 /* .xProc */)) = test_prepare                      // test1.c:7958:41:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 776 /* .xProc */)) = test_prepare16                    // test1.c:7959:41:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 800 /* .xProc */)) = test_prepare_v2                   // test1.c:7960:41:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 824 /* .xProc */)) = test_prepare_v3                   // test1.c:7961:41:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 848 /* .xProc */)) = test_prepare_tkt3134              // test1.c:7962:41:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 872 /* .xProc */)) = test_prepare16_v2                 // test1.c:7963:41:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 896 /* .xProc */)) = test_finalize                     // test1.c:7964:41:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 920 /* .xProc */)) = test_stmt_status                  // test1.c:7965:41:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 944 /* .xProc */)) = test_reset                        // test1.c:7966:41:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 968 /* .xProc */)) = test_expired                      // test1.c:7967:41:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 992 /* .xProc */)) = test_transfer_bind                // test1.c:7968:41:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1016 /* .xProc */)) = test_changes                     // test1.c:7969:41:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1040 /* .xProc */)) = test_step                        // test1.c:7970:41:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1064 /* .xProc */)) = test_sql                         // test1.c:7971:41:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1088 /* .xProc */)) = test_ex_sql                      // test1.c:7972:41:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1112 /* .xProc */)) = test_next_stmt                   // test1.c:7976:41:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1136 /* .xProc */)) = test_stmt_readonly               // test1.c:7977:41:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1160 /* .xProc */)) = test_stmt_isexplain              // test1.c:7978:41:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1184 /* .xProc */)) = test_stmt_busy                   // test1.c:7979:41:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1208 /* .xProc */)) = uses_stmt_journal                // test1.c:7980:41:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1232 /* .xProc */)) = test_release_memory              // test1.c:7982:41:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1256 /* .xProc */)) = test_db_release_memory           // test1.c:7983:41:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1280 /* .xProc */)) = test_db_cacheflush               // test1.c:7984:41:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1304 /* .xProc */)) = test_system_errno                // test1.c:7985:41:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1328 /* .xProc */)) = test_db_filename                 // test1.c:7986:41:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1352 /* .xProc */)) = test_db_readonly                 // test1.c:7987:41:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1376 /* .xProc */)) = test_soft_heap_limit             // test1.c:7988:41:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1400 /* .xProc */)) = test_soft_heap_limit             // test1.c:7989:41:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1424 /* .xProc */)) = test_hard_heap_limit             // test1.c:7990:41:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1448 /* .xProc */)) = test_thread_cleanup              // test1.c:7991:41:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1472 /* .xProc */)) = test_pager_refcounts             // test1.c:7992:41:
	*(*func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1496 /* .xProc */)) = test_load_extension           // test1.c:7994:41:
	*(*func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1520 /* .xProc */)) = test_enable_load              // test1.c:7995:41:
	*(*func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1544 /* .xProc */)) = test_extended_result_codes    // test1.c:7996:41:
	*(*func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1568 /* .xProc */)) = test_limit                    // test1.c:7997:41:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1592 /* .xProc */)) = test_dbconfig_maindbname_icecube // test1.c:7998:41:
	*(*func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1616 /* .xProc */)) = save_prng_state               // test1.c:8000:41:
	*(*func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1640 /* .xProc */)) = restore_prng_state            // test1.c:8001:41:
	*(*func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1664 /* .xProc */)) = reset_prng_state              // test1.c:8002:41:
	*(*func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1688 /* .xProc */)) = prng_seed                     // test1.c:8003:41:
	*(*func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1712 /* .xProc */)) = database_never_corrupt        // test1.c:8004:41:
	*(*func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1736 /* .xProc */)) = database_may_be_corrupt       // test1.c:8005:41:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1760 /* .xProc */)) = optimization_control             // test1.c:8006:41:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1784 /* .xProc */)) = runAsObjProc                     // test1.c:8015:41:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1808 /* .xProc */)) = test_column_count                // test1.c:8018:41:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1832 /* .xProc */)) = test_data_count                  // test1.c:8019:41:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1856 /* .xProc */)) = test_column_type                 // test1.c:8020:41:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1880 /* .xProc */)) = test_column_blob                 // test1.c:8021:41:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1904 /* .xProc */)) = test_column_double               // test1.c:8022:41:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1928 /* .xProc */)) = test_column_int64                // test1.c:8023:41:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1952 /* .xProc */)) = test_stmt_utf8                   // test1.c:8024:33:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1960 /* .clientData */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, int32) uintptr
	}{sqlite3.Xsqlite3_column_text})) // test1.c:8024:50:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1976 /* .xProc */)) = test_stmt_utf8 // test1.c:8025:33:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1984 /* .clientData */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, int32) uintptr
	}{sqlite3.Xsqlite3_column_name})) // test1.c:8025:50:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 2000 /* .xProc */)) = test_stmt_int // test1.c:8026:33:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 2008 /* .clientData */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, int32) int32
	}{sqlite3.Xsqlite3_column_int})) // test1.c:8026:50:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 2024 /* .xProc */)) = test_stmt_int // test1.c:8027:33:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 2032 /* .clientData */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, int32) int32
	}{sqlite3.Xsqlite3_column_bytes})) // test1.c:8027:50:
	*(*func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 2048 /* .xProc */)) = test_create_collation_v2         // test1.c:8052:39:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 2072 /* .xProc */)) = test_global_recover                 // test1.c:8053:38:
	*(*func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 2096 /* .xProc */)) = working_64bit_int                // test1.c:8054:38:
	*(*func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 2120 /* .xProc */)) = vfs_unlink_test                  // test1.c:8055:38:
	*(*func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 2144 /* .xProc */)) = vfs_initfail_test                // test1.c:8056:38:
	*(*func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 2168 /* .xProc */)) = vfs_unregister_all               // test1.c:8057:38:
	*(*func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 2192 /* .xProc */)) = vfs_reregister_all               // test1.c:8058:38:
	*(*func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 2216 /* .xProc */)) = file_control_test                // test1.c:8059:38:
	*(*func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 2240 /* .xProc */)) = file_control_lasterrno_test      // test1.c:8060:39:
	*(*func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 2264 /* .xProc */)) = file_control_lockproxy_test      // test1.c:8061:39:
	*(*func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 2288 /* .xProc */)) = file_control_chunksize_test      // test1.c:8062:39:
	*(*func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 2312 /* .xProc */)) = file_control_sizehint_test       // test1.c:8063:39:
	*(*func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 2336 /* .xProc */)) = file_control_data_version        // test1.c:8064:39:
	*(*func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 2360 /* .xProc */)) = file_control_persist_wal         // test1.c:8070:39:
	*(*func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 2384 /* .xProc */)) = file_control_powersafe_overwrite // test1.c:8071:43:
	*(*func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 2408 /* .xProc */)) = file_control_vfsname             // test1.c:8072:39:
	*(*func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 2432 /* .xProc */)) = file_control_tempfilename        // test1.c:8073:39:
	*(*func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 2456 /* .xProc */)) = vfs_list                         // test1.c:8074:38:
	*(*func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 2480 /* .xProc */)) = test_create_function_v2          // test1.c:8075:38:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 2504 /* .xProc */)) = test_errstr                         // test1.c:8084:35:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 2528 /* .xProc */)) = tcl_variable_type                   // test1.c:8085:35:
	*(*func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 2552 /* .xProc */)) = test_enable_shared               // test1.c:8087:39:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 2576 /* .xProc */)) = sqlite3BtreeSharedCacheReport       // test1.c:8088:39:
	*(*func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 2600 /* .xProc */)) = test_libversion_number           // test1.c:8090:37:
	*(*func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 2624 /* .xProc */)) = test_table_column_metadata       // test1.c:8091:41:
	*(*func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 2648 /* .xProc */)) = test_blob_reopen                 // test1.c:8093:31:
	*(*func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 2672 /* .xProc */)) = test_pcache_stats                // test1.c:8095:30:
	*(*func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 2696 /* .xProc */)) = test_unlock_notify               // test1.c:8097:33:
	*(*func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 2720 /* .xProc */)) = test_wal_checkpoint              // test1.c:8099:36:
	*(*func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 2744 /* .xProc */)) = test_wal_checkpoint_v2           // test1.c:8100:36:
	*(*func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 2768 /* .xProc */)) = test_wal_autocheckpoint          // test1.c:8101:37:
	*(*func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 2792 /* .xProc */)) = test_sqlite3_log                 // test1.c:8102:36:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 2816 /* .xProc */)) = test_print_eqp                      // test1.c:8104:36:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 2840 /* .xProc */)) = test_test_control                   // test1.c:8106:32:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 2864 /* .xProc */)) = test_getrusage                      // test1.c:8108:21:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 2888 /* .xProc */)) = tclLoadStaticExtensionCmd           // test1.c:8110:33:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 2912 /* .xProc */)) = sorter_test_fakeheap                // test1.c:8111:32:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 2936 /* .xProc */)) = sorter_test_sort4_helper            // test1.c:8112:36:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 2960 /* .xProc */)) = vfsCurrentTimeInt64                 // test1.c:8126:44:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 2984 /* .xProc */)) = test_delete_database                // test1.c:8137:35:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 3008 /* .xProc */)) = test_atomic_batch_write             // test1.c:8138:35:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 3032 /* .xProc */)) = test_mmap_warm                      // test1.c:8139:35:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 3056 /* .xProc */)) = test_config_sorterref               // test1.c:8140:36:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 3080 /* .xProc */)) = test_decode_hexdb                   // test1.c:8141:36:
	*(*func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd10)) + 8 /* .xProc */)) = test_intarray_create               // test_intarray.c:381:35:
	*(*func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd10)) + 32 /* .xProc */)) = test_intarray_bind                // test_intarray.c:382:33:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 8 /* .xProc */)) = test_malloc                           // test_malloc.c:1506:38:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 32 /* .xProc */)) = test_realloc                         // test_malloc.c:1507:38:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 56 /* .xProc */)) = test_free                            // test_malloc.c:1508:38:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 80 /* .xProc */)) = test_memset                          // test_malloc.c:1509:38:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 104 /* .xProc */)) = test_memget                         // test_malloc.c:1510:38:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 128 /* .xProc */)) = test_memory_used                    // test_malloc.c:1511:38:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 152 /* .xProc */)) = test_memory_highwater               // test_malloc.c:1512:38:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 176 /* .xProc */)) = test_memdebug_backtrace             // test_malloc.c:1513:38:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 200 /* .xProc */)) = test_memdebug_dump                  // test_malloc.c:1514:38:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 224 /* .xProc */)) = test_memdebug_fail                  // test_malloc.c:1515:38:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 248 /* .xProc */)) = test_memdebug_pending               // test_malloc.c:1516:38:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 272 /* .xProc */)) = test_memdebug_settitle              // test_malloc.c:1517:38:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 296 /* .xProc */)) = test_memdebug_malloc_count          // test_malloc.c:1518:41:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 320 /* .xProc */)) = test_memdebug_log                   // test_malloc.c:1519:38:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 344 /* .xProc */)) = test_config_pagecache               // test_malloc.c:1520:38:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 368 /* .xProc */)) = test_alt_pcache                     // test_malloc.c:1521:38:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 392 /* .xProc */)) = test_status                         // test_malloc.c:1522:38:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 416 /* .xProc */)) = test_db_status                      // test_malloc.c:1523:38:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 440 /* .xProc */)) = test_install_malloc_faultsim        // test_malloc.c:1524:38:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 464 /* .xProc */)) = test_config_heap                    // test_malloc.c:1525:38:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 488 /* .xProc */)) = test_config_heap_size               // test_malloc.c:1526:38:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 512 /* .xProc */)) = test_config_memstatus               // test_malloc.c:1527:38:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 536 /* .xProc */)) = test_config_lookaside               // test_malloc.c:1528:38:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 560 /* .xProc */)) = test_config_error                   // test_malloc.c:1529:38:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 584 /* .xProc */)) = test_config_uri                     // test_malloc.c:1530:38:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 608 /* .xProc */)) = test_config_cis                     // test_malloc.c:1531:38:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 632 /* .xProc */)) = test_config_pmasz                   // test_malloc.c:1532:38:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 656 /* .xProc */)) = test_db_config_lookaside            // test_malloc.c:1533:38:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 680 /* .xProc */)) = test_dump_memsys3                   // test_malloc.c:1534:38:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 704 /* .xProc */)) = test_dump_memsys3                   // test_malloc.c:1535:38:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 728 /* .xProc */)) = test_install_memsys3                // test_malloc.c:1536:38:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 752 /* .xProc */)) = test_vfs_oom_test                   // test_malloc.c:1537:41:
	*(*func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd12)) + 8 /* .xProc */)) = register_schema_module             // test_schema.c:336:34:
	*(*func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd13)) + 8 /* .xProc */)) = register_tclvar_module             // test_tclvar.c:553:36:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd14)) + 8 /* .xProc */)) = test_create_window                    // test_window.c:337:42:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd14)) + 32 /* .xProc */)) = test_create_window_misuse            // test_window.c:338:46:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd14)) + 56 /* .xProc */)) = test_create_sumint                   // test_window.c:339:30:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd14)) + 80 /* .xProc */)) = test_override_sum                    // test_window.c:340:29:
	*(*func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd2)) + 8 /* .xProc */)) = register_echo_module                // test8.c:1434:38:
	*(*func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd2)) + 32 /* .xProc */)) = declare_vtab                       // test8.c:1435:38:
	*(*func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd3)) + 8 /* .xProc */)) = c_misuse_test                       // test9.c:194:28:
	*(*func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd3)) + 32 /* .xProc */)) = c_realloc_test                     // test9.c:195:28:
	*(*func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd3)) + 56 /* .xProc */)) = c_collation_test                   // test9.c:196:28:
	*(*func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd4)) + 8 /* .xProc */)) = register_tcl_module                 // test_bestindex.c:611:33:
	*(*func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd5)) + 8 /* .xProc */)) = test_blob_open                      // test_blob.c:318:40:
	*(*func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd5)) + 24 /* .xProc */)) = test_blob_close                    // test_blob.c:319:40:
	*(*func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd5)) + 40 /* .xProc */)) = test_blob_bytes                    // test_blob.c:320:40:
	*(*func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd5)) + 56 /* .xProc */)) = test_blob_read                     // test_blob.c:321:40:
	*(*func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd5)) + 72 /* .xProc */)) = test_blob_write                    // test_blob.c:322:40:
	*(*func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd6)) + 8 /* .xProc */)) = register_fs_module                  // test_fs.c:908:32:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd7)) + 8 /* .xProc */)) = autoinstall_test_funcs                 // test_func.c:938:41:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd7)) + 24 /* .xProc */)) = abuse_create_function                 // test_func.c:939:41:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd7)) + 40 /* .xProc */)) = install_fts3_rank_function            // test_func.c:940:41:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd8)) + 8 /* .xProc */)) = hexio_read                             // test_hexio.c:451:40:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd8)) + 24 /* .xProc */)) = hexio_write                           // test_hexio.c:452:40:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd8)) + 40 /* .xProc */)) = hexio_get_int                         // test_hexio.c:453:40:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd8)) + 56 /* .xProc */)) = hexio_render_int16                    // test_hexio.c:454:40:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd8)) + 72 /* .xProc */)) = hexio_render_int32                    // test_hexio.c:455:40:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd8)) + 88 /* .xProc */)) = utf8_to_utf8                          // test_hexio.c:456:40:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd8)) + 104 /* .xProc */)) = read_fts3varint                      // test_hexio.c:457:40:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd8)) + 120 /* .xProc */)) = make_fts3record                      // test_hexio.c:458:40:
	*(*func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd9)) + 8 /* .xProc */)) = init_wrapper_install                // test_init.c:283:32:
	*(*func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd9)) + 24 /* .xProc */)) = init_wrapper_query                 // test_init.c:284:32:
	*(*func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd9)) + 40 /* .xProc */)) = init_wrapper_uninstall             // test_init.c:285:32:
	*(*func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd9)) + 56 /* .xProc */)) = init_wrapper_clear                 // test_init.c:286:32:
	*(*sqlite3_syscall_ptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 8 /* .xTest */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, int32, int32) int32
	}{ts_open})) // test_syscall.c:134:27:
	*(*sqlite3_syscall_ptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 40 /* .xTest */)) = *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, int32) int32 }{ts_close})) // test_syscall.c:135:27:
	*(*sqlite3_syscall_ptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 72 /* .xTest */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, int32) int32
	}{ts_access})) // test_syscall.c:136:27:
	*(*sqlite3_syscall_ptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 104 /* .xTest */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, size_t) uintptr
	}{ts_getcwd})) // test_syscall.c:137:27:
	*(*sqlite3_syscall_ptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 136 /* .xTest */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr) int32
	}{ts_stat})) // test_syscall.c:138:27:
	*(*sqlite3_syscall_ptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 168 /* .xTest */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, int32, uintptr) int32
	}{ts_fstat})) // test_syscall.c:139:27:
	*(*sqlite3_syscall_ptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 200 /* .xTest */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, int32, off_t) int32
	}{ts_ftruncate})) // test_syscall.c:140:27:
	*(*sqlite3_syscall_ptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 232 /* .xTest */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, int32, int32, uintptr) int32
	}{ts_fcntl})) // test_syscall.c:141:27:
	*(*sqlite3_syscall_ptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 264 /* .xTest */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, int32, uintptr, size_t) int32
	}{ts_read})) // test_syscall.c:142:27:
	*(*sqlite3_syscall_ptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 296 /* .xTest */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, int32, uintptr, size_t, off_t) int32
	}{ts_pread})) // test_syscall.c:143:27:
	*(*sqlite3_syscall_ptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 328 /* .xTest */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, int32, uintptr, size_t, sqlite3_uint64) int32
	}{ts_pread64})) // test_syscall.c:144:27:
	*(*sqlite3_syscall_ptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 360 /* .xTest */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, int32, uintptr, size_t) int32
	}{ts_write})) // test_syscall.c:145:27:
	*(*sqlite3_syscall_ptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 392 /* .xTest */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, int32, uintptr, size_t, off_t) int32
	}{ts_pwrite})) // test_syscall.c:146:27:
	*(*sqlite3_syscall_ptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 424 /* .xTest */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, int32, uintptr, size_t, sqlite3_uint64) int32
	}{ts_pwrite64})) // test_syscall.c:147:27:
	*(*sqlite3_syscall_ptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 456 /* .xTest */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, int32, mode_t) int32
	}{ts_fchmod})) // test_syscall.c:148:27:
	*(*sqlite3_syscall_ptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 488 /* .xTest */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, int32, off_t, off_t) int32
	}{ts_fallocate})) // test_syscall.c:149:27:
	*(*sqlite3_syscall_ptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 520 /* .xTest */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, size_t, int32, int32, int32, off_t) uintptr
	}{ts_mmap})) // test_syscall.c:150:27:
	*(*sqlite3_syscall_ptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 552 /* .xTest */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, size_t, size_t, int32, uintptr) uintptr
	}{ts_mremap})) // test_syscall.c:151:27:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&amatchModule)) + 8 /* .xCreate */)) = amatchConnect             // amatch.c:1456:3:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&amatchModule)) + 16 /* .xConnect */)) = amatchConnect           // amatch.c:1457:3:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&amatchModule)) + 24 /* .xBestIndex */)) = amatchBestIndex                                         // amatch.c:1458:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&amatchModule)) + 32 /* .xDisconnect */)) = amatchDisconnect                                                // amatch.c:1459:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&amatchModule)) + 40 /* .xDestroy */)) = amatchDisconnect                                                   // amatch.c:1460:3:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&amatchModule)) + 48 /* .xOpen */)) = amatchOpen                                                   // amatch.c:1461:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&amatchModule)) + 56 /* .xClose */)) = amatchClose                                                          // amatch.c:1462:3:
	*(*func(*crt.TLS, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&amatchModule)) + 64 /* .xFilter */)) = amatchFilter                        // amatch.c:1463:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&amatchModule)) + 72 /* .xNext */)) = amatchNext                                                            // amatch.c:1464:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&amatchModule)) + 80 /* .xEof */)) = amatchEof                                                              // amatch.c:1465:3:
	*(*func(*crt.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&amatchModule)) + 88 /* .xColumn */)) = amatchColumn                                        // amatch.c:1466:3:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&amatchModule)) + 96 /* .xRowid */)) = amatchRowid                                                 // amatch.c:1467:3:
	*(*func(*crt.TLS, uintptr, int32, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&amatchModule)) + 104 /* .xUpdate */)) = amatchUpdate                              // amatch.c:1468:3:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&carrayModule)) + 16 /* .xConnect */)) = carrayConnect           // carray.c:336:3:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&carrayModule)) + 24 /* .xBestIndex */)) = carrayBestIndex                                         // carray.c:337:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&carrayModule)) + 32 /* .xDisconnect */)) = carrayDisconnect                                                // carray.c:338:3:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&carrayModule)) + 48 /* .xOpen */)) = carrayOpen                                                   // carray.c:340:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&carrayModule)) + 56 /* .xClose */)) = carrayClose                                                          // carray.c:341:3:
	*(*func(*crt.TLS, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&carrayModule)) + 64 /* .xFilter */)) = carrayFilter                        // carray.c:342:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&carrayModule)) + 72 /* .xNext */)) = carrayNext                                                            // carray.c:343:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&carrayModule)) + 80 /* .xEof */)) = carrayEof                                                              // carray.c:344:3:
	*(*func(*crt.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&carrayModule)) + 88 /* .xColumn */)) = carrayColumn                                        // carray.c:345:3:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&carrayModule)) + 96 /* .xRowid */)) = carrayRowid                                                 // carray.c:346:3:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&closureModule)) + 8 /* .xCreate */)) = closureConnect           // closure.c:920:3:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&closureModule)) + 16 /* .xConnect */)) = closureConnect         // closure.c:921:3:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&closureModule)) + 24 /* .xBestIndex */)) = closureBestIndex                                       // closure.c:922:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&closureModule)) + 32 /* .xDisconnect */)) = closureDisconnect                                              // closure.c:923:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&closureModule)) + 40 /* .xDestroy */)) = closureDisconnect                                                 // closure.c:924:3:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&closureModule)) + 48 /* .xOpen */)) = closureOpen                                                 // closure.c:925:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&closureModule)) + 56 /* .xClose */)) = closureClose                                                        // closure.c:926:3:
	*(*func(*crt.TLS, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&closureModule)) + 64 /* .xFilter */)) = closureFilter                      // closure.c:927:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&closureModule)) + 72 /* .xNext */)) = closureNext                                                          // closure.c:928:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&closureModule)) + 80 /* .xEof */)) = closureEof                                                            // closure.c:929:3:
	*(*func(*crt.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&closureModule)) + 88 /* .xColumn */)) = closureColumn                                      // closure.c:930:3:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&closureModule)) + 96 /* .xRowid */)) = closureRowid                                               // closure.c:931:3:
	*(*func(*crt.TLS, uintptr, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&crashVfs)) + 40 /* .xOpen */)) = cfOpen                                  // test6.c:853:5:
	*(*func(*crt.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&crashVfs)) + 48 /* .xDelete */)) = cfDelete                                                // test6.c:854:5:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&crashVfs)) + 56 /* .xAccess */)) = cfAccess                                       // test6.c:855:5:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&crashVfs)) + 64 /* .xFullPathname */)) = cfFullPathname                           // test6.c:856:5:
	*(*func(*crt.TLS, uintptr, uintptr) uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&crashVfs)) + 72 /* .xDlOpen */)) = cfDlOpen                                                     // test6.c:857:5:
	*(*func(*crt.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&crashVfs)) + 80 /* .xDlError */)) = cfDlError                                                    // test6.c:858:5:
	*(*func(*crt.TLS, uintptr, uintptr, uintptr) uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&crashVfs)) + 88 /* .xDlSym */)) = cfDlSym                                              // test6.c:859:5:
	*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&crashVfs)) + 96 /* .xDlClose */)) = cfDlClose                                                           // test6.c:860:5:
	*(*func(*crt.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&crashVfs)) + 104 /* .xRandomness */)) = cfRandomness                                       // test6.c:861:5:
	*(*func(*crt.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&crashVfs)) + 112 /* .xSleep */)) = cfSleep                                                          // test6.c:862:5:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&crashVfs)) + 120 /* .xCurrentTime */)) = cfCurrentTime                                            // test6.c:863:5:
	*(*func(*crt.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&crashVfs)) + 128 /* .xGetLastError */)) = cfGetLastError                                   // test6.c:864:5:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&devsym_io_methods)) + 8 /* .xClose */)) = devsymClose                                                      // test_devsym.c:229:3:
	*(*func(*crt.TLS, uintptr, uintptr, int32, sqlite_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&devsym_io_methods)) + 16 /* .xRead */)) = devsymRead                         // test_devsym.c:230:3:
	*(*func(*crt.TLS, uintptr, uintptr, int32, sqlite_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&devsym_io_methods)) + 24 /* .xWrite */)) = devsymWrite                       // test_devsym.c:231:3:
	*(*func(*crt.TLS, uintptr, sqlite_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&devsym_io_methods)) + 32 /* .xTruncate */)) = devsymTruncate                                 // test_devsym.c:232:3:
	*(*func(*crt.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&devsym_io_methods)) + 40 /* .xSync */)) = devsymSync                                                // test_devsym.c:233:3:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&devsym_io_methods)) + 48 /* .xFileSize */)) = devsymFileSize                                      // test_devsym.c:234:3:
	*(*func(*crt.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&devsym_io_methods)) + 56 /* .xLock */)) = devsymLock                                                // test_devsym.c:235:3:
	*(*func(*crt.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&devsym_io_methods)) + 64 /* .xUnlock */)) = devsymUnlock                                            // test_devsym.c:236:3:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&devsym_io_methods)) + 72 /* .xCheckReservedLock */)) = devsymCheckReservedLock                    // test_devsym.c:237:3:
	*(*func(*crt.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&devsym_io_methods)) + 80 /* .xFileControl */)) = devsymFileControl                         // test_devsym.c:238:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&devsym_io_methods)) + 88 /* .xSectorSize */)) = devsymSectorSize                                           // test_devsym.c:239:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&devsym_io_methods)) + 96 /* .xDeviceCharacteristics */)) = devsymDeviceCharacteristics                     // test_devsym.c:240:3:
	*(*func(*crt.TLS, uintptr, int32, int32, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&devsym_io_methods)) + 104 /* .xShmMap */)) = devsymShmMap                    // test_devsym.c:241:3:
	*(*func(*crt.TLS, uintptr, int32, int32, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&devsym_io_methods)) + 112 /* .xShmLock */)) = devsymShmLock                           // test_devsym.c:242:3:
	*(*func(*crt.TLS, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&devsym_io_methods)) + 120 /* .xShmBarrier */)) = devsymShmBarrier                                                // test_devsym.c:243:3:
	*(*func(*crt.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&devsym_io_methods)) + 128 /* .xShmUnmap */)) = devsymShmUnmap                                       // test_devsym.c:244:3:
	*(*func(*crt.TLS, uintptr, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&devsym_vfs)) + 40 /* .xOpen */)) = devsymOpen                            // test_devsym.c:428:3:
	*(*func(*crt.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&devsym_vfs)) + 48 /* .xDelete */)) = devsymDelete                                          // test_devsym.c:429:3:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&devsym_vfs)) + 56 /* .xAccess */)) = devsymAccess                                 // test_devsym.c:430:3:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&devsym_vfs)) + 64 /* .xFullPathname */)) = devsymFullPathname                     // test_devsym.c:431:3:
	*(*func(*crt.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&devsym_vfs)) + 104 /* .xRandomness */)) = devsymRandomness                                 // test_devsym.c:443:3:
	*(*func(*crt.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&devsym_vfs)) + 112 /* .xSleep */)) = devsymSleep                                                    // test_devsym.c:444:3:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&devsym_vfs)) + 120 /* .xCurrentTime */)) = devsymCurrentTime                                      // test_devsym.c:445:3:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModule)) + 8 /* .xCreate */)) = echoCreate                  // test8.c:1301:3:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModule)) + 16 /* .xConnect */)) = echoConnect               // test8.c:1302:3:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModule)) + 24 /* .xBestIndex */)) = echoBestIndex                                             // test8.c:1303:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModule)) + 32 /* .xDisconnect */)) = echoDisconnect                                                    // test8.c:1304:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModule)) + 40 /* .xDestroy */)) = echoDestroy                                                          // test8.c:1305:3:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModule)) + 48 /* .xOpen */)) = echoOpen                                                       // test8.c:1306:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModule)) + 56 /* .xClose */)) = echoClose                                                              // test8.c:1307:3:
	*(*func(*crt.TLS, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModule)) + 64 /* .xFilter */)) = echoFilter                            // test8.c:1308:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModule)) + 72 /* .xNext */)) = echoNext                                                                // test8.c:1309:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModule)) + 80 /* .xEof */)) = echoEof                                                                  // test8.c:1310:3:
	*(*func(*crt.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModule)) + 88 /* .xColumn */)) = echoColumn                                            // test8.c:1311:3:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModule)) + 96 /* .xRowid */)) = echoRowid                                                     // test8.c:1312:3:
	*(*func(*crt.TLS, uintptr, int32, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModule)) + 104 /* .xUpdate */)) = echoUpdate                                  // test8.c:1313:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModule)) + 112 /* .xBegin */)) = echoBegin                                                             // test8.c:1314:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModule)) + 120 /* .xSync */)) = echoSync                                                               // test8.c:1315:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModule)) + 128 /* .xCommit */)) = echoCommit                                                           // test8.c:1316:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModule)) + 136 /* .xRollback */)) = echoRollback                                                       // test8.c:1317:3:
	*(*func(*crt.TLS, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModule)) + 144 /* .xFindFunction */)) = echoFindFunction             // test8.c:1318:3:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModule)) + 152 /* .xRename */)) = echoRename                                                  // test8.c:1319:3:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModuleV2)) + 8 /* .xCreate */)) = echoCreate                // test8.c:1324:3:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModuleV2)) + 16 /* .xConnect */)) = echoConnect             // test8.c:1325:3:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModuleV2)) + 24 /* .xBestIndex */)) = echoBestIndex                                           // test8.c:1326:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModuleV2)) + 32 /* .xDisconnect */)) = echoDisconnect                                                  // test8.c:1327:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModuleV2)) + 40 /* .xDestroy */)) = echoDestroy                                                        // test8.c:1328:3:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModuleV2)) + 48 /* .xOpen */)) = echoOpen                                                     // test8.c:1329:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModuleV2)) + 56 /* .xClose */)) = echoClose                                                            // test8.c:1330:3:
	*(*func(*crt.TLS, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModuleV2)) + 64 /* .xFilter */)) = echoFilter                          // test8.c:1331:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModuleV2)) + 72 /* .xNext */)) = echoNext                                                              // test8.c:1332:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModuleV2)) + 80 /* .xEof */)) = echoEof                                                                // test8.c:1333:3:
	*(*func(*crt.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModuleV2)) + 88 /* .xColumn */)) = echoColumn                                          // test8.c:1334:3:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModuleV2)) + 96 /* .xRowid */)) = echoRowid                                                   // test8.c:1335:3:
	*(*func(*crt.TLS, uintptr, int32, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModuleV2)) + 104 /* .xUpdate */)) = echoUpdate                                // test8.c:1336:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModuleV2)) + 112 /* .xBegin */)) = echoBegin                                                           // test8.c:1337:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModuleV2)) + 120 /* .xSync */)) = echoSync                                                             // test8.c:1338:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModuleV2)) + 128 /* .xCommit */)) = echoCommit                                                         // test8.c:1339:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModuleV2)) + 136 /* .xRollback */)) = echoRollback                                                     // test8.c:1340:3:
	*(*func(*crt.TLS, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModuleV2)) + 144 /* .xFindFunction */)) = echoFindFunction           // test8.c:1341:3:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModuleV2)) + 152 /* .xRename */)) = echoRename                                                // test8.c:1342:3:
	*(*func(*crt.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModuleV2)) + 160 /* .xSavepoint */)) = echoSavepoint                                            // test8.c:1343:3:
	*(*func(*crt.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModuleV2)) + 168 /* .xRelease */)) = echoRelease                                                // test8.c:1344:3:
	*(*func(*crt.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModuleV2)) + 176 /* .xRollbackTo */)) = echoRollbackTo                                          // test8.c:1345:3:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&expertModule)) + 8 /* .xCreate */)) = expertConnect             // sqlite3expert.c:625:5:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&expertModule)) + 16 /* .xConnect */)) = expertConnect           // sqlite3expert.c:626:5:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&expertModule)) + 24 /* .xBestIndex */)) = expertBestIndex                                         // sqlite3expert.c:627:5:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&expertModule)) + 32 /* .xDisconnect */)) = expertDisconnect                                                // sqlite3expert.c:628:5:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&expertModule)) + 40 /* .xDestroy */)) = expertDisconnect                                                   // sqlite3expert.c:629:5:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&expertModule)) + 48 /* .xOpen */)) = expertOpen                                                   // sqlite3expert.c:630:5:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&expertModule)) + 56 /* .xClose */)) = expertClose                                                          // sqlite3expert.c:631:5:
	*(*func(*crt.TLS, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&expertModule)) + 64 /* .xFilter */)) = expertFilter                        // sqlite3expert.c:632:5:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&expertModule)) + 72 /* .xNext */)) = expertNext                                                            // sqlite3expert.c:633:5:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&expertModule)) + 80 /* .xEof */)) = expertEof                                                              // sqlite3expert.c:634:5:
	*(*func(*crt.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&expertModule)) + 88 /* .xColumn */)) = expertColumn                                        // sqlite3expert.c:635:5:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&expertModule)) + 96 /* .xRowid */)) = expertRowid                                                 // sqlite3expert.c:636:5:
	*(*func(*crt.TLS, uintptr, int32, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&expertModule)) + 104 /* .xUpdate */)) = expertUpdate                              // sqlite3expert.c:637:5:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&explainModule)) + 16 /* .xConnect */)) = explainConnect         // explain.c:274:3:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&explainModule)) + 24 /* .xBestIndex */)) = explainBestIndex                                       // explain.c:275:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&explainModule)) + 32 /* .xDisconnect */)) = explainDisconnect                                              // explain.c:276:3:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&explainModule)) + 48 /* .xOpen */)) = explainOpen                                                 // explain.c:278:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&explainModule)) + 56 /* .xClose */)) = explainClose                                                        // explain.c:279:3:
	*(*func(*crt.TLS, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&explainModule)) + 64 /* .xFilter */)) = explainFilter                      // explain.c:280:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&explainModule)) + 72 /* .xNext */)) = explainNext                                                          // explain.c:281:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&explainModule)) + 80 /* .xEof */)) = explainEof                                                            // explain.c:282:3:
	*(*func(*crt.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&explainModule)) + 88 /* .xColumn */)) = explainColumn                                      // explain.c:283:3:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&explainModule)) + 96 /* .xRowid */)) = explainRowid                                               // explain.c:284:3:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsModule)) + 8 /* .xCreate */)) = fsConnect                     // test_fs.c:800:3:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsModule)) + 16 /* .xConnect */)) = fsConnect                   // test_fs.c:801:3:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsModule)) + 24 /* .xBestIndex */)) = fsBestIndex                                                 // test_fs.c:802:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsModule)) + 32 /* .xDisconnect */)) = fsDisconnect                                                        // test_fs.c:803:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsModule)) + 40 /* .xDestroy */)) = fsDisconnect                                                           // test_fs.c:804:3:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsModule)) + 48 /* .xOpen */)) = fsOpen                                                           // test_fs.c:805:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsModule)) + 56 /* .xClose */)) = fsClose                                                                  // test_fs.c:806:3:
	*(*func(*crt.TLS, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsModule)) + 64 /* .xFilter */)) = fsFilter                                // test_fs.c:807:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsModule)) + 72 /* .xNext */)) = fsNext                                                                    // test_fs.c:808:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsModule)) + 80 /* .xEof */)) = fsEof                                                                      // test_fs.c:809:3:
	*(*func(*crt.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsModule)) + 88 /* .xColumn */)) = fsColumn                                                // test_fs.c:810:3:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsModule)) + 96 /* .xRowid */)) = fsRowid                                                         // test_fs.c:811:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fs_io_methods)) + 8 /* .xClose */)) = fsClose1                                                             // test_onefile.c:210:3:
	*(*func(*crt.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fs_io_methods)) + 16 /* .xRead */)) = fsRead                                // test_onefile.c:211:3:
	*(*func(*crt.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fs_io_methods)) + 24 /* .xWrite */)) = fsWrite                              // test_onefile.c:212:3:
	*(*func(*crt.TLS, uintptr, sqlite3_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fs_io_methods)) + 32 /* .xTruncate */)) = fsTruncate                                        // test_onefile.c:213:3:
	*(*func(*crt.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fs_io_methods)) + 40 /* .xSync */)) = fsSync                                                        // test_onefile.c:214:3:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fs_io_methods)) + 48 /* .xFileSize */)) = fsFileSize                                              // test_onefile.c:215:3:
	*(*func(*crt.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fs_io_methods)) + 56 /* .xLock */)) = fsLock                                                        // test_onefile.c:216:3:
	*(*func(*crt.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fs_io_methods)) + 64 /* .xUnlock */)) = fsUnlock                                                    // test_onefile.c:217:3:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fs_io_methods)) + 72 /* .xCheckReservedLock */)) = fsCheckReservedLock                            // test_onefile.c:218:3:
	*(*func(*crt.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fs_io_methods)) + 80 /* .xFileControl */)) = fsFileControl                                 // test_onefile.c:219:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fs_io_methods)) + 88 /* .xSectorSize */)) = fsSectorSize                                                   // test_onefile.c:220:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fs_io_methods)) + 96 /* .xDeviceCharacteristics */)) = fsDeviceCharacteristics                             // test_onefile.c:221:3:
	*(*func(*crt.TLS, uintptr, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fs_vfs)) + 40 /* .xOpen */)) = fsOpen1                                   // test_onefile.c:191:5:
	*(*func(*crt.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fs_vfs)) + 48 /* .xDelete */)) = fsDelete                                                  // test_onefile.c:192:5:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fs_vfs)) + 56 /* .xAccess */)) = fsAccess                                         // test_onefile.c:193:5:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fs_vfs)) + 64 /* .xFullPathname */)) = fsFullPathname                             // test_onefile.c:194:5:
	*(*func(*crt.TLS, uintptr, uintptr) uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&fs_vfs)) + 72 /* .xDlOpen */)) = fsDlOpen                                                       // test_onefile.c:195:5:
	*(*func(*crt.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&fs_vfs)) + 80 /* .xDlError */)) = fsDlError                                                      // test_onefile.c:196:5:
	*(*func(*crt.TLS, uintptr, uintptr, uintptr) uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&fs_vfs)) + 88 /* .xDlSym */)) = fsDlSym                                                // test_onefile.c:197:5:
	*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&fs_vfs)) + 96 /* .xDlClose */)) = fsDlClose                                                             // test_onefile.c:198:5:
	*(*func(*crt.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fs_vfs)) + 104 /* .xRandomness */)) = fsRandomness                                         // test_onefile.c:199:5:
	*(*func(*crt.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fs_vfs)) + 112 /* .xSleep */)) = fsSleep                                                            // test_onefile.c:200:5:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fs_vfs)) + 120 /* .xCurrentTime */)) = fsCurrentTime                                              // test_onefile.c:201:5:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsdirModule)) + 8 /* .xCreate */)) = fsdirConnect1              // test_fs.c:823:3:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsdirModule)) + 16 /* .xConnect */)) = fsdirConnect1            // test_fs.c:824:3:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsdirModule)) + 24 /* .xBestIndex */)) = fsdirBestIndex1                                          // test_fs.c:825:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsdirModule)) + 32 /* .xDisconnect */)) = fsdirDisconnect1                                                 // test_fs.c:826:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsdirModule)) + 40 /* .xDestroy */)) = fsdirDisconnect1                                                    // test_fs.c:827:3:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsdirModule)) + 48 /* .xOpen */)) = fsdirOpen1                                                    // test_fs.c:828:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsdirModule)) + 56 /* .xClose */)) = fsdirClose1                                                           // test_fs.c:829:3:
	*(*func(*crt.TLS, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsdirModule)) + 64 /* .xFilter */)) = fsdirFilter1                         // test_fs.c:830:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsdirModule)) + 72 /* .xNext */)) = fsdirNext1                                                             // test_fs.c:831:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsdirModule)) + 80 /* .xEof */)) = fsdirEof1                                                               // test_fs.c:832:3:
	*(*func(*crt.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsdirModule)) + 88 /* .xColumn */)) = fsdirColumn1                                         // test_fs.c:833:3:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsdirModule)) + 96 /* .xRowid */)) = fsdirRowid1                                                  // test_fs.c:834:3:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsdirModule1)) + 16 /* .xConnect */)) = fsdirConnect            // fileio.c:942:5:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsdirModule1)) + 24 /* .xBestIndex */)) = fsdirBestIndex                                          // fileio.c:943:5:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsdirModule1)) + 32 /* .xDisconnect */)) = fsdirDisconnect                                                 // fileio.c:944:5:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsdirModule1)) + 48 /* .xOpen */)) = fsdirOpen                                                    // fileio.c:946:5:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsdirModule1)) + 56 /* .xClose */)) = fsdirClose                                                           // fileio.c:947:5:
	*(*func(*crt.TLS, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsdirModule1)) + 64 /* .xFilter */)) = fsdirFilter                         // fileio.c:948:5:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsdirModule1)) + 72 /* .xNext */)) = fsdirNext                                                             // fileio.c:949:5:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsdirModule1)) + 80 /* .xEof */)) = fsdirEof                                                               // fileio.c:950:5:
	*(*func(*crt.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsdirModule1)) + 88 /* .xColumn */)) = fsdirColumn                                         // fileio.c:951:5:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsdirModule1)) + 96 /* .xRowid */)) = fsdirRowid                                                  // fileio.c:952:5:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fstreeModule)) + 8 /* .xCreate */)) = fstreeConnect             // test_fs.c:846:3:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fstreeModule)) + 16 /* .xConnect */)) = fstreeConnect           // test_fs.c:847:3:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fstreeModule)) + 24 /* .xBestIndex */)) = fstreeBestIndex                                         // test_fs.c:848:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fstreeModule)) + 32 /* .xDisconnect */)) = fstreeDisconnect                                                // test_fs.c:849:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fstreeModule)) + 40 /* .xDestroy */)) = fstreeDisconnect                                                   // test_fs.c:850:3:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fstreeModule)) + 48 /* .xOpen */)) = fstreeOpen                                                   // test_fs.c:851:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fstreeModule)) + 56 /* .xClose */)) = fstreeClose                                                          // test_fs.c:852:3:
	*(*func(*crt.TLS, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fstreeModule)) + 64 /* .xFilter */)) = fstreeFilter                        // test_fs.c:853:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fstreeModule)) + 72 /* .xNext */)) = fstreeNext                                                            // test_fs.c:854:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fstreeModule)) + 80 /* .xEof */)) = fstreeEof                                                              // test_fs.c:855:3:
	*(*func(*crt.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fstreeModule)) + 88 /* .xColumn */)) = fstreeColumn                                        // test_fs.c:856:3:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fstreeModule)) + 96 /* .xRowid */)) = fstreeRowid                                                 // test_fs.c:857:3:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fuzzerModule)) + 8 /* .xCreate */)) = fuzzerConnect             // fuzzer.c:1149:3:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fuzzerModule)) + 16 /* .xConnect */)) = fuzzerConnect           // fuzzer.c:1150:3:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fuzzerModule)) + 24 /* .xBestIndex */)) = fuzzerBestIndex                                         // fuzzer.c:1151:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fuzzerModule)) + 32 /* .xDisconnect */)) = fuzzerDisconnect                                                // fuzzer.c:1152:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fuzzerModule)) + 40 /* .xDestroy */)) = fuzzerDisconnect                                                   // fuzzer.c:1153:3:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fuzzerModule)) + 48 /* .xOpen */)) = fuzzerOpen                                                   // fuzzer.c:1154:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fuzzerModule)) + 56 /* .xClose */)) = fuzzerClose                                                          // fuzzer.c:1155:3:
	*(*func(*crt.TLS, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fuzzerModule)) + 64 /* .xFilter */)) = fuzzerFilter                        // fuzzer.c:1156:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fuzzerModule)) + 72 /* .xNext */)) = fuzzerNext                                                            // fuzzer.c:1157:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fuzzerModule)) + 80 /* .xEof */)) = fuzzerEof                                                              // fuzzer.c:1158:3:
	*(*func(*crt.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fuzzerModule)) + 88 /* .xColumn */)) = fuzzerColumn                                        // fuzzer.c:1159:3:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fuzzerModule)) + 96 /* .xRowid */)) = fuzzerRowid                                                 // fuzzer.c:1160:3:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&intarrayModule)) + 8 /* .xCreate */)) = intarrayCreate          // test_intarray.c:189:3:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&intarrayModule)) + 16 /* .xConnect */)) = intarrayCreate        // test_intarray.c:190:3:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&intarrayModule)) + 24 /* .xBestIndex */)) = intarrayBestIndex                                     // test_intarray.c:191:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&intarrayModule)) + 32 /* .xDisconnect */)) = intarrayDestroy                                               // test_intarray.c:192:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&intarrayModule)) + 40 /* .xDestroy */)) = intarrayDestroy                                                  // test_intarray.c:193:3:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&intarrayModule)) + 48 /* .xOpen */)) = intarrayOpen                                               // test_intarray.c:194:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&intarrayModule)) + 56 /* .xClose */)) = intarrayClose                                                      // test_intarray.c:195:3:
	*(*func(*crt.TLS, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&intarrayModule)) + 64 /* .xFilter */)) = intarrayFilter                    // test_intarray.c:196:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&intarrayModule)) + 72 /* .xNext */)) = intarrayNext                                                        // test_intarray.c:197:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&intarrayModule)) + 80 /* .xEof */)) = intarrayEof                                                          // test_intarray.c:198:3:
	*(*func(*crt.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&intarrayModule)) + 88 /* .xColumn */)) = intarrayColumn                                    // test_intarray.c:199:3:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&intarrayModule)) + 96 /* .xRowid */)) = intarrayRowid                                             // test_intarray.c:200:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&jt_io_methods)) + 8 /* .xClose */)) = jtClose                                                              // test_journal.c:189:3:
	*(*func(*crt.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&jt_io_methods)) + 16 /* .xRead */)) = jtRead                                // test_journal.c:190:3:
	*(*func(*crt.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&jt_io_methods)) + 24 /* .xWrite */)) = jtWrite                              // test_journal.c:191:3:
	*(*func(*crt.TLS, uintptr, sqlite3_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&jt_io_methods)) + 32 /* .xTruncate */)) = jtTruncate                                        // test_journal.c:192:3:
	*(*func(*crt.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&jt_io_methods)) + 40 /* .xSync */)) = jtSync                                                        // test_journal.c:193:3:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&jt_io_methods)) + 48 /* .xFileSize */)) = jtFileSize                                              // test_journal.c:194:3:
	*(*func(*crt.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&jt_io_methods)) + 56 /* .xLock */)) = jtLock                                                        // test_journal.c:195:3:
	*(*func(*crt.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&jt_io_methods)) + 64 /* .xUnlock */)) = jtUnlock                                                    // test_journal.c:196:3:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&jt_io_methods)) + 72 /* .xCheckReservedLock */)) = jtCheckReservedLock                            // test_journal.c:197:3:
	*(*func(*crt.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&jt_io_methods)) + 80 /* .xFileControl */)) = jtFileControl                                 // test_journal.c:198:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&jt_io_methods)) + 88 /* .xSectorSize */)) = jtSectorSize                                                   // test_journal.c:199:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&jt_io_methods)) + 96 /* .xDeviceCharacteristics */)) = jtDeviceCharacteristics                             // test_journal.c:200:3:
	*(*func(*crt.TLS, uintptr, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&jt_vfs)) + 40 /* .xOpen */)) = jtOpen                                    // test_journal.c:172:3:
	*(*func(*crt.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&jt_vfs)) + 48 /* .xDelete */)) = jtDelete                                                  // test_journal.c:173:3:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&jt_vfs)) + 56 /* .xAccess */)) = jtAccess                                         // test_journal.c:174:3:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&jt_vfs)) + 64 /* .xFullPathname */)) = jtFullPathname                             // test_journal.c:175:3:
	*(*func(*crt.TLS, uintptr, uintptr) uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&jt_vfs)) + 72 /* .xDlOpen */)) = jtDlOpen                                                       // test_journal.c:176:3:
	*(*func(*crt.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&jt_vfs)) + 80 /* .xDlError */)) = jtDlError                                                      // test_journal.c:177:3:
	*(*func(*crt.TLS, uintptr, uintptr, uintptr) uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&jt_vfs)) + 88 /* .xDlSym */)) = jtDlSym                                                // test_journal.c:178:3:
	*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&jt_vfs)) + 96 /* .xDlClose */)) = jtDlClose                                                             // test_journal.c:179:3:
	*(*func(*crt.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&jt_vfs)) + 104 /* .xRandomness */)) = jtRandomness                                         // test_journal.c:180:3:
	*(*func(*crt.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&jt_vfs)) + 112 /* .xSleep */)) = jtSleep                                                            // test_journal.c:181:3:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&jt_vfs)) + 120 /* .xCurrentTime */)) = jtCurrentTime                                              // test_journal.c:182:3:
	*(*func(*crt.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&jt_vfs)) + 128 /* .xGetLastError */)) = jtGetLastError                                     // test_journal.c:183:3:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&jt_vfs)) + 136 /* .xCurrentTimeInt64 */)) = jtCurrentTimeInt64                                    // test_journal.c:184:3:
	*(*func(*crt.TLS, int32) uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&m)) + 0 /* .xMalloc */)) = faultsimMalloc                                                                  // test_malloc.c:208:5:
	*(*func(*crt.TLS, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&m)) + 8 /* .xFree */)) = faultsimFree                                                                            // test_malloc.c:209:5:
	*(*func(*crt.TLS, uintptr, int32) uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&m)) + 16 /* .xRealloc */)) = faultsimRealloc                                                      // test_malloc.c:210:5:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&m)) + 24 /* .xSize */)) = faultsimSize                                                                     // test_malloc.c:211:5:
	*(*func(*crt.TLS, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&m)) + 32 /* .xRoundup */)) = faultsimRoundup                                                                 // test_malloc.c:212:5:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&m)) + 40 /* .xInit */)) = faultsimInit                                                                     // test_malloc.c:213:5:
	*(*func(*crt.TLS, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&m)) + 48 /* .xShutdown */)) = faultsimShutdown                                                                   // test_malloc.c:214:5:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&prefixesModule)) + 16 /* .xConnect */)) = prefixesConnect       // prefixes.c:230:21:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&prefixesModule)) + 24 /* .xBestIndex */)) = prefixesBestIndex                                     // prefixes.c:231:21:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&prefixesModule)) + 32 /* .xDisconnect */)) = prefixesDisconnect                                            // prefixes.c:232:21:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&prefixesModule)) + 48 /* .xOpen */)) = prefixesOpen                                               // prefixes.c:234:21:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&prefixesModule)) + 56 /* .xClose */)) = prefixesClose                                                      // prefixes.c:235:21:
	*(*func(*crt.TLS, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&prefixesModule)) + 64 /* .xFilter */)) = prefixesFilter                    // prefixes.c:236:21:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&prefixesModule)) + 72 /* .xNext */)) = prefixesNext                                                        // prefixes.c:237:21:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&prefixesModule)) + 80 /* .xEof */)) = prefixesEof                                                          // prefixes.c:238:21:
	*(*func(*crt.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&prefixesModule)) + 88 /* .xColumn */)) = prefixesColumn                                    // prefixes.c:239:21:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&prefixesModule)) + 96 /* .xRowid */)) = prefixesRowid                                             // prefixes.c:240:21:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&rbuvfs_io_methods)) + 8 /* .xClose */)) = rbuVfsClose                                                      // sqlite3rbu.c:4951:5:
	*(*func(*crt.TLS, uintptr, uintptr, int32, sqlite_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&rbuvfs_io_methods)) + 16 /* .xRead */)) = rbuVfsRead                         // sqlite3rbu.c:4952:5:
	*(*func(*crt.TLS, uintptr, uintptr, int32, sqlite_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&rbuvfs_io_methods)) + 24 /* .xWrite */)) = rbuVfsWrite                       // sqlite3rbu.c:4953:5:
	*(*func(*crt.TLS, uintptr, sqlite_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&rbuvfs_io_methods)) + 32 /* .xTruncate */)) = rbuVfsTruncate                                 // sqlite3rbu.c:4954:5:
	*(*func(*crt.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&rbuvfs_io_methods)) + 40 /* .xSync */)) = rbuVfsSync                                                // sqlite3rbu.c:4955:5:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&rbuvfs_io_methods)) + 48 /* .xFileSize */)) = rbuVfsFileSize                                      // sqlite3rbu.c:4956:5:
	*(*func(*crt.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&rbuvfs_io_methods)) + 56 /* .xLock */)) = rbuVfsLock                                                // sqlite3rbu.c:4957:5:
	*(*func(*crt.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&rbuvfs_io_methods)) + 64 /* .xUnlock */)) = rbuVfsUnlock                                            // sqlite3rbu.c:4958:5:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&rbuvfs_io_methods)) + 72 /* .xCheckReservedLock */)) = rbuVfsCheckReservedLock                    // sqlite3rbu.c:4959:5:
	*(*func(*crt.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&rbuvfs_io_methods)) + 80 /* .xFileControl */)) = rbuVfsFileControl                         // sqlite3rbu.c:4960:5:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&rbuvfs_io_methods)) + 88 /* .xSectorSize */)) = rbuVfsSectorSize                                           // sqlite3rbu.c:4961:5:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&rbuvfs_io_methods)) + 96 /* .xDeviceCharacteristics */)) = rbuVfsDeviceCharacteristics                     // sqlite3rbu.c:4962:5:
	*(*func(*crt.TLS, uintptr, int32, int32, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&rbuvfs_io_methods)) + 104 /* .xShmMap */)) = rbuVfsShmMap                    // sqlite3rbu.c:4963:5:
	*(*func(*crt.TLS, uintptr, int32, int32, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&rbuvfs_io_methods)) + 112 /* .xShmLock */)) = rbuVfsShmLock                           // sqlite3rbu.c:4964:5:
	*(*func(*crt.TLS, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&rbuvfs_io_methods)) + 120 /* .xShmBarrier */)) = rbuVfsShmBarrier                                                // sqlite3rbu.c:4965:5:
	*(*func(*crt.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&rbuvfs_io_methods)) + 128 /* .xShmUnmap */)) = rbuVfsShmUnmap                                       // sqlite3rbu.c:4966:5:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&schemaModule)) + 8 /* .xCreate */)) = schemaCreate              // test_schema.c:276:3:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&schemaModule)) + 16 /* .xConnect */)) = schemaCreate            // test_schema.c:277:3:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&schemaModule)) + 24 /* .xBestIndex */)) = schemaBestIndex                                         // test_schema.c:278:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&schemaModule)) + 32 /* .xDisconnect */)) = schemaDestroy                                                   // test_schema.c:279:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&schemaModule)) + 40 /* .xDestroy */)) = schemaDestroy                                                      // test_schema.c:280:3:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&schemaModule)) + 48 /* .xOpen */)) = schemaOpen                                                   // test_schema.c:281:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&schemaModule)) + 56 /* .xClose */)) = schemaClose                                                          // test_schema.c:282:3:
	*(*func(*crt.TLS, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&schemaModule)) + 64 /* .xFilter */)) = schemaFilter                        // test_schema.c:283:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&schemaModule)) + 72 /* .xNext */)) = schemaNext                                                            // test_schema.c:284:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&schemaModule)) + 80 /* .xEof */)) = schemaEof                                                              // test_schema.c:285:3:
	*(*func(*crt.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&schemaModule)) + 88 /* .xColumn */)) = schemaColumn                                        // test_schema.c:286:3:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&schemaModule)) + 96 /* .xRowid */)) = schemaRowid                                                 // test_schema.c:287:3:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&seriesModule)) + 16 /* .xConnect */)) = seriesConnect           // series.c:383:3:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&seriesModule)) + 24 /* .xBestIndex */)) = seriesBestIndex                                         // series.c:384:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&seriesModule)) + 32 /* .xDisconnect */)) = seriesDisconnect                                                // series.c:385:3:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&seriesModule)) + 48 /* .xOpen */)) = seriesOpen                                                   // series.c:387:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&seriesModule)) + 56 /* .xClose */)) = seriesClose                                                          // series.c:388:3:
	*(*func(*crt.TLS, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&seriesModule)) + 64 /* .xFilter */)) = seriesFilter                        // series.c:389:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&seriesModule)) + 72 /* .xNext */)) = seriesNext                                                            // series.c:390:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&seriesModule)) + 80 /* .xEof */)) = seriesEof                                                              // series.c:391:3:
	*(*func(*crt.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&seriesModule)) + 88 /* .xColumn */)) = seriesColumn                                        // series.c:392:3:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&seriesModule)) + 96 /* .xRowid */)) = seriesRowid                                                 // series.c:393:3:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&spellfix1Module)) + 8 /* .xCreate */)) = spellfix1Create        // spellfix.c:2993:3:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&spellfix1Module)) + 16 /* .xConnect */)) = spellfix1Connect     // spellfix.c:2994:3:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&spellfix1Module)) + 24 /* .xBestIndex */)) = spellfix1BestIndex                                   // spellfix.c:2995:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&spellfix1Module)) + 32 /* .xDisconnect */)) = spellfix1Disconnect                                          // spellfix.c:2996:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&spellfix1Module)) + 40 /* .xDestroy */)) = spellfix1Destroy                                                // spellfix.c:2997:3:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&spellfix1Module)) + 48 /* .xOpen */)) = spellfix1Open                                             // spellfix.c:2998:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&spellfix1Module)) + 56 /* .xClose */)) = spellfix1Close                                                    // spellfix.c:2999:3:
	*(*func(*crt.TLS, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&spellfix1Module)) + 64 /* .xFilter */)) = spellfix1Filter                  // spellfix.c:3000:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&spellfix1Module)) + 72 /* .xNext */)) = spellfix1Next                                                      // spellfix.c:3001:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&spellfix1Module)) + 80 /* .xEof */)) = spellfix1Eof                                                        // spellfix.c:3002:3:
	*(*func(*crt.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&spellfix1Module)) + 88 /* .xColumn */)) = spellfix1Column                                  // spellfix.c:3003:3:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&spellfix1Module)) + 96 /* .xRowid */)) = spellfix1Rowid                                           // spellfix.c:3004:3:
	*(*func(*crt.TLS, uintptr, int32, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&spellfix1Module)) + 104 /* .xUpdate */)) = spellfix1Update                        // spellfix.c:3005:3:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&spellfix1Module)) + 152 /* .xRename */)) = spellfix1Rename                                        // spellfix.c:3011:3:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tclModule)) + 8 /* .xCreate */)) = tclConnect                   // test_bestindex.c:551:3:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tclModule)) + 16 /* .xConnect */)) = tclConnect                 // test_bestindex.c:552:3:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tclModule)) + 24 /* .xBestIndex */)) = tclBestIndex                                               // test_bestindex.c:553:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tclModule)) + 32 /* .xDisconnect */)) = tclDisconnect                                                      // test_bestindex.c:554:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tclModule)) + 40 /* .xDestroy */)) = tclDisconnect                                                         // test_bestindex.c:555:3:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tclModule)) + 48 /* .xOpen */)) = tclOpen                                                         // test_bestindex.c:556:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tclModule)) + 56 /* .xClose */)) = tclClose                                                                // test_bestindex.c:557:3:
	*(*func(*crt.TLS, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tclModule)) + 64 /* .xFilter */)) = tclFilter                              // test_bestindex.c:558:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tclModule)) + 72 /* .xNext */)) = tclNext                                                                  // test_bestindex.c:559:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tclModule)) + 80 /* .xEof */)) = tclEof                                                                    // test_bestindex.c:560:3:
	*(*func(*crt.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tclModule)) + 88 /* .xColumn */)) = tclColumn                                              // test_bestindex.c:561:3:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tclModule)) + 96 /* .xRowid */)) = tclRowid                                                       // test_bestindex.c:562:3:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tclvarModule)) + 8 /* .xCreate */)) = tclvarConnect             // test_tclvar.c:471:3:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tclvarModule)) + 16 /* .xConnect */)) = tclvarConnect           // test_tclvar.c:472:3:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tclvarModule)) + 24 /* .xBestIndex */)) = tclvarBestIndex                                         // test_tclvar.c:473:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tclvarModule)) + 32 /* .xDisconnect */)) = tclvarDisconnect                                                // test_tclvar.c:474:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tclvarModule)) + 40 /* .xDestroy */)) = tclvarDisconnect                                                   // test_tclvar.c:475:3:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tclvarModule)) + 48 /* .xOpen */)) = tclvarOpen                                                   // test_tclvar.c:476:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tclvarModule)) + 56 /* .xClose */)) = tclvarClose                                                          // test_tclvar.c:477:3:
	*(*func(*crt.TLS, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tclvarModule)) + 64 /* .xFilter */)) = tclvarFilter                        // test_tclvar.c:478:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tclvarModule)) + 72 /* .xNext */)) = tclvarNext                                                            // test_tclvar.c:479:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tclvarModule)) + 80 /* .xEof */)) = tclvarEof                                                              // test_tclvar.c:480:3:
	*(*func(*crt.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tclvarModule)) + 88 /* .xColumn */)) = tclvarColumn                                        // test_tclvar.c:481:3:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tclvarModule)) + 96 /* .xRowid */)) = tclvarRowid                                                 // test_tclvar.c:482:3:
	*(*func(*crt.TLS, uintptr, int32, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tclvarModule)) + 104 /* .xUpdate */)) = tclvarUpdate                              // test_tclvar.c:483:3:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&testPcache)) + 8 /* .pArg */)) = uintptr(unsafe.Pointer(&testpcacheGlobal))                                                      // test_pcache.c:435:5:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&testPcache)) + 16 /* .xInit */)) = testpcacheInit                                                          // test_pcache.c:436:5:
	*(*func(*crt.TLS, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&testPcache)) + 24 /* .xShutdown */)) = testpcacheShutdown                                                        // test_pcache.c:437:5:
	*(*func(*crt.TLS, int32, int32, int32) uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&testPcache)) + 32 /* .xCreate */)) = testpcacheCreate                                        // test_pcache.c:438:5:
	*(*func(*crt.TLS, uintptr, int32))(unsafe.Pointer(uintptr(unsafe.Pointer(&testPcache)) + 40 /* .xCachesize */)) = testpcacheCachesize                                               // test_pcache.c:439:5:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&testPcache)) + 48 /* .xPagecount */)) = testpcachePagecount                                                // test_pcache.c:440:5:
	*(*func(*crt.TLS, uintptr, uint32, int32) uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&testPcache)) + 56 /* .xFetch */)) = testpcacheFetch                                       // test_pcache.c:441:5:
	*(*func(*crt.TLS, uintptr, uintptr, int32))(unsafe.Pointer(uintptr(unsafe.Pointer(&testPcache)) + 64 /* .xUnpin */)) = testpcacheUnpin                                              // test_pcache.c:442:5:
	*(*func(*crt.TLS, uintptr, uintptr, uint32, uint32))(unsafe.Pointer(uintptr(unsafe.Pointer(&testPcache)) + 72 /* .xRekey */)) = testpcacheRekey                                     // test_pcache.c:443:5:
	*(*func(*crt.TLS, uintptr, uint32))(unsafe.Pointer(uintptr(unsafe.Pointer(&testPcache)) + 80 /* .xTruncate */)) = testpcacheTruncate                                                // test_pcache.c:444:5:
	*(*func(*crt.TLS, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&testPcache)) + 88 /* .xDestroy */)) = testpcacheDestroy                                                          // test_pcache.c:445:5:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tmp_io_methods)) + 8 /* .xClose */)) = tmpClose                                                            // test_onefile.c:231:3:
	*(*func(*crt.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tmp_io_methods)) + 16 /* .xRead */)) = tmpRead                              // test_onefile.c:232:3:
	*(*func(*crt.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tmp_io_methods)) + 24 /* .xWrite */)) = tmpWrite                            // test_onefile.c:233:3:
	*(*func(*crt.TLS, uintptr, sqlite3_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tmp_io_methods)) + 32 /* .xTruncate */)) = tmpTruncate                                      // test_onefile.c:234:3:
	*(*func(*crt.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tmp_io_methods)) + 40 /* .xSync */)) = tmpSync                                                      // test_onefile.c:235:3:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tmp_io_methods)) + 48 /* .xFileSize */)) = tmpFileSize                                            // test_onefile.c:236:3:
	*(*func(*crt.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tmp_io_methods)) + 56 /* .xLock */)) = tmpLock                                                      // test_onefile.c:237:3:
	*(*func(*crt.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tmp_io_methods)) + 64 /* .xUnlock */)) = tmpUnlock                                                  // test_onefile.c:238:3:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tmp_io_methods)) + 72 /* .xCheckReservedLock */)) = tmpCheckReservedLock                          // test_onefile.c:239:3:
	*(*func(*crt.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tmp_io_methods)) + 80 /* .xFileControl */)) = tmpFileControl                               // test_onefile.c:240:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tmp_io_methods)) + 88 /* .xSectorSize */)) = tmpSectorSize                                                 // test_onefile.c:241:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tmp_io_methods)) + 96 /* .xDeviceCharacteristics */)) = tmpDeviceCharacteristics                           // test_onefile.c:242:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tvfs_io_methods)) + 8 /* .xClose */)) = tvfsClose                                                          // test_vfs.c:206:3:
	*(*func(*crt.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tvfs_io_methods)) + 16 /* .xRead */)) = tvfsRead                            // test_vfs.c:207:3:
	*(*func(*crt.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tvfs_io_methods)) + 24 /* .xWrite */)) = tvfsWrite                          // test_vfs.c:208:3:
	*(*func(*crt.TLS, uintptr, sqlite3_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tvfs_io_methods)) + 32 /* .xTruncate */)) = tvfsTruncate                                    // test_vfs.c:209:3:
	*(*func(*crt.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tvfs_io_methods)) + 40 /* .xSync */)) = tvfsSync                                                    // test_vfs.c:210:3:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tvfs_io_methods)) + 48 /* .xFileSize */)) = tvfsFileSize                                          // test_vfs.c:211:3:
	*(*func(*crt.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tvfs_io_methods)) + 56 /* .xLock */)) = tvfsLock                                                    // test_vfs.c:212:3:
	*(*func(*crt.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tvfs_io_methods)) + 64 /* .xUnlock */)) = tvfsUnlock                                                // test_vfs.c:213:3:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tvfs_io_methods)) + 72 /* .xCheckReservedLock */)) = tvfsCheckReservedLock                        // test_vfs.c:214:3:
	*(*func(*crt.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tvfs_io_methods)) + 80 /* .xFileControl */)) = tvfsFileControl                             // test_vfs.c:215:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tvfs_io_methods)) + 88 /* .xSectorSize */)) = tvfsSectorSize                                               // test_vfs.c:216:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tvfs_io_methods)) + 96 /* .xDeviceCharacteristics */)) = tvfsDeviceCharacteristics                         // test_vfs.c:217:3:
	*(*func(*crt.TLS, uintptr, int32, int32, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tvfs_io_methods)) + 104 /* .xShmMap */)) = tvfsShmMap                        // test_vfs.c:218:3:
	*(*func(*crt.TLS, uintptr, int32, int32, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tvfs_io_methods)) + 112 /* .xShmLock */)) = tvfsShmLock                               // test_vfs.c:219:3:
	*(*func(*crt.TLS, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&tvfs_io_methods)) + 120 /* .xShmBarrier */)) = tvfsShmBarrier                                                    // test_vfs.c:220:3:
	*(*func(*crt.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tvfs_io_methods)) + 128 /* .xShmUnmap */)) = tvfsShmUnmap                                           // test_vfs.c:221:3:
	*(*func(*crt.TLS, uintptr, sqlite3_int64, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tvfs_io_methods)) + 136 /* .xFetch */)) = tvfsFetch                         // test_vfs.c:222:3:
	*(*func(*crt.TLS, uintptr, sqlite3_int64, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tvfs_io_methods)) + 144 /* .xUnfetch */)) = tvfsUnfetch                            // test_vfs.c:223:3:
	*(*func(*crt.TLS, uintptr, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tvfs_vfs)) + 40 /* .xOpen */)) = tvfsOpen                                // test_vfs.c:1447:5:
	*(*func(*crt.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tvfs_vfs)) + 48 /* .xDelete */)) = tvfsDelete                                              // test_vfs.c:1448:5:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tvfs_vfs)) + 56 /* .xAccess */)) = tvfsAccess                                     // test_vfs.c:1449:5:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tvfs_vfs)) + 64 /* .xFullPathname */)) = tvfsFullPathname                         // test_vfs.c:1450:5:
	*(*func(*crt.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tvfs_vfs)) + 104 /* .xRandomness */)) = tvfsRandomness                                     // test_vfs.c:1462:5:
	*(*func(*crt.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tvfs_vfs)) + 112 /* .xSleep */)) = tvfsSleep                                                        // test_vfs.c:1463:5:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tvfs_vfs)) + 120 /* .xCurrentTime */)) = tvfsCurrentTime                                          // test_vfs.c:1464:5:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&unionModule)) + 8 /* .xCreate */)) = unionConnect               // unionvtab.c:1332:5:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&unionModule)) + 16 /* .xConnect */)) = unionConnect             // unionvtab.c:1333:5:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&unionModule)) + 24 /* .xBestIndex */)) = unionBestIndex                                           // unionvtab.c:1334:5:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&unionModule)) + 32 /* .xDisconnect */)) = unionDisconnect                                                  // unionvtab.c:1335:5:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&unionModule)) + 40 /* .xDestroy */)) = unionDisconnect                                                     // unionvtab.c:1336:5:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&unionModule)) + 48 /* .xOpen */)) = unionOpen                                                     // unionvtab.c:1337:5:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&unionModule)) + 56 /* .xClose */)) = unionClose                                                            // unionvtab.c:1338:5:
	*(*func(*crt.TLS, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&unionModule)) + 64 /* .xFilter */)) = unionFilter                          // unionvtab.c:1339:5:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&unionModule)) + 72 /* .xNext */)) = unionNext                                                              // unionvtab.c:1340:5:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&unionModule)) + 80 /* .xEof */)) = unionEof                                                                // unionvtab.c:1341:5:
	*(*func(*crt.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&unionModule)) + 88 /* .xColumn */)) = unionColumn                                          // unionvtab.c:1342:5:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&unionModule)) + 96 /* .xRowid */)) = unionRowid                                                   // unionvtab.c:1343:5:
	*(*func(*crt.TLS, uintptr, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfs_template)) + 40 /* .xOpen */)) = rbuVfsOpen                          // sqlite3rbu.c:5222:5:
	*(*func(*crt.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfs_template)) + 48 /* .xDelete */)) = rbuVfsDelete                                        // sqlite3rbu.c:5223:5:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfs_template)) + 56 /* .xAccess */)) = rbuVfsAccess                               // sqlite3rbu.c:5224:5:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfs_template)) + 64 /* .xFullPathname */)) = rbuVfsFullPathname                   // sqlite3rbu.c:5225:5:
	*(*func(*crt.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfs_template)) + 104 /* .xRandomness */)) = rbuVfsRandomness                               // sqlite3rbu.c:5236:5:
	*(*func(*crt.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfs_template)) + 112 /* .xSleep */)) = rbuVfsSleep                                                  // sqlite3rbu.c:5237:5:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfs_template)) + 120 /* .xCurrentTime */)) = rbuVfsCurrentTime                                    // sqlite3rbu.c:5238:5:
	*(*func(*crt.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfs_template)) + 128 /* .xGetLastError */)) = rbuVfsGetLastError                           // sqlite3rbu.c:5239:5:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_io_methods)) + 8 /* .xClose */)) = vfslogClose                                                      // test_osinst.c:204:3:
	*(*func(*crt.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_io_methods)) + 16 /* .xRead */)) = vfslogRead                        // test_osinst.c:205:3:
	*(*func(*crt.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_io_methods)) + 24 /* .xWrite */)) = vfslogWrite                      // test_osinst.c:206:3:
	*(*func(*crt.TLS, uintptr, sqlite3_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_io_methods)) + 32 /* .xTruncate */)) = vfslogTruncate                                // test_osinst.c:207:3:
	*(*func(*crt.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_io_methods)) + 40 /* .xSync */)) = vfslogSync                                                // test_osinst.c:208:3:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_io_methods)) + 48 /* .xFileSize */)) = vfslogFileSize                                      // test_osinst.c:209:3:
	*(*func(*crt.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_io_methods)) + 56 /* .xLock */)) = vfslogLock                                                // test_osinst.c:210:3:
	*(*func(*crt.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_io_methods)) + 64 /* .xUnlock */)) = vfslogUnlock                                            // test_osinst.c:211:3:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_io_methods)) + 72 /* .xCheckReservedLock */)) = vfslogCheckReservedLock                    // test_osinst.c:212:3:
	*(*func(*crt.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_io_methods)) + 80 /* .xFileControl */)) = vfslogFileControl                         // test_osinst.c:213:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_io_methods)) + 88 /* .xSectorSize */)) = vfslogSectorSize                                           // test_osinst.c:214:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_io_methods)) + 96 /* .xDeviceCharacteristics */)) = vfslogDeviceCharacteristics                     // test_osinst.c:215:3:
	*(*func(*crt.TLS, uintptr, int32, int32, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_io_methods)) + 104 /* .xShmMap */)) = vfslogShmMap                    // test_osinst.c:216:3:
	*(*func(*crt.TLS, uintptr, int32, int32, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_io_methods)) + 112 /* .xShmLock */)) = vfslogShmLock                           // test_osinst.c:217:3:
	*(*func(*crt.TLS, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_io_methods)) + 120 /* .xShmBarrier */)) = vfslogShmBarrier                                                // test_osinst.c:218:3:
	*(*func(*crt.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_io_methods)) + 128 /* .xShmUnmap */)) = vfslogShmUnmap                                       // test_osinst.c:219:3:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_module)) + 8 /* .xCreate */)) = vlogConnect              // test_osinst.c:1074:5:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_module)) + 16 /* .xConnect */)) = vlogConnect            // test_osinst.c:1075:5:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_module)) + 24 /* .xBestIndex */)) = vlogBestIndex                                          // test_osinst.c:1076:5:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_module)) + 32 /* .xDisconnect */)) = vlogDisconnect                                                 // test_osinst.c:1077:5:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_module)) + 40 /* .xDestroy */)) = vlogDisconnect                                                    // test_osinst.c:1078:5:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_module)) + 48 /* .xOpen */)) = vlogOpen                                                    // test_osinst.c:1079:5:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_module)) + 56 /* .xClose */)) = vlogClose                                                           // test_osinst.c:1080:5:
	*(*func(*crt.TLS, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_module)) + 64 /* .xFilter */)) = vlogFilter                         // test_osinst.c:1081:5:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_module)) + 72 /* .xNext */)) = vlogNext                                                             // test_osinst.c:1082:5:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_module)) + 80 /* .xEof */)) = vlogEof                                                               // test_osinst.c:1083:5:
	*(*func(*crt.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_module)) + 88 /* .xColumn */)) = vlogColumn                                         // test_osinst.c:1084:5:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_module)) + 96 /* .xRowid */)) = vlogRowid                                                  // test_osinst.c:1085:5:
	*(*func(*crt.TLS, uintptr, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_vfs)) + 40 /* .xOpen */)) = vfslogOpen                            // test_osinst.c:187:3:
	*(*func(*crt.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_vfs)) + 48 /* .xDelete */)) = vfslogDelete                                          // test_osinst.c:188:3:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_vfs)) + 56 /* .xAccess */)) = vfslogAccess                                 // test_osinst.c:189:3:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_vfs)) + 64 /* .xFullPathname */)) = vfslogFullPathname                     // test_osinst.c:190:3:
	*(*func(*crt.TLS, uintptr, uintptr) uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_vfs)) + 72 /* .xDlOpen */)) = vfslogDlOpen                                               // test_osinst.c:191:3:
	*(*func(*crt.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_vfs)) + 80 /* .xDlError */)) = vfslogDlError                                              // test_osinst.c:192:3:
	*(*func(*crt.TLS, uintptr, uintptr, uintptr) uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_vfs)) + 88 /* .xDlSym */)) = vfslogDlSym                                        // test_osinst.c:193:3:
	*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_vfs)) + 96 /* .xDlClose */)) = vfslogDlClose                                                     // test_osinst.c:194:3:
	*(*func(*crt.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_vfs)) + 104 /* .xRandomness */)) = vfslogRandomness                                 // test_osinst.c:195:3:
	*(*func(*crt.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_vfs)) + 112 /* .xSleep */)) = vfslogSleep                                                    // test_osinst.c:196:3:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_vfs)) + 120 /* .xCurrentTime */)) = vfslogCurrentTime                                      // test_osinst.c:197:3:
	*(*func(*crt.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_vfs)) + 128 /* .xGetLastError */)) = vfslogGetLastError                             // test_osinst.c:198:3:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_vfs)) + 136 /* .xCurrentTimeInt64 */)) = vfslogCurrentTimeInt64                            // test_osinst.c:199:3:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&wholenumberModule)) + 8 /* .xCreate */)) = wholenumberConnect   // wholenumber.c:238:3:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&wholenumberModule)) + 16 /* .xConnect */)) = wholenumberConnect // wholenumber.c:239:3:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&wholenumberModule)) + 24 /* .xBestIndex */)) = wholenumberBestIndex                               // wholenumber.c:240:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&wholenumberModule)) + 32 /* .xDisconnect */)) = wholenumberDisconnect                                      // wholenumber.c:241:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&wholenumberModule)) + 40 /* .xDestroy */)) = wholenumberDisconnect                                         // wholenumber.c:242:3:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&wholenumberModule)) + 48 /* .xOpen */)) = wholenumberOpen                                         // wholenumber.c:243:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&wholenumberModule)) + 56 /* .xClose */)) = wholenumberClose                                                // wholenumber.c:244:3:
	*(*func(*crt.TLS, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&wholenumberModule)) + 64 /* .xFilter */)) = wholenumberFilter              // wholenumber.c:245:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&wholenumberModule)) + 72 /* .xNext */)) = wholenumberNext                                                  // wholenumber.c:246:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&wholenumberModule)) + 80 /* .xEof */)) = wholenumberEof                                                    // wholenumber.c:247:3:
	*(*func(*crt.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&wholenumberModule)) + 88 /* .xColumn */)) = wholenumberColumn                              // wholenumber.c:248:3:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&wholenumberModule)) + 96 /* .xRowid */)) = wholenumberRowid                                       // wholenumber.c:249:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&writecrash_io_methods)) + 8 /* .xClose */)) = devsymClose                                                  // test_devsym.c:393:3:
	*(*func(*crt.TLS, uintptr, uintptr, int32, sqlite_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&writecrash_io_methods)) + 16 /* .xRead */)) = devsymRead                     // test_devsym.c:394:3:
	*(*func(*crt.TLS, uintptr, uintptr, int32, sqlite_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&writecrash_io_methods)) + 24 /* .xWrite */)) = writecrashWrite               // test_devsym.c:395:3:
	*(*func(*crt.TLS, uintptr, sqlite_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&writecrash_io_methods)) + 32 /* .xTruncate */)) = devsymTruncate                             // test_devsym.c:396:3:
	*(*func(*crt.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&writecrash_io_methods)) + 40 /* .xSync */)) = devsymSync                                            // test_devsym.c:397:3:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&writecrash_io_methods)) + 48 /* .xFileSize */)) = devsymFileSize                                  // test_devsym.c:398:3:
	*(*func(*crt.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&writecrash_io_methods)) + 56 /* .xLock */)) = devsymLock                                            // test_devsym.c:399:3:
	*(*func(*crt.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&writecrash_io_methods)) + 64 /* .xUnlock */)) = devsymUnlock                                        // test_devsym.c:400:3:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&writecrash_io_methods)) + 72 /* .xCheckReservedLock */)) = devsymCheckReservedLock                // test_devsym.c:401:3:
	*(*func(*crt.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&writecrash_io_methods)) + 80 /* .xFileControl */)) = devsymFileControl                     // test_devsym.c:402:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&writecrash_io_methods)) + 88 /* .xSectorSize */)) = writecrashSectorSize                                   // test_devsym.c:403:3:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&writecrash_io_methods)) + 96 /* .xDeviceCharacteristics */)) = writecrashDeviceCharacteristics             // test_devsym.c:404:3:
	*(*func(*crt.TLS, uintptr, int32, int32, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&writecrash_io_methods)) + 104 /* .xShmMap */)) = devsymShmMap                // test_devsym.c:405:3:
	*(*func(*crt.TLS, uintptr, int32, int32, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&writecrash_io_methods)) + 112 /* .xShmLock */)) = devsymShmLock                       // test_devsym.c:406:3:
	*(*func(*crt.TLS, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&writecrash_io_methods)) + 120 /* .xShmBarrier */)) = devsymShmBarrier                                            // test_devsym.c:407:3:
	*(*func(*crt.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&writecrash_io_methods)) + 128 /* .xShmUnmap */)) = devsymShmUnmap                                   // test_devsym.c:408:3:
	*(*func(*crt.TLS, uintptr, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&writecrash_vfs)) + 40 /* .xOpen */)) = writecrashOpen                    // test_devsym.c:457:3:
	*(*func(*crt.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&writecrash_vfs)) + 48 /* .xDelete */)) = devsymDelete                                      // test_devsym.c:458:3:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&writecrash_vfs)) + 56 /* .xAccess */)) = devsymAccess                             // test_devsym.c:459:3:
	*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&writecrash_vfs)) + 64 /* .xFullPathname */)) = devsymFullPathname                 // test_devsym.c:460:3:
	*(*func(*crt.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&writecrash_vfs)) + 104 /* .xRandomness */)) = devsymRandomness                             // test_devsym.c:472:3:
	*(*func(*crt.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&writecrash_vfs)) + 112 /* .xSleep */)) = devsymSleep                                                // test_devsym.c:473:3:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&writecrash_vfs)) + 120 /* .xCurrentTime */)) = devsymCurrentTime                                  // test_devsym.c:474:3:
}

var ts1 = "*pRc==0\x00testdata/sqlite-src-3320300/ext/expert/sqlite3expert.c\x00nByte>0\x00idxMalloc\x00iHash>=0\x00idxHashAdd\x00idxHashFind\x00idxNewConstraint\x00%s\x00zIn[0]=='\\''\x00zIn[n-1]=='\\''\x00zIn[iIn+1]=='\\''\x00expertDequote\x00internal error!\x00sqlite3_stricmp(p->pTab->zName, argv[2])==0\x00expertConnect\x00pCsr->pData\x00expertNext\x00SELECT * FROM main.%Q WHERE sample()\x00expert\x00PRAGMA table_info=%Q\x00main\x00, \x00%Q\x00 COLLATE %Q\x00 COLLATE %s\x00 DESC\x00PRAGMA index_list=%Q\x00PRAGMA index_xInfo=%Q\x00%s_idx_%08x\x00CREATE INDEX '%q' ON %Q(%s)\x00CREATE INDEX %s ON %s(%s)\x00pCon->pLink==0\x00idxCreateFromWhere\x00EXPLAIN QUERY PLAN %s\x00 USING INDEX \x00 USING COVERING INDEX \x00%s\n\x00%s;\n\x00SELECT 'CREATE TEMP' || substr(sql, 7) FROM sqlite_master WHERE tbl_name = %Q AND type IN ('table', 'trigger') ORDER BY type;\x00ALTER TABLE temp.%Q RENAME TO %Q\x00INSERT INTO %Q VALUES(\x00%s?\x00\x00)\x00UPDATE %Q SET \x00%s%Q=?\x00pWrite->eOp==9\x00DELETE FROM %Q\x00idxProcessOneTrigger\x00t592690916721053953805701627921227776\x00DROP TABLE t592690916721053953805701627921227776\x00SELECT type, name, sql, 1 FROM sqlite_master WHERE type IN ('table','view') AND name NOT LIKE 'sqlite_%%'  UNION ALL SELECT type, name, sql, 2 FROM sqlite_master WHERE type = 'trigger'  AND tbl_name IN(SELECT name FROM sqlite_master WHERE type = 'view') ORDER BY 4, 1\x00CREATE TABLE x(\x00%s%Q COLLATE %s\x00CREATE VIRTUAL TABLE %Q USING expert(%Q)\x00argc==0\x00idxSampleFunc\x00argc==2\x00iSlot<=p->nSlot\x00idxRemFunc\x00SELECT max(i.seqno) FROM   sqlite_master AS s,   pragma_index_list(s.name) AS l,   pragma_index_info(l.name) AS i WHERE s.type = 'table'\x00p->iSample>0\x00%sx.%Q IS rem(%d, x.%Q) COLLATE %s\x00%s%d\x00SELECT %s FROM %Q x ORDER BY %s\x00SELECT %s FROM temp.t592690916721053953805701627921227776 x ORDER BY %s\x00%d\x00 %d\x00pEntry->zVal2==0\x00idxPopulateOneStat1\x00DROP TABLE IF EXISTS temp.t592690916721053953805701627921227776\x00CREATE TABLE temp.t592690916721053953805701627921227776 AS SELECT * FROM %Q\x00SELECT s.rowid, s.name, l.name FROM   sqlite_master AS s,   pragma_index_list(s.name) AS l WHERE s.type = 'table'\x00SELECT name, coll FROM pragma_index_xinfo(?) WHERE key\x00INSERT INTO sqlite_stat1 VALUES(?, ?, ?)\x00ANALYZE; PRAGMA writable_schema=1\x00rem\x00sample\x00ANALYZE sqlite_master\x00:memory:\x00SELECT sql FROM sqlite_master WHERE name NOT LIKE 'sqlite_%%' AND sql NOT LIKE 'CREATE VIRTUAL %%'\x00%s;%s%s\n\x00 -- stat1: \x00no such handle: \x00sql\x00TABLE\x00analyze\x00count\x00report\x00STMT EREPORT\x00destroy\x00SUBCOMMAND ...\x00sub-command\x00indexes\x00plan\x00candidates\x001==1\x00testdata/sqlite-src-3320300/ext/expert/test_expert.c\x002==2\x003==3\x004==4\x00iSub==4\x00testExpertCmd\x00DB\x00sqlite3expert%d\x00out of memory\x00sqlite3_expert_new\x00pBalance==pOld\x00testdata/sqlite-src-3320300/ext/misc/amatch.c\x00amatchAvlRemove\x00%s: cost must be between 1 and %d\x00%s: maximum string length is %d\x00%s: iLang must be between 0 and %d\x00?\x00SELECT * FROM %Q.%Q\x00%s: %s\x00%s: %s has %d columns, expected 4\x00p->pRule==0\x00amatchLoadRules\x00(int)strlen(zOut)<=nIn\x00amatchDequote\x00p->nCursor==0\x00amatchDisconnect\x00vocabulary_table\x00vocabulary_word\x00vocabulary_language\x00edit_distances\x00unrecognized argument: [%s]\n\x00no edit_distances table specified\x00CREATE TABLE x(word,distance,language,command HIDDEN,nword HIDDEN)\x000123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ^abcdefghijklmnopqrstuvwxyz~\x00pOther==0\x00amatchAddWord\x00SELECT \"%w\" FROM \"%w\"\x00 WHERE \"%w\">=?1 AND \"%w\"=?2 ORDER BY 1\x00SELECT \"%w\" FROM \"%w\" WHERE \"%w\">=?1 ORDER BY 1\x00*\x00DELETE from %s is not allowed\x00UPDATE of %s is not allowed\x00INSERT INTO %s allowed for column [command] only\x00approximate_match\x00int32\x00int64\x00double\x00char*\x00CREATE TABLE x(value,pointer hidden,count hidden,ctype hidden)\x00carray\x00unknown datatype: %Q\x00inttoptr\x00testdata/sqlite-src-3320300/ext/misc/closure.c\x00closureDequote\x00closureDisconnect\x00tablename\x00idcolumn\x00parentcolumn\x00CREATE TABLE x(id,depth,root HIDDEN,tablename HIDDEN,idcolumn HIDDEN,parentcolumn HIDDEN)\x00SELECT \"%w\".\"%w\" FROM \"%w\" WHERE \"%w\".\"%w\"=?1\x00transitive_closure\x00rb\x00cannot open '%s' for reading\x00p->in==0\x00testdata/sqlite-src-3320300/ext/misc/csv.c\x00csv_reader_open\x00p->iIn>=p->nIn\x00p->in!=0\x00csv_getc_refill\x00line %d: unescaped %c character\x00line %d: unterminated %c-quoted field\n\x00more than one '%s' parameter\x00yes\x00on\x00true\x00no\x00off\x00false\x00sizeof(azPValue)==sizeof(azParam)\x00header\x00more than one 'header' parameter\x00testflags\x00columns\x00more than one 'columns' parameter\x00column= value must be positive\x00bad parameter: '%s'\x00must specify either filename= or data= but not both\x00%sc%d TEXT\x00,\x00%s\"%w\" TEXT\x00bad schema: '%s' - %s\x00csvtabConnect\x00filename\x00data\x00schema\x00pCur->rdr.zIn==pTab->zData\x00pTab->iStart>=0\x00(size_t)pTab->iStart<=pCur->rdr.nIn\x00csvtabFilter\x00csv\x00csv_wr\x00 \x00eval\x00CREATE TABLE x(addr,opcode,p1,p2,p3,p4,p5,comment,sql HIDDEN)\x00EXPLAIN %s\x00explain\x00wb\x00wrong number of arguments to function writefile()\x00failed to create symlink: %s\x00failed to create directory: %s\x00failed to write file: %s\x00CREATE TABLE x(name,mode,mtime,data,path HIDDEN,dir HIDDEN)\x00cannot read directory: %s\x00%s/%s\x00cannot stat file: %s\x00table function fsdir requires an argument\x00argc==idxNum && (argc==1 || argc==2)\x00testdata/sqlite-src-3320300/ext/misc/fileio.c\x00table function fsdir requires a non-NULL argument\x00fsdirFilter\x00fsdir\x00readfile\x00writefile\x00lsmode\x00%s: ruleset must be between 0 and %d\x00%s: wrong number of CREATE VIRTUAL TABLE arguments\x00CREATE TABLE x(word,distance,ruleset)\x00fuzzer\x00sizeof(m)==sizeof(r)\x00testdata/sqlite-src-3320300/ext/misc/ieee754.c\x00ieee754(%lld,%d)\x00ieee754func\x00ieee754\x00BEGIN; SELECT * FROM %s%q%ssqlite_master\x00'\x00'.\x00PRAGMA %s%q%spage_size\x00sqlite3_mmap_warm_cache: Warmed up %d pages of %s\x00END\x00AND (%s)\x00collate \"%w\"\x00SELECT %s FROM %s WHERE %s>=(?1 || ?2) %s   AND %s<=(?1 || char(1114111)) %s   %s ORDER BY 1 %s ASC LIMIT 1\x00next_char\x00NULL\x00is\x00not\x00in(\x00in(select\x00in(with\x00?,?,?\x00sizeof(u)==sizeof(r)\x00testdata/sqlite-src-3320300/ext/misc/percentile.c\x00isInfinity\x002nd argument to percentile() is not a number between 0.0 and 100.0\x002nd argument to percentile() is not the same for all input rows\x001st argument to percentile() is not numeric\x00Inf input to percentile()\x00percentStep\x00percentile\x00CREATE TABLE prefixes(prefix TEXT, original_string TEXT HIDDEN)\x00prefixes\x00prefix_length\x00unknown \\ escape\x00afnrtv\\()*.+?[$^{|}]\x00\a\f\n\r\t\v\x00unmatched '('\x00'*' without operand\x00'+' without operand\x00'?' without operand\x00'{m,n}' without operand\x00unmatched '{'\x00n less than m in '{m,n}'\x00both m and n are zero in '{m,n}'\x00POSIX character classes not supported\x00unclosed '['\x00unrecognized character\x00regexp\x00testdata/sqlite-src-3320300/ext/misc/remember.c\x00rememberFunc\x00remember\x00CREATE TABLE x(value,start hidden,stop hidden,step hidden)\x002 == 1+1\x00testdata/sqlite-src-3320300/ext/misc/series.c\x003 == 1+2\x00iCol>=0 && iCol<=2\x00seriesBestIndex\x00generate_series() requires SQLite 3.8.12 or later\x00generate_series\x00.ABCDHLRMY9 ?\x00non-ASCII input to editdist()\x00NULL input to editdist()\x00SELECT iLang, cFrom, cTo, iCost FROM \"%w\" WHERE iLang>=0 ORDER BY iLang\x00editdist3\x00DROP TABLE IF EXISTS \"%w\".\"%w_vocab\"\x00CREATE TABLE x(word,rank,distance,langid, score, matchlen, phonehash HIDDEN, top HIDDEN, scope HIDDEN, srchcnt HIDDEN, soundslike HIDDEN, command HIDDEN)\x00CREATE TABLE IF NOT EXISTS \"%w\".\"%w_vocab\"(\n  id INTEGER PRIMARY KEY,\n  rank INT,\n  langid INT,\n  word TEXT,\n  k1 TEXT,\n  k2 TEXT\n);\n\x00CREATE INDEX IF NOT EXISTS \"%w\".\"%w_vocab_index_langid_k2\" ON \"%w_vocab\"(langid,k2);\x00edit_cost_table=\x00bad argument to spellfix1(): \"%s\"\x00SELECT id, word, rank, coalesce(k1,word)  FROM \"%w\".\"%w_vocab\" WHERE langid=%d AND k2>=?1 AND k2<?2\x00SELECT word, rank, NULL, langid, id FROM \"%w\".\"%w_vocab\"%s\x00 WHERE rowid=?\x00ROLLBACK\x00IGNORE\x00ABORT\x00REPLACE\x00DELETE FROM \"%w\".\"%w_vocab\"  WHERE id=%lld\x00NOT NULL constraint failed: %s.word\x00reset\x00null\x00unknown value for %s.command: \"%w\"\x00INSERT INTO \"%w\".\"%w_vocab\"(rank,langid,word,k1,k2) VALUES(%d,%d,%Q,nullif(%Q,%Q),%Q)\x00INSERT OR %s INTO \"%w\".\"%w_vocab\"(id,rank,langid,word,k1,k2) VALUES(%lld,%d,%d,%Q,nullif(%Q,%Q),%Q)\x00UPDATE OR %s \"%w\".\"%w_vocab\" SET id=%lld, rank=%d, langid=%d, word=%Q, k1=nullif(%Q,%Q), k2=%Q WHERE id=%lld\x00ALTER TABLE \"%w\".\"%w_vocab\" RENAME TO \"%w_vocab\"\x00spellfix1_translit\x00spellfix1_editdist\x00spellfix1_phonehash\x00spellfix1_scriptcode\x00spellfix1\x00922337203685477580\x00u<=(0xffffffff|(((sqlite3_int64)0x7fffffff)<<32))\x00testdata/sqlite-src-3320300/ext/misc/totype.c\x00u-1==(0xffffffff|(((sqlite3_int64)0x7fffffff)<<32))\x00(*pNum)==(((sqlite3_int64)-1) - (0xffffffff|(((sqlite3_int64)0x7fffffff)<<32)))\x00totypeAtoi64\x00argc==1\x00sqlite3_value_type(argv[0])==5\x00tointegerFunc\x00torealFunc\x00tointeger\x00toreal\x00testdata/sqlite-src-3320300/ext/misc/unionvtab.c\x00unionMalloc\x000\x00unionDequote\x00pzErr\x00sql error: %s\x00unionPrepare\x00p->db\x00unionCloseSources\x00_rowid_\x00integer\x00no such rowid table: %s%s%s\x00.\x00SELECT group_concat(quote(name) || '.' || quote(type)) FROM pragma_table_info(?, ?)\x00*pzErr==0\x00source table schema mismatch\x00unionSourceCheck\x00pTab->bSwarm && iSrc<pTab->nSrc\x00unionOpenDatabase\x00pSrc->nUser>=0 && pSrc->db\x00unionIncrRefcount\x00pSrc->nUser>=0\x00unionFinalizeCsrStmt\x00swarmvtab: no such SQL parameter: %s\x00maxopen\x00swarmvtab: illegal maxopen value\x00missing\x00swarmvtab: duplicate \"missing\" option\x00SELECT \"%w\"(?%s)\x00,?\x00openclose\x00swarmvtab: duplicate \"openclose\" option\x00SELECT \"%w\"(?,?%s)\x00swarmvtab: unrecognized option: %s\x00SELECT \"%w\"(?)\x00swarmvtab: parse error: %s\x00swarmvtab\x00unionvtab\x00temp\x00%s tables must be created in TEMP schema\x00wrong number of arguments for %s\x00SELECT * FROM (%z) ORDER BY 3\x00rc==0\x00rowid range mismatch error\x00no source tables configured\x00SELECT 'CREATE TABLE xyz('    || group_concat(quote(name) || ' ' || type, ', ')    || ')',max((cid+1) * (type='INTEGER' COLLATE nocase AND pk=1))-1 FROM pragma_table_info(%Q, ?)\x00unionConnect\x00pCsr->pStmt\x00SELECT rowid, * FROM %Q %s %lld\x00WHERE _rowid_ <=\x00-- \x00doUnionNext\x00idxNum==0 || idxNum==2 || idxNum==8 || idxNum==32 || idxNum==16 || idxNum==4 || idxNum==(32|8)\x00argc>=1\x00%z%sSELECT rowid, * FROM %s%q%s%Q\x00 UNION ALL \x00%z WHERE rowid=%lld\x00WHERE\x00%z WHERE rowid>=%lld\x00AND\x00%z %s rowid<=%lld\x00unionFilter\x00CREATE TABLE x(value)\x00wholenumber\x00testdata/sqlite-src-3320300/ext/rbu/sqlite3rbu.c\x00corrupt fossil delta\x00rbuFossilDeltaFunc\x00*pzErrmsg==0\x00prepareFreeAndCollectError\x00DROP TRIGGER IF EXISTS temp.rbu_insert_tr;DROP TRIGGER IF EXISTS temp.rbu_update1_tr;DROP TRIGGER IF EXISTS temp.rbu_update2_tr;DROP TRIGGER IF EXISTS temp.rbu_delete_tr;\x00argc==1 || argc==2\x00argc==2 || argc==1\x00rbuTargetNameFunc\x00SELECT rbu_target_name(name, type='view') AS target, name FROM sqlite_master WHERE type IN ('table', 'view') AND target IS NOT NULL  %s ORDER BY name\x00AND rootpage!=0 AND rootpage IS NOT NULL\x00SELECT name, rootpage, sql IS NULL OR substr(8, 6)=='UNIQUE'   FROM main.sqlite_master   WHERE type='index' AND tbl_name = ?\x00rbuMalloc\x00p->rc==0\x00SELECT (sql LIKE 'create virtual%%'), rootpage  FROM sqlite_master WHERE name=%Q\x00SELECT rootpage FROM sqlite_master WHERE name = %Q\x00rbuTableType\x00PRAGMA main.index_list = %Q\x00PRAGMA main.index_xinfo = %Q\x00pIter->eType==0\x00no such table: %s\x00pIter->eType==1 || pIter->eType==2 || pIter->eType==3 || pIter->eType==4 || pIter->eType==5\x00SELECT * FROM '%q'\x00rbu_\x00rbu_rowid\x00table %q %s rbu_rowid column\x00may not have\x00requires\x00PRAGMA table_info(%Q)\x00column missing from %q: %s\x00iPk>=0\x00pIter->eType!=5 || pIter->abIndexed==0\x00pIter->eType!=5 || pIter->nIndex==0\x00rbuObjIterCacheTableInfo\x00%z%s\"%w\"\x00%z%s%s\"%w\"%s\x00SELECT max(_rowid_) FROM \"%s%w\"\x00 WHERE _rowid_ > %lld \x00quote(\x00||','||\x00SELECT %s FROM \"%s%w\" ORDER BY %s LIMIT 1\x00 WHERE (%s) > (%s) \x00i<pIter->nTblCol\x00%z%s \"%w\" COLLATE %Q\x00%z%s \"rbu_imp_%d%w\" COLLATE %Q DESC\x00%z%s quote(\"rbu_imp_%d%w\")\x00SELECT %s FROM \"rbu_imp_%w\" ORDER BY %s LIMIT 1\x00%z%s%s\x00(%s) > (%s)\x00rbuVacuumIndexStart\x00p->zErrmsg==0\x00%z%s(%.*s) COLLATE %Q\x00INTEGER\x00%z%s\"%w\" COLLATE %Q\x00%z%s\"rbu_imp_%d%w\"%s\x00%z%s\"rbu_imp_%d%w\" %s COLLATE %Q\x00%z%s\"rbu_imp_%d%w\" IS ?\x00 AND \x00rbuObjIterGetIndexCols\x00%z%s%s.\"%w\"\x00%z%sNULL\x00%z, %s._rowid_\x00_rowid_ = ?%d\x00%z%sc%d=?%d\x00_rowid_ = (SELECT id FROM rbu_imposter2 WHERE %z)\x00%z%s\"%w\"=?%d\x00invalid rbu_control value\x00%z%s\"%w\"=rbu_delta(\"%w\", ?%d)\x00%z%s\"%w\"=rbu_fossil_delta(\"%w\", ?%d)\x00pIter->zIdx==0\x00PRIMARY KEY(\x00pk\x00%z%s\"%w\"%s\x00%z)\x00rbuWithoutRowidPK\x00SELECT name FROM sqlite_master WHERE rootpage = ?\x00%z%sc%d %s COLLATE %Q\x00%z%sc%d%s\x00%z, id INTEGER\x00CREATE TABLE rbu_imposter2(%z, PRIMARY KEY(%z)) WITHOUT ROWID\x00PRIMARY KEY \x00%z%s\"%w\" %s %sCOLLATE %Q%s\x00 NOT NULL\x00%z, %z\x00CREATE TABLE \"rbu_imp_%w\"(%z)%s\x00 WITHOUT ROWID\x00pIter->pTmpInsert==0\x00INSERT INTO %s.'rbu_tmp_%q'(rbu_control,%s%s) VALUES(%z)\x00rbuObjIterPrepareTmpInsert\x00sqlite3_value_int(apVal[0])!=0 || p->objiter.eType==3 || p->objiter.eType==1\x00rbuTmpInsertFunc\x00pIter->zIdxSql==0 && pIter->nIdxCol==0 && pIter->aIdxCol==0\x00SELECT trim(sql) FROM sqlite_master WHERE type='index' AND name=?\x00iIdxCol==0\x00rbuObjIterGetIndexWhere\x00pIter->bCleanup==0\x00 LIMIT -1 OFFSET %d\x00pIter->eType!=5\x00CREATE TABLE \"rbu_imp_%w\"( %s, PRIMARY KEY( %s ) ) WITHOUT ROWID\x00INSERT INTO \"rbu_imp_%w\" VALUES(%s)\x00DELETE FROM \"rbu_imp_%w\" WHERE %s\x00SELECT %s, 0 AS rbu_control FROM '%q' %s %s %s ORDER BY %s%s\x00SELECT %s, rbu_control FROM %s.'rbu_tmp_%q' %s ORDER BY %s%s\x00SELECT %s, rbu_control FROM %s.'rbu_tmp_%q' %s UNION ALL SELECT %s, rbu_control FROM '%q' %s %s typeof(rbu_control)='integer' AND rbu_control!=1 ORDER BY %s%s\x00old\x00new\x00rbu_imp_\x00INSERT INTO \"%s%w\"(%s%s) VALUES(%s)\x00, _rowid_\x00DELETE FROM \"%s%w\" WHERE %s\x00, rbu_rowid\x00CREATE TABLE IF NOT EXISTS %s.'rbu_tmp_%q' AS SELECT *%s FROM '%q' WHERE 0;\x00, 0 AS rbu_rowid\x00CREATE TEMP TRIGGER rbu_delete_tr BEFORE DELETE ON \"%s%w\" BEGIN   SELECT rbu_tmp_insert(3, %s);END;CREATE TEMP TRIGGER rbu_update1_tr BEFORE UPDATE ON \"%s%w\" BEGIN   SELECT rbu_tmp_insert(3, %s);END;CREATE TEMP TRIGGER rbu_update2_tr AFTER UPDATE ON \"%s%w\" BEGIN   SELECT rbu_tmp_insert(4, %s);END;\x00CREATE TEMP TRIGGER rbu_insert_tr AFTER INSERT ON \"%s%w\" BEGIN   SELECT rbu_tmp_insert(0, %s);END;\x00,_rowid_ \x00,rbu_rowid\x00SELECT %s,%s rbu_control%s FROM '%q'%s %s %s %s\x000 AS \x00ORDER BY\x00rbuObjIterPrepareAll\x00pUp==0 || pUp->pNext==0\x00UPDATE \"%s%w\" SET %s WHERE %s\x00rbuGetUpdateStmt\x00SELECT k, v FROM %s.rbu_state\x00p->rc || (p->dbMain==0 && p->dbRbu==0)\x00p->rc || ((p)->zTarget==0) || p->zTarget!=0\x00file://%s-vacuum?modeof=%s\x00ATTACH %Q AS stat\x00stat\x00CREATE TABLE IF NOT EXISTS %s.rbu_state(k INTEGER PRIMARY KEY, v)\x00cannot vacuum wal mode database\x00file:\x00file:%s-vactmp?rbu_memory=1%s%s\x00&\x00rbu_tmp_insert\x00rbu_fossil_delta\x00rbu_target_name\x00SELECT * FROM sqlite_master\x00rbu vfs not found\x00rbuOpenDatabase\x00PRAGMA main.wal_checkpoint=restart\x00p->nPagePerSector==0\x00rbuSetupCheckpoint\x00rbuCheckpointFrame\x00rbuLockDatabase\x00%s-oal\x00%s-wal\x00p->eStage==2\x00p->rc==0 && p->zErrmsg==0\x00rbuMoveOalFile\x00eType!=2 || pIter->zIdx==0\x00eType==2 || eType==4 || eType==1 || eType==5\x00datatype mismatch\x00rbuStepOneOp\x00eType==1 || eType==2 || eType==3 || eType==4 || eType==5 || eType==6\x00eType!=6 || pIter->zIdx==0\x00eType==6\x00rbuStep\x00PRAGMA schema_version\x00PRAGMA schema_version = %d\x00INSERT OR REPLACE INTO %s.rbu_state(k, v) VALUES (%d, %d), (%d, %Q), (%d, %Q), (%d, %d), (%d, %d), (%d, %lld), (%d, %lld), (%d, %lld), (%d, %lld), (%d, %Q)  \x00pInsert==0 || rc==0\x00rbuSaveState\x00PRAGMA main.%s\x00PRAGMA main.%s = %d\x00((p)->zTarget==0)\x00PRAGMA writable_schema=1\x00SELECT sql FROM sqlite_master WHERE sql!='' AND rootpage!=0 AND name!='sqlite_sequence'  ORDER BY type DESC\x00SELECT * FROM sqlite_master WHERE rootpage=0 OR rootpage IS NULL\x00INSERT INTO sqlite_master VALUES(?,?,?,?,?)\x00PRAGMA writable_schema=0\x00rbuCreateTargetSchema\x00user_version\x00application_id\x00DELETE FROM %s.'rbu_tmp_%q'\x00pIter->zTbl==0\x00COMMIT\x00sqlite3rbu_step\x00rbu_state mismatch error\x00rbuSetupOal\x00pVfs && p->rc==0 && p->zErrmsg==0\x00rbuDeleteOalFile\x00rbu_vfs_%d\x00pVfs\x00rbuCreateVfs\x00nVal==1\x00SELECT count(*) FROM sqlite_master WHERE type='index' AND tbl_name = %Q\x00rbuIndexCntFunc\x00rbu_index_cnt\x00SELECT 1 FROM sqlite_master WHERE tbl_name = 'rbu_count'\x00SELECT sum(cnt * (1 + rbu_index_cnt(rbu_target_name(tbl))))FROM rbu_count\x00pState || p->rc!=0\x00p->rc!=0 || p->eStage!=0\x00cannot update wal mode database\x00database modified during rbu %s\x00vacuum\x00update\x00BEGIN\x00page_size\x00auto_vacuum\x00BEGIN IMMEDIATE\x00PRAGMA journal_mode=off\x00openRbuHandle\x00-vactmp\x00DELETE FROM stat.rbu_state\x00p->szTemp==0\x00sqlite3rbu_close\x00sqlite3rbu_bp_progress\x005==5\x00aRes[1]==1\x00aRes[2]==2\x00aRes[4]==3\x00aRes[5]==4\x00p->rc!=101 || p->eStage==5\x00p->eStage==1 || p->eStage==2 || p->eStage==4 || p->eStage==5\x00sqlite3rbu_state\x00p->eStage>=1 && p->eStage<=5\x00rc!=101\x00sqlite3rbu_savestate\x00p->openFlags & 0x00000100\x00rbuUnlockShm\x00pRbu->szTemp>=0\x00rbuUpdateTempSize\x00(p->openFlags & 0x00000100)\x00rbuMainlistAdd\x00p->pMainNext==0 && p->pRbuVfs->pMain!=p\x00rbuVfsClose\x00p->openFlags & 0x00080000\x00rbuVfsRead\x00rbuVfsWrite\x00p->openFlags & (0x00000100|0x00000200)\x00rbuVfsLock\x00p->openFlags & (0x00000100|0x00000200) || p->openFlags & (0x00000400|0x00001000)\x00rbu/zipvfs setup error\x00rbu(%s)/%z\x00rbuVfsFileControl\x00rbuVfsShmLock\x00iRegion==p->nShm\x00p->apShm==0\x00rbuVfsShmMap\x00rbuVfsShmUnmap\x00rbu_memory\x00oflags & 0x00000100\x00rbuVfsOpen\x00pDb->pRbu\x00rbuVfsAccess\x00rbu_delta\x00step\x00close\x00create_rbu_delta\x00savestate\x00dbMain_eval\x00SQL\x00bp_progress\x00db\x00RBU\x00state\x00progress\x00close_no_error\x00temp_size_limit\x00LIMIT\x00temp_size\x00dbRbu_eval\x00METHOD\x00method\x00zErrmsg==0\x00testdata/sqlite-src-3320300/ext/rbu/test_rbu.c\x00 - \x00oal\x00move\x00checkpoint\x00done\x00error\x00eState>0 && eState<=5\x00!\"cannot happen\"\x00test_sqlite3rbu_cmd\x00NAME TARGET-DB RBU-DB ?STATE-DB?\x00NAME TARGET-DB ?STATE-DB?\x00?-default? NAME PARENT\x00NAME\x00sqlite3rbu_db(0, 0)!=0\x00sqlite3rbu\x00sqlite3rbu_vacuum\x00sqlite3rbu_create_vfs\x00sqlite3rbu_destroy_vfs\x00sqlite3rbu_internal_test\x00!\"Bad seekMode\"\x00testdata/sqlite-src-3320300/src/tclsqlite.c\x00incrblobSeek\x00incrblob\x00incrblob_%d\x00pFunc->pDb==pDb\x00DbDeleteCmd\x00%lld\x00pDb->pRollbackHook\x00DbRollbackHandler\x00pDb->pWalHook\x00db==pDb->db\x00DbWalHandler\x00sqlite_unlock_notify_arg\x00sqlite_unlock_notify_argcount\x00pDb->pUnlockNotify\x00DbUnlockNotify\x00(9-1)/9 == 0\x00(18-1)/9 == 1\x00(23-1)/9 == 2\x00pDb->pUpdateHook\x00op==18 || op==23 || op==9\x00DbUpdateHandler\x00DELETE\x00INSERT\x00UPDATE\x00bytearray\x00boolean\x00wideInt\x00int\x00SQLITE_COPY\x00SQLITE_CREATE_INDEX\x00SQLITE_CREATE_TABLE\x00SQLITE_CREATE_TEMP_INDEX\x00SQLITE_CREATE_TEMP_TABLE\x00SQLITE_CREATE_TEMP_TRIGGER\x00SQLITE_CREATE_TEMP_VIEW\x00SQLITE_CREATE_TRIGGER\x00SQLITE_CREATE_VIEW\x00SQLITE_DELETE\x00SQLITE_DROP_INDEX\x00SQLITE_DROP_TABLE\x00SQLITE_DROP_TEMP_INDEX\x00SQLITE_DROP_TEMP_TABLE\x00SQLITE_DROP_TEMP_TRIGGER\x00SQLITE_DROP_TEMP_VIEW\x00SQLITE_DROP_TRIGGER\x00SQLITE_DROP_VIEW\x00SQLITE_INSERT\x00SQLITE_PRAGMA\x00SQLITE_READ\x00SQLITE_SELECT\x00SQLITE_TRANSACTION\x00SQLITE_UPDATE\x00SQLITE_ATTACH\x00SQLITE_DETACH\x00SQLITE_ALTER_TABLE\x00SQLITE_REINDEX\x00SQLITE_ANALYZE\x00SQLITE_CREATE_VTABLE\x00SQLITE_DROP_VTABLE\x00SQLITE_FUNCTION\x00SQLITE_SAVEPOINT\x00SQLITE_RECURSIVE\x00????\x00SQLITE_DENY\x00SQLITE_OK\x00SQLITE_IGNORE\x00RELEASE _tcl_transaction\x00ROLLBACK TO _tcl_transaction ; RELEASE _tcl_transaction\x00pPreStmt==0\x00pPreStmt\x00strlen30(pPreStmt->zSql)==pPreStmt->nSql\x000==memcmp(pPreStmt->zSql, zSql, pPreStmt->nSql)\x00dbPrepareAndBind\x00pDb->nStmt==0\x00pDb->nStmt>0\x00dbReleaseStmt\x00!(*ppHook)\x00DbHookCmd\x00option\x00?CALLBACK?\x00?DATABASE? FILENAME\x00cannot open target database: \x00backup failed: \x00CALLBACK\x00cache option ?arg?\x00flush\x00size\x00size n\x00cannot convert \"\x00\" to integer\x00bad option \"\x00\": must be flush or size\x00NAME SCRIPT\x00SCRIPT\x00?OPTION? ?BOOLEAN?\x00unknown config option: \"\x00\"\x00CONFLICT-ALGORITHM TABLE FILENAME ?SEPARATOR? ?NULLINDICATOR?\x00\t\x00Error: non-null separator required for copy\x00rollback\x00abort\x00fail\x00ignore\x00replace\x00Error: \"\x00\", conflict-algorithm must be one of: rollback, abort, fail, ignore, or replace\x00Error: no such table: \x00Error: \x00Error: can't malloc()\x00INSERT OR %q INTO '%q' VALUES(?\x00Error: cannot open file: \x00Error: %s line %d: expected %d columns of data but found %d\x00, failed while processing line: \x00MEMDB not available in this build\x00extension loading is turned off at compile-time\x00-withoutnulls\x00unknown option: \"\x00?OPTIONS? SQL ?ARRAY-NAME? ?SCRIPT?\x00NAME ?SWITCHES? SCRIPT\x00-argcount\x00option requires an argument: \x00number of arguments must be non-negative\x00-deterministic\x00-directonly\x00-innocuous\x00-returntype\x00real\x00text\x00blob\x00any\x001==1 && 2==2 && 3==3\x004==4 && 5==5\x00type\x00\": must be -argcount, -deterministic, -directonly, -innocuous, or -returntype\x00-readonly\x00?-readonly? ?DB? TABLE COLUMN ROWID\x00NULLVALUE\x00N CALLBACK\x00KEY\x00cannot open source database: \x00restore failed: \x00restore failed: source database busy\x00(step|sort|autoindex)\x00sort\x00autoindex\x00vmstep\x00bad argument: should be autoindex, step, sort or vmstep\x00MILLISECONDS\x00?CALLBACK? ?MASK?\x00trace type\x00SAVEPOINT _tcl_transaction\x00[TYPE] SCRIPT\x00transaction type\x00BEGIN EXCLUSIVE\x00?SCRIPT?\x00preupdate_hook was omitted at compile-time\x00-use-legacy-prepare\x00-last-stmt-ptr\x00%p\x00unknown argument: \x00DbObjCmd\x00authorizer\x00backup\x00bind_fallback\x00busy\x00cache\x00changes\x00collate\x00collation_needed\x00commit_hook\x00complete\x00config\x00copy\x00deserialize\x00enable_load_extension\x00errorcode\x00exists\x00function\x00interrupt\x00last_insert_rowid\x00nullvalue\x00onecolumn\x00preupdate\x00profile\x00rekey\x00restore\x00rollback_hook\x00serialize\x00status\x00timeout\x00total_changes\x00trace\x00trace_v2\x00transaction\x00unlock_notify\x00update_hook\x00version\x00wal_hook\x00defensive\x00dqs_ddl\x00dqs_dml\x00enable_fkey\x00enable_qpsg\x00enable_trigger\x00enable_view\x00fts3_tokenizer\x00legacy_alter_table\x00legacy_file_format\x00load_extension\x00no_ckpt_on_close\x00reset_database\x00trigger_eqp\x00trusted_schema\x00writable_schema\x00statement\x00row\x00deferred\x00exclusive\x00immediate\x00HANDLE ?FILENAME? ?-vfs VFSNAME? ?-readonly BOOLEAN? ?-create BOOLEAN? ?-nofollow BOOLEAN? ?-nomutex BOOLEAN? ?-fullmutex BOOLEAN? ?-uri BOOLEAN?\x00-version\x00-sourceid\x00-has-codec\x00-key\x00-vfs\x00-create\x00-nofollow\x00-nomutex\x00-fullmutex\x00-uri\x00-translatefilename\x00unknown option: \x00sqlite3\x00sqlite\x003.32.3\x00if {[llength $argv]>=1} {\nset argv0 [lindex $argv 0]\nset argv [lrange $argv 1 end]\nsource $argv0\n} else {\nset line {}\nwhile {![eof stdin]} {\nif {$line!=\"\"} {\nputs -nonewline \"> \"\n} else {\nputs -nonewline \"% \"\n}\nflush stdout\nappend line [gets stdin]\nif {[info complete $line]} {\nif {[catch {uplevel #0 $line} result]} {\nputs stderr \"Error: $result\"\n} elseif {$result!=\"\"} {\nputs $result\n}\nset line {}\n} else {\nappend line \\n\n}\n}\n}\n\x00SQLITE_DEBUG_BREAK\x00attach debugger to process %d and press any key to continue.\n\x00utf-8\x00argc\x00argv0\x00argv\x00errorInfo\x00%s: %s\n\x00SQLITE-CONNECTION\x00command not found: \x00error code %s (%d) does not match sqlite3_errcode %s (%d)\x00OMIT_MISUSE\x00wrong # args: should be \"\x00 DB FORMAT STRING\x00 DB HEX\x00 DB\x00 DB SQL\x00%s%n\x00abcdefghijklmnopqrstuvwxyz\x00 DB FORMAT STRING ?COUNT?\x00 DB\"\x00 FILENAME\"\x00%02x\x00tkt2213 is not fixed\x00bytes\x00noop\x00x_coalesce\x00hex8\x00tkt2213func\x00pointer_change\x00counter1\x00counter2\x00intreal\x00value of 40 handed to x_count\x00x_count totals to 42\x00x_count\x00legacy_count\x00 TEXT\"\x00 FORMAT INT INT INT\"\x00argument is not a valid 64-bit integer\x00 FORMAT INT INT ?STRING?\"\x00 INT FORMAT INT INT ?STRING?\"\x00N must be non-negative\x00 FORMAT INT INT DOUBLE\"\x00 FORMAT DOUBLE DOUBLE\"\x00 FORMAT STRING\"\x00%08x%08x\x002nd argument should be 16-characters of hex\x00?BOOLEAN?\x00DB BOOLEAN\x00DB dbname tblname colname\x00CHANNEL ROWID\x00DB-HANDLE NAME CMP-PROC DEL-PROC\x00sqlite3_create_collate_v2() failed to detect an invalid encoding\x00utf8\x00utf16\x00utf16le\x00utf16be\x00DB NAME NARG ENC SWITCHES...\x00encoding\x00-func\x00-step\x00-final\x00-destroy\x00switch\x00DB-HANDLE FILE ?PROC?\x00this build omits sqlite3_load_extension()\x00DB-HANDLE ONOFF\x00string\x00value\x00first argument should be one of: int int64 string double null value\x00 DB FUNCTION-NAME\x00 <STMT>\x00STMT PARAMETER RESETFLAG\x00SQLITE_STMTSTATUS_FULLSCAN_STEP\x00SQLITE_STMTSTATUS_SORT\x00SQLITE_STMTSTATUS_AUTOINDEX\x00SQLITE_STMTSTATUS_VM_STEP\x00SQLITE_STMTSTATUS_REPREPARE\x00SQLITE_STMTSTATUS_RUN\x00SQLITE_STMTSTATUS_MEMUSED\x00NBYTE\x00FILE\x00PATH\x00 DB STMT\x00 STMT\x00 FROM-STMT TO-STMT\x00 VM IDX VALUE (null|static|normal)\"\x00static\x00static-nbytes\x00normal\x00blob10\x00abc\x00xyz\x00pq\x004th argument should be \"null\" or \"static\" or \"normal\"\x00(%d) \x00<error code>\x00STMT IDX N\x00 STMT N VALUE\x00NaN\x00SNaN\x00-NaN\x00-SNaN\x00+Inf\x00-Inf\x00Epsilon\x00-Epsilon\x00NaN0\x00-NaN0\x00 STMT N\x00 STMT N VALUE BYTES\x00 STMT N DATA BYTES\x00cannot use %d blob bytes, have %d\x00STMT\x00STMT N\x00STMT NAME\x00 DB sql bytes ?tailvar?\x00 DB sql bytes tailvar\x00 DB sql bytes flags tailvar\x00\x00SELECT 1\x00 filename options-list\x00FILENAME FLAGS VFS\x00SQLITE_OPEN_READONLY\x00SQLITE_OPEN_READWRITE\x00SQLITE_OPEN_CREATE\x00SQLITE_OPEN_DELETEONCLOSE\x00SQLITE_OPEN_EXCLUSIVE\x00SQLITE_OPEN_AUTOPROXY\x00SQLITE_OPEN_MAIN_DB\x00SQLITE_OPEN_TEMP_DB\x00SQLITE_OPEN_TRANSIENT_DB\x00SQLITE_OPEN_MAIN_JOURNAL\x00SQLITE_OPEN_TEMP_JOURNAL\x00SQLITE_OPEN_SUBJOURNAL\x00SQLITE_OPEN_MASTER_JOURNAL\x00SQLITE_OPEN_NOMUTEX\x00SQLITE_OPEN_FULLMUTEX\x00SQLITE_OPEN_SHAREDCACHE\x00SQLITE_OPEN_PRIVATECACHE\x00SQLITE_OPEN_WAL\x00SQLITE_OPEN_URI\x00flag\x00 STMT column\x00FLOAT\x00TEXT\x00BLOB\x00 DB MAGIC\x00SQLITE_MAGIC_OPEN\x00SQLITE_MAGIC_CLOSED\x00SQLITE_MAGIC_BUSY\x00SQLITE_MAGIC_ERROR\x00 DB function-name\x00VARIABLE\x00DB DBNAME\x00?N?\x001234567890000000\x00__one\x00__two\x00notadatabase\x00Unexpected non-zero errno: \x00DB [DBNAME]\x00%u\x00DB DBNAME SIZE\x00 DB PWD\x00 DB FLAG\x00%d %d\x00 DB ?AUXDB?\x00 DB ID VALUE\x00unknown limit type: \x00SQLITE_LIMIT_LENGTH\x00SQLITE_LIMIT_SQL_LENGTH\x00SQLITE_LIMIT_COLUMN\x00SQLITE_LIMIT_EXPR_DEPTH\x00SQLITE_LIMIT_COMPOUND_SELECT\x00SQLITE_LIMIT_VDBE_OP\x00SQLITE_LIMIT_FUNCTION_ARG\x00SQLITE_LIMIT_ATTACHED\x00SQLITE_LIMIT_LIKE_PATTERN_LENGTH\x00SQLITE_LIMIT_VARIABLE_NUMBER\x00SQLITE_LIMIT_TRIGGER_DEPTH\x00SQLITE_LIMIT_WORKER_THREADS\x00SQLITE_LIMIT_TOOSMALL\x00SQLITE_LIMIT_TOOBIG\x00SEED ?DB?\x00current\x00max\x00min\x00recyclable\x00DB ?NAME?\x00passive\x00full\x00restart\x00truncate\x00DB MODE ?NAME?\x00mode\x00DB VALUE\x00COMMAND ...\x00command has no objProc: \x00%d %d %d %s\n\x00SQLITE_TESTCTRL_LOCALTIME_FAULT\x00SQLITE_TESTCTRL_SORTER_MMAP\x00SQLITE_TESTCTRL_IMPOSTER\x00SQLITE_TESTCTRL_INTERNAL_FUNCTIONS\x00VERB ARGS...\x00VERB\x00ONOFF\x00DB LIMIT\x00DB dbName onOff tnum\x00ru_utime=%d.%06d ru_stime=%d.%06d ru_minflt=%d ru_majflt=%d\x00DB OPT BOOLEAN\x00unknown optimization - should be one of:\x00all\x00none\x00query-flattener\x00groupby-order\x00factor-constants\x00distinct-opt\x00cover-idx-scan\x00order-by-idx-join\x00transitive\x00omit-noop-join\x00stat4\x00skip-scan\x00push-down\x00DB NAME ...\x00no such extension: \x00initialization of \x00 failed: \x00amatch\x00closure\x00fileio\x00nextchar\x00series\x00spellfix\x00totype\x00BOOL\x00DB SQL1 NSTEP SQL2\x00data error: (a!=b)\x00checksum mismatch\x00sql error: \x00TYPE\x00Deliberate panic\x00DB SETTING [VALUE]\x00SQLITE_*\x00DBCONFIG_*\x00ENABLE_*\x00unknown sqlite3_db_config setting\x00FKEY\x00TRIGGER\x00FTS3_TOKENIZER\x00LOAD_EXTENSION\x00NO_CKPT_ON_CLOSE\x00QPSG\x00TRIGGER_EQP\x00RESET_DB\x00DEFENSIVE\x00WRITABLE_SCHEMA\x00LEGACY_ALTER_TABLE\x00DQS_DML\x00DQS_DDL\x00LEGACY_FILE_FORMAT\x00icecube\x00DB ?DBNAME?\x00HEXDB\x00| size %d pagesize %d\x00bad 'pagesize' field\x00bad 'size' field\x00| page %d offset %d\x00| %d: %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x\x00sqlite_search_count\x00sqlite_found_count\x00sqlite_sort_count\x00sqlite3_max_blobsize\x00sqlite_like_count\x00sqlite_interrupt_count\x00sqlite_open_file_count\x00sqlite_current_time\x00sqlite3_xferopt_count\x00sqlite3_pager_readdb_count\x00sqlite3_pager_writedb_count\x00sqlite3_pager_writej_count\x00sqlite_query_plan\x00sqlite_opentemp_count\x00sqlite_static_bind_value\x00sqlite_static_bind_nbyte\x00sqlite_temp_directory\x00sqlite_data_directory\x00bitmask_size\x00longdouble_size\x00sqlite_sync_count\x00sqlite_fullsync_count\x00db_enter\x00db_leave\x00sqlite3_mprintf_int\x00sqlite3_mprintf_int64\x00sqlite3_mprintf_long\x00sqlite3_mprintf_str\x00sqlite3_snprintf_str\x00sqlite3_mprintf_stronly\x00sqlite3_mprintf_double\x00sqlite3_mprintf_scaled\x00sqlite3_mprintf_hexdouble\x00sqlite3_mprintf_z_test\x00sqlite3_mprintf_n_test\x00sqlite3_snprintf_int\x00sqlite3_last_insert_rowid\x00sqlite3_exec_printf\x00sqlite3_exec_hex\x00sqlite3_exec\x00sqlite3_exec_nr\x00sqlite3_get_table_printf\x00sqlite3_close\x00sqlite3_close_v2\x00sqlite3_create_function\x00sqlite3_create_aggregate\x00sqlite3_drop_modules\x00sqlite_register_test_function\x00sqlite_abort\x00sqlite_bind\x00breakpoint\x00sqlite3_key\x00sqlite3_rekey\x00sqlite_set_magic\x00sqlite3_interrupt\x00sqlite_delete_function\x00sqlite_delete_collation\x00sqlite3_get_autocommit\x00sqlite3_busy_timeout\x00printf\x00sqlite3IoTrace\x00clang_sanitize_address\x00sqlite3_db_config\x00bad_behavior\x00register_dbstat_vtab\x00sqlite3_connection_pointer\x00intarray_addr\x00int64array_addr\x00doublearray_addr\x00textarray_addr\x00sqlite3_bind_int\x00sqlite3_bind_zeroblob\x00sqlite3_bind_zeroblob64\x00sqlite3_bind_int64\x00sqlite3_bind_double\x00sqlite3_bind_null\x00sqlite3_bind_text\x00sqlite3_bind_text16\x00sqlite3_bind_blob\x00sqlite3_bind_parameter_count\x00sqlite3_bind_parameter_name\x00sqlite3_bind_parameter_index\x00sqlite3_clear_bindings\x00sqlite3_sleep\x00sqlite3_errcode\x00sqlite3_extended_errcode\x00sqlite3_errmsg\x00sqlite3_errmsg16\x00sqlite3_open\x00sqlite3_open16\x00sqlite3_open_v2\x00sqlite3_complete16\x00sqlite3_normalize\x00sqlite3_prepare\x00sqlite3_prepare16\x00sqlite3_prepare_v2\x00sqlite3_prepare_v3\x00sqlite3_prepare_tkt3134\x00sqlite3_prepare16_v2\x00sqlite3_finalize\x00sqlite3_stmt_status\x00sqlite3_reset\x00sqlite3_expired\x00sqlite3_transfer_bindings\x00sqlite3_changes\x00sqlite3_step\x00sqlite3_sql\x00sqlite3_expanded_sql\x00sqlite3_next_stmt\x00sqlite3_stmt_readonly\x00sqlite3_stmt_isexplain\x00sqlite3_stmt_busy\x00uses_stmt_journal\x00sqlite3_release_memory\x00sqlite3_db_release_memory\x00sqlite3_db_cacheflush\x00sqlite3_system_errno\x00sqlite3_db_filename\x00sqlite3_db_readonly\x00sqlite3_soft_heap_limit\x00sqlite3_soft_heap_limit64\x00sqlite3_hard_heap_limit64\x00sqlite3_thread_cleanup\x00sqlite3_pager_refcounts\x00sqlite3_load_extension\x00sqlite3_enable_load_extension\x00sqlite3_extended_result_codes\x00sqlite3_limit\x00dbconfig_maindbname_icecube\x00save_prng_state\x00restore_prng_state\x00reset_prng_state\x00prng_seed\x00database_never_corrupt\x00database_may_be_corrupt\x00optimization_control\x00tcl_objproc\x00sqlite3_column_count\x00sqlite3_data_count\x00sqlite3_column_type\x00sqlite3_column_blob\x00sqlite3_column_double\x00sqlite3_column_int64\x00sqlite3_column_text\x00sqlite3_column_name\x00sqlite3_column_int\x00sqlite3_column_bytes\x00sqlite3_create_collation_v2\x00sqlite3_global_recover\x00working_64bit_int\x00vfs_unlink_test\x00vfs_initfail_test\x00vfs_unregister_all\x00vfs_reregister_all\x00file_control_test\x00file_control_lasterrno_test\x00file_control_lockproxy_test\x00file_control_chunksize_test\x00file_control_sizehint_test\x00file_control_data_version\x00file_control_persist_wal\x00file_control_powersafe_overwrite\x00file_control_vfsname\x00file_control_tempfilename\x00sqlite3_vfs_list\x00sqlite3_create_function_v2\x00sqlite3_test_errstr\x00tcl_variable_type\x00sqlite3_enable_shared_cache\x00sqlite3_shared_cache_report\x00sqlite3_libversion_number\x00sqlite3_table_column_metadata\x00sqlite3_blob_reopen\x00pcache_stats\x00sqlite3_unlock_notify\x00sqlite3_wal_checkpoint\x00sqlite3_wal_checkpoint_v2\x00sqlite3_wal_autocheckpoint\x00test_sqlite3_log\x00print_explain_query_plan\x00sqlite3_test_control\x00getrusage\x00load_static_extension\x00sorter_test_fakeheap\x00sorter_test_sort4_helper\x00vfs_current_time_int64\x00sqlite3_delete_database\x00atomic_batch_write\x00sqlite3_mmap_warm\x00sqlite3_config_sorterref\x00decode_hexdb\x00*** OBSOLETE VARIABLE ***\x00 FILENAME N-PAGE\"\x00 ID\"\x00ref\x00page\x00err\x00hit\x00miss\x00ovfl\x00 ID PGNO\"\x00 PAGE\"\x00 PAGE DATA\"\x00 N-MEGABYTES FILE\"\x00open failed: \x00Hello, World!\x00write failed: \x00 PENDING-BYTE\"\x00fault simulator script failed: [%s]\x00 SCRIPT\"\x00 SIZE PROGRAM\"\x00sqlite_io_error_pending\x00sqlite_io_error_persist\x00sqlite_io_error_hit\x00sqlite_io_error_hardhit\x00sqlite_diskfull_pending\x00sqlite_diskfull\x00sqlite_pending_byte\x00pager_open\x00pager_close\x00pager_commit\x00pager_rollback\x00pager_stmt_begin\x00pager_stmt_commit\x00pager_stmt_rollback\x00pager_stats\x00pager_pagecount\x00page_get\x00page_lookup\x00page_unref\x00page_read\x00page_write\x00page_number\x00pager_truncate\x00fake_big_file\x00sqlite3BitvecBuiltinTest\x00sqlite3_test_control_pending_byte\x00sqlite3_test_control_fault_install\x00 FILENAME NCACHE FLAGS\"\x00read\x00write\x00 ID TABLENUM WRITEABLE\"\x00 START MULTIPLIER COUNT INCREMENT\"\x00putVarint returned %d - should be between 1 and 9\x00putVarint returned %d and getVarint returned %d\x00Wrote 0x%016llx and got back 0x%016llx\x00putVarint returned %d and GetVarint32 returned %d\x00Wrote 0x%016llx and got back 0x%016llx from GetVarint32\x00 DB-HANDLE ?N?\"\x00No such db-handle: \"\x00 BT NCACHE\"\x00?-intkey? CSR KEY VALUE\x00btree_insert\x00btree_open\x00btree_close\x00btree_begin_transaction\x00btree_pager_stats\x00btree_cursor\x00btree_close_cursor\x00btree_next\x00btree_eof\x00btree_payload_size\x00btree_first\x00btree_varint_test\x00btree_from_db\x00btree_ismemdb\x00btree_set_cache_size\x00thread ID must be an upper case letter\x00 ID FILENAME\x00thread \x00 is already running\x00failed to create the thread\x00 ID\x00no such thread\x00 ID N\x00column number out of range\x00no database is open\x00 ID SQL\x00no virtual machine available\x00 IDL\x00 ID1 ID2\x00 ID DB\x00thread_create\x00thread_wait\x00thread_halt\x00thread_argc\x00thread_argv\x00thread_colname\x00thread_result\x00thread_error\x00thread_compile\x00thread_step\x00thread_finalize\x00thread_swap\x00thread_db_get\x00thread_db_put\x00thread_stmt_get\x00 <repeat-count> <do-calls>\x00hello world\x00UTF8\x00UTF16LE\x00UTF16BE\x00UTF16\x00No such encoding: \x00 <string/blob> <from enc> <to enc>\x00binarize\x00test_value_overhead\x00test_translate\x00translate_selftest\x00out of memory in the crash simulator\n\x00atomic\x00atomic512\x00atomic1k\x00atomic2k\x00atomic4k\x00atomic8k\x00atomic16k\x00atomic32k\x00atomic64k\x00sequential\x00safe_append\x00powersafe_overwrite\x00batch-atomic\x00-sectorsize\x00-characteristics\x00Bad option: \"\x00\" - must be \"-characteristics\" or \"-sectorsize\"\x00Option requires an argument: \"\x00no such flag\x00ENABLE ?DEFAULT?\x00crash\x00?OPTIONS? DELAY CRASHFILE\x00Filename is too long: \"\x00NWRITE\x00?-default? PARENT-VFS\x00-default\x00\": must be -default\x00Error in jt_register\x00sqlite3_crash_enable\x00sqlite3_crashparams\x00sqlite3_crash_now\x00sqlite3_simulate_device\x00sqlite3_crash_on_write\x00unregister_devsim\x00register_jt_vfs\x00unregister_jt_vfs\x00echo_module_fail(%s,%s)\x00echo-vtab-error: %s\x00SELECT * FROM %Q\x00PRAGMA index_list(%s)\x00PRAGMA index_info(%s)\x00echo_module\x00SELECT sql FROM sqlite_master WHERE type = 'table' AND name = ?\x00%s%s\x00xCreate\x00CREATE TABLE %Q(logmsg)\x00xConnect\x00xDisconnect\x00xDestroy\x00DROP TABLE %Q\x00xOpen\x00xNext\x00xColumn\x00xRowid\x00xFilter\x00, *\x00%z, %s\x00%z, NULL\x00echo_module_ignore_usable\x00xBestIndex\x00echo_module_cost\x00SELECT count(*) FROM %Q\x00SELECT rowid%z FROM %Q\x00rowid\x00=\x00<\x00>\x00<=\x00>=\x00LIKE\x00like\x00glob\x00 %s %s LIKE (SELECT '%%'||?||'%%')\x00 %s %s %s ?\x00DESC\x00ASC\x00 ORDER BY %s %s\x00xUpdate\x00 SET\x00UPDATE %Q\x00 SET rowid=?1 \x00%s %Q=?%d\x00 WHERE rowid=?%d\x00DELETE FROM %Q WHERE rowid = ?1\x00INSERT INTO %Q (\x00%s%Q\x00%s?%d\x00) VALUES(\x00echo(%s)\x00xBegin\x00echo_module_begin_fail\x00xSync\x00echo_module_sync_fail\x00xCommit\x00xRollback\x00::echo_glob_overload\x00xRename\x00ALTER TABLE %s RENAME TO %s%s\x00echo\x00echo_v2\x00DB SQL\x00register_echo_module\x00sqlite3_declare_vtab\x00N/A\x00sqlite3_create_collation\x00Error testing function: \x00sqlite3_malloc\x00sqlite3_realloc\x00c_misuse_test\x00c_realloc_test\x00c_collation_test\x00sqlite3_reset_auto_extension\x00npage\x00finish\x00remaining\x00pagecount\x00CMDNAME DESTHANDLE DESTNAME SRCHANDLE SRCNAME\x00sqlite3_backup_init() failed\x00sqlite3_backup\x00wrong number of arguments\x00unexpected: %s\x00eq\x00gt\x00le\x00lt\x00ge\x00match\x00ne\x00isnot\x00isnotnull\x00isnull\x00op\x00column\x00usable\x00desc\x00cost\x00orderby\x00idxnum\x00idxstr\x00rows\x00use\x00omit\x00unexpected: %d\x00tcl\x00register_tcl_module\x00incrblob_\x00DB DATABASE TABLE COLUMN ROWID FLAGS VARNAME\x00HANDLE\x00CHANNEL OFFSET N\x00out of memory in testdata/sqlite-src-3320300/src/test_blob.c\x00HANDLE OFFSET DATA ?NDATA?\x00sqlite3_blob_open\x00sqlite3_blob_close\x00sqlite3_blob_bytes\x00sqlite3_blob_read\x00sqlite3_blob_write\x00sqlite_options\x00malloc_usable_size\x00rowid32\x00casesensitivelike\x00curdir\x001\x00win32malloc\x00debug\x00default_ckptfullfsync\x00direct_read\x00dirsync\x00lfs\x00pagecache_overflow_stats\x00mmap\x00worker_threads\x008\x00memdebug\x008_3_names\x00cursorhints\x00hiddencolumns\x00mem3\x00mem5\x00offset_sql_func\x00snapshot\x00mutex\x00mutex_noop\x00altertable\x00api_armor\x00atomicwrite\x00json1\x00has_codec\x00like_match_blobs\x00attach\x00auth\x00autoinc\x00autoreset\x00autovacuum\x00default_autovacuum\x00between_opt\x00builtin_test\x00bloblit\x00cast\x00check\x00cte\x00columnmetadata\x00oversize_cell_check\x00compileoption_diags\x00compound\x00conflict\x00crashtest\x00datetime\x00decltype\x00deprecated\x00diskio\x00floatingpoint\x00foreignkey\x00fts1\x00fts2\x00fts3\x00fts5\x00fts3_unicode\x00fts4_deferred\x00gettable\x00icu\x00icu_collations\x00integrityck\x00legacyformat\x00like_opt\x00load_ext\x00localtime\x00lookaside\x00long_double\x00memorydb\x00memorymanage\x00mergesort\x00null_trim\x00or_opt\x00rbu\x00pager_pragmas\x00pragma\x00reindex\x00rtree\x00rtree_int_only\x00schema_pragmas\x00schema_version\x00session\x00stmtvtab\x00scanstatus\x00lock_proxy_pragmas\x00prefer_proxy_locking\x00shared_cache\x00subquery\x00tclvar\x00threadsafe\x00threadsafe1\x00threadsafe2\x00tempdb\x00trigger\x00truncate_opt\x00view\x00vtab\x00wal\x00wsd\x00update_delete_limit\x00fast_secure_delete\x00secure_delete\x00userauth\x00multiplex_ext_overwrite\x00yytrackmaxstackdepth\x00sqllog\x00uri_00_error\x00normalize\x00windowfunc\x00SQLITE_MAX_LENGTH\x00SQLITE_MAX_COLUMN\x00SQLITE_MAX_SQL_LENGTH\x00SQLITE_MAX_EXPR_DEPTH\x00SQLITE_MAX_COMPOUND_SELECT\x00SQLITE_MAX_VDBE_OP\x00SQLITE_MAX_FUNCTION_ARG\x00SQLITE_MAX_VARIABLE_NUMBER\x00SQLITE_MAX_PAGE_SIZE\x00SQLITE_MAX_PAGE_COUNT\x00SQLITE_MAX_LIKE_PATTERN_LENGTH\x00SQLITE_MAX_TRIGGER_DEPTH\x00SQLITE_DEFAULT_CACHE_SIZE\x00SQLITE_DEFAULT_PAGE_SIZE\x00SQLITE_DEFAULT_FILE_FORMAT\x00SQLITE_DEFAULT_SYNCHRONOUS\x00SQLITE_DEFAULT_WAL_SYNCHRONOUS\x00SQLITE_MAX_ATTACHED\x00SQLITE_MAX_DEFAULT_PAGE_SIZE\x00SQLITE_MAX_WORKER_THREADS\x00TEMP_STORE\x00pVfs==0\x00testdata/sqlite-src-3320300/src/test_delete.c\x00sqlite3DeleteUnlinkIfExists\x00%s-journal\x00%s-shm\x00%s%03d\x00%s-journal%03d\x00%s-wal%03d\x00devsym\x00writecrash\x00CREATE TABLE xyz(dir, name);\x00CREATE TABLE xyz(path, size, data);\x00WITH r(d) AS (  SELECT CASE WHEN dir=?2 THEN ?3 ELSE dir END || '/' || name     FROM fsdir WHERE dir=?1 AND name NOT LIKE '.%'  UNION ALL  SELECT dir || '/' || name FROM r, fsdir WHERE dir=d AND name NOT LIKE '.%') SELECT d FROM r;\x00/\x00CREATE TABLE x(path TEXT, data TEXT)\x00SELECT * FROM %Q.%Q WHERE rowid=?\x00fs\x00fstree\x00register_fs_module\x00abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789.-!,:*^+=_|?/<> \x00sqlite3_prepare_v2() error: %s\x000123456789abcdef\x00x'\x00test_agg_errmsg16\x00randstr\x00test_destructor\x00hex_to_utf8\x00test_destructor_count\x00test_auxdata\x00test_error\x00test_eval\x00test_isolation\x00test_counter\x00real2hex\x00test_decode\x00test_extract\x00test_zeroblob\x00test_getsubtype\x00test_setsubtype\x00test_frombind\x00tx\x00funcxx_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789\x00nullx_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789\x00sqlite3_create_function abused test failed\x00invalid matchinfo blob passed to function rank()\x00wrong number of arguments to function rank()\x00rank\x00autoinstall_test_functions\x00abuse_create_function\x00install_fts3_rank_function\x000123456789ABCDEF\x00FILENAME OFFSET AMT\x00r\x00cannot open input file \x00FILENAME OFFSET HEXDATA\x00r+b\x00r+\x00cannot open output file \x00HEXDATA\x00[utf8_to_utf8] unavailable - SQLITE_DEBUG not defined\x00BLOB VARNAME\x00LIST\x00hexio_read\x00hexio_write\x00hexio_get_int\x00hexio_render_int16\x00hexio_render_int32\x00utf8_to_utf8\x00read_fts3varint\x00make_fts3record\x00mem\x00pcache\x00Unknown argument: \"\x00init_wrapper_install\x00init_wrapper_query\x00init_wrapper_uninstall\x00init_wrapper_clear\x00CREATE TABLE x(value INTEGER PRIMARY KEY)\x00CREATE VIRTUAL TABLE temp.%Q USING %Q\x00INTARRAY\x00SQLITE_NOMEM\x00sqlite3_intarray_create\x00sqlite3_intarray_bind\x00jt\x00-journal\x00NBYTES\x00PRIOR NBYTES\x00bad pointer: \x00PRIOR\x00ADDRESS SIZE HEX\x00size must be positive\x00no data\x00ADDRESS SIZE\x00?RESET?\x00DEPT\x00FILENAME\x00COUNTER ?OPTIONS?\x00-repeat\x00-benigncnt\x00TITLE\x00SUB-COMMAND ...\x00start\x00stop\x00dump\x00clear\x00sync\x00SIZE N\x00INSTALLFLAG DISCARDCHANCE PRNGSEEED HIGHSTRESS\x00discard-chance should be between 0 and 100\x00BOOLEAN\x00SIZE COUNT\x00BUFID SIZE COUNT\x00illegal arguments - see documentation\x00NBYTE NMINALLOC\x00[DB]\x00sqlite3_db_config(db, 99999) does not return SQLITE_ERROR\x00sqlite3_config(99999) does not return SQLITE_ERROR\x00PARAMETER RESETFLAG\x00SQLITE_STATUS_MEMORY_USED\x00SQLITE_STATUS_MALLOC_SIZE\x00SQLITE_STATUS_PAGECACHE_USED\x00SQLITE_STATUS_PAGECACHE_OVERFLOW\x00SQLITE_STATUS_PAGECACHE_SIZE\x00SQLITE_STATUS_SCRATCH_USED\x00SQLITE_STATUS_SCRATCH_OVERFLOW\x00SQLITE_STATUS_SCRATCH_SIZE\x00SQLITE_STATUS_PARSER_STACK\x00SQLITE_STATUS_MALLOC_COUNT\x00DB PARAMETER RESETFLAG\x00SQLITE_\x00DBSTATUS_\x00LOOKASIDE_USED\x00CACHE_USED\x00SCHEMA_USED\x00STMT_USED\x00LOOKASIDE_HIT\x00LOOKASIDE_MISS_SIZE\x00LOOKASIDE_MISS_FULL\x00CACHE_HIT\x00CACHE_MISS\x00CACHE_WRITE\x00DEFERRED_FKS\x00CACHE_USED_SHARED\x00CACHE_SPILL\x00?INTEGER?\x00sqlite3_free\x00memset\x00memget\x00sqlite3_memory_used\x00sqlite3_memory_highwater\x00sqlite3_memdebug_backtrace\x00sqlite3_memdebug_dump\x00sqlite3_memdebug_fail\x00sqlite3_memdebug_pending\x00sqlite3_memdebug_settitle\x00sqlite3_memdebug_malloc_count\x00sqlite3_memdebug_log\x00sqlite3_config_pagecache\x00sqlite3_config_alt_pcache\x00sqlite3_status\x00sqlite3_db_status\x00install_malloc_faultsim\x00sqlite3_config_heap\x00sqlite3_config_heap_size\x00sqlite3_config_memstatus\x00sqlite3_config_lookaside\x00sqlite3_config_error\x00sqlite3_config_uri\x00sqlite3_config_cis\x00sqlite3_config_pmasz\x00sqlite3_db_config_lookaside\x00sqlite3_dump_memsys3\x00sqlite3_dump_memsys5\x00sqlite3_install_memsys3\x00sqlite3_memdebug_vfs_oom_test\x00%05u\x00 FILENAME [OFFSET AMT]\"\x00unable to open file \"\x00\" for reading\x00md5\x00md5-10x8\x00md5file\x00md5file-10x8\x00md5sum\x00%03d\x00zOut[n]=='\\0'\x00testdata/sqlite-src-3320300/src/test_multiplex.c\x00multiplexFilename\x00multiplexor.xAccess failure on %s\x00multiplexor.xOpen failure on %s\x00multiplex_control\x00zName || (flags & 0x00000008)\x00chunksize\x00multiplexOpen\x00multiplex_truncate\x00multiplex/%z\x00pOrigVfs!=&gMultiplex.sThisVfs\x00multiplex\x00sqlite3_multiplex_initialize\x00NAME MAKEDEFAULT\x00-force\x00?-force?\x00enable\x00chunk_size\x00max_chunks\x00HANDLE DBNAME SUB-COMMAND INT-VALUE\x00expected database handle, got \"\x00SUB-COMMAND\x00sqlite3_multiplex_shutdown\x00sqlite3_multiplex_control\x00fast\x00recursive\x00static_master\x00static_mem\x00static_open\x00static_prng\x00static_lru\x00static_pmem\x00static_app1\x00static_app2\x00static_app3\x00static_vfs1\x00static_vfs2\x00static_vfs3\x00mutex counters are \x00already installed\x00not installed\x00singlethread\x00multithread\x00serialized\x00mutex name\x00disable_mutex_init\x00disable_mutex_try\x00sqlite3_shutdown\x00sqlite3_initialize\x00sqlite3_config\x00enter_static_mutex\x00leave_static_mutex\x00enter_db_mutex\x00leave_db_mutex\x00alloc_dealloc_mutex\x00install_mutex_counters\x00read_mutex_counters\x00clear_mutex_counters\x00pReal->nRef>=0\x00testdata/sqlite-src-3320300/src/test_onefile.c\x00fsClose\x00strlen(\"-journal\")==8\x00eType==1\x00\x00\x00fsOpen\x00strcmp(\"-journal\", &zPath[nName])==0\x00\x00\x00\x00\x00\x00fsDelete\x00fsAccess\x00vfslog/%z\x00sqlite_ostrace1.....\x00xClose\x00xRead\x00xWrite\x00xTruncate\x00xFilesize\x00xLock\x00xUnlock\x00xCheckResLock\x00xFileControl\x00xSectorSize\x00xDeviceChar\x00xDelete\x00xAccess\x00xFullPathname\x00xRandomness\x00xSleep\x00xCurrentTime\x00xShmUnmap\x00xShmLock\x00xShmBarrier\x00xShmMap\x00annotation\x00CREATE TABLE xxx(event, file, click, rc, size, offset)\x00i<7\x00testdata/sqlite-src-3320300/src/test_osinst.c\x00vlogColumn\x00vfslog\x00VFS\x00failed\x00VFS PARENT LOGFILE\x00bad sqlite3 handle: \x00annotate\x00finalize\x00register\x00pArg==(void*)&testpcacheGlobal\x00testdata/sqlite-src-3320300/src/test_pcache.c\x00testpcacheGlobal.pDummy==0\x00testpcacheGlobal.nInstance==0\x00testpcacheInit\x00testpcacheGlobal.pDummy!=0\x00testpcacheShutdown\x00testpcacheCreate\x00p->iMagic==0x364585fd\x00testpcacheGlobal.nInstance>0\x00testpcacheCachesize\x00testpcachePagecount\x00p->nPinned <= 217 - p->nFree\x00testpcacheFetch\x00p->a[i].isPinned\x00p->nPinned>=0\x00p->nFree<=217\x00testpcacheUnpin\x00p->a[i].isPinned==0\x00&p->a[i].page==pOldPage\x00testpcacheRekey\x00testpcacheTruncate\x00testpcacheDestroy\x00discardChance<=100\x00defaultPcache.xCreate!=testpcacheCreate\x00defaultPcache.xCreate!=0\x00installTestPCache\x00pGroup->pFiles->nRef==0\x00testdata/sqlite-src-3320300/src/test_quota.c\x00quotaRemoveAllFiles\x00quota/%z\x00pOrigVfs!=&gQuota.sThisVfs\x00quota\x00sqlite3_quota_initialize\x00quotaGroupOpenFileCount(pGroup)==0\x00sqlite3_quota_shutdown\x00::piLimit_\x00PATTERN LIMIT SCRIPT\x00FILENAME MODE\x00HANDLE SIZE NELEM\x00HANDLE SIZE NELEM CONTENT\x00HANDLE ?HARDSYNC?\x00HANDLE OFFSET WHENCE\x00SEEK_SET\x00SEEK_CUR\x00SEEK_END\x00WHENCE should be SEEK_SET, SEEK_CUR, or SEEK_END\x00HANDLE SIZE\x00PATTERN TEXT\x00sqlite3_quota_set\x00sqlite3_quota_file\x00sqlite3_quota_dump\x00sqlite3_quota_fopen\x00sqlite3_quota_fread\x00sqlite3_quota_fwrite\x00sqlite3_quota_fclose\x00sqlite3_quota_fflush\x00sqlite3_quota_fseek\x00sqlite3_quota_rewind\x00sqlite3_quota_ftell\x00sqlite3_quota_ftruncate\x00sqlite3_quota_file_size\x00sqlite3_quota_file_truesize\x00sqlite3_quota_file_mtime\x00sqlite3_quota_remove\x00sqlite3_quota_glob\x00sqlite3_quota_file_available\x00sqlite3_quota_ferror\x00register_cube_geom\x00register_circle_geom\x00CREATE TABLE x(database,tablename,cid,name,type,not_null,dflt_value,pk)\x00SELECT name FROM sqlite_temp_master WHERE type='table'\x00SELECT name FROM %Q.sqlite_master WHERE type='table'\x00PRAGMA %Q.table_info(%Q)\x00PRAGMA database_list\x00register_schema_module\x00PRAGMA main.journal_mode\x00CMDNAME PATH ?VFS? ?BUSY-HANDLER-SCRIPT?\x00rc==0 || pLock==0\x00testdata/sqlite-src-3320300/src/test_superlock.c\x00rc!=0 || pLock!=0\x00superlock_cmd\x00sqlite3demo_superlock\x00open\x00access\x00getcwd\x00fstat\x00ftruncate\x00fcntl\x00pread\x00pread64\x00pwrite\x00pwrite64\x00fchmod\x00fallocate\x00mremap\x00SYSCALL-LIST\x00system-call\x00?COUNT PERSIST?\x00EACCES\x00EINTR\x00EIO\x00EOVERFLOW\x00ENOMEM\x00EAGAIN\x00ETIMEDOUT\x00EBUSY\x00EPERM\x00EDEADLK\x00ENOLCK\x00SYSCALL ERRNO\x00errno\x00PGSZ\x00getpagesize\x00pgsz out of range\x00fault\x00install\x00uninstall\x00list\x00defaultvfs\x00pagesize\x00VFS does not support xSetSystemCall\x00test_syscall\x00load_testfixture_extensions\x00SLAVE\x00CREATE TABLE x(  name TEXT,  arrayname TEXT,  value TEXT,  fullname TEXT PRIMARY KEY) WITHOUT ROWID\x00array names\x00tclvar_filter_cmd\x00%s(%s)\x00expr {[info exists ::tclvar_set_omit] && $::tclvar_set_omit}\x00the 'fullname' column must be TEXT\x00prohibited TCL variable change\x00proc like {pattern str} {\n  set p [string map {% * _ ?} $pattern]\n  string match $p $str\n}\nproc tclvar_filter_cmd {eq match glob regexp like} {\n  set res {}\n  set pattern $eq\n  if {$pattern=={}} { set pattern $match }\n  if {$pattern=={}} { set pattern * }\n  foreach v [uplevel #0 info vars $pattern] {\n    if {($glob=={} || [string match $glob [uplevel #0 set $v]])\n     && ($like=={} || [like $like [uplevel #0 set $v]])\n     && ($regexp=={} || [regexp $regexp [uplevel #0 set $v]])\n    } {\n      lappend res $v\n    }\n  }\n  set res\n}\n\x00register_tclvar_module\x00clock_seconds\x00sqlthread\x00sqlite3_blocking_step\x00sqlite3_blocking_prepare_v2\x00sqlite3_nonblocking_prepare_v2\x00set\x00Error in Tcl_CreateThread()\x00no parent thread\x00parent\x00spawn\x00VARNAME SCRIPT\x00DBNAME\x00id\x00%s \x00SQLITE_ERROR\x00SQLITE_IOERR\x00SQLITE_LOCKED\x00SQLITE_BUSY\x00SQLITE_READONLY\x00SQLITE_READONLY_CANTINIT\x00SQLITE_NOTFOUND\x00SQLITE_OMIT\x00normal|dataonly\x00full|dataonly\x00xCheckReservedLock\x00BEGIN_ATOMIC_WRITE\x00COMMIT_ATOMIC_WRITE\x00ZIPVFS\x00anon\x00SQLITE_ACCESS_EXISTS\x00SQLITE_ACCESS_READWRITE\x00SQLITE_ACCESS_READ\x00xShmOpen\x00 lock\x00 unlock\x00 shared\x00 exclusive\x00shm\x00delete\x00filter\x00ioerr\x00fullerr\x00cantopenerr\x00script\x00devchar\x00sectorsize\x00subcommand\x00FILE ?VALUE?\x00failed to get full path: \x00no such file: \x00unknown method: \x00?CNT PERSIST?\x00default\x00undeletable_when_open\x00immutable\x00?ATTR-LIST?\x00bad flags: \x00?VALUE?\x00-noshm\x00-szosfile\x00-mxpathname\x00-iversion\x00-fullshm\x00VFSNAME ?-noshm BOOL? ?-fullshm BOOL? ?-default BOOL? ?-mxpathname INT? ?-szosfile INT? ?-iversion INT?\x00shared\x00lock\x00unlock\x00DB DBNAME (shared|exclusive) (lock|unlock) OFFSET N\x00ARG\x00DB DBNAME SLOT ?VALUE?\x00*-shm is not yet mapped\x00testvfs\x00vfs_shmlock\x00vfs_set_readmark\x00DB NAME XSTEP XFINAL XVALUE XINVERSE\x00fff\x00misuse test error\x00invalid argument\x00sumint\x00sum\x00sqlite3_create_window_function\x00test_create_window_function_misuse\x00test_create_sumint\x00test_override_sum\x00"
var ts = (*reflect.StringHeader)(unsafe.Pointer(&ts1)).Data
